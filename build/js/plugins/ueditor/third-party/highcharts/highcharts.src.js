// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highcharts JS v3.0.6 (2013-10-04)
 *
 * (c) 2009-2013 Torstein HÃ¸nsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */

(function () {
// encapsulated variables
var UNDEFINED,
	doc = document,
	win = window,
	math = Math,
	mathRound = math.round,
	mathFloor = math.floor,
	mathCeil = math.ceil,
	mathMax = math.max,
	mathMin = math.min,
	mathAbs = math.abs,
	mathCos = math.cos,
	mathSin = math.sin,
	mathPI = math.PI,
	deg2rad = mathPI * 2 / 360,


	// some variables
	userAgent = navigator.userAgent,
	isOpera = win.opera,
	isIE = /msie/i.test(userAgent) && !isOpera,
	docMode8 = doc.documentMode === 8,
	isWebKit = /AppleWebKit/.test(userAgent),
	isFirefox = /Firefox/.test(userAgent),
	isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
	SVG_NS = 'http://www.w3.org/2000/svg',
	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
	Renderer,
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED,
	symbolSizes = {},
	idCounter = 0,
	garbageBin,
	defaultOptions,
	dateFormat, // function
	globalAnimation,
	pathAnim,
	timeUnits,
	noop = function () {},
	charts = [],
	PRODUCT = 'Highcharts',
	VERSION = '3.0.6',

	// some constants for frequently used strings
	DIV = 'div',
	ABSOLUTE = 'absolute',
	RELATIVE = 'relative',
	HIDDEN = 'hidden',
	PREFIX = 'highcharts-',
	VISIBLE = 'visible',
	PX = 'px',
	NONE = 'none',
	M = 'M',
	L = 'L',
	/*
	 * Empirical lowest possible opacities for TRACKER_FILL
	 * IE6: 0.002
	 * IE7: 0.002
	 * IE8: 0.002
	 * IE9: 0.00000000001 (unlimited)
	 * IE10: 0.0001 (exporting only)
	 * FF: 0.00000000001 (unlimited)
	 * Chrome: 0.000001
	 * Safari: 0.000001
	 * Opera: 0.00000000001 (unlimited)
	 */
	TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')', // invisible but clickable
	//TRACKER_FILL = 'rgba(192,192,192,0.5)',
	NORMAL_STATE = '',
	HOVER_STATE = 'hover',
	SELECT_STATE = 'select',
	MILLISECOND = 'millisecond',
	SECOND = 'second',
	MINUTE = 'minute',
	HOUR = 'hour',
	DAY = 'day',
	WEEK = 'week',
	MONTH = 'month',
	YEAR = 'year',

	// constants for attributes
	LINEAR_GRADIENT = 'linearGradient',
	STOPS = 'stops',
	STROKE_WIDTH = 'stroke-width',

	// time methods, changed based on whether or not UTC is used
	makeTime,
	getMinutes,
	getHours,
	getDay,
	getDate,
	getMonth,
	getFullYear,
	setMinutes,
	setHours,
	setDate,
	setMonth,
	setFullYear,


	// lookup over the types and the associated classes
	seriesTypes = {};

// The Highcharts namespace
win.Highcharts = win.Highcharts ? error(16, true) : {};

/**
 * Extend an object with the members of another
 * @param {Object} a The object to be extended
 * @param {Object} b The object to add to the first one
 */
function extend(a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
}
	
/**
 * Deep merge two or more objects and return a third object.
 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
 * it copied properties from extended prototypes. 
 */
function merge() {
	var i,
		len = arguments.length,
		ret = {},
		doCopy = function (copy, original) {
			var value, key;

			// An object is replacing a primitive
			if (typeof copy !== 'object') {
				copy = {};
			}

			for (key in original) {
				if (original.hasOwnProperty(key)) {
					value = original[key];

					// Copy the contents of objects, but not arrays or DOM nodes
					if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]'
							&& typeof value.nodeType !== 'number') {
						copy[key] = doCopy(copy[key] || {}, value);
				
					// Primitives and arrays are copied over directly
					} else {
						copy[key] = original[key];
					}
				}
			}
			return copy;
		};

	// For each argument, extend the return
	for (i = 0; i < len; i++) {
		ret = doCopy(ret, arguments[i]);
	}

	return ret;
}

/**
 * Take an array and turn into a hash with even number arguments as keys and odd numbers as
 * values. Allows creating constants for commonly used style properties, attributes etc.
 * Avoid it in performance critical situations like looping
 */
function hash() {
	var i = 0,
		args = arguments,
		length = args.length,
		obj = {};
	for (; i < length; i++) {
		obj[args[i++]] = args[i];
	}
	return obj;
}

/**
 * Shortcut for parseInt
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
function pInt(s, mag) {
	return parseInt(s, mag || 10);
}

/**
 * Check for string
 * @param {Object} s
 */
function isString(s) {
	return typeof s === 'string';
}

/**
 * Check for object
 * @param {Object} obj
 */
function isObject(obj) {
	return typeof obj === 'object';
}

/**
 * Check for array
 * @param {Object} obj
 */
function isArray(obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
}

/**
 * Check for number
 * @param {Object} n
 */
function isNumber(n) {
	return typeof n === 'number';
}

function log2lin(num) {
	return math.log(num) / math.LN10;
}
function lin2log(num) {
	return math.pow(10, num);
}

/**
 * Remove last occurence of an item from an array
 * @param {Array} arr
 * @param {Mixed} item
 */
function erase(arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
	//return arr;
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

/**
 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
 * it attempts to set expando properties on the SVG element, which is not allowed.
 *
 * @param {Object} elem The DOM element to receive the attribute(s)
 * @param {String|Object} prop The property or an abject of key-value pairs
 * @param {String} value The value if a single property is set
 */
function attr(elem, prop, value) {
	var key,
		setAttribute = 'setAttribute',
		ret;

	// if the prop is a string
	if (isString(prop)) {
		// set the value
		if (defined(value)) {

			elem[setAttribute](prop, value);

		// get the value
		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (defined(prop) && isObject(prop)) {
		for (key in prop) {
			elem[setAttribute](key, prop[key]);
		}
	}
	return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array. Like
 * MooTools' $.splat.
 */
function splat(obj) {
	return isArray(obj) ? obj : [obj];
}


/**
 * Return the first value that is defined. Like MooTools' $.pick.
 */
function pick() {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (typeof arg !== 'undefined' && arg !== null) {
			return arg;
		}
	}
}

/**
 * Set CSS on a given element
 * @param {Object} el
 * @param {Object} styles Style object with camel case property names
 */
function css(el, styles) {
	if (isIE) {
		if (styles && styles.opacity !== UNDEFINED) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	extend(el.style, styles);
}

/**
 * Utility function to create element with attributes and styles
 * @param {Object} tag
 * @param {Object} attribs
 * @param {Object} styles
 * @param {Object} parent
 * @param {Object} nopad
 */
function createElement(tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag);
	if (attribs) {
		extend(el, attribs);
	}
	if (nopad) {
		css(el, {padding: 0, border: NONE, margin: 0});
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
}

/**
 * Extend a prototyped class by new members
 * @param {Object} parent
 * @param {Object} members
 */
function extendClass(parent, members) {
	var object = function () {};
	object.prototype = new parent();
	extend(object.prototype, members);
	return object;
}

/**
 * Format a number and return a string based on input settings
 * @param {Number} number The input number to format
 * @param {Number} decimals The amount of decimals
 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
 */
function numberFormat(number, decimals, decPoint, thousandsSep) {
	var lang = defaultOptions.lang,
		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
		n = +number || 0,
		c = decimals === -1 ?
			(n.toString().split('.')[1] || '').length : // preserve decimals
			(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
		d = decPoint === undefined ? lang.decimalPoint : decPoint,
		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
		s = n < 0 ? "-" : "",
		i = String(pInt(n = mathAbs(n).toFixed(c))),
		j = i.length > 3 ? i.length % 3 : 0;

	return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
}

/**
 * Pad a string to a given length by adding 0 to the beginning
 * @param {Number} number
 * @param {Number} length
 */
function pad(number, length) {
	// Create an array of the remaining length +1 and join it with 0's
	return new Array((length || 2) + 1 - String(number).length).join(0) + number;
}

/**
 * Wrap a method with extended functionality, preserving the original function
 * @param {Object} obj The context object that the method belongs to 
 * @param {String} method The name of the method to extend
 * @param {Function} func A wrapper function callback. This function is called with the same arguments
 * as the original function, except that the original function is unshifted and passed as the first 
 * argument. 
 */
function wrap(obj, method, func) {
	var proceed = obj[method];
	obj[method] = function () {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(proceed);
		return func.apply(this, args);
	};
}

/**
 * Based on http://www.php.net/manual/en/function.strftime.php
 * @param {String} format
 * @param {Number} timestamp
 * @param {Boolean} capitalize
 */
dateFormat = function (format, timestamp, capitalize) {
	if (!defined(timestamp) || isNaN(timestamp)) {
		return 'Invalid date';
	}
	format = pick(format, '%Y-%m-%d %H:%M:%S');

	var date = new Date(timestamp),
		key, // used in for constuct below
		// get the basic time values
		hours = date[getHours](),
		day = date[getDay](),
		dayOfMonth = date[getDate](),
		month = date[getMonth](),
		fullYear = date[getFullYear](),
		lang = defaultOptions.lang,
		langWeekdays = lang.weekdays,

		// List all format keys. Custom formats can be added from the outside. 
		replacements = extend({

			// Day
			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
			'A': langWeekdays[day], // Long weekday, like 'Monday'
			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
			'e': dayOfMonth, // Day of the month, 1 through 31

			// Week (none implemented)
			//'W': weekNumber(),

			// Month
			'b': lang.shortMonths[month], // Short month, like 'Jan'
			'B': lang.months[month], // Long month, like 'January'
			'm': pad(month + 1), // Two digit month number, 01 through 12

			// Year
			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
			'Y': fullYear, // Four digits year, like 2009

			// Time
			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
		}, Highcharts.dateFormats);


	// do the replaces
	for (key in replacements) {
		while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
			format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
		}
	}

	// Optionally capitalize the string and return
	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
};

/** 
 * Format a single variable. Similar to sprintf, without the % prefix.
 */
function formatSingle(format, val) {
	var floatRegex = /f$/,
		decRegex = /\.([0-9])/,
		lang = defaultOptions.lang,
		decimals;

	if (floatRegex.test(format)) { // float
		decimals = format.match(decRegex);
		decimals = decimals ? decimals[1] : -1;
		val = numberFormat(
			val,
			decimals,
			lang.decimalPoint,
			format.indexOf(',') > -1 ? lang.thousandsSep : ''
		);
	} else {
		val = dateFormat(format, val);
	}
	return val;
}

/**
 * Format a string according to a subset of the rules of Python's String.format method.
 */
function format(str, ctx) {
	var splitter = '{',
		isInside = false,
		segment,
		valueAndFormat,
		path,
		i,
		len,
		ret = [],
		val,
		index;
	
	while ((index = str.indexOf(splitter)) !== -1) {
		
		segment = str.slice(0, index);
		if (isInside) { // we're on the closing bracket looking back
			
			valueAndFormat = segment.split(':');
			path = valueAndFormat.shift().split('.'); // get first and leave format
			len = path.length;
			val = ctx;

			// Assign deeper paths
			for (i = 0; i < len; i++) {
				val = val[path[i]];
			}

			// Format the replacement
			if (valueAndFormat.length) {
				val = formatSingle(valueAndFormat.join(':'), val);
			}

			// Push the result and advance the cursor
			ret.push(val);
			
		} else {
			ret.push(segment);
			
		}
		str = str.slice(index + 1); // the rest
		isInside = !isInside; // toggle
		splitter = isInside ? '}' : '{'; // now look for next matching bracket
	}
	ret.push(str);
	return ret.join('');
}

/**
 * Get the magnitude of a number
 */
function getMagnitude(num) {
	return math.pow(10, mathFloor(math.log(num) / math.LN10));
}

/**
 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 * @param {Number} interval
 * @param {Array} multiples
 * @param {Number} magnitude
 * @param {Object} options
 */
function normalizeTickInterval(interval, multiples, magnitude, options) {
	var normalized, i;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = [1, 2, 2.5, 5, 10];

		// the allowDecimals option
		if (options && options.allowDecimals === false) {
			if (magnitude === 1) {
				multiples = [1, 2, 5, 10];
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		interval = multiples[i];
		if (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
			break;
		}
	}

	// multiply back to the correct magnitude
	interval *= magnitude;

	return interval;
}

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to 
 * prevent it for running over again for each segment having the same interval. 
 * #662, #697.
 */
function normalizeTimeTickInterval(tickInterval, unitsOption) {
	var units = unitsOption || [[
				MILLISECOND, // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				SECOND,
				[1, 2, 5, 10, 15, 30]
			], [
				MINUTE,
				[1, 2, 5, 10, 15, 30]
			], [
				HOUR,
				[1, 2, 3, 4, 6, 8, 12]
			], [
				DAY,
				[1, 2]
			], [
				WEEK,
				[1, 2]
			], [
				MONTH,
				[1, 2, 3, 4, 6]
			], [
				YEAR,
				null
			]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;
		
	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits[YEAR] && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(
		tickInterval / interval, 
		multiples,
		unit[0] === YEAR ? getMagnitude(tickInterval / interval) : 1 // #1913
	);
	
	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
}

/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
function getTimeTicks(normalizedInterval, min, max, startOfWeek) {
	var tickPositions = [],
		i,
		higherRanks = {},
		useUTC = defaultOptions.global.useUTC,
		minYear, // used in months and years as a basis for Date.UTC()
		minDate = new Date(min),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count;

	if (defined(min)) { // #1300
		if (interval >= timeUnits[SECOND]) { // second
			minDate.setMilliseconds(0);
			minDate.setSeconds(interval >= timeUnits[MINUTE] ? 0 :
				count * mathFloor(minDate.getSeconds() / count));
		}
	
		if (interval >= timeUnits[MINUTE]) { // minute
			minDate[setMinutes](interval >= timeUnits[HOUR] ? 0 :
				count * mathFloor(minDate[getMinutes]() / count));
		}
	
		if (interval >= timeUnits[HOUR]) { // hour
			minDate[setHours](interval >= timeUnits[DAY] ? 0 :
				count * mathFloor(minDate[getHours]() / count));
		}
	
		if (interval >= timeUnits[DAY]) { // day
			minDate[setDate](interval >= timeUnits[MONTH] ? 1 :
				count * mathFloor(minDate[getDate]() / count));
		}
	
		if (interval >= timeUnits[MONTH]) { // month
			minDate[setMonth](interval >= timeUnits[YEAR] ? 0 :
				count * mathFloor(minDate[getMonth]() / count));
			minYear = minDate[getFullYear]();
		}
	
		if (interval >= timeUnits[YEAR]) { // year
			minYear -= minYear % count;
			minDate[setFullYear](minYear);
		}
	
		// week is a special case that runs outside the hierarchy
		if (interval === timeUnits[WEEK]) {
			// get start of current week, independent of count
			minDate[setDate](minDate[getDate]() - minDate[getDay]() +
				pick(startOfWeek, 1));
		}
	
	
		// get tick positions
		i = 1;
		minYear = minDate[getFullYear]();
		var time = minDate.getTime(),
			minMonth = minDate[getMonth](),
			minDateDate = minDate[getDate](),
			timezoneOffset = useUTC ? 
				0 : 
				(24 * 3600 * 1000 + minDate.getTimezoneOffset() * 60 * 1000) % (24 * 3600 * 1000); // #950
	
		// iterate and add tick positions at appropriate values
		while (time < max) {
			tickPositions.push(time);
	
			// if the interval is years, use Date.UTC to increase years
			if (interval === timeUnits[YEAR]) {
				time = makeTime(minYear + i * count, 0);
	
			// if the interval is months, use Date.UTC to increase months
			} else if (interval === timeUnits[MONTH]) {
				time = makeTime(minYear, minMonth + i * count);
	
			// if we're using global time, the interval is not fixed as it jumps
			// one hour at the DST crossover
			} else if (!useUTC && (interval === timeUnits[DAY] || interval === timeUnits[WEEK])) {
				time = makeTime(minYear, minMonth, minDateDate +
					i * count * (interval === timeUnits[DAY] ? 1 : 7));
	
			// else, the interval is fixed and we use simple addition
			} else {
				time += interval * count;
			}
	
			i++;
		}
	
		// push the last time
		tickPositions.push(time);


		// mark new days if the time is dividible by day (#1649, #1760)
		each(grep(tickPositions, function (time) {
			return interval <= timeUnits[HOUR] && time % timeUnits[DAY] === timezoneOffset;
		}), function (time) {
			higherRanks[time] = DAY;
		});
	}


	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
}

/**
 * Helper class that contains variuos counters that are local to the chart.
 */
function ChartCounters() {
	this.color = 0;
	this.symbol = 0;
}

ChartCounters.prototype =  {
	/**
	 * Wraps the color counter if it reaches the specified length.
	 */
	wrapColor: function (length) {
		if (this.color >= length) {
			this.color = 0;
		}
	},

	/**
	 * Wraps the symbol counter if it reaches the specified length.
	 */
	wrapSymbol: function (length) {
		if (this.symbol >= length) {
			this.symbol = 0;
		}
	}
};


/**
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behaviour when items are equal.
 */
function stableSort(arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].ss_i = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].ss_i; // stable sort index
	}
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMin(data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMax(data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
}

/**
 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 * It loops all properties and invokes destroy if there is a destroy method. The property is
 * then delete'ed.
 * @param {Object} The object to destroy properties on
 * @param {Object} Exception, do not destroy this property, only delete it.
 */
function destroyObjectProperties(obj, except) {
	var n;
	for (n in obj) {
		// If the object is non-null and destroy is defined
		if (obj[n] && obj[n] !== except && obj[n].destroy) {
			// Invoke the destroy
			obj[n].destroy();
		}

		// Delete the property from the object.
		delete obj[n];
	}
}


/**
 * Discard an element by moving it to the bin and delete
 * @param {Object} The HTML node to discard
 */
function discardElement(element) {
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = createElement(DIV);
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
}

/**
 * Provide error messages for debugging, with links to online explanation 
 */
function error(code, stop) {
	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	if (stop) {
		throw msg;
	} else if (win.console) {
		console.log(msg);
	}
}

/**
 * Fix JS round off float errors
 * @param {Number} num
 */
function correctFloat(num) {
	return parseFloat(
		num.toPrecision(14)
	);
}

/**
 * Set the global animation to either a given value, or fall back to the
 * given chart's animation option
 * @param {Object} animation
 * @param {Object} chart
 */
function setAnimation(animation, chart) {
	globalAnimation = pick(animation, chart.animation);
}

/**
 * The time unit lookup
 */
/*jslint white: true*/
timeUnits = hash(
	MILLISECOND, 1,
	SECOND, 1000,
	MINUTE, 60000,
	HOUR, 3600000,
	DAY, 24 * 3600000,
	WEEK, 7 * 24 * 3600000,
	MONTH, 31 * 24 * 3600000,
	YEAR, 31556952000
);
/*jslint white: false*/
/**
 * Path interpolation algorithm used across adapters
 */
pathAnim = {
	/**
	 * Prepare start and end values so that the path can be animated one to one
	 */
	init: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift = elem.shift,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			endLength,
			slice,
			i,
			start = fromD.split(' '),
			end = [].concat(toD), // copy
			startBaseLine,
			endBaseLine,
			sixify = function (arr) { // in splines make move points have six parameters like bezier curves
				i = arr.length;
				while (i--) {
					if (arr[i] === M) {
						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
					}
				}
			};

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// pull out the base lines before padding
		if (elem.isArea) {
			startBaseLine = start.splice(start.length - 6, 6);
			endBaseLine = end.splice(end.length - 6, 6);
		}

		// if shifting points, prepend a dummy point to the end path
		if (shift <= end.length / numParams && start.length === end.length) {
			while (shift--) {
				end = [].concat(end).splice(0, numParams).concat(end);
			}
		}
		elem.shift = 0; // reset for following animations

		// copy and append last point until the length matches the end length
		if (start.length) {
			endLength = end.length;
			while (start.length < endLength) {

				//bezier && sixify(start);
				slice = [].concat(start).splice(start.length - numParams, numParams);
				if (bezier) { // disable first control point
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				start = start.concat(slice);
			}
		}

		if (startBaseLine) { // append the base lines for areas
			start = start.concat(startBaseLine);
			end = end.concat(endBaseLine);
		}
		return [start, end];
	},

	/**
	 * Interpolate each value of the path and return the array
	 */
	step: function (start, end, pos, complete) {
		var ret = [],
			i = start.length,
			startVal;

		if (pos === 1) { // land on the final path without adjustment points appended in the ends
			ret = complete;

		} else if (i === end.length && pos < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
						start[i] :
						pos * (parseFloat(end[i] - startVal)) + startVal;

			}
		} else { // if animation is finished or length not matching, land on right value
			ret = end;
		}
		return ret;
	}
};

(function ($) {
	/**
	 * The default HighchartsAdapter for jQuery
	 */
	win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
		
		/**
		 * Initialize the adapter by applying some extensions to jQuery
		 */
		init: function (pathAnim) {
			
			// extend the animate function to allow SVG animations
			var Fx = $.fx,
				Step = Fx.step,
				dSetter,
				Tween = $.Tween,
				propHooks = Tween && Tween.propHooks,
				opacityHook = $.cssHooks.opacity;
			
			/*jslint unparam: true*//* allow unused param x in this function */
			$.extend($.easing, {
				easeOutQuad: function (x, t, b, c, d) {
					return -c * (t /= d) * (t - 2) + b;
				}
			});
			/*jslint unparam: false*/
		
			// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
			$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
				var obj = Step,
					base,
					elem;
					
				// Handle different parent objects
				if (fn === 'cur') {
					obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
				
				} else if (fn === '_default' && Tween) { // jQuery 1.8 model
					obj = propHooks[fn];
					fn = 'set';
				}
		
				// Overwrite the method
				base = obj[fn];
				if (base) { // step.width and step.height don't exist in jQuery < 1.7
		
					// create the extended function replacement
					obj[fn] = function (fx) {
		
						// Fx.prototype.cur does not use fx argument
						fx = i ? fx : this;

						// Don't run animations on textual properties like align (#1821)
						if (fx.prop === 'align') {
							return;
						}
		
						// shortcut
						elem = fx.elem;
		
						// Fx.prototype.cur returns the current value. The other ones are setters
						// and returning a value has no effect.
						return elem.attr ? // is SVG element wrapper
							elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
							base.apply(this, arguments); // use jQuery's built-in method
					};
				}
			});

			// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
			wrap(opacityHook, 'get', function (proceed, elem, computed) {
				return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
			});
			
			
			// Define the setter function for d (path definitions)
			dSetter = function (fx) {
				var elem = fx.elem,
					ends;
		
				// Normally start and end should be set in state == 0, but sometimes,
				// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
				// in these cases
				if (!fx.started) {
					ends = pathAnim.init(elem, elem.d, elem.toD);
					fx.start = ends[0];
					fx.end = ends[1];
					fx.started = true;
				}
		
		
				// interpolate each value of the path
				elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
			};
			
			// jQuery 1.8 style
			if (Tween) {
				propHooks.d = {
					set: dSetter
				};
			// pre 1.8
			} else {
				// animate paths
				Step.d = dSetter;
			}
			
			/**
			 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			this.each = Array.prototype.forEach ?
				function (arr, fn) { // modern browsers
					return Array.prototype.forEach.call(arr, fn);
					
				} : 
				function (arr, fn) { // legacy
					var i = 0, 
						len = arr.length;
					for (; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			
			/**
			 * Register Highcharts as a plugin in the respective framework
			 */
			$.fn.highcharts = function () {
				var constr = 'Chart', // default constructor
					args = arguments,
					options,
					ret,
					chart;

				if (isString(args[0])) {
					constr = args[0];
					args = Array.prototype.slice.call(args, 1); 
				}
				options = args[0];

				// Create the chart
				if (options !== UNDEFINED) {
					/*jslint unused:false*/
					options.chart = options.chart || {};
					options.chart.renderTo = this[0];
					chart = new Highcharts[constr](options, args[1]);
					ret = this;
					/*jslint unused:true*/
				}

				// When called without parameters or with the return argument, get a predefined chart
				if (options === UNDEFINED) {
					ret = charts[attr(this[0], 'data-highcharts-chart')];
				}	

				return ret;
			};

		},

		
		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: $.getScript,
		
		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: $.inArray,
		
		/**
		 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
		 * @param {Object} elem The HTML element
		 * @param {String} method Which method to run on the wrapped element
		 */
		adapterRun: function (elem, method) {
			return $(elem)[method]();
		},
	
		/**
		 * Filter an array
		 */
		grep: $.grep,
	
		/**
		 * Map an array
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		map: function (arr, fn) {
			//return jQuery.map(arr, fn);
			var results = [],
				i = 0,
				len = arr.length;
			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}
			return results;
	
		},
	
		/**
		 * Get the position of an element relative to the top left of the page
		 */
		offset: function (el) {
			return $(el).offset();
		},
	
		/**
		 * Add an event listener
		 * @param {Object} el A HTML element or custom object
		 * @param {String} event The event type
		 * @param {Function} fn The event handler
		 */
		addEvent: function (el, event, fn) {
			$(el).bind(event, fn);
		},
	
		/**
		 * Remove event added with addEvent
		 * @param {Object} el The object
		 * @param {String} eventType The event type. Leave blank to remove all events.
		 * @param {Function} handler The function to remove
		 */
		removeEvent: function (el, eventType, handler) {
			// workaround for jQuery issue with unbinding custom events:
			// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
			var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
			if (doc[func] && el && !el[func]) {
				el[func] = function () {};
			}
	
			$(el).unbind(eventType, handler);
		},
	
		/**
		 * Fire an event on a custom object
		 * @param {Object} el
		 * @param {String} type
		 * @param {Object} eventArguments
		 * @param {Function} defaultFunction
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var event = $.Event(type),
				detachedType = 'detached' + type,
				defaultPrevented;
	
			// Remove warnings in Chrome when accessing layerX and layerY. Although Highcharts
			// never uses these properties, Chrome includes them in the default click event and
			// raises the warning when they are copied over in the extend statement below.
			//
			// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
			// testing if they are there (warning in chrome) the only option is to test if running IE.
			if (!isIE && eventArguments) {
				delete eventArguments.layerX;
				delete eventArguments.layerY;
			}
	
			extend(event, eventArguments);
	
			// Prevent jQuery from triggering the object method that is named the
			// same as the event. For example, if the event is 'select', jQuery
			// attempts calling el.select and it goes into a loop.
			if (el[type]) {
				el[detachedType] = el[type];
				el[type] = null;
			}
	
			// Wrap preventDefault and stopPropagation in try/catch blocks in
			// order to prevent JS errors when cancelling events on non-DOM
			// objects. #615.
			/*jslint unparam: true*/
			$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
				var base = event[fn];
				event[fn] = function () {
					try {
						base.call(event);
					} catch (e) {
						if (fn === 'preventDefault') {
							defaultPrevented = true;
						}
					}
				};
			});
			/*jslint unparam: false*/
	
			// trigger it
			$(el).trigger(event);
	
			// attach the method
			if (el[detachedType]) {
				el[type] = el[detachedType];
				el[detachedType] = null;
			}
	
			if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
				defaultFunction(event);
			}
		},
		
		/**
		 * Extension method needed for MooTools
		 */
		washMouseEvent: function (e) {
			var ret = e.originalEvent || e;
			
			// computed by jQuery, needed by IE8
			if (ret.pageX === UNDEFINED) { // #1236
				ret.pageX = e.pageX;
				ret.pageY = e.pageY;
			}
			
			return ret;
		},
	
		/**
		 * Animate a HTML element or SVG element wrapper
		 * @param {Object} el
		 * @param {Object} params
		 * @param {Object} options jQuery-like animation options: duration, easing, callback
		 */
		animate: function (el, params, options) {
			var $el = $(el);
			if (!el.style) {
				el.style = {}; // #1881
			}
			if (params.d) {
				el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
				params.d = 1; // because in jQuery, animating to an array has a different meaning
			}
	
			$el.stop();
			if (params.opacity !== UNDEFINED && el.attr) {
				params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
			}
			$el.animate(params, options);
	
		},
		/**
		 * Stop running animation
		 */
		stop: function (el) {
			$(el).stop();
		}
	});
}(win.jQuery));


// check for a custom HighchartsAdapter defined prior to this file
var globalAdapter = win.HighchartsAdapter,
	adapter = globalAdapter || {};
	
// Initialize the adapter
if (globalAdapter) {
	globalAdapter.init.call(globalAdapter, pathAnim);
}


// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
// and all the utility functions will be null. In that case they are populated by the
// default adapters below.
var adapterRun = adapter.adapterRun,
	getScript = adapter.getScript,
	inArray = adapter.inArray,
	each = adapter.each,
	grep = adapter.grep,
	offset = adapter.offset,
	map = adapter.map,
	addEvent = adapter.addEvent,
	removeEvent = adapter.removeEvent,
	fireEvent = adapter.fireEvent,
	washMouseEvent = adapter.washMouseEvent,
	animate = adapter.animate,
	stop = adapter.stop;



/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
var

defaultLabelOptions = {
	enabled: true,
	// rotation: 0,
	// align: 'center',
	x: 0,
	y: 15,
	/*formatter: function () {
		return this.value;
	},*/
	style: {
		color: '#666',
		cursor: 'default',
		fontSize: '11px',
		lineHeight: '14px'
	}
};

defaultOptions = {
	colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce', '#492970',
		'#f28f43', '#77a1e5', '#c42525', '#a6c96a'],
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {
		loading: 'Loading...',
		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
				'August', 'September', 'October', 'November', 'December'],
		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		decimalPoint: '.',
		numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
		resetZoom: 'Reset zoom',
		resetZoomTitle: 'Reset zoom level 1:1',
		thousandsSep: ','
	},
	global: {
		useUTC: true,
		canvasToolsURL: 'http://code.highcharts.com/3.0.6/modules/canvas-tools.js',
		VMLRadialGradientURL: 'http://code.highcharts.com/3.0.6/gfx/vml-radial-gradient.png'
	},
	chart: {
		//animation: true,
		//alignTicks: false,
		//reflow: true,
		//className: null,
		//events: { load, selection },
		//margin: [null],
		//marginTop: null,
		//marginRight: null,
		//marginBottom: null,
		//marginLeft: null,
		borderColor: '#4572A7',
		//borderWidth: 0,
		borderRadius: 5,
		defaultSeriesType: 'line',
		ignoreHiddenSeries: true,
		//inverted: false,
		//shadow: false,
		spacing: [10, 10, 15, 10],
		//spacingTop: 10,
		//spacingRight: 10,
		//spacingBottom: 15,
		//spacingLeft: 10,
		style: {
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			fontSize: '12px'
		},
		backgroundColor: '#FFFFFF',
		//plotBackgroundColor: null,
		plotBorderColor: '#C0C0C0',
		//plotBorderWidth: 0,
		//plotShadow: false,
		//zoomType: ''
		resetZoomButton: {
			theme: {
				zIndex: 20
			},
			position: {
				align: 'right',
				x: -10,
				//verticalAlign: 'top',
				y: 10
			}
			// relativeTo: 'plot'
		}
	},
	title: {
		text: 'Chart title',
		align: 'center',
		// floating: false,
		margin: 15,
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#274b6d',//#3E576F',
			fontSize: '16px'
		}

	},
	subtitle: {
		text: '',
		align: 'center',
		// floating: false
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#4d759e'
		}
	},

	plotOptions: {
		line: { // base series options
			allowPointSelect: false,
			showCheckbox: false,
			animation: {
				duration: 1000
			},
			//connectNulls: false,
			//cursor: 'default',
			//clip: true,
			//dashStyle: null,
			//enableMouseTracking: true,
			events: {},
			//legendIndex: 0,
			lineWidth: 2,
			//shadow: false,
			// stacking: null,
			marker: {
				enabled: true,
				//symbol: null,
				lineWidth: 0,
				radius: 4,
				lineColor: '#FFFFFF',
				//fillColor: null,
				states: { // states for a single point
					hover: {
						enabled: true
						//radius: base + 2
					},
					select: {
						fillColor: '#FFFFFF',
						lineColor: '#000000',
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: merge(defaultLabelOptions, {
				align: 'center',
				enabled: false,
				formatter: function () {
					return this.y === null ? '' : numberFormat(this.y, -1);
				},
				verticalAlign: 'bottom', // above singular point
				y: 0
				// backgroundColor: undefined,
				// borderColor: undefined,
				// borderRadius: undefined,
				// borderWidth: undefined,
				// padding: 3,
				// shadow: false
			}),
			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
			pointRange: 0,
			//pointStart: 0,
			//pointInterval: 1,
			showInLegend: true,
			states: { // states for the entire series
				hover: {
					//enabled: false,
					//lineWidth: base + 1,
					marker: {
						// lineWidth: base + 1,
						// radius: base + 1
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: true
			//tooltip: {
				//pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b>'
				//valueDecimals: null,
				//xDateFormat: '%A, %b %e, %Y',
				//valuePrefix: '',
				//ySuffix: ''				
			//}
			// turboThreshold: 1000
			// zIndex: null
		}
	},
	labels: {
		//items: [],
		style: {
			//font: defaultFont,
			position: ABSOLUTE,
			color: '#3E576F'
		}
	},
	legend: {
		enabled: true,
		align: 'center',
		//floating: false,
		layout: 'horizontal',
		labelFormatter: function () {
			return this.name;
		},
		borderWidth: 1,
		borderColor: '#909090',
		borderRadius: 5,
		navigation: {
			// animation: true,
			activeColor: '#274b6d',
			// arrowSize: 12
			inactiveColor: '#CCC'
			// style: {} // text styles
		},
		// margin: 10,
		// reversed: false,
		shadow: false,
		// backgroundColor: null,
		/*style: {
			padding: '5px'
		},*/
		itemStyle: {
			cursor: 'pointer',
			color: '#274b6d',
			fontSize: '12px'
		},
		itemHoverStyle: {
			//cursor: 'pointer', removed as of #601
			color: '#000'
		},
		itemHiddenStyle: {
			color: '#CCC'
		},
		itemCheckboxStyle: {
			position: ABSOLUTE,
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,
		symbolWidth: 16,
		symbolPadding: 5,
		verticalAlign: 'bottom',
		// width: undefined,
		x: 0,
		y: 0,
		title: {
			//text: null,
			style: {
				fontWeight: 'bold'
			}
		}			
	},

	loading: {
		// hideDuration: 100,
		labelStyle: {
			fontWeight: 'bold',
			position: RELATIVE,
			top: '1em'
		},
		// showDuration: 0,
		style: {
			position: ABSOLUTE,
			backgroundColor: 'white',
			opacity: 0.5,
			textAlign: 'center'
		}
	},

	tooltip: {
		enabled: true,
		animation: hasSVG,
		//crosshairs: null,
		backgroundColor: 'rgba(255, 255, 255, .85)',
		borderWidth: 1,
		borderRadius: 3,
		dateTimeLabelFormats: { 
			millisecond: '%A, %b %e, %H:%M:%S.%L',
			second: '%A, %b %e, %H:%M:%S',
			minute: '%A, %b %e, %H:%M',
			hour: '%A, %b %e, %H:%M',
			day: '%A, %b %e, %Y',
			week: 'Week from %A, %b %e, %Y',
			month: '%B %Y',
			year: '%Y'
		},
		//formatter: defaultFormatter,
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
		pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
		shadow: true,
		//shared: false,
		snap: isTouchDevice ? 25 : 10,
		style: {
			color: '#333333',
			cursor: 'default',
			fontSize: '12px',
			padding: '8px',
			whiteSpace: 'nowrap'
		}
		//xDateFormat: '%A, %b %e, %Y',
		//valueDecimals: null,
		//valuePrefix: '',
		//valueSuffix: ''
	},

	credits: {
		enabled: true,
		text: 'Highcharts.com',
		href: 'http://www.highcharts.com',
		position: {
			align: 'right',
			x: -10,
			verticalAlign: 'bottom',
			y: -5
		},
		style: {
			cursor: 'pointer',
			color: '#909090',
			fontSize: '9px'
		}
	}
};




// Series defaults
var defaultPlotOptions = defaultOptions.plotOptions,
	defaultSeriesOptions = defaultPlotOptions.line;

// set the default time methods
setTimeMethods();



/**
 * Set the time methods globally based on the useUTC option. Time method can be either
 * local time or UTC (default).
 */
function setTimeMethods() {
	var useUTC = defaultOptions.global.useUTC,
		GET = useUTC ? 'getUTC' : 'get',
		SET = useUTC ? 'setUTC' : 'set';

	makeTime = useUTC ? Date.UTC : function (year, month, date, hours, minutes, seconds) {
		return new Date(
			year,
			month,
			pick(date, 1),
			pick(hours, 0),
			pick(minutes, 0),
			pick(seconds, 0)
		).getTime();
	};
	getMinutes =  GET + 'Minutes';
	getHours =    GET + 'Hours';
	getDay =      GET + 'Day';
	getDate =     GET + 'Date';
	getMonth =    GET + 'Month';
	getFullYear = GET + 'FullYear';
	setMinutes =  SET + 'Minutes';
	setHours =    SET + 'Hours';
	setDate =     SET + 'Date';
	setMonth =    SET + 'Month';
	setFullYear = SET + 'FullYear';

}

/**
 * Merge the default options with custom options and return the new options structure
 * @param {Object} options The new custom options
 */
function setOptions(options) {
	
	// Pull out axis options and apply them to the respective default axis options 
	/*defaultXAxisOptions = merge(defaultXAxisOptions, options.xAxis);
	defaultYAxisOptions = merge(defaultYAxisOptions, options.yAxis);
	options.xAxis = options.yAxis = UNDEFINED;*/
	
	// Merge in the default options
	defaultOptions = merge(defaultOptions, options);
	
	// Apply UTC
	setTimeMethods();

	return defaultOptions;
}

/**
 * Get the updated default options. Merely exposing defaultOptions for outside modules
 * isn't enough because the setOptions method creates a new object.
 */
function getOptions() {
	return defaultOptions;
}


/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
var Color = function (input) {
	// declare variables
	var rgba = [], result, stops;

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	function init(input) {

		// Gradients
		if (input && input.stops) {
			stops = map(input.stops, function (stop) {
				return Color(stop[1]);
			});

		// Solid colors
		} else {
			// rgba
			result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
			if (result) {
				rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
			} else { 
				// hex
				result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
				if (result) {
					rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
				} else {
					// rgb
					result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(input);
					if (result) {
						rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
					}
				}
			}
		}		

	}
	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	function get(format) {
		var ret;

		if (stops) {
			ret = merge(input);
			ret.stops = [].concat(ret.stops);
			each(stops, function (stop, i) {
				ret.stops[i] = [ret.stops[i][0], stop.get(format)];
			});

		// it's NaN if gradient colors on a column chart
		} else if (rgba && !isNaN(rgba[0])) {
			if (format === 'rgb') {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	}

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	function brighten(alpha) {
		if (stops) {
			each(stops, function (stop) {
				stop.brighten(alpha);
			});
		
		} else if (isNumber(alpha) && alpha !== 0) {
			var i;
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	}
	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	function setOpacity(alpha) {
		rgba[3] = alpha;
		return this;
	}

	// initialize: parse the input
	init(input);

	// public methods
	return {
		get: get,
		brighten: brighten,
		rgba: rgba,
		setOpacity: setOpacity
	};
};


/**
 * A wrapper object for SVG elements
 */
function SVGElement() {}

SVGElement.prototype = {
	/**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this;
		wrapper.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(SVG_NS, nodeName);
		wrapper.renderer = renderer;
		/**
		 * A collection of attribute setters. These methods, if defined, are called right before a certain
		 * attribute is set on an element wrapper. Returning false prevents the default attribute
		 * setter to run. Returning a value causes the default setter to set that value. Used in
		 * Renderer.label.
		 */
		wrapper.attrSetters = {};
	},
	/**
	 * Default base for animation
	 */
	opacity: 1,
	/**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
	animate: function (params, options, complete) {
		var animOptions = pick(options, globalAnimation, true);
		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
		if (animOptions) {
			animOptions = merge(animOptions);
			if (complete) { // allows using a callback with the global animation without overwriting it
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params);
			if (complete) {
				complete();
			}
		}
	},
	/**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			result,
			i,
			child,
			element = wrapper.element,
			nodeName = element.nodeName.toLowerCase(), // Android2 requires lower for "text"
			renderer = wrapper.renderer,
			skipAttr,
			titleNode,
			attrSetters = wrapper.attrSetters,
			shadows = wrapper.shadows,
			hasSetSymbolSize,
			doTransform,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (isString(hash)) {
			key = hash;
			if (nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			} else if (key === 'strokeWidth') {
				key = 'stroke-width';
			}
			ret = attr(element, key) || wrapper[key] || 0;
			if (key !== 'd' && key !== 'visibility' && key !== 'fill') { // 'd' is string in animation step
				ret = parseFloat(ret);
			}

		// setter
		} else {

			for (key in hash) {
				skipAttr = false; // reset
				value = hash[key];

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);

				if (result !== false) {
					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}


					// paths
					if (key === 'd') {
						if (value && value.join) { // join path
							value = value.join(' ');
						}
						if (/(NaN| {2}|^$)/.test(value)) {
							value = 'M 0 0';
						}
						//wrapper.d = value; // shortcut for animations

					// update child tspans x values
					} else if (key === 'x' && nodeName === 'text') {
						for (i = 0; i < element.childNodes.length; i++) {
							child = element.childNodes[i];
							// if the x values are equal, the tspan represents a linebreak
							if (attr(child, 'x') === attr(element, 'x')) {
								//child.setAttribute('x', value);
								attr(child, 'x', value);
							}
						}

					} else if (wrapper.rotation && (key === 'x' || key === 'y')) {
						doTransform = true;

					// apply gradients
					} else if (key === 'fill') {
						value = renderer.color(value, element, key);

					// circle x and y
					} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
						key = { x: 'cx', y: 'cy' }[key] || key;

					// rectangle border radius
					} else if (nodeName === 'rect' && key === 'r') {
						attr(element, {
							rx: value,
							ry: value
						});
						skipAttr = true;

					// translation and text rotation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' ||
							key === 'verticalAlign' || key === 'scaleX' || key === 'scaleY') {
						doTransform = true;
						skipAttr = true;

					// apply opacity as subnode (required by legacy WebKit and Batik)
					} else if (key === 'stroke') {
						value = renderer.color(value, element, key);

					// emulate VML's dashstyle implementation
					} else if (key === 'dashstyle') {
						key = 'stroke-dasharray';
						value = value && value.toLowerCase();
						if (value === 'solid') {
							value = NONE;
						} else if (value) {
							value = value
								.replace('shortdashdotdot', '3,1,1,1,1,1,')
								.replace('shortdashdot', '3,1,1,1')
								.replace('shortdot', '1,1,')
								.replace('shortdash', '3,1,')
								.replace('longdash', '8,3,')
								.replace(/dot/g, '1,3,')
								.replace('dash', '4,3,')
								.replace(/,$/, '')
								.split(','); // ending comma

							i = value.length;
							while (i--) {
								value[i] = pInt(value[i]) * pick(hash['stroke-width'], wrapper['stroke-width']);
							}
							value = value.join(',');
						}

					// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
					// is unable to cast them. Test again with final IE9.
					} else if (key === 'width') {
						value = pInt(value);

					// Text alignment
					} else if (key === 'align') {
						key = 'text-anchor';
						value = { left: 'start', center: 'middle', right: 'end' }[value];

					// Title requires a subnode, #431
					} else if (key === 'title') {
						titleNode = element.getElementsByTagName('title')[0];
						if (!titleNode) {
							titleNode = doc.createElementNS(SVG_NS, 'title');
							element.appendChild(titleNode);
						}
						titleNode.textContent = value;
					}

					// jQuery animate changes case
					if (key === 'strokeWidth') {
						key = 'stroke-width';
					}

					// In Chrome/Win < 6 as well as Batik, the stroke attribute can't be set when the stroke-
					// width is 0. #1369
					if (key === 'stroke-width' || key === 'stroke') {
						wrapper[key] = value;
						// Only apply the stroke attribute if the stroke width is defined and larger than 0
						if (wrapper.stroke && wrapper['stroke-width']) {
							attr(element, 'stroke', wrapper.stroke);
							attr(element, 'stroke-width', wrapper['stroke-width']);
							wrapper.hasStroke = true;
						} else if (key === 'stroke-width' && value === 0 && wrapper.hasStroke) {
							element.removeAttribute('stroke');
							wrapper.hasStroke = false;
						}
						skipAttr = true;
					}

					// symbols
					if (wrapper.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {


						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					// let the shadow follow the main element
					if (shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
						i = shadows.length;
						while (i--) {
							attr(
								shadows[i],
								key,
								key === 'height' ?
									mathMax(value - (shadows[i].cutHeight || 0), 0) :
									value
							);
						}
					}

					// validate heights
					if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
						value = 0;
					}

					// Record for animation and quick access without polling the DOM
					wrapper[key] = value;


					if (key === 'text') {
						// Delete bBox memo when the text changes
						if (value !== wrapper.textStr) {
							delete wrapper.bBox;
						}
						wrapper.textStr = value;
						if (wrapper.added) {
							renderer.buildText(wrapper);
						}
					} else if (!skipAttr) {
						attr(element, key, value);
					}

				}

			}

			// Update transform. Do this outside the loop to prevent redundant updating for batch setting
			// of attributes.
			if (doTransform) {
				wrapper.updateTransform();
			}

		}

		return ret;
	},


	/**
	 * Add a class name to an element
	 */
	addClass: function (className) {
		var element = this.element,
			currentClassName = attr(element, 'class') || '';

		if (currentClassName.indexOf(className) === -1) {
			attr(element, 'class', currentClassName + ' ' + className);
		}
		return this;
	},
	/* hasClass and removeClass are not (yet) needed
	hasClass: function (className) {
		return attr(this.element, 'class').indexOf(className) !== -1;
	},
	removeClass: function (className) {
		attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
		return this;
	},
	*/

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](
				wrapper.x,
				wrapper.y,
				wrapper.width,
				wrapper.height,
				wrapper
			)
		});
	},

	/**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
	clip: function (clipRect) {
		return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	crisp: function (strokeWidth, x, y, width, height) {

		var wrapper = this,
			key,
			attribs = {},
			values = {},
			normalizer;

		strokeWidth = strokeWidth || wrapper.strokeWidth || (wrapper.attr && wrapper.attr('stroke-width')) || 0;
		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

		// normalize for crisp edges
		values.x = mathFloor(x || wrapper.x || 0) + normalizer;
		values.y = mathFloor(y || wrapper.y || 0) + normalizer;
		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
		values.strokeWidth = strokeWidth;

		for (key in values) {
			if (wrapper[key] !== values[key]) { // only set attribute if changed
				wrapper[key] = attribs[key] = values[key];
			}
		}

		return attribs;
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: function (styles) {
		/*jslint unparam: true*//* allow unused param a in the regexp function below */
		var elemWrapper = this,
			elem = elemWrapper.element,
			textWidth = styles && styles.width && elem.nodeName.toLowerCase() === 'text',
			n,
			serializedCss = '',
			hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
		/*jslint unparam: false*/

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Merge the new styles with the old ones
		styles = extend(
			elemWrapper.styles,
			styles
		);

		// store object
		elemWrapper.styles = styles;


		// Don't handle line wrap on canvas
		if (useCanVG && textWidth) {
			delete styles.width;
		}

		// serialize and set style attribute
		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
			if (textWidth) {
				delete styles.width;
			}
			css(elemWrapper.element, styles);
		} else {
			for (n in styles) {
				serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
			}
			attr(elem, 'style', serializedCss); // #1881
		}


		// re-build text
		if (textWidth && elemWrapper.added) {
			elemWrapper.renderer.buildText(elemWrapper);
		}

		return elemWrapper;
	},

	/**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		var svgElement = this,
			element = svgElement.element;
		
		// touch
		if (hasTouch && eventType === 'click') {
			element.ontouchstart = function (e) {			
				svgElement.touchEventFired = Date.now();				
				e.preventDefault();
				handler.call(element, e);
			};
			element.onclick = function (e) {												
				if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
					handler.call(element, e);
				}
			};			
		} else {
			// simplest possible event model for internal use
			element['on' + eventType] = handler;
		}
		return this;
	},

	/**
	 * Set the coordinates needed to draw a consistent radial gradient across
	 * pie slices regardless of positioning inside the chart. The format is
	 * [centerX, centerY, diameter] in pixels.
	 */
	setRadialReference: function (coordinates) {
		this.element.radialReference = coordinates;
		return this;
	},

	/**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip
	 */
	invert: function () {
		var wrapper = this;
		wrapper.inverted = true;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}

		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},



	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	 * use the cached value
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function () {
		var wrapper = this,
			element = wrapper.element,
			bBox = wrapper.bBox;

		// faking getBBox in exported SVG in legacy IE
		if (!bBox) {
			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			bBox = wrapper.bBox = {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		}

		return bBox;
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			nonLeft = align && align !== 'left',
			shadows = wrapper.shadows;

		// apply translate
		css(elem, {
			marginLeft: translateX,
			marginTop: translateY
		});
		if (shadows) { // used in labels/tooltip
			each(shadows, function (shadow) {
				css(shadow, {
					marginLeft: translateX + 1,
					marginTop: translateY + 1
				});
			});
		}

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var width, height,
				rotation = wrapper.rotation,
				baseline,
				radians = 0,
				costheta = 1,
				sintheta = 0,
				quad,
				textWidth = pInt(wrapper.textWidth),
				xCorr = wrapper.xCorr || 0,
				yCorr = wrapper.yCorr || 0,
				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed

				if (defined(rotation)) {

					radians = rotation * deg2rad; // deg to rad
					costheta = mathCos(radians);
					sintheta = mathSin(radians);

					wrapper.setSpanRotation(rotation, sintheta, costheta);

				}

				width = pick(wrapper.elemWidth, elem.offsetWidth);
				height = pick(wrapper.elemHeight, elem.offsetHeight);

				// update textWidth
				if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
					css(elem, {
						width: textWidth + PX,
						display: 'block',
						whiteSpace: 'normal'
					});
					width = textWidth;
				}

				// correct x and y
				baseline = renderer.fontMetrics(elem.style.fontSize).b;
				xCorr = costheta < 0 && -width;
				yCorr = sintheta < 0 && -height;

				// correct for baseline and corners spilling out after rotation
				quad = costheta * sintheta < 0;
				xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
				yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);

				// correct for the length/height of the text
				if (nonLeft) {
					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
					if (rotation) {
						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
					}
					css(elem, {
						textAlign: align
					});
				}

				// record correction
				wrapper.xCorr = xCorr;
				wrapper.yCorr = yCorr;
			}

			// apply position with correction
			css(elem, {
				left: (x + xCorr) + PX,
				top: (y + yCorr) + PX
			});

			// force reflow in webkit to apply the left and top on useHTML element (#1249)
			if (isWebKit) {
				height = elem.offsetHeight; // assigned to height for JSLint purpose
			}

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Set the rotation of an individual HTML span
	 */
	setSpanRotation: function (rotation) {
		var rotationStyle = {},
			cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

		rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
		css(this.element, rotationStyle);
	},

	/**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			scaleX = wrapper.scaleX,
			scaleY = wrapper.scaleY,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			transform;

		// flipping affects translate as adjustment for flipping around the group's axis
		if (inverted) {
			translateX += wrapper.attr('width');
			translateY += wrapper.attr('height');
		}

		// Apply translate. Nearly all transformed elements have translation, so instead
		// of checking for translate = 0, do it always (#1767, #1846).
		transform = ['translate(' + translateX + ',' + translateY + ')'];

		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push('rotate(' + rotation + ' ' + (wrapper.x || 0) + ' ' + (wrapper.y || 0) + ')');
		}

		// apply scale
		if (defined(scaleX) || defined(scaleY)) {
			transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
		}

		if (transform.length) {
			attr(wrapper.element, 'transform', transform.join(' '));
		}
	},
	/**
	 * Bring the element to the front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {String[Object} box The box to align to, needs a width and height. When the
	 *        box is a string, it refers to an object in the Renderer. For example, when
	 *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
	 *        x and y properties.
	 *
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var align,
			vAlign,
			x,
			y,
			attribs = {},
			alignTo,
			renderer = this.renderer,
			alignedObjects = renderer.alignedObjects;

		// First call on instanciate
		if (alignOptions) {
			this.alignOptions = alignOptions;
			this.alignByTranslate = alignByTranslate;
			if (!box || isString(box)) { // boxes other than renderer handle this internally
				this.alignTo = alignTo = box || 'renderer';
				erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
				alignedObjects.push(this);
				box = null; // reassign it below
			}

		// When called on resize, no arguments are supplied
		} else {
			alignOptions = this.alignOptions;
			alignByTranslate = this.alignByTranslate;
			alignTo = this.alignTo;
		}

		box = pick(box, renderer[alignTo], renderer);

		// Assign variables
		align = alignOptions.align;
		vAlign = alignOptions.verticalAlign;
		x = (box.x || 0) + (alignOptions.x || 0); // default: left align
		y = (box.y || 0) + (alignOptions.y || 0); // default: top align

		// Align
		if (align === 'right' || align === 'center') {
			x += (box.width - (alignOptions.width || 0)) /
					{ right: 1, center: 2 }[align];
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


		// Vertical align
		if (vAlign === 'bottom' || vAlign === 'middle') {
			y += (box.height - (alignOptions.height || 0)) /
					({ bottom: 1, middle: 2 }[vAlign] || 1);

		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

		// Animate only if already placed
		this[this.placed ? 'animate' : 'attr'](attribs);
		this.placed = true;
		this.alignAttr = attribs;

		return this;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element
	 */
	getBBox: function () {
		var wrapper = this,
			bBox = wrapper.bBox,
			renderer = wrapper.renderer,
			width,
			height,
			rotation = wrapper.rotation,
			element = wrapper.element,
			styles = wrapper.styles,
			rad = rotation * deg2rad;

		if (!bBox) {
			// SVG elements
			if (element.namespaceURI === SVG_NS || renderer.forExport) {
				try { // Fails in Firefox if the container has display: none.

					bBox = element.getBBox ?
						// SVG: use extend because IE9 is not allowed to change width and height in case
						// of rotation (below)
						extend({}, element.getBBox()) :
						// Canvas renderer and legacy IE in export mode
						{
							width: element.offsetWidth,
							height: element.offsetHeight
						};
				} catch (e) {}

				// If the bBox is not set, the try-catch block above failed. The other condition
				// is for Opera that returns a width of -Infinity on hidden elements.
				if (!bBox || bBox.width < 0) {
					bBox = { width: 0, height: 0 };
				}


			// VML Renderer or useHTML within SVG
			} else {

				bBox = wrapper.htmlGetBBox();

			}

			// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
			// need to compensated for rotation
			if (renderer.isSVG) {
				width = bBox.width;
				height = bBox.height;

				// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669)
				if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '22.7') {
					bBox.height = height = 14;
				}

				// Adjust for rotated text
				if (rotation) {
					bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
					bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
				}
			}

			wrapper.bBox = bBox;
		}
		return bBox;
	},

	/**
	 * Show the element
	 */
	show: function () {
		return this.attr({ visibility: VISIBLE });
	},

	/**
	 * Hide the element
	 */
	hide: function () {
		return this.attr({ visibility: HIDDEN });
	},

	fadeOut: function (duration) {
		var elemWrapper = this;
		elemWrapper.animate({
			opacity: 0
		}, {
			duration: duration || 150,
			complete: function () {
				elemWrapper.hide();
			}
		});
	},

	/**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *    to append the element to the renderer.box.
	 */
	add: function (parent) {

		var renderer = this.renderer,
			parentWrapper = parent || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes = parentNode.childNodes,
			element = this.element,
			zIndex = attr(element, 'zIndex'),
			otherElement,
			otherZIndex,
			i,
			inserted;

		if (parent) {
			this.parentGroup = parent;
		}

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// mark the container as having z indexed children
		if (zIndex) {
			parentWrapper.handleZ = true;
			zIndex = pInt(zIndex);
		}

		// insert according to this and other elements' zIndex
		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
			for (i = 0; i < childNodes.length; i++) {
				otherElement = childNodes[i];
				otherZIndex = attr(otherElement, 'zIndex');
				if (otherElement !== element && (
						// insert before the first element with a higher zIndex
						pInt(otherZIndex) > zIndex ||
						// if no zIndex given, insert before the first element with a zIndex
						(!defined(zIndex) && defined(otherZIndex))

						)) {
					parentNode.insertBefore(element, otherElement);
					inserted = true;
					break;
				}
			}
		}

		// default: append at the end
		if (!inserted) {
			parentNode.appendChild(element);
		}

		// mark as added
		this.added = true;

		// fire an event for internal hooks
		fireEvent(this, 'add');

		return this;
	},

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			shadows = wrapper.shadows,
			parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && element.parentNode,
			grandParent,
			key,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath) {
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		// destroy shadows
		if (shadows) {
			each(shadows, function (shadow) {
				wrapper.safeRemoveChild(shadow);
			});
		}

		// In case of useHTML, clean up empty containers emulating SVG groups (#1960).
		while (parentToClean && parentToClean.childNodes.length === 0) {
			grandParent = parentToClean.parentNode;
			wrapper.safeRemoveChild(parentToClean);
			parentToClean = grandParent;
		}

		// remove from alignObjects
		if (wrapper.alignTo) {
			erase(wrapper.renderer.alignedObjects, wrapper);
		}

		for (key in wrapper) {
			delete wrapper[key];
		}

		return null;
	},

	/**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			shadow,
			element = this.element,
			strokeWidth,
			shadowWidth,
			shadowElementOpacity,

			// compensate for inverted plot area
			transform;


		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			transform = this.parentInverted ?
				'(-1,-1)' :
				'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
			for (i = 1; i <= shadowWidth; i++) {
				shadow = element.cloneNode(0);
				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
				attr(shadow, {
					'isShadow': 'true',
					'stroke': shadowOptions.color || 'black',
					'stroke-opacity': shadowElementOpacity * i,
					'stroke-width': strokeWidth,
					'transform': 'translate' + transform,
					'fill': NONE
				});
				if (cutOff) {
					attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
					shadow.cutHeight = strokeWidth;
				}

				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	}
};


/**
 * The default SVG renderer
 */
var SVGRenderer = function () {
	this.init.apply(this, arguments);
};
SVGRenderer.prototype = {
	Element: SVGElement,

	/**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
	init: function (container, width, height, forExport) {
		var renderer = this,
			loc = location,
			boxWrapper,
			element,
			desc;

		boxWrapper = renderer.createElement('svg')
			.attr({
				version: '1.1'
			});
		element = boxWrapper.element;
		container.appendChild(element);

		// For browsers other than IE, add the namespace attribute (#1978)
		if (container.innerHTML.indexOf('xmlns') === -1) {
			attr(element, 'xmlns', SVG_NS);
		}

		// object properties
		renderer.isSVG = true;
		renderer.box = element;
		renderer.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];

		// Page url used for internal references. #24, #672, #1070
		renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
			loc.href
				.replace(/#.*?$/, '') // remove the hash
				.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
				.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
			'';

		// Add description
		desc = this.createElement('desc').add();
		desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


		renderer.defs = this.createElement('defs').add();
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored

		renderer.setSize(width, height, false);



		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position may land
		// between pixels. The container itself doesn't display this, but an SVG element
		// inside this container will be drawn at subpixel precision. In order to draw
		// sharp lines, this must be compensated for. This doesn't seem to work inside
		// iframes though (like in jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			renderer.subPixelFix = subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (mathCeil(rect.left) - rect.left) + PX,
					top: (mathCeil(rect.top) - rect.top) + PX
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			addEvent(win, 'resize', subPixelFix);
		}
	},

	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none. #608.
	 */
	isHidden: function () {
		return !this.boxWrapper.getBBox().width;
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		// Remove sub pixel fix handler
		// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
		// See issue #982
		if (renderer.subPixelFix) {
			removeEvent(win, 'resize', renderer.subPixelFix);
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for use in canvas renderer
	 */
	draw: function () {},

	/**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			renderer = this,
			forExport = renderer.forExport,
			lines = pick(wrapper.textStr, '').toString()
				.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
				.replace(/<(i|em)>/g, '<span style="font-style:italic">')
				.replace(/<a/g, '<span')
				.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
				.split(/<br.*?>/g),
			childNodes = textNode.childNodes,
			styleRegex = /style="([^"]+)"/,
			hrefRegex = /href="(http[^"]+)"/,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = textStyles && textStyles.width && pInt(textStyles.width),
			textLineHeight = textStyles && textStyles.lineHeight,
			i = childNodes.length;

		/// remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		if (width && !wrapper.added) {
			this.box.appendChild(textNode); // attach it to the DOM to read offset width
		}

		// remove empty line at end
		if (lines[lines.length - 1] === '') {
			lines.pop();
		}

		// build the lines
		each(lines, function (line, lineNo) {
			var spans, spanNo = 0;

			line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
			spans = line.split('|||');

			each(spans, function (span) {
				if (span !== '' || spans.length === 1) {
					var attributes = {},
						tspan = doc.createElementNS(SVG_NS, 'tspan'),
						spanStyle; // #390
					if (styleRegex.test(span)) {
						spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
						attr(tspan, 'style', spanStyle);
					}
					if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
						attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
						css(tspan, { cursor: 'pointer' });
					}

					span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
						.replace(/&lt;/g, '<')
						.replace(/&gt;/g, '>');

					// Nested tags aren't supported, and cause crash in Safari (#1596)
					if (span !== ' ') {

						// add the text node
						tspan.appendChild(doc.createTextNode(span));

						if (!spanNo) { // first span in a line, align it to the left
							attributes.x = parentX;
						} else {
							attributes.dx = 0; // #16
						}

						// add attributes
						attr(tspan, attributes);

						// first span on subsequent line, add the line height
						if (!spanNo && lineNo) {

							// allow getting the right offset height in exporting in IE
							if (!hasSVG && forExport) {
								css(tspan, { display: 'block' });
							}

							// Set the line height based on the font size of either
							// the text element or the tspan element
							attr(
								tspan,
								'dy',
								textLineHeight || renderer.fontMetrics(
									/px$/.test(tspan.style.fontSize) ?
										tspan.style.fontSize :
										textStyles.fontSize
								).h,
								// Safari 6.0.2 - too optimized for its own good (#1539)
								// TODO: revisit this with future versions of Safari
								isWebKit && tspan.offsetHeight
							);
						}

						// Append it
						textNode.appendChild(tspan);

						spanNo++;

						// check width and apply soft breaks
						if (width) {
							var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
								tooLong,
								actualWidth,
								clipHeight = wrapper._clipHeight,
								rest = [],
								dy = pInt(textLineHeight || 16),
								softLineNo = 1,
								bBox;

							while (words.length || rest.length) {
								delete wrapper.bBox; // delete cache
								bBox = wrapper.getBBox();
								actualWidth = bBox.width;
								tooLong = actualWidth > width;
								if (!tooLong || words.length === 1) { // new line needed
									words = rest;
									rest = [];
									if (words.length) {
										softLineNo++;

										if (clipHeight && softLineNo * dy > clipHeight) {
											words = ['...'];
											wrapper.attr('title', wrapper.textStr);
										} else {

											tspan = doc.createElementNS(SVG_NS, 'tspan');
											attr(tspan, {
												dy: dy,
												x: parentX
											});
											if (spanStyle) { // #390
												attr(tspan, 'style', spanStyle);
											}
											textNode.appendChild(tspan);

											if (actualWidth > width) { // a single word is pressing it out
												width = actualWidth;
											}
										}
									}
								} else { // append to existing line tspan
									tspan.removeChild(tspan.firstChild);
									rest.unshift(words.pop());
								}
								if (words.length) {
									tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
								}
							}
						}
					}
				}
			});
		});
	},

	/**
	 * Create a button with preset states
	 * @param {String} text
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Function} callback
	 * @param {Object} normalState
	 * @param {Object} hoverState
	 * @param {Object} pressedState
	 */
	button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState) {
		var label = this.label(text, x, y, null, null, null, null, null, 'button'),
			curState = 0,
			stateOptions,
			stateStyle,
			normalStyle,
			hoverStyle,
			pressedStyle,
			disabledStyle,
			STYLE = 'style',
			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

		// Normal state - prepare the attributes
		normalState = merge({
			'stroke-width': 1,
			stroke: '#CCCCCC',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FEFEFE'],
					[1, '#F6F6F6']
				]
			},
			r: 2,
			padding: 5,
			style: {
				color: 'black'
			}
		}, normalState);
		normalStyle = normalState[STYLE];
		delete normalState[STYLE];

		// Hover state
		hoverState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FFF'],
					[1, '#ACF']
				]
			}
		}, hoverState);
		hoverStyle = hoverState[STYLE];
		delete hoverState[STYLE];

		// Pressed state
		pressedState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#9BD'],
					[1, '#CDF']
				]
			}
		}, pressedState);
		pressedStyle = pressedState[STYLE];
		delete pressedState[STYLE];

		// Disabled state
		disabledState = merge(normalState, {
			style: {
				color: '#CCC'
			}
		}, disabledState);
		disabledStyle = disabledState[STYLE];
		delete disabledState[STYLE];

		// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
		addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
			if (curState !== 3) {
				label.attr(hoverState)
					.css(hoverStyle);
			}
		});
		addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
			if (curState !== 3) {
				stateOptions = [normalState, hoverState, pressedState][curState];
				stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
				label.attr(stateOptions)
					.css(stateStyle);
			}
		});

		label.setState = function (state) {
			label.state = curState = state;
			if (!state) {
				label.attr(normalState)
					.css(normalStyle);
			} else if (state === 2) {
				label.attr(pressedState)
					.css(pressedStyle);
			} else if (state === 3) {
				label.attr(disabledState)
					.css(disabledStyle);
			}
		};

		return label
			.on('click', function () {
				if (curState !== 3) {
					callback.call(label);
				}
			})
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
	crispLine: function (points, width) {
		// points format: [M, 0, 0, L, 100, 0]
		// normalize to a crisp line
		if (points[1] === points[4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave the same.
			points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
	path: function (path) {
		var attr = {
			fill: NONE
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		return this.createElement('path').attr(attr);
	},

	/**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
	circle: function (x, y, r) {
		var attr = isObject(x) ?
			x :
			{
				x: x,
				y: y,
				r: r
			};

		return this.createElement('circle').attr(attr);
	},

	/**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
	arc: function (x, y, r, innerR, start, end) {
		var arc;

		if (isObject(x)) {
			y = x.y;
			r = x.r;
			innerR = x.innerR;
			start = x.start;
			end = x.end;
			x = x.x;
		}

		// Arcs are defined as symbols for the ability to set
		// attributes in attr and animate
		arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
			innerR: innerR || 0,
			start: start || 0,
			end: end || 0
		});
		arc.r = r; // #959
		return arc;
	},

	/**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		r = isObject(x) ? x.r : r;

		var wrapper = this.createElement('rect').attr({
				rx: r,
				ry: r,
				fill: NONE
			});
		return wrapper.attr(
				isObject(x) ?
					x :
					// do not crispify when an object is passed in (as in column charts)
					wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0))
			);
	},

	/**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
			width: width,
			height: height
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *     This can be used for styling and scripting.
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	},

	/**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: NONE
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
	}

		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var obj,

			// get the symbol definition function
			symbolFn = this.symbols[symbol],

			// check if there's a path defined for this symbol
			path = symbolFn && symbolFn(
				mathRound(x),
				mathRound(y),
				width,
				height,
				options
			),

			imageElement,
			imageRegex = /^url\((.*?)\)$/,
			imageSrc,
			imageSize,
			centerImage;

		if (path) {

			obj = this.path(path);
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: symbol,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// image symbols
		} else if (imageRegex.test(symbol)) {

			// On image load, set the size and position
			centerImage = function (img, size) {
				if (img.element) { // it may be destroyed in the meantime (#1390)
					img.attr({
						width: size[0],
						height: size[1]
					});

					if (!img.alignByTranslate) { // #185
						img.translate(
							mathRound((width - size[0]) / 2), // #1378
							mathRound((height - size[1]) / 2)
						);
					}
				}
			};

			imageSrc = symbol.match(imageRegex)[1];
			imageSize = symbolSizes[imageSrc];

			// Ireate the image synchronously, add attribs async
			obj = this.image(imageSrc)
				.attr({
					x: x,
					y: y
				});
			obj.isImg = true;

			if (imageSize) {
				centerImage(obj, imageSize);
			} else {
				// Initialize image to be 0 size so export will still function if there's no cached sizes.
				//
				obj.attr({ width: 0, height: 0 });

				// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
				// the created element must be assigned to a variable in order to load (#292).
				imageElement = createElement('img', {
					onload: function () {
						centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
					},
					src: imageSrc
				});
			}
		}

		return obj;
	},

	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			var cpw = 0.166 * w;
			return [
				M, x + w / 2, y,
				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
				'Z'
			];
		},

		'square': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				radius = options.r || w || h,
				end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
				innerRadius = options.innerR,
				open = options.open,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				longArc = options.end - start < mathPI ? 0 : 1;

			return [
				M,
				x + radius * cosStart,
				y + radius * sinStart,
				'A', // arcTo
				radius, // x radius
				radius, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + radius * cosEnd,
				y + radius * sinEnd,
				open ? M : L,
				x + innerRadius * cosEnd,
				y + innerRadius * sinEnd,
				'A', // arcTo
				innerRadius, // x radius
				innerRadius, // y radius
				0, // slanting
				longArc, // long or short arc
				0, // clockwise
				x + innerRadius * cosStart,
				y + innerRadius * sinStart,

				open ? '' : 'Z' // close
			];
		}
	},

	/**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = PREFIX + idCounter++,

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;

		return wrapper;
	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object. Prior to Highstock, an array was used to define
	 * a linear gradient with pixel positions relative to the SVG. In newer versions
	 * we change the coordinates to apply relative to the shape, using coordinates
	 * 0-1 within the shape. To preserve backwards compatibility, linearGradient
	 * in this definition is an object of x1, y1, x2 and y2.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop) {
		var renderer = this,
			colorObject,
			regexRgba = /^rgba/,
			gradName,
			gradAttr,
			gradients,
			gradientObject,
			stops,
			stopColor,
			stopOpacity,
			radialReference,
			n,
			id,
			key = [];

		// Apply linear or radial gradients
		if (color && color.linearGradient) {
			gradName = 'linearGradient';
		} else if (color && color.radialGradient) {
			gradName = 'radialGradient';
		}

		if (gradName) {
			gradAttr = color[gradName];
			gradients = renderer.gradients;
			stops = color.stops;
			radialReference = elem.radialReference;

			// Keep < 2.2 kompatibility
			if (isArray(gradAttr)) {
				color[gradName] = gradAttr = {
					x1: gradAttr[0],
					y1: gradAttr[1],
					x2: gradAttr[2],
					y2: gradAttr[3],
					gradientUnits: 'userSpaceOnUse'
				};
			}

			// Correct the radial gradient for the radial reference system
			if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
				gradAttr = merge(gradAttr, {
					cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
					cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
					r: gradAttr.r * radialReference[2],
					gradientUnits: 'userSpaceOnUse'
				});
			}

			// Build the unique key to detect whether we need to create a new element (#1282)
			for (n in gradAttr) {
				if (n !== 'id') {
					key.push(n, gradAttr[n]);
				}
			}
			for (n in stops) {
				key.push(stops[n]);
			}
			key = key.join(',');

			// Check if a gradient object with the same config object is created within this renderer
			if (gradients[key]) {
				id = gradients[key].id;

			} else {

				// Set the id and create the element
				gradAttr.id = id = PREFIX + idCounter++;
				gradients[key] = gradientObject = renderer.createElement(gradName)
					.attr(gradAttr)
					.add(renderer.defs);


				// The gradient needs to keep a list of stops to be able to destroy them
				gradientObject.stops = [];
				each(stops, function (stop) {
					var stopObject;
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});
			}

			// Return the reference to the gradient object
			return 'url(' + renderer.url + '#' + id + ')';

		// Webkit and Batik can't show rgba.
		} else if (regexRgba.test(color)) {
			colorObject = Color(color);
			attr(elem, prop + '-opacity', colorObject.get('a'));

			return colorObject.get('rgb');


		} else {
			// Remove the opacity attribute added above. Does not throw if the attribute is not there.
			elem.removeAttribute(prop + '-opacity');

			return color;
		}

	},


	/**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Boolean} useHTML Use HTML to render the text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			defaultChartStyle = defaultOptions.chart.style,
			fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
			wrapper;

		if (useHTML && !renderer.forExport) {
			return renderer.html(str, x, y);
		}

		x = mathRound(pick(x, 0));
		y = mathRound(pick(y, 0));

		wrapper = renderer.createElement('text')
			.attr({
				x: x,
				y: y,
				text: str
			})
			.css({
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
		if (fakeSVG) {
			wrapper.css({
				position: ABSOLUTE
			});
		}

		wrapper.x = x;
		wrapper.y = y;
		return wrapper;
	},


	/**
	 * Create HTML text node. This is used by the VML renderer as well as the SVG
	 * renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var defaultChartStyle = defaultOptions.chart.style,
			wrapper = this.createElement('span'),
			attrSetters = wrapper.attrSetters,
			element = wrapper.element,
			renderer = wrapper.renderer;

		// Text setter
		attrSetters.text = function (value) {
			if (value !== element.innerHTML) {
				delete this.bBox;
			}
			element.innerHTML = value;
			return false;
		};

		// Various setters which rely on update transform
		attrSetters.x = attrSetters.y = attrSetters.align = function (value, key) {
			if (key === 'align') {
				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
			return false;
		};

		// Set the default attributes
		wrapper.attr({
				text: str,
				x: mathRound(x),
				y: mathRound(y)
			})
			.css({
				position: ABSOLUTE,
				whiteSpace: 'nowrap',
				fontFamily: defaultChartStyle.fontFamily,
				fontSize: defaultChartStyle.fontSize
			});

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (renderer.isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					container = renderer.box.parentNode,
					parentGroup,
					parents = [];

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {

						// Read the parent chain into an array and read from top down
						parentGroup = svgGroupWrapper;
						while (parentGroup) {

							parents.push(parentGroup);

							// Move up to the next parent group
							parentGroup = parentGroup.parentGroup;
						}

						// Ensure dynamically updating position when any parent is translated
						each(parents.reverse(), function (parentGroup) {
							var htmlGroupStyle;

							// Create a HTML div and append it to the parent div to emulate
							// the SVG group structure
							htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
								className: attr(parentGroup.element, 'class')
							}, {
								position: ABSOLUTE,
								left: (parentGroup.translateX || 0) + PX,
								top: (parentGroup.translateY || 0) + PX
							}, htmlGroup || container); // the top group is appended to container

							// Shortcut
							htmlGroupStyle = htmlGroup.style;

							// Set listeners to update the HTML div's position whenever the SVG group
							// position is changed
							extend(parentGroup.attrSetters, {
								translateX: function (value) {
									htmlGroupStyle.left = value + PX;
								},
								translateY: function (value) {
									htmlGroupStyle.top = value + PX;
								},
								visibility: function (value, key) {
									htmlGroupStyle[key] = value;
								}
							});
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font size
	 */
	fontMetrics: function (fontSize) {
		fontSize = pInt(fontSize || 11);

		// Empirical values found by comparing font size and bounding box height.
		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
		var lineHeight = fontSize < 24 ? fontSize + 4 : mathRound(fontSize * 1.2),
			baseline = mathRound(lineHeight * 0.8);

		return {
			h: lineHeight,
			b: baseline
		};
	},

	/**
	 * Add a label, a text item that can hold a colored or gradient background
	 * as well as a border and shadow.
	 * @param {string} str
	 * @param {Number} x
	 * @param {Number} y
	 * @param {String} shape
	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	 *    coordinates it should be pinned to
	 * @param {Number} anchorY
	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	 *    like renderer.text, or to the upper border of the rectangle.
	 * @param {String} className Class name for the group
	 */
	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

		var renderer = this,
			wrapper = renderer.g(className),
			text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				}),
				//.add(wrapper),
			box,
			bBox,
			alignFactor = 0,
			padding = 3,
			paddingLeft = 0,
			width,
			height,
			wrapperX,
			wrapperY,
			crispAdjust = 0,
			deferredAttr = {},
			baselineOffset,
			attrSetters = wrapper.attrSetters,
			needsBox;

		/**
		 * This function runs after the label is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxX,
				boxY,
				style = text.element.style;

			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) &&
				text.getBBox();
			wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
			wrapper.height = (height || bBox.height || 0) + 2 * padding;

			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;

			if (needsBox) {

				// create the border box if it is not already present
				if (!box) {
					boxX = mathRound(-alignFactor * padding);
					boxY = baseline ? -baselineOffset : 0;

					wrapper.box = box = shape ?
						renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height) :
						renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
					box.add(wrapper);
				}

				// apply the box attributes
				if (!box.isImg) { // #1630
					box.attr(merge({
						width: wrapper.width,
						height: wrapper.height
					}, deferredAttr));
				}
				deferredAttr = null;
			}
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = paddingLeft + padding * (1 - alignFactor),
				y;

			// determin y based on the baseline
			y = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr({
					x: x,
					y: y
				});
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		function getSizeAfterAdd() {
			text.add(wrapper);
			wrapper.attr({
				text: str, // alignment is available now
				x: x,
				y: y
			});

			if (box && defined(anchorX)) {
				wrapper.attr({
					anchorX: anchorX,
					anchorY: anchorY
				});
			}
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		addEvent(wrapper, 'add', getSizeAfterAdd);

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		attrSetters.width = function (value) {
			width = value;
			return false;
		};
		attrSetters.height = function (value) {
			height = value;
			return false;
		};
		attrSetters.padding =  function (value) {
			if (defined(value) && value !== padding) {
				padding = value;
				updateTextPadding();
			}
			return false;
		};
		attrSetters.paddingLeft =  function (value) {
			if (defined(value) && value !== paddingLeft) {
				paddingLeft = value;
				updateTextPadding();
			}
			return false;
		};


		// change local variable and set attribue as well
		attrSetters.align = function (value) {
			alignFactor = { left: 0, center: 0.5, right: 1 }[value];
			return false; // prevent setting text-anchor on the group
		};

		// apply these to the box and the text alike
		attrSetters.text = function (value, key) {
			text.attr(key, value);
			updateBoxSize();
			updateTextPadding();
			return false;
		};

		// apply these to the box but not to the text
		attrSetters[STROKE_WIDTH] = function (value, key) {
			needsBox = true;
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
			return false;
		};
		attrSetters.stroke = attrSetters.fill = attrSetters.r = function (value, key) {
			if (key === 'fill') {
				needsBox = true;
			}
			boxAttr(key, value);
			return false;
		};
		attrSetters.anchorX = function (value, key) {
			anchorX = value;
			boxAttr(key, value + crispAdjust - wrapperX);
			return false;
		};
		attrSetters.anchorY = function (value, key) {
			anchorY = value;
			boxAttr(key, value - wrapperY);
			return false;
		};

		// rename attributes
		attrSetters.x = function (value) {
			wrapper.x = value; // for animation getter
			value -= alignFactor * ((width || bBox.width) + padding);
			wrapperX = mathRound(value);

			wrapper.attr('translateX', wrapperX);
			return false;
		};
		attrSetters.y = function (value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', wrapperY);
			return false;
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					styles = merge(styles); // create a copy to avoid altering the original object (#537)
					each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width', 'textDecoration', 'textShadow'], function (prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function () {
				return {
					width: bBox.width + 2 * padding,
					height: bBox.height + 2 * padding,
					x: bBox.x - padding,
					y: bBox.y - padding
				};
			},
			/**
			 * Apply the shadow to the box
			 */
			shadow: function (b) {
				if (box) {
					box.shadow(b);
				}
				return wrapper;
			},
			/**
			 * Destroy and release memory.
			 */
			destroy: function () {
				removeEvent(wrapper, 'add', getSizeAfterAdd);

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					text = text.destroy();
				}
				if (box) {
					box = box.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);

				// Release local pointers (#1298)
				wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
			}
		});
	}
}; // end SVGRenderer


// general renderer
Renderer = SVGRenderer;


/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/

/**
 * @constructor
 */
var VMLRenderer, VMLElement;
if (!hasSVG && !useCanVG) {

/**
 * The VML element wrapper.
 */
Highcharts.VMLElement = VMLElement = {

	/**
	 * Initialize a new VML element wrapper. It builds the markup as a string
	 * to minimize DOM traffic.
	 * @param {Object} renderer
	 * @param {Object} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this,
			markup =  ['<', nodeName, ' filled="f" stroked="f"'],
			style = ['position: ', ABSOLUTE, ';'],
			isDiv = nodeName === DIV;

		// divs and shapes need size
		if (nodeName === 'shape' || isDiv) {
			style.push('left:0;top:0;width:1px;height:1px;');
		}
		style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

		markup.push(' style="', style.join(''), '"/>');

		// create element with default attributes and style
		if (nodeName) {
			markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
				markup.join('')
				: renderer.prepVML(markup);
			wrapper.element = createElement(markup);
		}

		wrapper.renderer = renderer;
		wrapper.attrSetters = {};
	},

	/**
	 * Add the node to the given parent
	 * @param {Object} parent
	 */
	add: function (parent) {
		var wrapper = this,
			renderer = wrapper.renderer,
			element = wrapper.element,
			box = renderer.box,
			inverted = parent && parent.inverted,

			// get the parent node
			parentNode = parent ?
				parent.element || parent :
				box;


		// if the parent group is inverted, apply inversion on all children
		if (inverted) { // only on groups
			renderer.invertChild(element, parentNode);
		}

		// append it
		parentNode.appendChild(element);

		// align text after adding to be able to read offset
		wrapper.added = true;
		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
			wrapper.updateTransform();
		}

		// fire an event for internal hooks
		fireEvent(wrapper, 'add');

		return wrapper;
	},

	/**
	 * VML always uses htmlUpdateTransform
	 */
	updateTransform: SVGElement.prototype.htmlUpdateTransform,

	/**
	 * Set the rotation of a span with oldIE's filter
	 */
	setSpanRotation: function (rotation, sintheta, costheta) {
		// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
		// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
		// has support for CSS3 transform. The getBBox method also needs to be updated
		// to compensate for the rotation, like it currently does for SVG.
		// Test case: http://highcharts.com/tests/?file=text-rotation
		css(this.element, {
			filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
				', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
				', sizingMethod=\'auto expand\')'].join('') : NONE
		});
	},

	/**
	 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	 * as the parameter and returns a string.
	 */
	pathToVML: function (value) {
		// convert paths
		var i = value.length,
			path = [],
			clockwise;

		while (i--) {

			// Multiply by 10 to allow subpixel precision.
			// Substracting half a pixel seems to make the coordinates
			// align with SVG, but this hasn't been tested thoroughly
			if (isNumber(value[i])) {
				path[i] = mathRound(value[i] * 10) - 5;
			} else if (value[i] === 'Z') { // close the path
				path[i] = 'x';
			} else {
				path[i] = value[i];

				// When the start X and end X coordinates of an arc are too close,
				// they are rounded to the same value above. In this case, substract 1 from the end X
				// position. #760, #1371.
				if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
					clockwise = value[i] === 'wa' ? 1 : -1; // #1642
					if (path[i + 5] === path[i + 7]) {
						path[i + 7] -= clockwise;
					}
					// Start and end Y (#1410)
					if (path[i + 6] === path[i + 8]) {
						path[i + 8] -= clockwise;
					}
				}
			}
		}
		// Loop up again to handle path shortcuts (#2132)
		/*while (i++ < path.length) {
			if (path[i] === 'H') { // horizontal line to
				path[i] = 'L';
				path.splice(i + 2, 0, path[i - 1]);
			} else if (path[i] === 'V') { // vertical line to
				path[i] = 'L';
				path.splice(i + 1, 0, path[i - 2]);
			}
		}*/
		return path.join(' ') || 'x';
	},

	/**
	 * Get or set attributes
	 */
	attr: function (hash, val) {
		var wrapper = this,
			key,
			value,
			i,
			result,
			element = wrapper.element || {},
			elemStyle = element.style,
			nodeName = element.nodeName,
			renderer = wrapper.renderer,
			symbolName = wrapper.symbolName,
			hasSetSymbolSize,
			shadows = wrapper.shadows,
			skipAttr,
			attrSetters = wrapper.attrSetters,
			ret = wrapper;

		// single key-value pair
		if (isString(hash) && defined(val)) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter, val is undefined
		if (isString(hash)) {
			key = hash;
			if (key === 'strokeWidth' || key === 'stroke-width') {
				ret = wrapper.strokeweight;
			} else {
				ret = wrapper[key];
			}

		// setter
		} else {
			for (key in hash) {
				value = hash[key];
				skipAttr = false;

				// check for a specific attribute setter
				result = attrSetters[key] && attrSetters[key].call(wrapper, value, key);

				if (result !== false && value !== null) { // #620

					if (result !== UNDEFINED) {
						value = result; // the attribute setter has returned a new value to set
					}


					// prepare paths
					// symbols
					if (symbolName && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(key)) {
						// if one of the symbol size affecting parameters are changed,
						// check all the others only once for each call to an element's
						// .attr() method
						if (!hasSetSymbolSize) {
							wrapper.symbolAttr(hash);

							hasSetSymbolSize = true;
						}
						skipAttr = true;

					} else if (key === 'd') {
						value = value || [];
						wrapper.d = value.join(' '); // used in getter for animation

						element.path = value = wrapper.pathToVML(value);

						// update shadows
						if (shadows) {
							i = shadows.length;
							while (i--) {
								shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
							}
						}
						skipAttr = true;

					// handle visibility
					} else if (key === 'visibility') {

						// let the shadow follow the main element
						if (shadows) {
							i = shadows.length;
							while (i--) {
								shadows[i].style[key] = value;
							}
						}

						// Instead of toggling the visibility CSS property, move the div out of the viewport.
						// This works around #61 and #586
						if (nodeName === 'DIV') {
							value = value === HIDDEN ? '-999em' : 0;

							// In order to redraw, IE7 needs the div to be visible when tucked away
							// outside the viewport. So the visibility is actually opposite of
							// the expected value. This applies to the tooltip only.
							if (!docMode8) {
								elemStyle[key] = value ? VISIBLE : HIDDEN;
							}
							key = 'top';
						}
						elemStyle[key] = value;
						skipAttr = true;

					// directly mapped to css
					} else if (key === 'zIndex') {

						if (value) {
							elemStyle[key] = value;
						}
						skipAttr = true;

					// x, y, width, height
					} else if (inArray(key, ['x', 'y', 'width', 'height']) !== -1) {

						wrapper[key] = value; // used in getter

						if (key === 'x' || key === 'y') {
							key = { x: 'left', y: 'top' }[key];
						} else {
							value = mathMax(0, value); // don't set width or height below zero (#311)
						}

						// clipping rectangle special
						if (wrapper.updateClipping) {
							wrapper[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
							wrapper.updateClipping();
						} else {
							// normal
							elemStyle[key] = value;
						}

						skipAttr = true;

					// class name
					} else if (key === 'class' && nodeName === 'DIV') {
						// IE8 Standards mode has problems retrieving the className
						element.className = value;

					// stroke
					} else if (key === 'stroke') {

						value = renderer.color(value, element, key);

						key = 'strokecolor';

					// stroke width
					} else if (key === 'stroke-width' || key === 'strokeWidth') {
						element.stroked = value ? true : false;
						key = 'strokeweight';
						wrapper[key] = value; // used in getter, issue #113
						if (isNumber(value)) {
							value += PX;
						}

					// dashStyle
					} else if (key === 'dashstyle') {
						var strokeElem = element.getElementsByTagName('stroke')[0] ||
							createElement(renderer.prepVML(['<stroke/>']), null, null, element);
						strokeElem[key] = value || 'solid';
						wrapper.dashstyle = value; /* because changing stroke-width will change the dash length
							and cause an epileptic effect */
						skipAttr = true;

					// fill
					} else if (key === 'fill') {

						if (nodeName === 'SPAN') { // text color
							elemStyle.color = value;
						} else if (nodeName !== 'IMG') { // #1336
							element.filled = value !== NONE ? true : false;

							value = renderer.color(value, element, key, wrapper);

							key = 'fillcolor';
						}

					// opacity: don't bother - animation is too slow and filters introduce artifacts
					} else if (key === 'opacity') {
						/*css(element, {
							opacity: value
						});*/
						skipAttr = true;

					// rotation on VML elements
					} else if (nodeName === 'shape' && key === 'rotation') {

						wrapper[key] = element.style[key] = value; // style is for #1873

						// Correction for the 1x1 size of the shape container. Used in gauge needles.
						element.style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
						element.style.top = mathRound(mathCos(value * deg2rad)) + PX;

					// translation for animation
					} else if (key === 'translateX' || key === 'translateY' || key === 'rotation') {
						wrapper[key] = value;
						wrapper.updateTransform();

						skipAttr = true;

					// text for rotated and non-rotated elements
					} else if (key === 'text') {
						this.bBox = null;
						element.innerHTML = value;
						skipAttr = true;
					}


					if (!skipAttr) {
						if (docMode8) { // IE8 setAttribute bug
							element[key] = value;
						} else {
							attr(element, key, value);
						}
					}

				}
			}
		}
		return ret;
	},

	/**
	 * Set the element's clipping to a predefined rectangle
	 *
	 * @param {String} id The id of the clip rectangle
	 */
	clip: function (clipRect) {
		var wrapper = this,
			clipMembers,
			cssRet;

		if (clipRect) {
			clipMembers = clipRect.members;
			erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
			clipMembers.push(wrapper);
			wrapper.destroyClip = function () {
				erase(clipMembers, wrapper);
			};
			cssRet = clipRect.getCSS(wrapper);

		} else {
			if (wrapper.destroyClip) {
				wrapper.destroyClip();
			}
			cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
		}

		return wrapper.css(cssRet);

	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: SVGElement.prototype.htmlCss,

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		// discardElement will detach the node from its parent before attaching it
		// to the garbage bin. Therefore it is important that the node is attached and have parent.
		if (element.parentNode) {
			discardElement(element);
		}
	},

	/**
	 * Extend element.destroy by removing it from the clip members array
	 */
	destroy: function () {
		if (this.destroyClip) {
			this.destroyClip();
		}

		return SVGElement.prototype.destroy.apply(this);
	},

	/**
	 * Add an event listener. VML override for normalizing event parameters.
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		// simplest possible event model for internal use
		this.element['on' + eventType] = function () {
			var evt = win.event;
			evt.target = evt.srcElement;
			handler(evt);
		};
		return this;
	},

	/**
	 * In stacked columns, cut off the shadows so that they don't overlap
	 */
	cutOffPath: function (path, length) {

		var len;

		path = path.split(/[ ,]/);
		len = path.length;

		if (len === 9 || len === 11) {
			path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
		}
		return path.join(' ');
	},

	/**
	 * Apply a drop shadow by copying elements and giving them different strokes
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			element = this.element,
			renderer = this.renderer,
			shadow,
			elemStyle = element.style,
			markup,
			path = element.path,
			strokeWidth,
			modifiedPath,
			shadowWidth,
			shadowElementOpacity;

		// some times empty paths are not strings
		if (path && typeof path.value !== 'string') {
			path = 'x';
		}
		modifiedPath = path;

		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			for (i = 1; i <= 3; i++) {

				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

				// Cut off shadows for stacked column items
				if (cutOff) {
					modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
				}

				markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
					'" filled="false" path="', modifiedPath,
					'" coordsize="10 10" style="', element.style.cssText, '" />'];

				shadow = createElement(renderer.prepVML(markup),
					null, {
						left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
						top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
					}
				);
				if (cutOff) {
					shadow.cutOff = strokeWidth + 1;
				}

				// apply the opacity
				markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
				createElement(renderer.prepVML(markup), null, null, shadow);


				// insert it
				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				// record it
				shadows.push(shadow);

			}

			this.shadows = shadows;
		}
		return this;

	}
};
VMLElement = extendClass(SVGElement, VMLElement);

/**
 * The VML renderer
 */
var VMLRendererExtension = { // inherit SVGRenderer

	Element: VMLElement,
	isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	/**
	 * Initialize the VMLRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 */
	init: function (container, width, height) {
		var renderer = this,
			boxWrapper,
			box;

		renderer.alignedObjects = [];

		boxWrapper = renderer.createElement(DIV);
		box = boxWrapper.element;
		box.style.position = RELATIVE; // for freeform drawing using renderer directly
		container.appendChild(boxWrapper.element);


		// generate the containing box
		renderer.isVML = true;
		renderer.box = box;
		renderer.boxWrapper = boxWrapper;


		renderer.setSize(width, height, false);

		// The only way to make IE6 and IE7 print is to use a global namespace. However,
		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
		// seems to be to add the xmlns attribute and the behaviour style inline.
		if (!doc.namespaces.hcv) {

			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

			// Setup default CSS (#2153)
			(doc.styleSheets.length ? doc.styleSheets[0] : doc.createStyleSheet()).cssText +=
				'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
				'{ behavior:url(#default#VML); display: inline-block; } ';

		}
	},


	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none
	 */
	isHidden: function () {
		return !this.box.offsetWidth;
	},

	/**
	 * Define a clipping rectangle. In VML it is accomplished by storing the values
	 * for setting the CSS style to all associated members.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {

		// create a dummy element
		var clipRect = this.createElement(),
			isObj = isObject(x);

		// mimic a rectangle with its style object for automatic updating in attr
		return extend(clipRect, {
			members: [],
			left: (isObj ? x.x : x) + 1,
			top: (isObj ? x.y : y) + 1,
			width: (isObj ? x.width : width) - 1,
			height: (isObj ? x.height : height) - 1,
			getCSS: function (wrapper) {
				var element = wrapper.element,
					nodeName = element.nodeName,
					isShape = nodeName === 'shape',
					inverted = wrapper.inverted,
					rect = this,
					top = rect.top - (isShape ? element.offsetTop : 0),
					left = rect.left,
					right = left + rect.width,
					bottom = top + rect.height,
					ret = {
						clip: 'rect(' +
							mathRound(inverted ? left : top) + 'px,' +
							mathRound(inverted ? bottom : right) + 'px,' +
							mathRound(inverted ? right : bottom) + 'px,' +
							mathRound(inverted ? top : left) + 'px)'
					};

				// issue 74 workaround
				if (!inverted && docMode8 && nodeName === 'DIV') {
					extend(ret, {
						width: right + PX,
						height: bottom + PX
					});
				}
				return ret;
			},

			// used in attr and animation to update the clipping of all members
			updateClipping: function () {
				each(clipRect.members, function (member) {
					member.css(clipRect.getCSS(member));
				});
			}
		});

	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object, and apply opacity.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop, wrapper) {
		var renderer = this,
			colorObject,
			regexRgba = /^rgba/,
			markup,
			fillType,
			ret = NONE;

		// Check for linear or radial gradient
		if (color && color.linearGradient) {
			fillType = 'gradient';
		} else if (color && color.radialGradient) {
			fillType = 'pattern';
		}


		if (fillType) {

			var stopColor,
				stopOpacity,
				gradient = color.linearGradient || color.radialGradient,
				x1,
				y1,
				x2,
				y2,
				opacity1,
				opacity2,
				color1,
				color2,
				fillAttr = '',
				stops = color.stops,
				firstStop,
				lastStop,
				colors = [],
				addFillNode = function () {
					// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
					// are reversed.
					markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
						'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
					createElement(renderer.prepVML(markup), null, null, elem);
				};

			// Extend from 0 to 1
			firstStop = stops[0];
			lastStop = stops[stops.length - 1];
			if (firstStop[0] > 0) {
				stops.unshift([
					0,
					firstStop[1]
				]);
			}
			if (lastStop[0] < 1) {
				stops.push([
					1,
					lastStop[1]
				]);
			}

			// Compute the stops
			each(stops, function (stop, i) {
				if (regexRgba.test(stop[1])) {
					colorObject = Color(stop[1]);
					stopColor = colorObject.get('rgb');
					stopOpacity = colorObject.get('a');
				} else {
					stopColor = stop[1];
					stopOpacity = 1;
				}

				// Build the color attribute
				colors.push((stop[0] * 100) + '% ' + stopColor);

				// Only start and end opacities are allowed, so we use the first and the last
				if (!i) {
					opacity1 = stopOpacity;
					color2 = stopColor;
				} else {
					opacity2 = stopOpacity;
					color1 = stopColor;
				}
			});

			// Apply the gradient to fills only.
			if (prop === 'fill') {

				// Handle linear gradient angle
				if (fillType === 'gradient') {
					x1 = gradient.x1 || gradient[0] || 0;
					y1 = gradient.y1 || gradient[1] || 0;
					x2 = gradient.x2 || gradient[2] || 0;
					y2 = gradient.y2 || gradient[3] || 0;
					fillAttr = 'angle="' + (90  - math.atan(
						(y2 - y1) / // y vector
						(x2 - x1) // x vector
						) * 180 / mathPI) + '"';

					addFillNode();

				// Radial (circular) gradient
				} else {

					var r = gradient.r,
						sizex = r * 2,
						sizey = r * 2,
						cx = gradient.cx,
						cy = gradient.cy,
						radialReference = elem.radialReference,
						bBox,
						applyRadialGradient = function () {
							if (radialReference) {
								bBox = wrapper.getBBox();
								cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
								cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
								sizex *= radialReference[2] / bBox.width;
								sizey *= radialReference[2] / bBox.height;
							}
							fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
								'size="' + sizex + ',' + sizey + '" ' +
								'origin="0.5,0.5" ' +
								'position="' + cx + ',' + cy + '" ' +
								'color2="' + color2 + '" ';

							addFillNode();
						};

					// Apply radial gradient
					if (wrapper.added) {
						applyRadialGradient();
					} else {
						// We need to know the bounding box to get the size and position right
						addEvent(wrapper, 'add', applyRadialGradient);
					}

					// The fill element's color attribute is broken in IE8 standards mode, so we
					// need to set the parent shape's fillcolor attribute instead.
					ret = color1;
				}

			// Gradients are not supported for VML stroke, return the first color. #722.
			} else {
				ret = stopColor;
			}

		// if the color is an rgba color, split it and add a fill node
		// to hold the opacity component
		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

			colorObject = Color(color);

			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
			createElement(this.prepVML(markup), null, null, elem);

			ret = colorObject.get('rgb');


		} else {
			var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
			if (propNodes.length) {
				propNodes[0].opacity = 1;
				propNodes[0].type = 'solid';
			}
			ret = color;
		}

		return ret;
	},

	/**
	 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	 * @param {Array} markup A string array of the VML markup to prepare
	 */
	prepVML: function (markup) {
		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
			isIE8 = this.isIE8;

		markup = markup.join('');

		if (isIE8) { // add xmlns and style inline
			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
			if (markup.indexOf('style="') === -1) {
				markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
			} else {
				markup = markup.replace('style="', 'style="' + vmlStyle);
			}

		} else { // add namespace
			markup = markup.replace('<', '<hcv:');
		}

		return markup;
	},

	/**
	 * Create rotated and aligned text
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	text: SVGRenderer.prototype.html,

	/**
	 * Create and return a path element
	 * @param {Array} path
	 */
	path: function (path) {
		var attr = {
			// subpixel precision down to 0.1 (width and height = 1px)
			coordsize: '10 10'
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		// create the shape
		return this.createElement('shape').attr(attr);
	},

	/**
	 * Create and return a circle element. In VML circles are implemented as
	 * shapes, which is faster than v:oval
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} r
	 */
	circle: function (x, y, r) {
		var circle = this.symbol('circle');
		if (isObject(x)) {
			r = x.r;
			y = x.y;
			x = x.x;
		}
		circle.isCircle = true; // Causes x and y to mean center (#1682)
		circle.r = r;
		return circle.attr({ x: x, y: y });
	},

	/**
	 * Create a group using an outer div and an inner v:group to allow rotating
	 * and flipping. A simple v:group would have problems with positioning
	 * child HTML elements and CSS clip.
	 *
	 * @param {String} name The name of the group
	 */
	g: function (name) {
		var wrapper,
			attribs;

		// set the class name
		if (name) {
			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
		}

		// the div to hold HTML and clipping
		wrapper = this.createElement(DIV).attr(attribs);

		return wrapper;
	},

	/**
	 * VML override to create a regular HTML image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var obj = this.createElement('img')
			.attr({ src: src });

		if (arguments.length > 1) {
			obj.attr({
				x: x,
				y: y,
				width: width,
				height: height
			});
		}
		return obj;
	},

	/**
	 * VML uses a shape for rect to overcome bugs and rotation problems
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		var wrapper = this.symbol('rect');
		wrapper.r = isObject(x) ? x.r : r;

		//return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
		return wrapper.attr(
				isObject(x) ?
					x :
					// do not crispify when an object is passed in (as in column charts)
					wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0))
			);
	},

	/**
	 * In the VML renderer, each child of an inverted div (group) is inverted
	 * @param {Object} element
	 * @param {Object} parentNode
	 */
	invertChild: function (element, parentNode) {
		var parentStyle = parentNode.style;
		css(element, {
			flip: 'x',
			left: pInt(parentStyle.width) - 1,
			top: pInt(parentStyle.height) - 1,
			rotation: -90
		});
	},

	/**
	 * Symbol definitions that override the parent SVG renderer's symbols
	 *
	 */
	symbols: {
		// VML specific arc function
		arc: function (x, y, w, h, options) {
			var start = options.start,
				end = options.end,
				radius = options.r || w || h,
				innerRadius = options.innerR,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				ret;

			if (end - start === 0) { // no angle, don't show it.
				return ['x'];
			}

			ret = [
				'wa', // clockwise arc to
				x - radius, // left
				y - radius, // top
				x + radius, // right
				y + radius, // bottom
				x + radius * cosStart, // start x
				y + radius * sinStart, // start y
				x + radius * cosEnd, // end x
				y + radius * sinEnd  // end y
			];

			if (options.open && !innerRadius) {
				ret.push(
					'e',
					M,
					x,// - innerRadius,
					y// - innerRadius
				);
			}

			ret.push(
				'at', // anti clockwise arc to
				x - innerRadius, // left
				y - innerRadius, // top
				x + innerRadius, // right
				y + innerRadius, // bottom
				x + innerRadius * cosEnd, // start x
				y + innerRadius * sinEnd, // start y
				x + innerRadius * cosStart, // end x
				y + innerRadius * sinStart, // end y
				'x', // finish path
				'e' // close
			);

			ret.isArc = true;
			return ret;

		},
		// Add circle symbol path. This performs significantly faster than v:oval.
		circle: function (x, y, w, h, wrapper) {

			if (wrapper) {
				w = h = 2 * wrapper.r;
			}

			// Center correction, #1682
			if (wrapper && wrapper.isCircle) {
				x -= w / 2;
				y -= h / 2;
			}

			// Return the path
			return [
				'wa', // clockwisearcto
				x, // left
				y, // top
				x + w, // right
				y + h, // bottom
				x + w, // start x
				y + h / 2,     // start y
				x + w, // end x
				y + h / 2,     // end y
				//'x', // finish path
				'e' // close
			];
		},
		/**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape
		 *
		 * @param {Number} left Left position
		 * @param {Number} top Top position
		 * @param {Number} r Border radius
		 * @param {Object} options Width and height
		 */

		rect: function (left, top, width, height, options) {

			var right = left + width,
				bottom = top + height,
				ret,
				r;

			// No radius, return the more lightweight square
			if (!defined(options) || !options.r) {
				ret = SVGRenderer.prototype.symbols.square.apply(0, arguments);

			// Has radius add arcs for the corners
			} else {

				r = mathMin(options.r, width, height);
				ret = [
					M,
					left + r, top,

					L,
					right - r, top,
					'wa',
					right - 2 * r, top,
					right, top + 2 * r,
					right - r, top,
					right, top + r,

					L,
					right, bottom - r,
					'wa',
					right - 2 * r, bottom - 2 * r,
					right, bottom,
					right, bottom - r,
					right - r, bottom,

					L,
					left + r, bottom,
					'wa',
					left, bottom - 2 * r,
					left + 2 * r, bottom,
					left + r, bottom,
					left, bottom - r,

					L,
					left, top + r,
					'wa',
					left, top,
					left + 2 * r, top + 2 * r,
					left, top + r,
					left + r, top,


					'x',
					'e'
				];
			}
			return ret;
		}
	}
};
Highcharts.VMLRenderer = VMLRenderer = function () {
	this.init.apply(this, arguments);
};
VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	// general renderer
	Renderer = VMLRenderer;
}

/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/
/* ****************************************************************************
 *                                                                            *
 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
 * TARGETING THAT SYSTEM.                                                     *
 *                                                                            *
 *****************************************************************************/
var CanVGRenderer,
	CanVGController;

if (useCanVG) {
	/**
	 * The CanVGRenderer is empty from start to keep the source footprint small.
	 * When requested, the CanVGController downloads the rest of the source packaged
	 * together with the canvg library.
	 */
	Highcharts.CanVGRenderer = CanVGRenderer = function () {
		// Override the global SVG namespace to fake SVG/HTML that accepts CSS
		SVG_NS = 'http://www.w3.org/1999/xhtml';
	};

	/**
	 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
	 * the implementation from SvgRenderer will not be merged in until first render.
	 */
	CanVGRenderer.prototype.symbols = {};

	/**
	 * Handles on demand download of canvg rendering support.
	 */
	CanVGController = (function () {
		// List of renderering calls
		var deferredRenderCalls = [];

		/**
		 * When downloaded, we are ready to draw deferred charts.
		 */
		function drawDeferred() {
			var callLength = deferredRenderCalls.length,
				callIndex;

			// Draw all pending render calls
			for (callIndex = 0; callIndex < callLength; callIndex++) {
				deferredRenderCalls[callIndex]();
			}
			// Clear the list
			deferredRenderCalls = [];
		}

		return {
			push: function (func, scriptLocation) {
				// Only get the script once
				if (deferredRenderCalls.length === 0) {
					getScript(scriptLocation, drawDeferred);
				}
				// Register render call
				deferredRenderCalls.push(func);
			}
		};
	}());

	Renderer = CanVGRenderer;
} // end CanVGRenderer

/* ****************************************************************************
 *                                                                            *
 * END OF ANDROID < 3 SPECIFIC CODE                                           *
 *                                                                            *
 *****************************************************************************/

/**
 * The Tick class
 */
function Tick(axis, pos, type, noLabel) {
	this.axis = axis;
	this.pos = pos;
	this.type = type || '';
	this.isNew = true;

	if (!type && !noLabel) {
		this.addLabel();
	}
}

Tick.prototype = {
	/**
	 * Write the tick label
	 */
	addLabel: function () {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			horiz = axis.horiz,
			categories = axis.categories,
			names = axis.series[0] && axis.series[0].names,
			pos = tick.pos,
			labelOptions = options.labels,
			str,
			tickPositions = axis.tickPositions,
			width = (horiz && categories &&
				!labelOptions.step && !labelOptions.staggerLines &&
				!labelOptions.rotation &&
				chart.plotWidth / tickPositions.length) ||
				(!horiz && (chart.margin[3] || chart.chartWidth * 0.33)), // #1580, #1931
			isFirst = pos === tickPositions[0],
			isLast = pos === tickPositions[tickPositions.length - 1],
			css,
			attr,
			value = categories ?
				pick(categories[pos], names && names[pos], pos) : 
				pos,
			label = tick.label,
			tickPositionInfo = tickPositions.info,
			dateTimeLabelFormat;

		// Set the datetime label format. If a higher rank is set for this position, use that. If not,
		// use the general format.
		if (axis.isDatetimeAxis && tickPositionInfo) {
			dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
		}

		// set properties for access in render method
		tick.isFirst = isFirst;
		tick.isLast = isLast;

		// get the string
		str = axis.labelFormatter.call({
			axis: axis,
			chart: chart,
			isFirst: isFirst,
			isLast: isLast,
			dateTimeLabelFormat: dateTimeLabelFormat,
			value: axis.isLog ? correctFloat(lin2log(value)) : value
		});

		// prepare CSS
		css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
		css = extend(css, labelOptions.style);

		// first call
		if (!defined(label)) {
			attr = {
				align: axis.labelAlign
			};
			if (isNumber(labelOptions.rotation)) {
				attr.rotation = labelOptions.rotation;
			}
			if (width && labelOptions.ellipsis) {
				attr._clipHeight = axis.len / tickPositions.length;
			}

			tick.label =
				defined(str) && labelOptions.enabled ?
					chart.renderer.text(
							str,
							0,
							0,
							labelOptions.useHTML
						)
						.attr(attr)
						// without position absolute, IE export sometimes is wrong
						.css(css)
						.add(axis.labelGroup) :
					null;

		// update
		} else if (label) {
			label.attr({
					text: str
				})
				.css(css);
		}
	},

	/**
	 * Get the offset height or width of the label
	 */
	getLabelSize: function () {
		var label = this.label,
			axis = this.axis;
		return label ?
			((this.labelBBox = label.getBBox()))[axis.horiz ? 'height' : 'width'] :
			0;
	},

	/**
	 * Find how far the labels extend to the right and left of the tick's x position. Used for anti-collision
	 * detection with overflow logic.
	 */
	getLabelSides: function () {
		var bBox = this.labelBBox, // assume getLabelSize has run at this point
			axis = this.axis,
			options = axis.options,
			labelOptions = options.labels,
			width = bBox.width,
			leftSide = width * { left: 0, center: 0.5, right: 1 }[axis.labelAlign] - labelOptions.x;

		return [-leftSide, width - leftSide];
	},

	/**
	 * Handle the label overflow by adjusting the labels to the left and right edge, or
	 * hide them if they collide into the neighbour label.
	 */
	handleOverflow: function (index, xy) {
		var show = true,
			axis = this.axis,
			chart = axis.chart,
			isFirst = this.isFirst,
			isLast = this.isLast,
			x = xy.x,
			reversed = axis.reversed,
			tickPositions = axis.tickPositions;

		if (isFirst || isLast) {

			var sides = this.getLabelSides(),
				leftSide = sides[0],
				rightSide = sides[1],
				plotLeft = chart.plotLeft,
				plotRight = plotLeft + axis.len,
				neighbour = axis.ticks[tickPositions[index + (isFirst ? 1 : -1)]],
				neighbourEdge = neighbour && neighbour.label.xy && neighbour.label.xy.x + neighbour.getLabelSides()[isFirst ? 0 : 1];

			if ((isFirst && !reversed) || (isLast && reversed)) {
				// Is the label spilling out to the left of the plot area?
				if (x + leftSide < plotLeft) {

					// Align it to plot left
					x = plotLeft - leftSide;

					// Hide it if it now overlaps the neighbour label
					if (neighbour && x + rightSide > neighbourEdge) {
						show = false;
					}
				}

			} else {
				// Is the label spilling out to the right of the plot area?
				if (x + rightSide > plotRight) {

					// Align it to plot right
					x = plotRight - rightSide;

					// Hide it if it now overlaps the neighbour label
					if (neighbour && x + leftSide < neighbourEdge) {
						show = false;
					}

				}
			}

			// Set the modified x position of the label
			xy.x = x;
		}
		return show;
	},

	/**
	 * Get the x and y position for ticks and labels
	 */
	getPosition: function (horiz, pos, tickmarkOffset, old) {
		var axis = this.axis,
			chart = axis.chart,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight;
		
		return {
			x: horiz ?
				axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
				axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

			y: horiz ?
				cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
				cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
		};
		
	},
	
	/**
	 * Get the x, y position of the tick label
	 */
	getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
		var axis = this.axis,
			transA = axis.transA,
			reversed = axis.reversed,
			staggerLines = axis.staggerLines,
			baseline = axis.chart.renderer.fontMetrics(labelOptions.style.fontSize).b,
			rotation = labelOptions.rotation;
			
		x = x + labelOptions.x - (tickmarkOffset && horiz ?
			tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
		y = y + labelOptions.y - (tickmarkOffset && !horiz ?
			tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

		// Correct for rotation (#1764)
		if (rotation && axis.side === 2) {
			y -= baseline - baseline * mathCos(rotation * deg2rad);
		}
		
		// Vertically centered
		if (!defined(labelOptions.y) && !rotation) { // #1951
			y += baseline - label.getBBox().height / 2;
		}
		
		// Correct for staggered labels
		if (staggerLines) {
			y += (index / (step || 1) % staggerLines) * (axis.labelOffset / staggerLines);
		}
		
		return {
			x: x,
			y: y
		};
	},
	
	/**
	 * Extendible method to return the path of the marker
	 */
	getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
		return renderer.crispLine([
				M,
				x,
				y,
				L,
				x + (horiz ? 0 : -tickLength),
				y + (horiz ? tickLength : 0)
			], tickWidth);
	},

	/**
	 * Put everything in place
	 *
	 * @param index {Number}
	 * @param old {Boolean} Use old coordinates to prepare an animation into new position
	 */
	render: function (index, old, opacity) {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			renderer = chart.renderer,
			horiz = axis.horiz,
			type = tick.type,
			label = tick.label,
			pos = tick.pos,
			labelOptions = options.labels,
			gridLine = tick.gridLine,
			gridPrefix = type ? type + 'Grid' : 'grid',
			tickPrefix = type ? type + 'Tick' : 'tick',
			gridLineWidth = options[gridPrefix + 'LineWidth'],
			gridLineColor = options[gridPrefix + 'LineColor'],
			dashStyle = options[gridPrefix + 'LineDashStyle'],
			tickLength = options[tickPrefix + 'Length'],
			tickWidth = options[tickPrefix + 'Width'] || 0,
			tickColor = options[tickPrefix + 'Color'],
			tickPosition = options[tickPrefix + 'Position'],
			gridLinePath,
			mark = tick.mark,
			markPath,
			step = labelOptions.step,
			attribs,
			show = true,
			tickmarkOffset = axis.tickmarkOffset,
			xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
			x = xy.x,
			y = xy.y,
			reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1, // #1480, #1687
			staggerLines = axis.staggerLines;

		this.isActive = true;
		
		// create the grid line
		if (gridLineWidth) {
			gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

			if (gridLine === UNDEFINED) {
				attribs = {
					stroke: gridLineColor,
					'stroke-width': gridLineWidth
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
				if (!type) {
					attribs.zIndex = 1;
				}
				if (old) {
					attribs.opacity = 0;
				}
				tick.gridLine = gridLine =
					gridLineWidth ?
						renderer.path(gridLinePath)
							.attr(attribs).add(axis.gridGroup) :
						null;
			}

			// If the parameter 'old' is set, the current call will be followed
			// by another call, therefore do not do any animations this time
			if (!old && gridLine && gridLinePath) {
				gridLine[tick.isNew ? 'attr' : 'animate']({
					d: gridLinePath,
					opacity: opacity
				});
			}
		}

		// create the tick mark
		if (tickWidth && tickLength) {

			// negate the length
			if (tickPosition === 'inside') {
				tickLength = -tickLength;
			}
			if (axis.opposite) {
				tickLength = -tickLength;
			}

			markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);

			if (mark) { // updating
				mark.animate({
					d: markPath,
					opacity: opacity
				});
			} else { // first time
				tick.mark = renderer.path(
					markPath
				).attr({
					stroke: tickColor,
					'stroke-width': tickWidth,
					opacity: opacity
				}).add(axis.axisGroup);
			}
		}

		// the label is created on init - now move it into place
		if (label && !isNaN(x)) {
			label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

			// Apply show first and show last. If the tick is both first and last, it is 
			// a single centered tick, in which case we show the label anyway (#2100).
			if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
					(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
				show = false;

			// Handle label overflow and show or hide accordingly
			} else if (!staggerLines && horiz && labelOptions.overflow === 'justify' && !tick.handleOverflow(index, xy)) {
				show = false;
			}

			// apply step
			if (step && index % step) {
				// show those indices dividable by step
				show = false;
			}

			// Set the new position, and show or hide
			if (show && !isNaN(xy.y)) {
				xy.opacity = opacity;
				label[tick.isNew ? 'attr' : 'animate'](xy);
				tick.isNew = false;
			} else {
				label.attr('y', -9999); // #1338
			}
		}
	},

	/**
	 * Destructor for the tick prototype
	 */
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	}
};

/**
 * The object wrapper for plot lines and plot bands
 * @param {Object} options
 */
function PlotLineOrBand(axis, options) {
	this.axis = axis;

	if (options) {
		this.options = options;
		this.id = options.id;
	}
}

PlotLineOrBand.prototype = {
	
	/**
	 * Render the plot line or plot band. If it is already existing,
	 * move it.
	 */
	render: function () {
		var plotLine = this,
			axis = plotLine.axis,
			horiz = axis.horiz,
			halfPointRange = (axis.pointRange || 0) / 2,
			options = plotLine.options,
			optionsLabel = options.label,
			label = plotLine.label,
			width = options.width,
			to = options.to,
			from = options.from,
			isBand = defined(from) && defined(to),
			value = options.value,
			dashStyle = options.dashStyle,
			svgElem = plotLine.svgElem,
			path = [],
			addEvent,
			eventType,
			xs,
			ys,
			x,
			y,
			color = options.color,
			zIndex = options.zIndex,
			events = options.events,
			attribs,
			renderer = axis.chart.renderer;

		// logarithmic conversion
		if (axis.isLog) {
			from = log2lin(from);
			to = log2lin(to);
			value = log2lin(value);
		}

		// plot line
		if (width) {
			path = axis.getPlotLinePath(value, width);
			attribs = {
				stroke: color,
				'stroke-width': width
			};
			if (dashStyle) {
				attribs.dashstyle = dashStyle;
			}
		} else if (isBand) { // plot band
			
			// keep within plot area
			from = mathMax(from, axis.min - halfPointRange);
			to = mathMin(to, axis.max + halfPointRange);
			
			path = axis.getPlotBandPath(from, to, options);
			attribs = {
				fill: color
			};
			if (options.borderWidth) {
				attribs.stroke = options.borderColor;
				attribs['stroke-width'] = options.borderWidth;
			}
		} else {
			return;
		}
		// zIndex
		if (defined(zIndex)) {
			attribs.zIndex = zIndex;
		}

		// common for lines and bands
		if (svgElem) {
			if (path) {
				svgElem.animate({
					d: path
				}, null, svgElem.onGetPath);
			} else {
				svgElem.hide();
				svgElem.onGetPath = function () {
					svgElem.show();
				};
			}
		} else if (path && path.length) {
			plotLine.svgElem = svgElem = renderer.path(path)
				.attr(attribs).add();

			// events
			if (events) {
				addEvent = function (eventType) {
					svgElem.on(eventType, function (e) {
						events[eventType].apply(plotLine, [e]);
					});
				};
				for (eventType in events) {
					addEvent(eventType);
				}
			}
		}

		// the plot band/line label
		if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
			// apply defaults
			optionsLabel = merge({
				align: horiz && isBand && 'center',
				x: horiz ? !isBand && 4 : 10,
				verticalAlign : !horiz && isBand && 'middle',
				y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
				rotation: horiz && !isBand && 90
			}, optionsLabel);

			// add the SVG element
			if (!label) {
				plotLine.label = label = renderer.text(
						optionsLabel.text,
						0,
						0,
						optionsLabel.useHTML
					)
					.attr({
						align: optionsLabel.textAlign || optionsLabel.align,
						rotation: optionsLabel.rotation,
						zIndex: zIndex
					})
					.css(optionsLabel.style)
					.add();
			}

			// get the bounding box and align the label
			xs = [path[1], path[4], pick(path[6], path[1])];
			ys = [path[2], path[5], pick(path[7], path[2])];
			x = arrayMin(xs);
			y = arrayMin(ys);

			label.align(optionsLabel, false, {
				x: x,
				y: y,
				width: arrayMax(xs) - x,
				height: arrayMax(ys) - y
			});
			label.show();

		} else if (label) { // move out of sight
			label.hide();
		}

		// chainable
		return plotLine;
	},

	/**
	 * Remove the plot line or band
	 */
	destroy: function () {
		// remove it from the lookup
		erase(this.axis.plotLinesAndBands, this);
		
		delete this.axis;
		destroyObjectProperties(this);
	}
};
/**
 * The class for stack items
 */
function StackItem(axis, options, isNegative, x, stackOption, stacking) {
	
	var inverted = axis.chart.inverted;

	this.axis = axis;

	// Tells if the stack is negative
	this.isNegative = isNegative;

	// Save the options to be able to style the label
	this.options = options;

	// Save the x value to be able to position the label later
	this.x = x;

	// Initialize total value
	this.total = null;

	// This will keep each points' extremes stored by series.index
	this.points = {};

	// Save the stack option on the series configuration object, and whether to treat it as percent
	this.stack = stackOption;
	this.percent = stacking === 'percent';

	// The align options and text align varies on whether the stack is negative and
	// if the chart is inverted or not.
	// First test the user supplied value, then use the dynamic.
	this.alignOptions = {
		align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
		verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
		y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
		x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	};

	this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
}

StackItem.prototype = {
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	},

	/**
	 * Renders the stack total label and adds it to the stack label group.
	 */
	render: function (group) {
		var options = this.options,
			formatOption = options.format,
			str = formatOption ?
				format(formatOption, this) : 
				options.formatter.call(this);  // format the text in the label

		// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
		if (this.label) {
			this.label.attr({text: str, visibility: HIDDEN});
		// Create new label
		} else {
			this.label =
				this.axis.chart.renderer.text(str, 0, 0, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
					.css(options.style)				// apply style
					.attr({
						align: this.textAlign,				// fix the text-anchor
						rotation: options.rotation,	// rotation
						visibility: HIDDEN					// hidden until setOffset is called
					})				
					.add(group);							// add to the labels-group
		}
	},

	/**
	 * Sets the offset that the stack has from the x value and repositions the label.
	 */
	setOffset: function (xOffset, xWidth) {
		var stackItem = this,
			axis = stackItem.axis,
			chart = axis.chart,
			inverted = chart.inverted,
			neg = this.isNegative,							// special treatment is needed for negative stacks
			y = axis.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
			yZero = axis.translate(0),						// stack origin
			h = mathAbs(y - yZero),							// stack height
			x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
			plotHeight = chart.plotHeight,
			stackBox = {	// this is the box for the complete stack
				x: inverted ? (neg ? y : y - h) : x,
				y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
				width: inverted ? h : xWidth,
				height: inverted ? xWidth : h
			},
			label = this.label,
			alignAttr;
		
		if (label) {
			label.align(this.alignOptions, null, stackBox);	// align the label to the box
				
			// Set visibility (#678)
			alignAttr = label.alignAttr;
			label.attr({ 
				visibility: this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 
					(hasSVG ? 'inherit' : VISIBLE) : 
					HIDDEN
			});
		}
	}
};
/**
 * Create a new axis object
 * @param {Object} chart
 * @param {Object} options
 */
function Axis() {
	this.init.apply(this, arguments);
}

Axis.prototype = {
	
	/**
	 * Default options for the X axis - the Y axis has extended defaults 
	 */
	defaultOptions: {
		// allowDecimals: null,
		// alternateGridColor: null,
		// categories: [],
		dateTimeLabelFormats: {
			millisecond: '%H:%M:%S.%L',
			second: '%H:%M:%S',
			minute: '%H:%M',
			hour: '%H:%M',
			day: '%e. %b',
			week: '%e. %b',
			month: '%b \'%y',
			year: '%Y'
		},
		endOnTick: false,
		gridLineColor: '#C0C0C0',
		// gridLineDashStyle: 'solid',
		// gridLineWidth: 0,
		// reversed: false,
	
		labels: defaultLabelOptions,
			// { step: null },
		lineColor: '#C0D0E0',
		lineWidth: 1,
		//linkedTo: null,
		//max: undefined,
		//min: undefined,
		minPadding: 0.01,
		maxPadding: 0.01,
		//minRange: null,
		minorGridLineColor: '#E0E0E0',
		// minorGridLineDashStyle: null,
		minorGridLineWidth: 1,
		minorTickColor: '#A0A0A0',
		//minorTickInterval: null,
		minorTickLength: 2,
		minorTickPosition: 'outside', // inside or outside
		//minorTickWidth: 0,
		//opposite: false,
		//offset: 0,
		//plotBands: [{
		//	events: {},
		//	zIndex: 1,
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//plotLines: [{
		//	events: {}
		//  dashStyle: {}
		//	zIndex:
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//reversed: false,
		// showFirstLabel: true,
		// showLastLabel: true,
		startOfWeek: 1,
		startOnTick: false,
		tickColor: '#C0D0E0',
		//tickInterval: null,
		tickLength: 5,
		tickmarkPlacement: 'between', // on or between
		tickPixelInterval: 100,
		tickPosition: 'outside',
		tickWidth: 1,
		title: {
			//text: null,
			align: 'middle', // low, middle or high
			//margin: 0 for horizontal, 10 for vertical axes,
			//rotation: 0,
			//side: 'outside',
			style: {
				color: '#4d759e',
				//font: defaultFont.replace('normal', 'bold')
				fontWeight: 'bold'
			}
			//x: 0,
			//y: 0
		},
		type: 'linear' // linear, logarithmic or datetime
	},
	
	/**
	 * This options set extends the defaultOptions for Y axes
	 */
	defaultYAxisOptions: {
		endOnTick: true,
		gridLineWidth: 1,
		tickPixelInterval: 72,
		showLastLabel: true,
		labels: {
			x: -8,
			y: 3
		},
		lineWidth: 0,
		maxPadding: 0.05,
		minPadding: 0.05,
		startOnTick: true,
		tickWidth: 0,
		title: {
			rotation: 270,
			text: 'Values'
		},
		stackLabels: {
			enabled: false,
			//align: dynamic,
			//y: dynamic,
			//x: dynamic,
			//verticalAlign: dynamic,
			//textAlign: dynamic,
			//rotation: 0,
			formatter: function () {
				return numberFormat(this.total, -1);
			},
			style: defaultLabelOptions.style
		}
	},
	
	/**
	 * These options extend the defaultOptions for left axes
	 */
	defaultLeftAxisOptions: {
		labels: {
			x: -8,
			y: null
		},
		title: {
			rotation: 270
		}
	},
	
	/**
	 * These options extend the defaultOptions for right axes
	 */
	defaultRightAxisOptions: {
		labels: {
			x: 8,
			y: null
		},
		title: {
			rotation: 90
		}
	},
	
	/**
	 * These options extend the defaultOptions for bottom axes
	 */
	defaultBottomAxisOptions: {
		labels: {
			x: 0,
			y: 14
			// overflow: undefined,
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},
	/**
	 * These options extend the defaultOptions for left axes
	 */
	defaultTopAxisOptions: {
		labels: {
			x: 0,
			y: -5
			// overflow: undefined
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},
	
	/**
	 * Initialize the axis
	 */
	init: function (chart, userOptions) {
			
		
		var isXAxis = userOptions.isX,
			axis = this;
	
		// Flag, is the axis horizontal
		axis.horiz = chart.inverted ? !isXAxis : isXAxis;
		
		// Flag, isXAxis
		axis.isXAxis = isXAxis;
		axis.xOrY = isXAxis ? 'x' : 'y';
	
	
		axis.opposite = userOptions.opposite; // needed in setOptions
		axis.side = axis.horiz ?
				(axis.opposite ? 0 : 2) : // top : bottom
				(axis.opposite ? 1 : 3);  // right : left
	
		axis.setOptions(userOptions);
		
	
		var options = this.options,
			type = options.type,
			isDatetimeAxis = type === 'datetime';
	
		axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format
	
	
		// Flag, stagger lines or not
		axis.userOptions = userOptions;
	
		//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
		axis.minPixelPadding = 0;
		//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
		//axis.ignoreMaxPadding = UNDEFINED;
	
		axis.chart = chart;
		axis.reversed = options.reversed;
		axis.zoomEnabled = options.zoomEnabled !== false;
	
		// Initial categories
		axis.categories = options.categories || type === 'category';
	
		// Elements
		//axis.axisGroup = UNDEFINED;
		//axis.gridGroup = UNDEFINED;
		//axis.axisTitle = UNDEFINED;
		//axis.axisLine = UNDEFINED;
	
		// Shorthand types
		axis.isLog = type === 'logarithmic';
		axis.isDatetimeAxis = isDatetimeAxis;
	
		// Flag, if axis is linked to another axis
		axis.isLinked = defined(options.linkedTo);
		// Linked axis.
		//axis.linkedParent = UNDEFINED;	
		
		// Tick positions
		//axis.tickPositions = UNDEFINED; // array containing predefined positions
		// Tick intervals
		//axis.tickInterval = UNDEFINED;
		//axis.minorTickInterval = UNDEFINED;
		
		axis.tickmarkOffset = (axis.categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;
	
		// Major ticks
		axis.ticks = {};
		// Minor ticks
		axis.minorTicks = {};
		//axis.tickAmount = UNDEFINED;
	
		// List of plotLines/Bands
		axis.plotLinesAndBands = [];
	
		// Alternate bands
		axis.alternateBands = {};
	
		// Axis metrics
		//axis.left = UNDEFINED;
		//axis.top = UNDEFINED;
		//axis.width = UNDEFINED;
		//axis.height = UNDEFINED;
		//axis.bottom = UNDEFINED;
		//axis.right = UNDEFINED;
		//axis.transA = UNDEFINED;
		//axis.transB = UNDEFINED;
		//axis.oldTransA = UNDEFINED;
		axis.len = 0;
		//axis.oldMin = UNDEFINED;
		//axis.oldMax = UNDEFINED;
		//axis.oldUserMin = UNDEFINED;
		//axis.oldUserMax = UNDEFINED;
		//axis.oldAxisLength = UNDEFINED;
		axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
		axis.range = options.range;
		axis.offset = options.offset || 0;
	
	
		// Dictionary for stacks
		axis.stacks = {};
		axis.oldStacks = {};

		// Dictionary for stacks max values
		axis.stackExtremes = {};

		// Min and max in the data
		//axis.dataMin = UNDEFINED,
		//axis.dataMax = UNDEFINED,
	
		// The axis range
		axis.max = null;
		axis.min = null;
	
		// User set min and max
		//axis.userMin = UNDEFINED,
		//axis.userMax = UNDEFINED,

		// Run Axis
		
		var eventType,
			events = axis.options.events;

		// Register
		if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
			chart.axes.push(axis);
			chart[isXAxis ? 'xAxis' : 'yAxis'].push(axis);
		}

		axis.series = axis.series || []; // populated by Series

		// inverted charts have reversed xAxes as default
		if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
			axis.reversed = true;
		}

		axis.removePlotBand = axis.removePlotBandOrLine;
		axis.removePlotLine = axis.removePlotBandOrLine;


		// register event listeners
		for (eventType in events) {
			addEvent(axis, eventType, events[eventType]);
		}

		// extend logarithmic axis
		if (axis.isLog) {
			axis.val2lin = log2lin;
			axis.lin2val = lin2log;
		}
	},
	
	/**
	 * Merge and set options
	 */
	setOptions: function (userOptions) {
		this.options = merge(
			this.defaultOptions,
			this.isXAxis ? {} : this.defaultYAxisOptions,
			[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
				this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
			merge(
				defaultOptions[this.isXAxis ? 'xAxis' : 'yAxis'], // if set in setOptions (#1053)
				userOptions
			)
		);
	},

	/**
	 * Update the axis with a new options structure
	 */
	update: function (newOptions, redraw) {
		var chart = this.chart;

		newOptions = chart.options[this.xOrY + 'Axis'][this.options.index] = merge(this.userOptions, newOptions);

		this.destroy(true);
		this._addedPlotLB = this.userMin = this.userMax = UNDEFINED; // #1611, #2306

		this.init(chart, extend(newOptions, { events: UNDEFINED }));

		chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw();
		}
	},	
	
	/**
     * Remove the axis from the chart
     */
	remove: function (redraw) {
		var chart = this.chart,
			key = this.xOrY + 'Axis'; // xAxis or yAxis

		// Remove associated series
		each(this.series, function (series) {
			series.remove(false);
		});

		// Remove the axis
		erase(chart.axes, this);
		erase(chart[key], this);
		chart.options[key].splice(this.options.index, 1);
		each(chart[key], function (axis, i) { // Re-index, #1706
			axis.options.index = i;
		});
		this.destroy();
		chart.isDirtyBox = true;

		if (pick(redraw, true)) {
			chart.redraw();
		}
	},
	
	/** 
	 * The default label formatter. The context is a special config object for the label.
	 */
	defaultLabelFormatter: function () {
		var axis = this.axis,
			value = this.value,
			categories = axis.categories, 
			dateTimeLabelFormat = this.dateTimeLabelFormat,
			numericSymbols = defaultOptions.lang.numericSymbols,
			i = numericSymbols && numericSymbols.length,
			multi,
			ret,
			formatOption = axis.options.labels.format,
			
			// make sure the same symbol is added for all labels on a linear axis
			numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

		if (formatOption) {
			ret = format(formatOption, this);
		
		} else if (categories) {
			ret = value;
		
		} else if (dateTimeLabelFormat) { // datetime axis
			ret = dateFormat(dateTimeLabelFormat, value);
		
		} else if (i && numericSymbolDetector >= 1000) {
			// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
			// If we are to enable this in tooltip or other places as well, we can move this
			// logic to the numberFormatter and enable it by a parameter.
			while (i-- && ret === UNDEFINED) {
				multi = Math.pow(1000, i + 1);
				if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
					ret = numberFormat(value / multi, -1) + numericSymbols[i];
				}
			}
		}
		
		if (ret === UNDEFINED) {
			if (value >= 1000) { // add thousands separators
				ret = numberFormat(value, 0);

			} else { // small numbers
				ret = numberFormat(value, -1);
			}
		}
		
		return ret;
	},

	/**
	 * Get the minimum and maximum for the series of each axis
	 */
	getSeriesExtremes: function () {
		var axis = this,
			chart = axis.chart;

		axis.hasVisibleSeries = false;

		// reset dataMin and dataMax in case we're redrawing
		axis.dataMin = axis.dataMax = null;

		// reset cached stacking extremes
		axis.stackExtremes = {};

		axis.buildStacks();

		// loop through this axis' series
		each(axis.series, function (series) {

			if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

				var seriesOptions = series.options,
					xData,
					threshold = seriesOptions.threshold,
					seriesDataMin,
					seriesDataMax;

				axis.hasVisibleSeries = true;

				// Validate threshold in logarithmic axes
				if (axis.isLog && threshold <= 0) {
					threshold = null;
				}

				// Get dataMin and dataMax for X axes
				if (axis.isXAxis) {
					xData = series.xData;
					if (xData.length) {
						axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
						axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
					}

				// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
				} else {

					// Get this particular series extremes
					series.getExtremes();
					seriesDataMax = series.dataMax;
					seriesDataMin = series.dataMin;

					// Get the dataMin and dataMax so far. If percentage is used, the min and max are
					// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
					// doesn't have active y data, we continue with nulls
					if (defined(seriesDataMin) && defined(seriesDataMax)) {
						axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
						axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
					}

					// Adjust to threshold
					if (defined(threshold)) {
						if (axis.dataMin >= threshold) {
							axis.dataMin = threshold;
							axis.ignoreMinPadding = true;
						} else if (axis.dataMax < threshold) {
							axis.dataMax = threshold;
							axis.ignoreMaxPadding = true;
						}
					}
				}
			}
		});
	},

	/**
	 * Translate from axis value to pixel position on the chart, or back
	 *
	 */
	translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
		var axis = this,
			axisLength = axis.len,
			sign = 1,
			cvsOffset = 0,
			localA = old ? axis.oldTransA : axis.transA,
			localMin = old ? axis.oldMin : axis.min,
			returnValue,
			minPixelPadding = axis.minPixelPadding,
			postTranslate = (axis.options.ordinal || (axis.isLog && handleLog)) && axis.lin2val;

		if (!localA) {
			localA = axis.transA;
		}

		// In vertical axes, the canvas coordinates start from 0 at the top like in 
		// SVG. 
		if (cvsCoord) {
			sign *= -1; // canvas coordinates inverts the value
			cvsOffset = axisLength;
		}

		// Handle reversed axis
		if (axis.reversed) { 
			sign *= -1;
			cvsOffset -= sign * axisLength;
		}

		// From pixels to value
		if (backwards) { // reverse translation
			
			val = val * sign + cvsOffset;
			val -= minPixelPadding;
			returnValue = val / localA + localMin; // from chart pixel to value
			if (postTranslate) { // log and ordinal axes
				returnValue = axis.lin2val(returnValue);
			}

		// From value to pixels
		} else {
			if (postTranslate) { // log and ordinal axes
				val = axis.val2lin(val);
			}
			if (pointPlacement === 'between') {
				pointPlacement = 0.5;
			}
			returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
				(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
		}

		return returnValue;
	},

	/**
	 * Utility method to translate an axis value to pixel position. 
	 * @param {Number} value A value in terms of axis units
	 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
	 *        or just the axis/pane itself.
	 */
	toPixels: function (value, paneCoordinates) {
		return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
	},

	/*
	 * Utility method to translate a pixel position in to an axis value
	 * @param {Number} pixel The pixel value coordinate
	 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
	 *        axis/pane itself.
	 */
	toValue: function (pixel, paneCoordinates) {
		return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
	},

	/**
	 * Create the path for a plot line that goes from the given value on
	 * this axis, across the plot to the opposite side
	 * @param {Number} value
	 * @param {Number} lineWidth Used for calculation crisp line
	 * @param {Number] old Use old coordinates (for resizing and rescaling)
	 */
	getPlotLinePath: function (value, lineWidth, old, force) {
		var axis = this,
			chart = axis.chart,
			axisLeft = axis.left,
			axisTop = axis.top,
			x1,
			y1,
			x2,
			y2,
			translatedValue = axis.translate(value, null, null, old),
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
			cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
			skip,
			transB = axis.transB;

		x1 = x2 = mathRound(translatedValue + transB);
		y1 = y2 = mathRound(cHeight - translatedValue - transB);

		if (isNaN(translatedValue)) { // no min or max
			skip = true;

		} else if (axis.horiz) {
			y1 = axisTop;
			y2 = cHeight - axis.bottom;
			if (x1 < axisLeft || x1 > axisLeft + axis.width) {
				skip = true;
			}
		} else {
			x1 = axisLeft;
			x2 = cWidth - axis.right;

			if (y1 < axisTop || y1 > axisTop + axis.height) {
				skip = true;
			}
		}
		return skip && !force ?
			null :
			chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
	},
	
	/**
	 * Create the path for a plot band
	 */
	getPlotBandPath: function (from, to) {

		var toPath = this.getPlotLinePath(to),
			path = this.getPlotLinePath(from);
			
		if (path && toPath) {
			path.push(
				toPath[4],
				toPath[5],
				toPath[1],
				toPath[2]
			);
		} else { // outside the axis area
			path = null;
		}
		
		return path;
	},
	
	/**
	 * Set the tick positions of a linear axis to round values like whole tens or every five.
	 */
	getLinearTickPositions: function (tickInterval, min, max) {
		var pos,
			lastPos,
			roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
			roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
			tickPositions = [];

		// Populate the intermediate values
		pos = roundedMin;
		while (pos <= roundedMax) {

			// Place the tick on the rounded value
			tickPositions.push(pos);

			// Always add the raw tickInterval, not the corrected one.
			pos = correctFloat(pos + tickInterval);

			// If the interval is not big enough in the current min - max range to actually increase
			// the loop variable, we need to break out to prevent endless loop. Issue #619
			if (pos === lastPos) {
				break;
			}

			// Record the last value
			lastPos = pos;
		}
		return tickPositions;
	},
	
	/**
	 * Set the tick positions of a logarithmic axis
	 */
	getLogTickPositions: function (interval, min, max, minor) {
		var axis = this,
			options = axis.options,
			axisLength = axis.len,
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			positions = []; 
		
		// Reset
		if (!minor) {
			axis._minorAutoInterval = null;
		}
		
		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		if (interval >= 0.5) {
			interval = mathRound(interval);
			positions = axis.getLinearTickPositions(interval, min, max);
			
		// Second case: We need intermediary ticks. For example 
		// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
		} else if (interval >= 0.08) {
			var roundedMin = mathFloor(min),
				intermediate,
				i,
				j,
				len,
				pos,
				lastPos,
				break2;
				
			if (interval > 0.3) {
				intermediate = [1, 2, 4];
			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 4, 6, 8];
			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			}
			
			for (i = roundedMin; i < max + 1 && !break2; i++) {
				len = intermediate.length;
				for (j = 0; j < len && !break2; j++) {
					pos = log2lin(lin2log(i) * intermediate[j]);
					
					if (pos > min && (!minor || lastPos <= max)) { // #1670
						positions.push(lastPos);
					}
					
					if (lastPos > max) {
						break2 = true;
					}
					lastPos = pos;
				}
			}
			
		// Third case: We are so deep in between whole logarithmic values that
		// we might as well handle the tick positions like a linear axis. For
		// example 1.01, 1.02, 1.03, 1.04.
		} else {
			var realMin = lin2log(min),
				realMax = lin2log(max),
				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
			
			interval = pick(
				filteredTickIntervalOption,
				axis._minorAutoInterval,
				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
			);
			
			interval = normalizeTickInterval(
				interval, 
				null, 
				getMagnitude(interval)
			);
			
			positions = map(axis.getLinearTickPositions(
				interval, 
				realMin,
				realMax	
			), log2lin);
			
			if (!minor) {
				axis._minorAutoInterval = interval / 5;
			}
		}
		
		// Set the axis-level tickInterval variable 
		if (!minor) {
			axis.tickInterval = interval;
		}
		return positions;
	},

	/**
	 * Return the minor tick positions. For logarithmic axes, reuse the same logic
	 * as for major ticks.
	 */
	getMinorTickPositions: function () {
		var axis = this,
			options = axis.options,
			tickPositions = axis.tickPositions,
			minorTickInterval = axis.minorTickInterval,
			minorTickPositions = [],
			pos,
			i,
			len;
		
		if (axis.isLog) {
			len = tickPositions.length;
			for (i = 1; i < len; i++) {
				minorTickPositions = minorTickPositions.concat(
					axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
				);	
			}
		} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
			minorTickPositions = minorTickPositions.concat(
				getTimeTicks(
					normalizeTimeTickInterval(minorTickInterval),
					axis.min,
					axis.max,
					options.startOfWeek
				)
			);
			if (minorTickPositions[0] < axis.min) {
				minorTickPositions.shift();
			}
		} else {			
			for (pos = axis.min + (tickPositions[0] - axis.min) % minorTickInterval; pos <= axis.max; pos += minorTickInterval) {
				minorTickPositions.push(pos);
			}
		}
		return minorTickPositions;
	},

	/**
	 * Adjust the min and max for the minimum range. Keep in mind that the series data is 
	 * not yet processed, so we don't have information on data cropping and grouping, or 
	 * updated axis.pointRange or series.pointRange. The data can't be processed until
	 * we have finally established min and max.
	 */
	adjustForMinRange: function () {
		var axis = this,
			options = axis.options,
			min = axis.min,
			max = axis.max,
			zoomOffset,
			spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
			closestDataRange,
			i,
			distance,
			xData,
			loopLength,
			minArgs,
			maxArgs;

		// Set the automatic minimum range based on the closest point distance
		if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

			if (defined(options.min) || defined(options.max)) {
				axis.minRange = null; // don't do this again

			} else {

				// Find the closest distance between raw data points, as opposed to
				// closestPointRange that applies to processed points (cropped and grouped)
				each(axis.series, function (series) {
					xData = series.xData;
					loopLength = series.xIncrement ? 1 : xData.length - 1;
					for (i = loopLength; i > 0; i--) {
						distance = xData[i] - xData[i - 1];
						if (closestDataRange === UNDEFINED || distance < closestDataRange) {
							closestDataRange = distance;
						}
					}
				});
				axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
			}
		}

		// if minRange is exceeded, adjust
		if (max - min < axis.minRange) {
			var minRange = axis.minRange;
			zoomOffset = (minRange - max + min) / 2;

			// if min and max options have been set, don't go beyond it
			minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
			if (spaceAvailable) { // if space is available, stay within the data range
				minArgs[2] = axis.dataMin;
			}
			min = arrayMax(minArgs);

			maxArgs = [min + minRange, pick(options.max, min + minRange)];
			if (spaceAvailable) { // if space is availabe, stay within the data range
				maxArgs[2] = axis.dataMax;
			}

			max = arrayMin(maxArgs);

			// now if the max is adjusted, adjust the min back
			if (max - min < minRange) {
				minArgs[0] = max - minRange;
				minArgs[1] = pick(options.min, max - minRange);
				min = arrayMax(minArgs);
			}
		}
		
		// Record modified extremes
		axis.min = min;
		axis.max = max;
	},

	/**
	 * Update translation information
	 */
	setAxisTranslation: function (saveOld) {
		var axis = this,
			range = axis.max - axis.min,
			pointRange = 0,
			closestPointRange,
			minPointOffset = 0,
			pointRangePadding = 0,
			linkedParent = axis.linkedParent,
			ordinalCorrection,
			transA = axis.transA;

		// adjust translation for padding
		if (axis.isXAxis) {
			if (linkedParent) {
				minPointOffset = linkedParent.minPointOffset;
				pointRangePadding = linkedParent.pointRangePadding;
				
			} else {
				each(axis.series, function (series) {
					var seriesPointRange = series.pointRange,
						pointPlacement = series.options.pointPlacement,
						seriesClosestPointRange = series.closestPointRange;

					if (seriesPointRange > range) { // #1446
						seriesPointRange = 0;
					}
					pointRange = mathMax(pointRange, seriesPointRange);
					
					// minPointOffset is the value padding to the left of the axis in order to make
					// room for points with a pointRange, typically columns. When the pointPlacement option
					// is 'between' or 'on', this padding does not apply.
					minPointOffset = mathMax(
						minPointOffset, 
						isString(pointPlacement) ? 0 : seriesPointRange / 2
					);
					
					// Determine the total padding needed to the length of the axis to make room for the 
					// pointRange. If the series' pointPlacement is 'on', no padding is added.
					pointRangePadding = mathMax(
						pointRangePadding,
						pointPlacement === 'on' ? 0 : seriesPointRange
					);

					// Set the closestPointRange
					if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
						closestPointRange = defined(closestPointRange) ?
							mathMin(closestPointRange, seriesClosestPointRange) :
							seriesClosestPointRange;
					}
				});
			}
			
			// Record minPointOffset and pointRangePadding
			ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
			axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
			axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

			// pointRange means the width reserved for each point, like in a column chart
			axis.pointRange = mathMin(pointRange, range);

			// closestPointRange means the closest distance between points. In columns
			// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
			// is some other value
			axis.closestPointRange = closestPointRange;
		}

		// Secondary values
		if (saveOld) {
			axis.oldTransA = transA;
		}
		axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
		axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
		axis.minPixelPadding = transA * minPointOffset;
	},

	/**
	 * Set the tick positions to round values and optionally extend the extremes
	 * to the nearest tick
	 */
	setTickPositions: function (secondPass) {
		var axis = this,
			chart = axis.chart,
			options = axis.options,
			isLog = axis.isLog,
			isDatetimeAxis = axis.isDatetimeAxis,
			isXAxis = axis.isXAxis,
			isLinked = axis.isLinked,
			tickPositioner = axis.options.tickPositioner,
			maxPadding = options.maxPadding,
			minPadding = options.minPadding,
			length,
			linkedParentExtremes,
			tickIntervalOption = options.tickInterval,
			minTickIntervalOption = options.minTickInterval,
			tickPixelIntervalOption = options.tickPixelInterval,
			tickPositions,
			keepTwoTicksOnly,
			categories = axis.categories;

		// linked axis gets the extremes from the parent axis
		if (isLinked) {
			axis.linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
			linkedParentExtremes = axis.linkedParent.getExtremes();
			axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
			axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
			if (options.type !== axis.linkedParent.options.type) {
				error(11, 1); // Can't link axes of different type
			}
		} else { // initial min and max from the extreme data values
			axis.min = pick(axis.userMin, options.min, axis.dataMin);
			axis.max = pick(axis.userMax, options.max, axis.dataMax);
		}

		if (isLog) {
			if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
				error(10, 1); // Can't plot negative values on log axis
			}
			axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
			axis.max = correctFloat(log2lin(axis.max));
		}

		// handle zoomed range
		if (axis.range) {
			axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
			axis.userMax = axis.max;
			if (secondPass) {
				axis.range = null;  // don't use it when running setExtremes
			}
		}
		
		// Hook for adjusting this.min and this.max. Used by bubble series.
		if (axis.beforePadding) {
			axis.beforePadding();
		}

		// adjust min and max for the minimum range
		axis.adjustForMinRange();
		
		// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
		// into account, we do this after computing tick interval (#1337).
		if (!categories && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
			length = axis.max - axis.min;
			if (length) {
				if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
					axis.min -= length * minPadding;
				}
				if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
					axis.max += length * maxPadding;
				}
			}
		}

		// get tickInterval
		if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
			axis.tickInterval = 1;
		} else if (isLinked && !tickIntervalOption &&
				tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
			axis.tickInterval = axis.linkedParent.tickInterval;
		} else {
			axis.tickInterval = pick(
				tickIntervalOption,
				categories ? // for categoried axis, 1 is default, for linear axis use tickPix
					1 :
					// don't let it be more than the data range
					(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
			);
			// For squished axes, set only two ticks
			if (!defined(tickIntervalOption) && axis.len < tickPixelIntervalOption && !this.isRadial) {
				keepTwoTicksOnly = true;
				axis.tickInterval /= 4; // tick extremes closer to the real values
			}
		}

		// Now we're finished detecting min and max, crop and group series data. This
		// is in turn needed in order to find tick positions in ordinal axes. 
		if (isXAxis && !secondPass) {
			each(axis.series, function (series) {
				series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
			});
		}

		// set the translation factor used in translate function
		axis.setAxisTranslation(true);

		// hook for ordinal axes and radial axes
		if (axis.beforeSetTickPositions) {
			axis.beforeSetTickPositions();
		}
		
		// hook for extensions, used in Highstock ordinal axes
		if (axis.postProcessTickInterval) {
			axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
		}

		// In column-like charts, don't cramp in more ticks than there are points (#1943)
		if (axis.pointRange) {
			axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
		}
		
		// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
		if (!tickIntervalOption && axis.tickInterval < minTickIntervalOption) {
			axis.tickInterval = minTickIntervalOption;
		}

		// for linear axes, get magnitude and normalize the interval
		if (!isDatetimeAxis && !isLog) { // linear
			if (!tickIntervalOption) {
				axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), options);
			}
		}

		// get minorTickInterval
		axis.minorTickInterval = options.minorTickInterval === 'auto' && axis.tickInterval ?
				axis.tickInterval / 5 : options.minorTickInterval;

		// find the tick positions
		axis.tickPositions = tickPositions = options.tickPositions ?
			[].concat(options.tickPositions) : // Work on a copy (#1565)
			(tickPositioner && tickPositioner.apply(axis, [axis.min, axis.max]));
		if (!tickPositions) {
			
			// Too many ticks
			if (!axis.ordinalPositions && (axis.max - axis.min) / axis.tickInterval > mathMax(2 * axis.len, 200)) {
				error(19, true);
			}
			
			if (isDatetimeAxis) {
				tickPositions = (axis.getNonLinearTimeTicks || getTimeTicks)(
					normalizeTimeTickInterval(axis.tickInterval, options.units),
					axis.min,
					axis.max,
					options.startOfWeek,
					axis.ordinalPositions,
					axis.closestPointRange,
					true
				);
			} else if (isLog) {
				tickPositions = axis.getLogTickPositions(axis.tickInterval, axis.min, axis.max);
			} else {
				tickPositions = axis.getLinearTickPositions(axis.tickInterval, axis.min, axis.max);
			}
			if (keepTwoTicksOnly) {
				tickPositions.splice(1, tickPositions.length - 2);
			}

			axis.tickPositions = tickPositions;
		}

		if (!isLinked) {

			// reset min/max or remove extremes based on start/end on tick
			var roundedMin = tickPositions[0],
				roundedMax = tickPositions[tickPositions.length - 1],
				minPointOffset = axis.minPointOffset || 0,
				singlePad;

			if (options.startOnTick) {
				axis.min = roundedMin;
			} else if (axis.min - minPointOffset > roundedMin) {
				tickPositions.shift();
			}

			if (options.endOnTick) {
				axis.max = roundedMax;
			} else if (axis.max + minPointOffset < roundedMax) {
				tickPositions.pop();
			}
			
			// When there is only one point, or all points have the same value on this axis, then min
			// and max are equal and tickPositions.length is 1. In this case, add some padding
			// in order to center the point, but leave it with one tick. #1337.
			if (tickPositions.length === 1) {
				singlePad = 0.001; // The lowest possible number to avoid extra padding on columns
				axis.min -= singlePad;
				axis.max += singlePad;
			}
		}
	},
	
	/**
	 * Set the max ticks of either the x and y axis collection
	 */
	setMaxTicks: function () {
		
		var chart = this.chart,
			maxTicks = chart.maxTicks || {},
			tickPositions = this.tickPositions,
			key = this._maxTicksKey = [this.xOrY, this.pos, this.len].join('-');
		
		if (!this.isLinked && !this.isDatetimeAxis && tickPositions && tickPositions.length > (maxTicks[key] || 0) && this.options.alignTicks !== false) {
			maxTicks[key] = tickPositions.length;
		}
		chart.maxTicks = maxTicks;
	},

	/**
	 * When using multiple axes, adjust the number of ticks to match the highest
	 * number of ticks in that group
	 */
	adjustTickAmount: function () {
		var axis = this,
			chart = axis.chart,
			key = axis._maxTicksKey,
			tickPositions = axis.tickPositions,
			maxTicks = chart.maxTicks;

		if (maxTicks && maxTicks[key] && !axis.isDatetimeAxis && !axis.categories && !axis.isLinked && axis.options.alignTicks !== false) { // only apply to linear scale
			var oldTickAmount = axis.tickAmount,
				calculatedTickAmount = tickPositions.length,
				tickAmount;

			// set the axis-level tickAmount to use below
			axis.tickAmount = tickAmount = maxTicks[key];

			if (calculatedTickAmount < tickAmount) {
				while (tickPositions.length < tickAmount) {
					tickPositions.push(correctFloat(
						tickPositions[tickPositions.length - 1] + axis.tickInterval
					));
				}
				axis.transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
				axis.max = tickPositions[tickPositions.length - 1];

			}
			if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
				axis.isDirty = true;
			}
		}
	},

	/**
	 * Set the scale based on data min and max, user set min and max or options
	 *
	 */
	setScale: function () {
		var axis = this,
			stacks = axis.stacks,
			type,
			i,
			isDirtyData,
			isDirtyAxisLength;

		axis.oldMin = axis.min;
		axis.oldMax = axis.max;
		axis.oldAxisLength = axis.len;

		// set the new axisLength
		axis.setAxisSize();
		//axisLength = horiz ? axisWidth : axisHeight;
		isDirtyAxisLength = axis.len !== axis.oldAxisLength;

		// is there new data?
		each(axis.series, function (series) {
			if (series.isDirtyData || series.isDirty ||
					series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
				isDirtyData = true;
			}
		});

		// do we really need to go through all this?
		if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
			axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {
			
			// reset stacks
			if (!axis.isXAxis) {
				for (type in stacks) {
					delete stacks[type];
				}
			}

			axis.forceRedraw = false;

			// get data extremes if needed
			axis.getSeriesExtremes();

			// get fixed positions based on tickInterval
			axis.setTickPositions();

			// record old values to decide whether a rescale is necessary later on (#540)
			axis.oldUserMin = axis.userMin;
			axis.oldUserMax = axis.userMax;

			// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
			if (!axis.isDirty) {
				axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
			}
		} else if (!axis.isXAxis) {
			if (axis.oldStacks) {
				stacks = axis.stacks = axis.oldStacks;
			}

			// reset stacks
			for (type in stacks) {
				for (i in stacks[type]) {
					stacks[type][i].cum = stacks[type][i].total;
				}
			}
		}
		
		// Set the maximum tick amount
		axis.setMaxTicks();
	},

	/**
	 * Set the extremes and optionally redraw
	 * @param {Number} newMin
	 * @param {Number} newMax
	 * @param {Boolean} redraw
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 * @param {Object} eventArguments 
	 *
	 */
	setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
		var axis = this,
			chart = axis.chart;

		redraw = pick(redraw, true); // defaults to true

		// Extend the arguments with min and max
		eventArguments = extend(eventArguments, {
			min: newMin,
			max: newMax
		});

		// Fire the event
		fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

			axis.userMin = newMin;
			axis.userMax = newMax;
			axis.eventArgs = eventArguments;

			// Mark for running afterSetExtremes
			axis.isDirtyExtremes = true;

			// redraw
			if (redraw) {
				chart.redraw(animation);
			}
		});
	},
	
	/**
	 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
	 * in stock charts.
	 */
	zoom: function (newMin, newMax) {

		// Prevent pinch zooming out of range. Check for defined is for #1946.
		if (!this.allowZoomOutside) {
			if (defined(this.dataMin) && newMin <= this.dataMin) {
				newMin = UNDEFINED;
			}
			if (defined(this.dataMax) && newMax >= this.dataMax) {
				newMax = UNDEFINED;
			}
		}

		// In full view, displaying the reset zoom button is not required
		this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;
		
		// Do it
		this.setExtremes(
			newMin,
			newMax,
			false, 
			UNDEFINED, 
			{ trigger: 'zoom' }
		);
		return true;
	},
	
	/**
	 * Update the axis metrics
	 */
	setAxisSize: function () {
		var chart = this.chart,
			options = this.options,
			offsetLeft = options.offsetLeft || 0,
			offsetRight = options.offsetRight || 0,
			horiz = this.horiz,
			width,
			height,
			top,
			left;

		// Expose basic values to use in Series object and navigator
		this.left = left = pick(options.left, chart.plotLeft + offsetLeft);
		this.top = top = pick(options.top, chart.plotTop);
		this.width = width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight);
		this.height = height = pick(options.height, chart.plotHeight);
		this.bottom = chart.chartHeight - height - top;
		this.right = chart.chartWidth - width - left;

		// Direction agnostic properties
		this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
		this.pos = horiz ? left : top; // distance from SVG origin
	},

	/**
	 * Get the actual axis extremes
	 */
	getExtremes: function () {
		var axis = this,
			isLog = axis.isLog;

		return {
			min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
			max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
			dataMin: axis.dataMin,
			dataMax: axis.dataMax,
			userMin: axis.userMin,
			userMax: axis.userMax
		};
	},

	/**
	 * Get the zero plane either based on zero or on the min or max value.
	 * Used in bar and area plots
	 */
	getThreshold: function (threshold) {
		var axis = this,
			isLog = axis.isLog;

		var realMin = isLog ? lin2log(axis.min) : axis.min,
			realMax = isLog ? lin2log(axis.max) : axis.max;
		
		if (realMin > threshold || threshold === null) {
			threshold = realMin;
		} else if (realMax < threshold) {
			threshold = realMax;
		}

		return axis.translate(threshold, 0, 1, 0, 1);
	},

	addPlotBand: function (options) {
		this.addPlotBandOrLine(options, 'plotBands');
	},
	
	addPlotLine: function (options) {
		this.addPlotBandOrLine(options, 'plotLines');
	},

	/**
	 * Add a plot band or plot line after render time
	 *
	 * @param options {Object} The plotBand or plotLine configuration object
	 */
	addPlotBandOrLine: function (options, coll) {
		var obj = new PlotLineOrBand(this, options).render(),
			userOptions = this.userOptions;

		if (obj) { // #2189
			// Add it to the user options for exporting and Axis.update
			if (coll) {
				userOptions[coll] = userOptions[coll] || [];
				userOptions[coll].push(options); 
			}
			this.plotLinesAndBands.push(obj); 
		}
		
		return obj;
	},

	/**
	 * Compute auto alignment for the axis label based on which side the axis is on 
	 * and the given rotation for the label
	 */
	autoLabelAlign: function (rotation) {
		var ret, 
			angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

		if (angle > 15 && angle < 165) {
			ret = 'right';
		} else if (angle > 195 && angle < 345) {
			ret = 'left';
		} else {
			ret = 'center';
		}
		return ret;
	},

	/**
	 * Render the tick labels to a preliminary position to get their sizes
	 */
	getOffset: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			tickPositions = axis.tickPositions,
			ticks = axis.ticks,
			horiz = axis.horiz,
			side = axis.side,
			invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
			hasData,
			showAxis,
			titleOffset = 0,
			titleOffsetOption,
			titleMargin = 0,
			axisTitleOptions = options.title,
			labelOptions = options.labels,
			labelOffset = 0, // reset
			axisOffset = chart.axisOffset,
			clipOffset = chart.clipOffset,
			directionFactor = [-1, 1, 1, -1][side],
			n,
			i,
			autoStaggerLines = 1,
			maxStaggerLines = pick(labelOptions.maxStaggerLines, 5),
			sortedPositions,
			lastRight,
			overlap,
			pos,
			bBox,
			x,
			w,
			lineNo;
			
		// For reuse in Axis.render
		axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));
		axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

		// Set/reset staggerLines
		axis.staggerLines = axis.horiz && labelOptions.staggerLines;
		
		// Create the axisGroup and gridGroup elements on first iteration
		if (!axis.axisGroup) {
			axis.gridGroup = renderer.g('grid')
				.attr({ zIndex: options.gridZIndex || 1 })
				.add();
			axis.axisGroup = renderer.g('axis')
				.attr({ zIndex: options.zIndex || 2 })
				.add();
			axis.labelGroup = renderer.g('axis-labels')
				.attr({ zIndex: labelOptions.zIndex || 7 })
				.add();
		}

		if (hasData || axis.isLinked) {
			
			// Set the explicit or automatic label alignment
			axis.labelAlign = pick(labelOptions.align || axis.autoLabelAlign(labelOptions.rotation));

			each(tickPositions, function (pos) {
				if (!ticks[pos]) {
					ticks[pos] = new Tick(axis, pos);
				} else {
					ticks[pos].addLabel(); // update labels depending on tick interval
				}
			});

			// Handle automatic stagger lines
			if (axis.horiz && !axis.staggerLines && maxStaggerLines && !labelOptions.rotation) {
				sortedPositions = axis.reversed ? [].concat(tickPositions).reverse() : tickPositions;
				while (autoStaggerLines < maxStaggerLines) {
					lastRight = [];
					overlap = false;
					
					for (i = 0; i < sortedPositions.length; i++) {
						pos = sortedPositions[i];
						bBox = ticks[pos].label && ticks[pos].label.getBBox();
						w = bBox ? bBox.width : 0;
						lineNo = i % autoStaggerLines;
						
						if (w) {
							x = axis.translate(pos); // don't handle log
							if (lastRight[lineNo] !== UNDEFINED && x < lastRight[lineNo]) {
								overlap = true;
							}
							lastRight[lineNo] = x + w;
						}
					}
					if (overlap) {
						autoStaggerLines++;
					} else {
						break;
					}
				}

				if (autoStaggerLines > 1) {
					axis.staggerLines = autoStaggerLines;
				}
			}


			each(tickPositions, function (pos) {
				// left side must be align: right and right side must have align: left for labels
				if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

					// get the highest offset
					labelOffset = mathMax(
						ticks[pos].getLabelSize(),
						labelOffset
					);
				}

			});
			if (axis.staggerLines) {
				labelOffset *= axis.staggerLines;
				axis.labelOffset = labelOffset;
			}
			

		} else { // doesn't have data
			for (n in ticks) {
				ticks[n].destroy();
				delete ticks[n];
			}
		}

		if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) { 
			if (!axis.axisTitle) {
				axis.axisTitle = renderer.text(
					axisTitleOptions.text,
					0,
					0,
					axisTitleOptions.useHTML
				)
				.attr({
					zIndex: 7,
					rotation: axisTitleOptions.rotation || 0,
					align:
						axisTitleOptions.textAlign ||
						{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
				})
				.css(axisTitleOptions.style)
				.add(axis.axisGroup);
				axis.axisTitle.isNew = true;
			}

			if (showAxis) {
				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
				titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
				titleOffsetOption = axisTitleOptions.offset;
			}

			// hide or show the title depending on whether showEmpty is set
			axis.axisTitle[showAxis ? 'show' : 'hide']();
		}
		
		// handle automatic or user set offset
		axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
		
		axis.axisTitleMargin =
			pick(titleOffsetOption,
				labelOffset + titleMargin +
				(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x'])
			);

		axisOffset[side] = mathMax(
			axisOffset[side],
			axis.axisTitleMargin + titleOffset + directionFactor * axis.offset
		);
		clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
	},
	
	/**
	 * Get the path for the axis line
	 */
	getLinePath: function (lineWidth) {
		var chart = this.chart,
			opposite = this.opposite,
			offset = this.offset,
			horiz = this.horiz,
			lineLeft = this.left + (opposite ? this.width : 0) + offset,
			lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
			
		if (opposite) {
			lineWidth *= -1; // crispify the other way - #1480, #1687
		}

		return chart.renderer.crispLine([
				M,
				horiz ?
					this.left :
					lineLeft,
				horiz ?
					lineTop :
					this.top,
				L,
				horiz ?
					chart.chartWidth - this.right :
					lineLeft,
				horiz ?
					lineTop :
					chart.chartHeight - this.bottom
			], lineWidth);
	},
	
	/**
	 * Position the title
	 */
	getTitlePosition: function () {
		// compute anchor points for each of the title align options
		var horiz = this.horiz,
			axisLeft = this.left,
			axisTop = this.top,
			axisLength = this.len,
			axisTitleOptions = this.options.title,			
			margin = horiz ? axisLeft : axisTop,
			opposite = this.opposite,
			offset = this.offset,
			fontSize = pInt(axisTitleOptions.style.fontSize || 12),
			
			// the position in the length direction of the axis
			alongAxis = {
				low: margin + (horiz ? 0 : axisLength),
				middle: margin + axisLength / 2,
				high: margin + (horiz ? axisLength : 0)
			}[axisTitleOptions.align],
	
			// the position in the perpendicular direction of the axis
			offAxis = (horiz ? axisTop + this.height : axisLeft) +
				(horiz ? 1 : -1) * // horizontal axis reverses the margin
				(opposite ? -1 : 1) * // so does opposite axes
				this.axisTitleMargin +
				(this.side === 2 ? fontSize : 0);

		return {
			x: horiz ?
				alongAxis :
				offAxis + (opposite ? this.width : 0) + offset +
					(axisTitleOptions.x || 0), // x
			y: horiz ?
				offAxis - (opposite ? this.height : 0) + offset :
				alongAxis + (axisTitleOptions.y || 0) // y
		};
	},
	
	/**
	 * Render the axis
	 */
	render: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			isLog = axis.isLog,
			isLinked = axis.isLinked,
			tickPositions = axis.tickPositions,
			axisTitle = axis.axisTitle,
			stacks = axis.stacks,
			ticks = axis.ticks,
			minorTicks = axis.minorTicks,
			alternateBands = axis.alternateBands,
			stackLabelOptions = options.stackLabels,
			alternateGridColor = options.alternateGridColor,
			tickmarkOffset = axis.tickmarkOffset,
			lineWidth = options.lineWidth,
			linePath,
			hasRendered = chart.hasRendered,
			slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
			hasData = axis.hasData,
			showAxis = axis.showAxis,
			from,
			to;

		// Mark all elements inActive before we go over and mark the active ones
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos;
			for (pos in coll) {
				coll[pos].isActive = false;
			}
		});

		// If the series has data draw the ticks. Else only the line and title
		if (hasData || isLinked) {

			// minor ticks
			if (axis.minorTickInterval && !axis.categories) {
				each(axis.getMinorTickPositions(), function (pos) {
					if (!minorTicks[pos]) {
						minorTicks[pos] = new Tick(axis, pos, 'minor');
					}

					// render new ticks in old position
					if (slideInTicks && minorTicks[pos].isNew) {
						minorTicks[pos].render(null, true);
					}

					minorTicks[pos].render(null, false, 1);
				});
			}

			// Major ticks. Pull out the first item and render it last so that
			// we can get the position of the neighbour label. #808.
			if (tickPositions.length) { // #1300
				each(tickPositions.slice(1).concat([tickPositions[0]]), function (pos, i) {
	
					// Reorganize the indices
					i = (i === tickPositions.length - 1) ? 0 : i + 1;
	
					// linked axes need an extra check to find out if
					if (!isLinked || (pos >= axis.min && pos <= axis.max)) {
	
						if (!ticks[pos]) {
							ticks[pos] = new Tick(axis, pos);
						}
	
						// render new ticks in old position
						if (slideInTicks && ticks[pos].isNew) {
							ticks[pos].render(i, true);
						}
	
						ticks[pos].render(i, false, 1);
					}
	
				});
				// In a categorized axis, the tick marks are displayed between labels. So
				// we need to add a tick mark and grid line at the left edge of the X axis.
				if (tickmarkOffset && axis.min === 0) {
					if (!ticks[-1]) {
						ticks[-1] = new Tick(axis, -1, null, true);
					}
					ticks[-1].render(-1);
				}
				
			}

			// alternate grid color
			if (alternateGridColor) {
				each(tickPositions, function (pos, i) {
					if (i % 2 === 0 && pos < axis.max) {
						if (!alternateBands[pos]) {
							alternateBands[pos] = new PlotLineOrBand(axis);
						}
						from = pos + tickmarkOffset; // #949
						to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
						alternateBands[pos].options = {
							from: isLog ? lin2log(from) : from,
							to: isLog ? lin2log(to) : to,
							color: alternateGridColor
						};
						alternateBands[pos].render();
						alternateBands[pos].isActive = true;
					}
				});
			}

			// custom plot lines and bands
			if (!axis._addedPlotLB) { // only first time
				each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
					axis.addPlotBandOrLine(plotLineOptions);
				});
				axis._addedPlotLB = true;
			}

		} // end if hasData

		// Remove inactive ticks
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos, 
				i,
				forDestruction = [],
				delay = globalAnimation ? globalAnimation.duration || 500 : 0,
				destroyInactiveItems = function () {
					i = forDestruction.length;
					while (i--) {
						// When resizing rapidly, the same items may be destroyed in different timeouts,
						// or the may be reactivated
						if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
							coll[forDestruction[i]].destroy();
							delete coll[forDestruction[i]];
						}
					}
					
				};

			for (pos in coll) {

				if (!coll[pos].isActive) {
					// Render to zero opacity
					coll[pos].render(pos, false, 0);
					coll[pos].isActive = false;
					forDestruction.push(pos);
				}
			}

			// When the objects are finished fading out, destroy them
			if (coll === alternateBands || !chart.hasRendered || !delay) {
				destroyInactiveItems();
			} else if (delay) {
				setTimeout(destroyInactiveItems, delay);
			}
		});

		// Static items. As the axis group is cleared on subsequent calls
		// to render, these items are added outside the group.
		// axis line
		if (lineWidth) {
			linePath = axis.getLinePath(lineWidth);
			if (!axis.axisLine) {
				axis.axisLine = renderer.path(linePath)
					.attr({
						stroke: options.lineColor,
						'stroke-width': lineWidth,
						zIndex: 7
					})
					.add(axis.axisGroup);
			} else {
				axis.axisLine.animate({ d: linePath });
			}

			// show or hide the line depending on options.showEmpty
			axis.axisLine[showAxis ? 'show' : 'hide']();
		}

		if (axisTitle && showAxis) {
			
			axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
				axis.getTitlePosition()
			);
			axisTitle.isNew = false;
		}

		// Stacked totals:
		if (stackLabelOptions && stackLabelOptions.enabled) {
			var stackKey, oneStack, stackCategory,
				stackTotalGroup = axis.stackTotalGroup;

			// Create a separate group for the stack total labels
			if (!stackTotalGroup) {
				axis.stackTotalGroup = stackTotalGroup =
					renderer.g('stack-labels')
						.attr({
							visibility: VISIBLE,
							zIndex: 6
						})
						.add();
			}

			// plotLeft/Top will change when y axis gets wider so we need to translate the
			// stackTotalGroup at every render call. See bug #506 and #516
			stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

			// Render each stack total
			for (stackKey in stacks) {
				oneStack = stacks[stackKey];
				for (stackCategory in oneStack) {
					oneStack[stackCategory].render(stackTotalGroup);
				}
			}
		}
		// End stacked totals

		axis.isDirty = false;
	},

	/**
	 * Remove a plot band or plot line from the chart by id
	 * @param {Object} id
	 */
	removePlotBandOrLine: function (id) {
		var plotLinesAndBands = this.plotLinesAndBands,
			options = this.options,
			userOptions = this.userOptions,
			i = plotLinesAndBands.length;
		while (i--) {
			if (plotLinesAndBands[i].id === id) {
				plotLinesAndBands[i].destroy();
			}
		}
		each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
			i = arr.length;
			while (i--) {
				if (arr[i].id === id) {
					erase(arr, arr[i]);
				}
			}
		});

	},

	/**
	 * Update the axis title by options
	 */
	setTitle: function (newTitleOptions, redraw) {
		this.update({ title: newTitleOptions }, redraw);
	},

	/**
	 * Redraw the axis to reflect changes in the data or axis extremes
	 */
	redraw: function () {
		var axis = this,
			chart = axis.chart,
			pointer = chart.pointer;

		// hide tooltip and hover states
		if (pointer.reset) {
			pointer.reset(true);
		}

		// render the axis
		axis.render();

		// move plot lines and bands
		each(axis.plotLinesAndBands, function (plotLine) {
			plotLine.render();
		});

		// mark associated series as dirty and ready for redraw
		each(axis.series, function (series) {
			series.isDirty = true;
		});

	},

	/**
	 * Build the stacks from top down
	 */
	buildStacks: function () {
		var series = this.series,
			i = series.length;
		if (!this.isXAxis) {
			while (i--) {
				series[i].setStackedPoints();
			}
			// Loop up again to compute percent stack
			if (this.usePercentage) {
				for (i = 0; i < series.length; i++) {
					series[i].setPercentStacks();
				}
			}
		}
	},

	/**
	 * Set new axis categories and optionally redraw
	 * @param {Array} categories
	 * @param {Boolean} redraw
	 */
	setCategories: function (categories, redraw) {
		this.update({ categories: categories }, redraw);
	},

	/**
	 * Destroys an Axis instance.
	 */
	destroy: function (keepEvents) {
		var axis = this,
			stacks = axis.stacks,
			stackKey,
			plotLinesAndBands = axis.plotLinesAndBands,
			i;

		// Remove the events
		if (!keepEvents) {
			removeEvent(axis);
		}

		// Destroy each stack total
		for (stackKey in stacks) {
			destroyObjectProperties(stacks[stackKey]);

			stacks[stackKey] = null;
		}

		// Destroy collections
		each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
			destroyObjectProperties(coll);
		});
		i = plotLinesAndBands.length;
		while (i--) { // #1975
			plotLinesAndBands[i].destroy();
		}

		// Destroy local variables
		each(['stackTotalGroup', 'axisLine', 'axisGroup', 'gridGroup', 'labelGroup', 'axisTitle'], function (prop) {
			if (axis[prop]) {
				axis[prop] = axis[prop].destroy();
			}
		});
	}

	
}; // end Axis

/**
 * The tooltip object
 * @param {Object} chart The chart instance
 * @param {Object} options Tooltip options
 */
function Tooltip() {
	this.init.apply(this, arguments);
}

Tooltip.prototype = {

	init: function (chart, options) {

		var borderWidth = options.borderWidth,
			style = options.style,
			padding = pInt(style.padding);

		// Save the chart and options
		this.chart = chart;
		this.options = options;

		// Keep track of the current series
		//this.currentSeries = UNDEFINED;

		// List of crosshairs
		this.crosshairs = [];

		// Current values of x and y when animating
		this.now = { x: 0, y: 0 };

		// The tooltip is initially hidden
		this.isHidden = true;


		// create the label
		this.label = chart.renderer.label('', 0, 0, options.shape, null, null, options.useHTML, null, 'tooltip')
			.attr({
				padding: padding,
				fill: options.backgroundColor,
				'stroke-width': borderWidth,
				r: options.borderRadius,
				zIndex: 8
			})
			.css(style)
			.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
			.add()
			.attr({ y: -999 }); // #2301

		// When using canVG the shadow shows up as a gray circle
		// even if the tooltip is hidden.
		if (!useCanVG) {
			this.label.shadow(options.shadow);
		}

		// Public property for getting the shared state.
		this.shared = options.shared;
	},

	/**
	 * Destroy the tooltip and its elements.
	 */
	destroy: function () {
		each(this.crosshairs, function (crosshair) {
			if (crosshair) {
				crosshair.destroy();
			}
		});

		// Destroy and clear local variables
		if (this.label) {
			this.label = this.label.destroy();
		}
		clearTimeout(this.hideTimer);
		clearTimeout(this.tooltipTimeout);
	},

	/**
	 * Provide a soft movement for the tooltip
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @private
	 */
	move: function (x, y, anchorX, anchorY) {
		var tooltip = this,
			now = tooltip.now,
			animate = tooltip.options.animation !== false && !tooltip.isHidden;

		// get intermediate values for animation
		extend(now, {
			x: animate ? (2 * now.x + x) / 3 : x,
			y: animate ? (now.y + y) / 2 : y,
			anchorX: animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
			anchorY: animate ? (now.anchorY + anchorY) / 2 : anchorY
		});

		// move to the intermediate value
		tooltip.label.attr(now);

		
		// run on next tick of the mouse tracker
		if (animate && (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1)) {
		
			// never allow two timeouts
			clearTimeout(this.tooltipTimeout);
			
			// set the fixed interval ticking for the smooth tooltip
			this.tooltipTimeout = setTimeout(function () {
				// The interval function may still be running during destroy, so check that the chart is really there before calling.
				if (tooltip) {
					tooltip.move(x, y, anchorX, anchorY);
				}
			}, 32);
			
		}
	},

	/**
	 * Hide the tooltip
	 */
	hide: function () {
		var tooltip = this,
			hoverPoints;
		
		clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
		if (!this.isHidden) {
			hoverPoints = this.chart.hoverPoints;

			this.hideTimer = setTimeout(function () {
				tooltip.label.fadeOut();
				tooltip.isHidden = true;
			}, pick(this.options.hideDelay, 500));

			// hide previous hoverPoints and set new
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			this.chart.hoverPoints = null;
		}
	},

	/**
	 * Hide the crosshairs
	 */
	hideCrosshairs: function () {
		each(this.crosshairs, function (crosshair) {
			if (crosshair) {
				crosshair.hide();
			}
		});
	},
	
	/** 
	 * Extendable method to get the anchor position of the tooltip
	 * from a point or set of points
	 */
	getAnchor: function (points, mouseEvent) {
		var ret,
			chart = this.chart,
			inverted = chart.inverted,
			plotTop = chart.plotTop,
			plotX = 0,
			plotY = 0,
			yAxis;
		
		points = splat(points);
		
		// Pie uses a special tooltipPos
		ret = points[0].tooltipPos;
		
		// When tooltip follows mouse, relate the position to the mouse
		if (this.followPointer && mouseEvent) {
			if (mouseEvent.chartX === UNDEFINED) {
				mouseEvent = chart.pointer.normalize(mouseEvent);
			}
			ret = [
				mouseEvent.chartX - chart.plotLeft,
				mouseEvent.chartY - plotTop
			];
		}
		// When shared, use the average position
		if (!ret) {
			each(points, function (point) {
				yAxis = point.series.yAxis;
				plotX += point.plotX;
				plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
					(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
			});
			
			plotX /= points.length;
			plotY /= points.length;
			
			ret = [
				inverted ? chart.plotWidth - plotY : plotX,
				this.shared && !inverted && points.length > 1 && mouseEvent ? 
					mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
					inverted ? chart.plotHeight - plotX : plotY
			];
		}

		return map(ret, mathRound);
	},
	
	/**
	 * Place the tooltip in a chart without spilling over
	 * and not covering the point it self.
	 */
	getPosition: function (boxWidth, boxHeight, point) {
		
		// Set up the variables
		var chart = this.chart,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			distance = pick(this.options.distance, 12),
			pointX = point.plotX,
			pointY = point.plotY,
			x = pointX + plotLeft + (chart.inverted ? distance : -boxWidth - distance),
			y = pointY - boxHeight + plotTop + 15, // 15 means the point is 15 pixels up from the bottom of the tooltip
			alignedRight;
	
		// It is too far to the left, adjust it
		if (x < 7) {
			x = plotLeft + mathMax(pointX, 0) + distance;
		}
	
		// Test to see if the tooltip is too far to the right,
		// if it is, move it back to be inside and then up to not cover the point.
		if ((x + boxWidth) > (plotLeft + plotWidth)) {
			x -= (x + boxWidth) - (plotLeft + plotWidth);
			y = pointY - boxHeight + plotTop - distance;
			alignedRight = true;
		}
	
		// If it is now above the plot area, align it to the top of the plot area
		if (y < plotTop + 5) {
			y = plotTop + 5;
	
			// If the tooltip is still covering the point, move it below instead
			if (alignedRight && pointY >= y && pointY <= (y + boxHeight)) {
				y = pointY + plotTop + distance; // below
			}
		} 
	
		// Now if the tooltip is below the chart, move it up. It's better to cover the
		// point than to disappear outside the chart. #834.
		if (y + boxHeight > plotTop + plotHeight) {
			y = mathMax(plotTop, plotTop + plotHeight - boxHeight - distance); // below
		}
	
		return {x: x, y: y};
	},

	/**
	 * In case no user defined formatter is given, this will be used. Note that the context
	 * here is an object holding point, series, x, y etc.
	 */
	defaultFormatter: function (tooltip) {
		var items = this.points || splat(this),
			series = items[0].series,
			s;

		// build the header
		s = [series.tooltipHeaderFormatter(items[0])];

		// build the values
		each(items, function (item) {
			series = item.series;
			s.push((series.tooltipFormatter && series.tooltipFormatter(item)) ||
				item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
		});

		// footer
		s.push(tooltip.options.footerFormat || '');

		return s.join('');
	},

	/**
	 * Refresh the tooltip's text and position.
	 * @param {Object} point
	 */
	refresh: function (point, mouseEvent) {
		var tooltip = this,
			chart = tooltip.chart,
			label = tooltip.label,
			options = tooltip.options,
			x,
			y,
			anchor,
			textConfig = {},
			text,
			pointConfig = [],
			formatter = options.formatter || tooltip.defaultFormatter,
			hoverPoints = chart.hoverPoints,
			borderColor,
			crosshairsOptions = options.crosshairs,
			shared = tooltip.shared,
			currentSeries;
			
		clearTimeout(this.hideTimer);
		
		// get the reference point coordinates (pie charts use tooltipPos)
		tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
		anchor = tooltip.getAnchor(point, mouseEvent);
		x = anchor[0];
		y = anchor[1];

		// shared tooltip, array is sent over
		if (shared && !(point.series && point.series.noSharedTooltip)) {
			
			// hide previous hoverPoints and set new
			
			chart.hoverPoints = point;
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(point, function (item) {
				item.setState(HOVER_STATE);

				pointConfig.push(item.getLabelConfig());
			});

			textConfig = {
				x: point[0].category,
				y: point[0].y
			};
			textConfig.points = pointConfig;
			point = point[0];

		// single point tooltip
		} else {
			textConfig = point.getLabelConfig();
		}
		text = formatter.call(textConfig, tooltip);

		// register the current series
		currentSeries = point.series;

		// update the inner HTML
		if (text === false) {
			this.hide();
		} else {

			// show it
			if (tooltip.isHidden) {
				stop(label);
				label.attr('opacity', 1).show();
			}

			// update text
			label.attr({
				text: text
			});

			// set the stroke color of the box
			borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
			label.attr({
				stroke: borderColor
			});
			
			tooltip.updatePosition({ plotX: x, plotY: y });
		
			this.isHidden = false;
		}

		// crosshairs
		if (crosshairsOptions) {
			crosshairsOptions = splat(crosshairsOptions); // [x, y]

			var path,
				i = crosshairsOptions.length,
				attribs,
				axis,
				val,
				series;

			while (i--) {
				series = point.series;
				axis = series[i ? 'yAxis' : 'xAxis'];
				if (crosshairsOptions[i] && axis) {
					val = i ? pick(point.stackY, point.y) : point.x; // #814
					if (axis.isLog) { // #1671
						val = log2lin(val);
					}
					if (i === 1 && series.modifyValue) { // #1205, #2316
						val = series.modifyValue(val);
					}

					path = axis.getPlotLinePath(
						val,
						1
					);

					if (tooltip.crosshairs[i]) {
						tooltip.crosshairs[i].attr({ d: path, visibility: VISIBLE });
					} else {
						attribs = {
							'stroke-width': crosshairsOptions[i].width || 1,
							stroke: crosshairsOptions[i].color || '#C0C0C0',
							zIndex: crosshairsOptions[i].zIndex || 2
						};
						if (crosshairsOptions[i].dashStyle) {
							attribs.dashstyle = crosshairsOptions[i].dashStyle;
						}
						tooltip.crosshairs[i] = chart.renderer.path(path)
							.attr(attribs)
							.add();
					}
				}
			}
		}
		fireEvent(chart, 'tooltipRefresh', {
				text: text,
				x: x + chart.plotLeft,
				y: y + chart.plotTop,
				borderColor: borderColor
			});
	},
	
	/**
	 * Find the new position and perform the move
	 */
	updatePosition: function (point) {
		var chart = this.chart,
			label = this.label, 
			pos = (this.options.positioner || this.getPosition).call(
				this,
				label.width,
				label.height,
				point
			);

		// do the move
		this.move(
			mathRound(pos.x), 
			mathRound(pos.y), 
			point.plotX + chart.plotLeft, 
			point.plotY + chart.plotTop
		);
	}
};
/**
 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
 * Subsequent methods should be named differently from what they are doing.
 * @param {Object} chart The Chart instance
 * @param {Object} options The root options object
 */
function Pointer(chart, options) {
	this.init(chart, options);
}

Pointer.prototype = {
	/**
	 * Initialize Pointer
	 */
	init: function (chart, options) {
		
		var chartOptions = options.chart,
			chartEvents = chartOptions.events,
			zoomType = useCanVG ? '' : chartOptions.zoomType,
			inverted = chart.inverted,
			zoomX,
			zoomY;

		// Store references
		this.options = options;
		this.chart = chart;
		
		// Zoom status
		this.zoomX = zoomX = /x/.test(zoomType);
		this.zoomY = zoomY = /y/.test(zoomType);
		this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
		this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);

		// Do we need to handle click on a touch device?
		this.runChartClick = chartEvents && !!chartEvents.click;

		this.pinchDown = [];
		this.lastValidTouch = {};

		if (options.tooltip.enabled) {
			chart.tooltip = new Tooltip(chart, options.tooltip);
		}

		this.setDOMEvents();
	}, 

	/**
	 * Add crossbrowser support for chartX and chartY
	 * @param {Object} e The event object in standard browsers
	 */
	normalize: function (e, chartPosition) {
		var chartX,
			chartY,
			ePos;

		// common IE normalizing
		e = e || win.event;
		if (!e.target) {
			e.target = e.srcElement;
		}

		// Framework specific normalizing (#1165)
		e = washMouseEvent(e);
		
		// iOS
		ePos = e.touches ? e.touches.item(0) : e;

		// Get mouse position
		if (!chartPosition) {
			this.chartPosition = chartPosition = offset(this.chart.container);
		}

		// chartX and chartY
		if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
			chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
				// for IE10 quirks mode within framesets
			chartY = e.y;
		} else {
			chartX = ePos.pageX - chartPosition.left;
			chartY = ePos.pageY - chartPosition.top;
		}

		return extend(e, {
			chartX: mathRound(chartX),
			chartY: mathRound(chartY)
		});
	},

	/**
	 * Get the click position in terms of axis values.
	 *
	 * @param {Object} e A pointer event
	 */
	getCoordinates: function (e) {
		var coordinates = {
				xAxis: [],
				yAxis: []
			};

		each(this.chart.axes, function (axis) {
			coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
				axis: axis,
				value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
			});
		});
		return coordinates;
	},
	
	/**
	 * Return the index in the tooltipPoints array, corresponding to pixel position in 
	 * the plot area.
	 */
	getIndex: function (e) {
		var chart = this.chart;
		return chart.inverted ? 
			chart.plotHeight + chart.plotTop - e.chartY : 
			e.chartX - chart.plotLeft;
	},

	/**
	 * With line type charts with a single tracker, get the point closest to the mouse.
	 * Run Point.onMouseOver and display tooltip for the point or points.
	 */
	runPointActions: function (e) {
		var pointer = this,
			chart = pointer.chart,
			series = chart.series,
			tooltip = chart.tooltip,
			point,
			points,
			hoverPoint = chart.hoverPoint,
			hoverSeries = chart.hoverSeries,
			i,
			j,
			distance = chart.chartWidth,
			index = pointer.getIndex(e),
			anchor;

		// shared tooltip
		if (tooltip && pointer.options.tooltip.shared && !(hoverSeries && hoverSeries.noSharedTooltip)) {
			points = [];

			// loop over all series and find the ones with points closest to the mouse
			i = series.length;
			for (j = 0; j < i; j++) {
				if (series[j].visible &&
						series[j].options.enableMouseTracking !== false &&
						!series[j].noSharedTooltip && series[j].tooltipPoints.length) {
					point = series[j].tooltipPoints[index];
					if (point && point.series) { // not a dummy point, #1544
						point._dist = mathAbs(index - point.clientX);
						distance = mathMin(distance, point._dist);
						points.push(point);
					}
				}
			}
			// remove furthest points
			i = points.length;
			while (i--) {
				if (points[i]._dist > distance) {
					points.splice(i, 1);
				}
			}
			// refresh the tooltip if necessary
			if (points.length && (points[0].clientX !== pointer.hoverX)) {
				tooltip.refresh(points, e);
				pointer.hoverX = points[0].clientX;
			}
		}

		// separate tooltip and general mouse events
		if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker

			// get the point
			point = hoverSeries.tooltipPoints[index];

			// a new point is hovered, refresh the tooltip
			if (point && point !== hoverPoint) {

				// trigger the events
				point.onMouseOver(e);

			}
			
		} else if (tooltip && tooltip.followPointer && !tooltip.isHidden) {
			anchor = tooltip.getAnchor([{}], e);
			tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
		}
	},



	/**
	 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
	 * 
	 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
	 */
	reset: function (allowMove) {
		var pointer = this,
			chart = pointer.chart,
			hoverSeries = chart.hoverSeries,
			hoverPoint = chart.hoverPoint,
			tooltip = chart.tooltip,
			tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
			
		// Narrow in allowMove
		allowMove = allowMove && tooltip && tooltipPoints;
			
		// Check if the points have moved outside the plot area, #1003
		if (allowMove && splat(tooltipPoints)[0].plotX === UNDEFINED) {
			allowMove = false;
		}	

		// Just move the tooltip, #349
		if (allowMove) {
			tooltip.refresh(tooltipPoints);

		// Full reset
		} else {

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide();
				tooltip.hideCrosshairs();
			}

			pointer.hoverX = null;

		}
	},

	/**
	 * Scale series groups to a certain scale and translation
	 */
	scaleGroups: function (attribs, clip) {

		var chart = this.chart,
			seriesAttribs;

		// Scale each series
		each(chart.series, function (series) {
			seriesAttribs = attribs || series.getPlotBox(); // #1701
			if (series.xAxis && series.xAxis.zoomEnabled) {
				series.group.attr(seriesAttribs);
				if (series.markerGroup) {
					series.markerGroup.attr(seriesAttribs);
					series.markerGroup.clip(clip ? chart.clipRect : null);
				}
				if (series.dataLabelsGroup) {
					series.dataLabelsGroup.attr(seriesAttribs);
				}
			}
		});
		
		// Clip
		chart.clipRect.attr(clip || chart.clipBox);
	},

	/**
	 * Run translation operations for each direction (horizontal and vertical) independently
	 */
	pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
		var chart = this.chart,
			xy = horiz ? 'x' : 'y',
			XY = horiz ? 'X' : 'Y',
			sChartXY = 'chart' + XY,
			wh = horiz ? 'width' : 'height',
			plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
			selectionWH,
			selectionXY,
			clipXY,
			scale = 1,
			inverted = chart.inverted,
			bounds = chart.bounds[horiz ? 'h' : 'v'],
			singleTouch = pinchDown.length === 1,
			touch0Start = pinchDown[0][sChartXY],
			touch0Now = touches[0][sChartXY],
			touch1Start = !singleTouch && pinchDown[1][sChartXY],
			touch1Now = !singleTouch && touches[1][sChartXY],
			outOfBounds,
			transformScale,
			scaleKey,
			setScale = function () {
				if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
					scale = mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);	
				}
				
				clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
				selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
			};

		// Set the scale, first pass
		setScale();

		selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

		// Out of bounds
		if (selectionXY < bounds.min) {
			selectionXY = bounds.min;
			outOfBounds = true;
		} else if (selectionXY + selectionWH > bounds.max) {
			selectionXY = bounds.max - selectionWH;
			outOfBounds = true;
		}
		
		// Is the chart dragged off its bounds, determined by dataMin and dataMax?
		if (outOfBounds) {

			// Modify the touchNow position in order to create an elastic drag movement. This indicates
			// to the user that the chart is responsive but can't be dragged further.
			touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
			if (!singleTouch) {
				touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
			}

			// Set the scale, second pass to adapt to the modified touchNow positions
			setScale();

		} else {
			lastValidTouch[xy] = [touch0Now, touch1Now];
		}

		
		// Set geometry for clipping, selection and transformation
		if (!inverted) { // TODO: implement clipping for inverted charts
			clip[xy] = clipXY - plotLeftTop;
			clip[wh] = selectionWH;
		}
		scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
		transformScale = inverted ? 1 / scale : scale;

		selectionMarker[wh] = selectionWH;
		selectionMarker[xy] = selectionXY;
		transform[scaleKey] = scale;
		transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	},
	
	/**
	 * Handle touch events with two touches
	 */
	pinch: function (e) {

		var self = this,
			chart = self.chart,
			pinchDown = self.pinchDown,
			followTouchMove = chart.tooltip && chart.tooltip.options.followTouchMove,
			touches = e.touches,
			touchesLength = touches.length,
			lastValidTouch = self.lastValidTouch,
			zoomHor = self.zoomHor || self.pinchHor,
			zoomVert = self.zoomVert || self.pinchVert,
			hasZoom = zoomHor || zoomVert,
			selectionMarker = self.selectionMarker,
			transform = {},
			fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
				chart.runTrackerClick) || chart.runChartClick),
			clip = {};

		// On touch devices, only proceed to trigger click if a handler is defined
		if ((hasZoom || followTouchMove) && !fireClickEvent) {
			e.preventDefault();
		}
		
		// Normalize each touch
		map(touches, function (e) {
			return self.normalize(e);
		});
			
		// Register the touch start position
		if (e.type === 'touchstart') {
			each(touches, function (e, i) {
				pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
			});
			lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
			lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

			// Identify the data bounds in pixels
			each(chart.axes, function (axis) {
				if (axis.zoomEnabled) {
					var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
						minPixelPadding = axis.minPixelPadding,
						min = axis.toPixels(axis.dataMin),
						max = axis.toPixels(axis.dataMax),
						absMin = mathMin(min, max),
						absMax = mathMax(min, max);

					// Store the bounds for use in the touchmove handler
					bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
					bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
				}
			});
		
		// Event type is touchmove, handle panning and pinching
		} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
			

			// Set the marker
			if (!selectionMarker) {
				self.selectionMarker = selectionMarker = extend({
					destroy: noop
				}, chart.plotBox);
			}

			

			if (zoomHor) {
				self.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
			if (zoomVert) {
				self.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}

			self.hasPinched = hasZoom;

			// Scale and translate the groups to provide visual feedback during pinching
			self.scaleGroups(transform, clip);
			
			// Optionally move the tooltip on touchmove
			if (!hasZoom && followTouchMove && touchesLength === 1) {
				this.runPointActions(self.normalize(e));
			}
		}
	},

	/**
	 * Start a drag operation
	 */
	dragStart: function (e) {
		var chart = this.chart;

		// Record the start position
		chart.mouseIsDown = e.type;
		chart.cancelClick = false;
		chart.mouseDownX = this.mouseDownX = e.chartX;
		chart.mouseDownY = this.mouseDownY = e.chartY;
	},

	/**
	 * Perform a drag operation in response to a mousemove event while the mouse is down
	 */
	drag: function (e) {

		var chart = this.chart,
			chartOptions = chart.options.chart,
			chartX = e.chartX,
			chartY = e.chartY,
			zoomHor = this.zoomHor,
			zoomVert = this.zoomVert,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			clickedInside,
			size,
			mouseDownX = this.mouseDownX,
			mouseDownY = this.mouseDownY;

		// If the mouse is outside the plot area, adjust to cooordinates
		// inside to prevent the selection marker from going outside
		if (chartX < plotLeft) {
			chartX = plotLeft;
		} else if (chartX > plotLeft + plotWidth) {
			chartX = plotLeft + plotWidth;
		}

		if (chartY < plotTop) {
			chartY = plotTop;
		} else if (chartY > plotTop + plotHeight) {
			chartY = plotTop + plotHeight;
		}
		
		// determine if the mouse has moved more than 10px
		this.hasDragged = Math.sqrt(
			Math.pow(mouseDownX - chartX, 2) +
			Math.pow(mouseDownY - chartY, 2)
		);
		if (this.hasDragged > 10) {
			clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

			// make a selection
			if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside) {
				if (!this.selectionMarker) {
					this.selectionMarker = chart.renderer.rect(
						plotLeft,
						plotTop,
						zoomHor ? 1 : plotWidth,
						zoomVert ? 1 : plotHeight,
						0
					)
					.attr({
						fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
						zIndex: 7
					})
					.add();
				}
			}

			// adjust the width of the selection marker
			if (this.selectionMarker && zoomHor) {
				size = chartX - mouseDownX;
				this.selectionMarker.attr({
					width: mathAbs(size),
					x: (size > 0 ? 0 : size) + mouseDownX
				});
			}
			// adjust the height of the selection marker
			if (this.selectionMarker && zoomVert) {
				size = chartY - mouseDownY;
				this.selectionMarker.attr({
					height: mathAbs(size),
					y: (size > 0 ? 0 : size) + mouseDownY
				});
			}

			// panning
			if (clickedInside && !this.selectionMarker && chartOptions.panning) {
				chart.pan(e, chartOptions.panning);
			}
		}
	},

	/**
	 * On mouse up or touch end across the entire document, drop the selection.
	 */
	drop: function (e) {
		var chart = this.chart,
			hasPinched = this.hasPinched;

		if (this.selectionMarker) {
			var selectionData = {
					xAxis: [],
					yAxis: [],
					originalEvent: e.originalEvent || e
				},
				selectionBox = this.selectionMarker,
				selectionLeft = selectionBox.x,
				selectionTop = selectionBox.y,
				runZoom;
			// a selection has been made
			if (this.hasDragged || hasPinched) {

				// record each axis' min and max
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled) {
						var horiz = axis.horiz,
							selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop)),
							selectionMax = axis.toValue((horiz ? selectionLeft + selectionBox.width : selectionTop + selectionBox.height));

						if (!isNaN(selectionMin) && !isNaN(selectionMax)) { // #859
							selectionData[axis.xOrY + 'Axis'].push({
								axis: axis,
								min: mathMin(selectionMin, selectionMax), // for reversed axes,
								max: mathMax(selectionMin, selectionMax)
							});
							runZoom = true;
						}
					}
				});
				if (runZoom) {
					fireEvent(chart, 'selection', selectionData, function (args) { 
						chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
					});
				}

			}
			this.selectionMarker = this.selectionMarker.destroy();

			// Reset scaling preview
			if (hasPinched) {
				this.scaleGroups();
			}
		}

		// Reset all
		if (chart) { // it may be destroyed on mouse up - #877
			css(chart.container, { cursor: chart._cursor });
			chart.cancelClick = this.hasDragged > 10; // #370
			chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
			this.pinchDown = [];
		}
	},

	onContainerMouseDown: function (e) {

		e = this.normalize(e);

		// issue #295, dragging not always working in Firefox
		if (e.preventDefault) {
			e.preventDefault();
		}
		
		this.dragStart(e);
	},

	

	onDocumentMouseUp: function (e) {
		this.drop(e);
	},

	/**
	 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
	 * Issue #149 workaround. The mouseleave event does not always fire. 
	 */
	onDocumentMouseMove: function (e) {
		var chart = this.chart,
			chartPosition = this.chartPosition,
			hoverSeries = chart.hoverSeries;

		e = this.normalize(e, chartPosition);

		// If we're outside, hide the tooltip
		if (chartPosition && hoverSeries && !this.inClass(e.target, 'highcharts-tracker') &&
				!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
			this.reset();
		}
	},

	/**
	 * When mouse leaves the container, hide the tooltip.
	 */
	onContainerMouseLeave: function () {
		this.reset();
		this.chartPosition = null; // also reset the chart position, used in #149 fix
	},

	// The mousemove, touchmove and touchstart event handler
	onContainerMouseMove: function (e) {

		var chart = this.chart;

		// normalize
		e = this.normalize(e);

		// #295
		e.returnValue = false;
		
		
		if (chart.mouseIsDown === 'mousedown') {
			this.drag(e);
		} 
		
		// Show the tooltip and run mouse over events (#977)
		if ((this.inClass(e.target, 'highcharts-tracker') || 
				chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
			this.runPointActions(e);
		}
	},

	/**
	 * Utility to detect whether an element has, or has a parent with, a specific
	 * class name. Used on detection of tracker objects and on deciding whether
	 * hovering the tooltip should cause the active series to mouse out.
	 */
	inClass: function (element, className) {
		var elemClassName;
		while (element) {
			elemClassName = attr(element, 'class');
			if (elemClassName) {
				if (elemClassName.indexOf(className) !== -1) {
					return true;
				} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
					return false;
				}
			}
			element = element.parentNode;
		}		
	},

	onTrackerMouseOut: function (e) {
		var series = this.chart.hoverSeries;
		if (series && !series.options.stickyTracking && !this.inClass(e.toElement || e.relatedTarget, PREFIX + 'tooltip')) {
			series.onMouseOut();
		}
	},

	onContainerClick: function (e) {
		var chart = this.chart,
			hoverPoint = chart.hoverPoint, 
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			inverted = chart.inverted,
			chartPosition,
			plotX,
			plotY;
		
		e = this.normalize(e);
		e.cancelBubble = true; // IE specific

		if (!chart.cancelClick) {
			
			// On tracker click, fire the series and point events. #783, #1583
			if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {
				chartPosition = this.chartPosition;
				plotX = hoverPoint.plotX;
				plotY = hoverPoint.plotY;

				// add page position info
				extend(hoverPoint, {
					pageX: chartPosition.left + plotLeft +
						(inverted ? chart.plotWidth - plotY : plotX),
					pageY: chartPosition.top + plotTop +
						(inverted ? chart.plotHeight - plotX : plotY)
				});
			
				// the series click event
				fireEvent(hoverPoint.series, 'click', extend(e, {
					point: hoverPoint
				}));

				// the point click event
				if (chart.hoverPoint) { // it may be destroyed (#1844)
					hoverPoint.firePointEvent('click', e);
				}

			// When clicking outside a tracker, fire a chart event
			} else {
				extend(e, this.getCoordinates(e));

				// fire a click event in the chart
				if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
					fireEvent(chart, 'click', e);
				}
			}


		}
	},

	onContainerTouchStart: function (e) {
		var chart = this.chart;

		if (e.touches.length === 1) {

			e = this.normalize(e);

			if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {

				// Prevent the click pseudo event from firing unless it is set in the options
				/*if (!chart.runChartClick) {
					e.preventDefault();
				}*/
			
				// Run mouse events and display tooltip etc
				this.runPointActions(e);

				this.pinch(e);

			} else {
				// Hide the tooltip on touching outside the plot area (#1203)
				this.reset();
			}

		} else if (e.touches.length === 2) {
			this.pinch(e);
		}		
	},

	onContainerTouchMove: function (e) {
		if (e.touches.length === 1 || e.touches.length === 2) {
			this.pinch(e);
		}
	},

	onDocumentTouchEnd: function (e) {
		this.drop(e);
	},

	/**
	 * Set the JS DOM events on the container and document. This method should contain
	 * a one-to-one assignment between methods and their handlers. Any advanced logic should
	 * be moved to the handler reflecting the event's name.
	 */
	setDOMEvents: function () {

		var pointer = this,
			container = pointer.chart.container,
			events;

		this._events = events = [
			[container, 'onmousedown', 'onContainerMouseDown'],
			[container, 'onmousemove', 'onContainerMouseMove'],
			[container, 'onclick', 'onContainerClick'],
			[container, 'mouseleave', 'onContainerMouseLeave'],
			[doc, 'mousemove', 'onDocumentMouseMove'],
			[doc, 'mouseup', 'onDocumentMouseUp']
		];

		if (hasTouch) {
			events.push(
				[container, 'ontouchstart', 'onContainerTouchStart'],
				[container, 'ontouchmove', 'onContainerTouchMove'],
				[doc, 'touchend', 'onDocumentTouchEnd']
			);
		}

		each(events, function (eventConfig) {

			// First, create the callback function that in turn calls the method on Pointer
			pointer['_' + eventConfig[2]] = function (e) {
				pointer[eventConfig[2]](e);
			};

			// Now attach the function, either as a direct property or through addEvent
			if (eventConfig[1].indexOf('on') === 0) {
				eventConfig[0][eventConfig[1]] = pointer['_' + eventConfig[2]];
			} else {
				addEvent(eventConfig[0], eventConfig[1], pointer['_' + eventConfig[2]]);
			}
		});

		
	},

	/**
	 * Destroys the Pointer object and disconnects DOM events.
	 */
	destroy: function () {
		var pointer = this;

		// Release all DOM events
		each(pointer._events, function (eventConfig) {	
			if (eventConfig[1].indexOf('on') === 0) {
				eventConfig[0][eventConfig[1]] = null; // delete breaks oldIE
			} else {		
				removeEvent(eventConfig[0], eventConfig[1], pointer['_' + eventConfig[2]]);
			}
		});
		delete pointer._events;

		// memory and CPU leak
		clearInterval(pointer.tooltipTimeout);
	}
};
/**
 * The overview of the chart's series
 */
function Legend(chart, options) {
	this.init(chart, options);
}

Legend.prototype = {
	
	/**
	 * Initialize the legend
	 */
	init: function (chart, options) {
		
		var legend = this,
			itemStyle = options.itemStyle,
			padding = pick(options.padding, 8),
			itemMarginTop = options.itemMarginTop || 0;
	
		this.options = options;

		if (!options.enabled) {
			return;
		}
	
		legend.baseline = pInt(itemStyle.fontSize) + 3 + itemMarginTop; // used in Series prototype
		legend.itemStyle = itemStyle;
		legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
		legend.itemMarginTop = itemMarginTop;
		legend.padding = padding;
		legend.initialItemX = padding;
		legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
		legend.maxItemWidth = 0;
		legend.chart = chart;
		legend.itemHeight = 0;
		legend.lastLineHeight = 0;

		// Render it
		legend.render();

		// move checkboxes
		addEvent(legend.chart, 'endResize', function () { 
			legend.positionCheckboxes();
		});

	},

	/**
	 * Set the colors for the legend item
	 * @param {Object} item A Series or Point instance
	 * @param {Object} visible Dimmed or colored
	 */
	colorizeItem: function (item, visible) {
		var legend = this,
			options = legend.options,
			legendItem = item.legendItem,
			legendLine = item.legendLine,
			legendSymbol = item.legendSymbol,
			hiddenColor = legend.itemHiddenStyle.color,
			textColor = visible ? options.itemStyle.color : hiddenColor,
			symbolColor = visible ? item.color : hiddenColor,
			markerOptions = item.options && item.options.marker,
			symbolAttr = {
				stroke: symbolColor,
				fill: symbolColor
			},
			key,
			val;
		
		if (legendItem) {
			legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
		}
		if (legendLine) {
			legendLine.attr({ stroke: symbolColor });
		}
		
		if (legendSymbol) {
			
			// Apply marker options
			if (markerOptions && legendSymbol.isMarker) { // #585
				markerOptions = item.convertAttribs(markerOptions);
				for (key in markerOptions) {
					val = markerOptions[key];
					if (val !== UNDEFINED) {
						symbolAttr[key] = val;
					}
				}
			}

			legendSymbol.attr(symbolAttr);
		}
	},

	/**
	 * Position the legend item
	 * @param {Object} item A Series or Point instance
	 */
	positionItem: function (item) {
		var legend = this,
			options = legend.options,
			symbolPadding = options.symbolPadding,
			ltr = !options.rtl,
			legendItemPos = item._legendItemPos,
			itemX = legendItemPos[0],
			itemY = legendItemPos[1],
			checkbox = item.checkbox;

		if (item.legendGroup) {
			item.legendGroup.translate(
				ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
				itemY
			);
		}

		if (checkbox) {
			checkbox.x = itemX;
			checkbox.y = itemY;
		}
	},

	/**
	 * Destroy a single legend item
	 * @param {Object} item The series or point
	 */
	destroyItem: function (item) {
		var checkbox = item.checkbox;

		// destroy SVG elements
		each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
			if (item[key]) {
				item[key] = item[key].destroy();
			}
		});

		if (checkbox) {
			discardElement(item.checkbox);
		}
	},

	/**
	 * Destroys the legend.
	 */
	destroy: function () {
		var legend = this,
			legendGroup = legend.group,
			box = legend.box;

		if (box) {
			legend.box = box.destroy();
		}

		if (legendGroup) {
			legend.group = legendGroup.destroy();
		}
	},

	/**
	 * Position the checkboxes after the width is determined
	 */
	positionCheckboxes: function (scrollOffset) {
		var alignAttr = this.group.alignAttr,
			translateY,
			clipHeight = this.clipHeight || this.legendHeight;

		if (alignAttr) {
			translateY = alignAttr.translateY;
			each(this.allItems, function (item) {
				var checkbox = item.checkbox,
					top;
				
				if (checkbox) {
					top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
					css(checkbox, {
						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 20) + PX,
						top: top + PX,
						display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
					});
				}
			});
		}
	},
	
	/**
	 * Render the legend title on top of the legend
	 */
	renderTitle: function () {
		var options = this.options,
			padding = this.padding,
			titleOptions = options.title,
			titleHeight = 0,
			bBox;
		
		if (titleOptions.text) {
			if (!this.title) {
				this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
					.attr({ zIndex: 1 })
					.css(titleOptions.style)
					.add(this.group);
			}
			bBox = this.title.getBBox();
			titleHeight = bBox.height;
			this.offsetWidth = bBox.width; // #1717
			this.contentGroup.attr({ translateY: titleHeight });
		}
		this.titleHeight = titleHeight;
	},

	/**
	 * Render a single specific legend item
	 * @param {Object} item A series or point
	 */
	renderItem: function (item) {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			options = legend.options,
			horizontal = options.layout === 'horizontal',
			symbolWidth = options.symbolWidth,
			symbolPadding = options.symbolPadding,
			itemStyle = legend.itemStyle,
			itemHiddenStyle = legend.itemHiddenStyle,
			padding = legend.padding,
			itemDistance = horizontal ? pick(options.itemDistance, 8) : 0,
			ltr = !options.rtl,
			itemHeight,
			widthOption = options.width,
			itemMarginBottom = options.itemMarginBottom || 0,
			itemMarginTop = legend.itemMarginTop,
			initialItemX = legend.initialItemX,
			bBox,
			itemWidth,
			li = item.legendItem,
			series = item.series || item,
			itemOptions = series.options,
			showCheckbox = itemOptions.showCheckbox,
			useHTML = options.useHTML;

		if (!li) { // generate it once, later move it

			// Generate the group box
			// A group to hold the symbol and text. Text is to be appended in Legend class.
			item.legendGroup = renderer.g('legend-item')
				.attr({ zIndex: 1 })
				.add(legend.scrollGroup);

			// Draw the legend symbol inside the group box
			series.drawLegendSymbol(legend, item);

			// Generate the list item text and add it to the group
			item.legendItem = li = renderer.text(
					options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),
					ltr ? symbolWidth + symbolPadding : -symbolPadding,
					legend.baseline,
					useHTML
				)
				.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
				.attr({
					align: ltr ? 'left' : 'right',
					zIndex: 2
				})
				.add(item.legendGroup);

			// Set the events on the item group, or in case of useHTML, the item itself (#1249)
			(useHTML ? li : item.legendGroup).on('mouseover', function () {
					item.setState(HOVER_STATE);
					li.css(legend.options.itemHoverStyle);
				})
				.on('mouseout', function () {
					li.css(item.visible ? itemStyle : itemHiddenStyle);
					item.setState();
				})
				.on('click', function (event) {
					var strLegendItemClick = 'legendItemClick',
						fnLegendItemClick = function () {
							item.setVisible();
						};
						
					// Pass over the click/touch event. #4.
					event = {
						browserEvent: event
					};

					// click the name or symbol
					if (item.firePointEvent) { // point
						item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
					} else {
						fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
					}
				});

			// Colorize the items
			legend.colorizeItem(item, item.visible);

			// add the HTML checkbox on top
			if (itemOptions && showCheckbox) {
				item.checkbox = createElement('input', {
					type: 'checkbox',
					checked: item.selected,
					defaultChecked: item.selected // required by IE7
				}, options.itemCheckboxStyle, chart.container);

				addEvent(item.checkbox, 'click', function (event) {
					var target = event.target;
					fireEvent(item, 'checkboxClick', {
							checked: target.checked
						},
						function () {
							item.select();
						}
					);
				});
			}
		}

		// calculate the positions for the next line
		bBox = li.getBBox();

		itemWidth = item.legendItemWidth =
			options.itemWidth || symbolWidth + symbolPadding + bBox.width + itemDistance +
			(showCheckbox ? 20 : 0);
		legend.itemHeight = itemHeight = bBox.height;

		// if the item exceeds the width, start a new line
		if (horizontal && legend.itemX - initialItemX + itemWidth >
				(widthOption || (chart.chartWidth - 2 * padding - initialItemX))) {
			legend.itemX = initialItemX;
			legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
			legend.lastLineHeight = 0; // reset for next line
		}

		// If the item exceeds the height, start a new column
		/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
			legend.itemY = legend.initialItemY;
			legend.itemX += legend.maxItemWidth;
			legend.maxItemWidth = 0;
		}*/

		// Set the edge positions
		legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
		legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
		legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

		// cache the position of the newly generated or reordered items
		item._legendItemPos = [legend.itemX, legend.itemY];

		// advance
		if (horizontal) {
			legend.itemX += itemWidth;

		} else {
			legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
			legend.lastLineHeight = itemHeight;
		}

		// the width of the widest item
		legend.offsetWidth = widthOption || mathMax(
			(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
			legend.offsetWidth
		);
	},

	/**
	 * Render the legend. This method can be called both before and after
	 * chart.render. If called after, it will only rearrange items instead
	 * of creating new ones.
	 */
	render: function () {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			legendGroup = legend.group,
			allItems,
			display,
			legendWidth,
			legendHeight,
			box = legend.box,
			options = legend.options,
			padding = legend.padding,
			legendBorderWidth = options.borderWidth,
			legendBackgroundColor = options.backgroundColor;

		legend.itemX = legend.initialItemX;
		legend.itemY = legend.initialItemY;
		legend.offsetWidth = 0;
		legend.lastItemY = 0;

		if (!legendGroup) {
			legend.group = legendGroup = renderer.g('legend')
				.attr({ zIndex: 7 }) 
				.add();
			legend.contentGroup = renderer.g()
				.attr({ zIndex: 1 }) // above background
				.add(legendGroup);
			legend.scrollGroup = renderer.g()
				.add(legend.contentGroup);
		}
		
		legend.renderTitle();

		// add each series or point
		allItems = [];
		each(chart.series, function (serie) {
			var seriesOptions = serie.options;

			if (!seriesOptions.showInLegend || defined(seriesOptions.linkedTo)) {
				return;
			}

			// use points or series for the legend item depending on legendType
			allItems = allItems.concat(
					serie.legendItems ||
					(seriesOptions.legendType === 'point' ?
							serie.data :
							serie)
			);
		});

		// sort by legendIndex
		stableSort(allItems, function (a, b) {
			return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
		});

		// reversed legend
		if (options.reversed) {
			allItems.reverse();
		}

		legend.allItems = allItems;
		legend.display = display = !!allItems.length;

		// render the items
		each(allItems, function (item) {
			legend.renderItem(item); 
		});

		// Draw the border
		legendWidth = options.width || legend.offsetWidth;
		legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
		
		
		legendHeight = legend.handleOverflow(legendHeight);

		if (legendBorderWidth || legendBackgroundColor) {
			legendWidth += padding;
			legendHeight += padding;

			if (!box) {
				legend.box = box = renderer.rect(
					0,
					0,
					legendWidth,
					legendHeight,
					options.borderRadius,
					legendBorderWidth || 0
				).attr({
					stroke: options.borderColor,
					'stroke-width': legendBorderWidth || 0,
					fill: legendBackgroundColor || NONE
				})
				.add(legendGroup)
				.shadow(options.shadow);
				box.isNew = true;

			} else if (legendWidth > 0 && legendHeight > 0) {
				box[box.isNew ? 'attr' : 'animate'](
					box.crisp(null, null, null, legendWidth, legendHeight)
				);
				box.isNew = false;
			}

			// hide the border if no items
			box[display ? 'show' : 'hide']();
		}
		
		legend.legendWidth = legendWidth;
		legend.legendHeight = legendHeight;

		// Now that the legend width and height are established, put the items in the 
		// final position
		each(allItems, function (item) {
			legend.positionItem(item);
		});

		// 1.x compatibility: positioning based on style
		/*var props = ['left', 'right', 'top', 'bottom'],
			prop,
			i = 4;
		while (i--) {
			prop = props[i];
			if (options.style[prop] && options.style[prop] !== 'auto') {
				options[i < 2 ? 'align' : 'verticalAlign'] = prop;
				options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
			}
		}*/

		if (display) {
			legendGroup.align(extend({
				width: legendWidth,
				height: legendHeight
			}, options), true, 'spacingBox');
		}

		if (!chart.isResizing) {
			this.positionCheckboxes();
		}
	},
	
	/**
	 * Set up the overflow handling by adding navigation with up and down arrows below the
	 * legend.
	 */
	handleOverflow: function (legendHeight) {
		var legend = this,
			chart = this.chart,
			renderer = chart.renderer,
			pageCount,
			options = this.options,
			optionsY = options.y,
			alignTop = options.verticalAlign === 'top',
			spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
			maxHeight = options.maxHeight,
			clipHeight,
			clipRect = this.clipRect,
			navOptions = options.navigation,
			animation = pick(navOptions.animation, true),
			arrowSize = navOptions.arrowSize || 12,
			nav = this.nav;
			
		// Adjust the height
		if (options.layout === 'horizontal') {
			spaceHeight /= 2;
		}
		if (maxHeight) {
			spaceHeight = mathMin(spaceHeight, maxHeight);
		}
		
		// Reset the legend height and adjust the clipping rectangle
		if (legendHeight > spaceHeight && !options.useHTML) {

			this.clipHeight = clipHeight = spaceHeight - 20 - this.titleHeight;
			this.pageCount = pageCount = mathCeil(legendHeight / clipHeight);
			this.currentPage = pick(this.currentPage, 1);
			this.fullHeight = legendHeight;
			
			// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
			if (!clipRect) {
				clipRect = legend.clipRect = renderer.clipRect(0, 0, 9999, 0);
				legend.contentGroup.clip(clipRect);
			}
			clipRect.attr({
				height: clipHeight
			});
			
			// Add navigation elements
			if (!nav) {
				this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
				this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(-1, animation);
					})
					.add(nav);
				this.pager = renderer.text('', 15, 10)
					.css(navOptions.style)
					.add(nav);
				this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(1, animation);
					})
					.add(nav);
			}
			
			// Set initial position
			legend.scroll(0);
			
			legendHeight = spaceHeight;
			
		} else if (nav) {
			clipRect.attr({
				height: chart.chartHeight
			});
			nav.hide();
			this.scrollGroup.attr({
				translateY: 1
			});
			this.clipHeight = 0; // #1379
		}
		
		return legendHeight;
	},
	
	/**
	 * Scroll the legend by a number of pages
	 * @param {Object} scrollBy
	 * @param {Object} animation
	 */
	scroll: function (scrollBy, animation) {
		var pageCount = this.pageCount,
			currentPage = this.currentPage + scrollBy,
			clipHeight = this.clipHeight,
			navOptions = this.options.navigation,
			activeColor = navOptions.activeColor,
			inactiveColor = navOptions.inactiveColor,
			pager = this.pager,
			padding = this.padding,
			scrollOffset;
		
		// When resizing while looking at the last page
		if (currentPage > pageCount) {
			currentPage = pageCount;
		}
		
		if (currentPage > 0) {
			
			if (animation !== UNDEFINED) {
				setAnimation(animation, this.chart);
			}
			
			this.nav.attr({
				translateX: padding,
				translateY: clipHeight + 7 + this.titleHeight,
				visibility: VISIBLE
			});
			this.up.attr({
					fill: currentPage === 1 ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === 1 ? 'default' : 'pointer'
				});
			pager.attr({
				text: currentPage + '/' + this.pageCount
			});
			this.down.attr({
					x: 18 + this.pager.getBBox().width, // adjust to text width
					fill: currentPage === pageCount ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === pageCount ? 'default' : 'pointer'
				});
			
			scrollOffset = -mathMin(clipHeight * (currentPage - 1), this.fullHeight - clipHeight + padding) + 1;
			this.scrollGroup.animate({
				translateY: scrollOffset
			});
			pager.attr({
				text: currentPage + '/' + pageCount
			});
			
			
			this.currentPage = currentPage;
			this.positionCheckboxes(scrollOffset);
		}
			
	}
	
};

// Workaround for #2030, horizontal legend items not displaying in IE11 Preview.
// TODO: When IE11 is released, check again for this bug, and remove the fix
// or make a better one.
if (/Trident.*?11\.0/.test(userAgent)) {
	wrap(Legend.prototype, 'positionItem', function (proceed, item) {
		var legend = this;
		setTimeout(function () {
			proceed.call(legend, item);
		});
	});
}

/**
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
function Chart() {
	this.init.apply(this, arguments);
}

Chart.prototype = {

	/**
	 * Initialize the chart
	 */
	init: function (userOptions, callback) {

		// Handle regular options
		var options,
			seriesOptions = userOptions.series; // skip merging data points to increase performance

		userOptions.series = null;
		options = merge(defaultOptions, userOptions); // do the merge
		options.series = userOptions.series = seriesOptions; // set back the series data

		var optionsChart = options.chart;
		
		// Create margin & spacing array
		this.margin = this.splashArray('margin', optionsChart);
		this.spacing = this.splashArray('spacing', optionsChart);

		var chartEvents = optionsChart.events;

		//this.runChartClick = chartEvents && !!chartEvents.click;
		this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

		this.callback = callback;
		this.isResizing = 0;
		this.options = options;
		//chartTitleOptions = UNDEFINED;
		//chartSubtitleOptions = UNDEFINED;

		this.axes = [];
		this.series = [];
		this.hasCartesianSeries = optionsChart.showAxes;
		//this.axisOffset = UNDEFINED;
		//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
		//this.inverted = UNDEFINED;
		//this.loadingShown = UNDEFINED;
		//this.container = UNDEFINED;
		//this.chartWidth = UNDEFINED;
		//this.chartHeight = UNDEFINED;
		//this.marginRight = UNDEFINED;
		//this.marginBottom = UNDEFINED;
		//this.containerWidth = UNDEFINED;
		//this.containerHeight = UNDEFINED;
		//this.oldChartWidth = UNDEFINED;
		//this.oldChartHeight = UNDEFINED;

		//this.renderTo = UNDEFINED;
		//this.renderToClone = UNDEFINED;

		//this.spacingBox = UNDEFINED

		//this.legend = UNDEFINED;

		// Elements
		//this.chartBackground = UNDEFINED;
		//this.plotBackground = UNDEFINED;
		//this.plotBGImage = UNDEFINED;
		//this.plotBorder = UNDEFINED;
		//this.loadingDiv = UNDEFINED;
		//this.loadingSpan = UNDEFINED;

		var chart = this,
			eventType;

		// Add the chart to the global lookup
		chart.index = charts.length;
		charts.push(chart);

		// Set up auto resize
		if (optionsChart.reflow !== false) {
			addEvent(chart, 'load', function () {
				chart.initReflow();
			});
		}

		// Chart event handlers
		if (chartEvents) {
			for (eventType in chartEvents) {
				addEvent(chart, eventType, chartEvents[eventType]);
			}
		}

		chart.xAxis = [];
		chart.yAxis = [];

		// Expose methods and variables
		chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
		chart.pointCount = 0;
		chart.counters = new ChartCounters();

		chart.firstRender();
	},

	/**
	 * Initialize an individual series, called internally before render time
	 */
	initSeries: function (options) {
		var chart = this,
			optionsChart = chart.options.chart,
			type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			series,
			constr = seriesTypes[type];

		// No such series type
		if (!constr) {
			error(17, true);
		}

		series = new constr();
		series.init(this, options);
		return series;
	},

	/**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
	addSeries: function (options, redraw, animation) {
		var series,
			chart = this;

		if (options) {
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = chart.initSeries(options);
				
				chart.isDirtyLegend = true; // the series array is out of sync with the display
				chart.linkSeries();
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}

		return series;
	},

	/**
     * Add an axis to the chart
     * @param {Object} options The axis option
     * @param {Boolean} isX Whether it is an X axis or a value axis
     */
	addAxis: function (options, isX, redraw, animation) {
		var key = isX ? 'xAxis' : 'yAxis',
			chartOptions = this.options,
			axis;

		/*jslint unused: false*/
		axis = new Axis(this, merge(options, {
			index: this[key].length,
			isX: isX
		}));
		/*jslint unused: true*/

		// Push the new axis options to the chart options
		chartOptions[key] = splat(chartOptions[key] || {});
		chartOptions[key].push(options);

		if (pick(redraw, true)) {
			this.redraw(animation);
		}
	},

	/**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} plotX Pixel x relative to the plot area
	 * @param {Number} plotY Pixel y relative to the plot area
	 * @param {Boolean} inverted Whether the chart is inverted
	 */
	isInsidePlot: function (plotX, plotY, inverted) {
		var x = inverted ? plotY : plotX,
			y = inverted ? plotX : plotY;
			
		return x >= 0 &&
			x <= this.plotWidth &&
			y >= 0 &&
			y <= this.plotHeight;
	},

	/**
	 * Adjust all axes tick amounts
	 */
	adjustTickAmounts: function () {
		if (this.options.chart.alignTicks !== false) {
			each(this.axes, function (axis) {
				axis.adjustTickAmount();
			});
		}
		this.maxTicks = null;
	},

	/**
	 * Redraw legend, axes or series based on updated data
	 *
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	redraw: function (animation) {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			pointer = chart.pointer,
			legend = chart.legend,
			redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			hasDirtyStacks,
			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
			seriesLength = series.length,
			i = seriesLength,
			serie,
			renderer = chart.renderer,
			isHiddenChart = renderer.isHidden(),
			afterRedraw = [];
			
		setAnimation(animation, chart);
		
		if (isHiddenChart) {
			chart.cloneRenderTo();
		}

		// Adjust title layout (reflow multiline text)
		chart.layOutTitles();

		// link stacked series
		while (i--) {
			serie = series[i];

			if (serie.options.stacking) {
				hasStackedSeries = true;
				
				if (serie.isDirty) {
					hasDirtyStacks = true;
					break;
				}
			}
		}
		if (hasDirtyStacks) { // mark others as dirty
			i = seriesLength;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) { // prepare the data so axis can read it
				if (serie.options.legendType === 'point') {
					redrawLegend = true;
				}
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
			// draw legend graphics
			legend.render();

			chart.isDirtyLegend = false;
		}

		// reset stacks
		if (hasStackedSeries) {
			chart.getStacks();
		}


		if (chart.hasCartesianSeries) {
			if (!chart.isResizing) {

				// reset maxTicks
				chart.maxTicks = null;

				// set axes scales
				each(axes, function (axis) {
					axis.setScale();
				});
			}

			chart.adjustTickAmounts();
			chart.getMargins();

			// If one axis is dirty, all axes must be redrawn (#792, #2169)
			each(axes, function (axis) {
				if (axis.isDirty) {
					isDirtyBox = true;
				}
			});

			// redraw axes
			each(axes, function (axis) {
				
				// Fire 'afterSetExtremes' only if extremes are set
				if (axis.isDirtyExtremes) { // #821
					axis.isDirtyExtremes = false;
					afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
						fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
						delete axis.eventArgs;
					});
				}
				
				if (isDirtyBox || hasStackedSeries) {
					axis.redraw();
				}
			});


		}
		// the plot areas size has changed
		if (isDirtyBox) {
			chart.drawChartBox();
		}


		// redraw affected series
		each(series, function (serie) {
			if (serie.isDirty && serie.visible &&
					(!serie.isCartesian || serie.xAxis)) { // issue #153
				serie.redraw();
			}
		});

		// move tooltip or reset
		if (pointer && pointer.reset) {
			pointer.reset(true);
		}

		// redraw if canvas
		renderer.draw();

		// fire the event
		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
		
		if (isHiddenChart) {
			chart.cloneRenderTo(true);
		}
		
		// Fire callbacks that are put on hold until after the redraw
		each(afterRedraw, function (callback) {
			callback.call();
		});
	},



	/**
	 * Dim the chart and show a loading text or symbol
	 * @param {String} str An optional text to show in the loading label instead of the default one
	 */
	showLoading: function (str) {
		var chart = this,
			options = chart.options,
			loadingDiv = chart.loadingDiv;

		var loadingOptions = options.loading;

		// create the layer at the first call
		if (!loadingDiv) {
			chart.loadingDiv = loadingDiv = createElement(DIV, {
				className: PREFIX + 'loading'
			}, extend(loadingOptions.style, {
				zIndex: 10,
				display: NONE
			}), chart.container);

			chart.loadingSpan = createElement(
				'span',
				null,
				loadingOptions.labelStyle,
				loadingDiv
			);

		}

		// update text
		chart.loadingSpan.innerHTML = str || options.lang.loading;

		// show it
		if (!chart.loadingShown) {
			css(loadingDiv, { 
				opacity: 0, 
				display: '',
				left: chart.plotLeft + PX,
				top: chart.plotTop + PX,
				width: chart.plotWidth + PX,
				height: chart.plotHeight + PX
			});
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity
			}, {
				duration: loadingOptions.showDuration || 0
			});
			chart.loadingShown = true;
		}
	},

	/**
	 * Hide the loading layer
	 */
	hideLoading: function () {
		var options = this.options,
			loadingDiv = this.loadingDiv;

		if (loadingDiv) {
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: NONE });
				}
			});
		}
		this.loadingShown = false;
	},

	/**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
	get: function (id) {
		var chart = this,
			axes = chart.axes,
			series = chart.series;

		var i,
			j,
			points;

		// search axes
		for (i = 0; i < axes.length; i++) {
			if (axes[i].options.id === id) {
				return axes[i];
			}
		}

		// search series
		for (i = 0; i < series.length; i++) {
			if (series[i].options.id === id) {
				return series[i];
			}
		}

		// search points
		for (i = 0; i < series.length; i++) {
			points = series[i].points || [];
			for (j = 0; j < points.length; j++) {
				if (points[j].id === id) {
					return points[j];
				}
			}
		}
		return null;
	},

	/**
	 * Create the Axis instances based on the config options
	 */
	getAxes: function () {
		var chart = this,
			options = this.options,
			xAxisOptions = options.xAxis = splat(options.xAxis || {}),
			yAxisOptions = options.yAxis = splat(options.yAxis || {}),
			optionsArray,
			axis;

		// make sure the options are arrays and add some members
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			axis = new Axis(chart, axisOptions);
		});

		chart.adjustTickAmounts();
	},


	/**
	 * Get the currently selected points from all series
	 */
	getSelectedPoints: function () {
		var points = [];
		each(this.series, function (serie) {
			points = points.concat(grep(serie.points || [], function (point) {
				return point.selected;
			}));
		});
		return points;
	},

	/**
	 * Get the currently selected series
	 */
	getSelectedSeries: function () {
		return grep(this.series, function (serie) {
			return serie.selected;
		});
	},

	/**
	 * Generate stacks for each series and calculate stacks total values
	 */
	getStacks: function () {
		var chart = this;

		// reset stacks for each yAxis
		each(chart.yAxis, function (axis) {
			if (axis.stacks && axis.hasVisibleSeries) {
				axis.oldStacks = axis.stacks;
			}
		});

		each(chart.series, function (series) {
			if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
				series.stackKey = series.type + pick(series.options.stack, '');
			}
		});
	},

	/**
	 * Display the zoom button
	 */
	showResetZoom: function () {
		var chart = this,
			lang = defaultOptions.lang,
			btnOptions = chart.options.chart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
			
		this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.add()
			.align(btnOptions.position, false, alignTo);
			
	},

	/**
	 * Zoom out to 1:1
	 */
	zoomOut: function () {
		var chart = this;
		fireEvent(chart, 'selection', { resetSelection: true }, function () { 
			chart.zoom();
		});
	},

	/**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
	zoom: function (event) {
		var chart = this,
			hasZoomed,
			pointer = chart.pointer,
			displayButton = false,
			resetZoomButton;

		// If zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(chart.axes, function (axis) {
				hasZoomed = axis.zoom();
			});
		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis,
					isXAxis = axis.isXAxis;

				// don't zoom more than minRange
				if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
					hasZoomed = axis.zoom(axisData.min, axisData.max);
					if (axis.displayBtn) {
						displayButton = true;
					}
				}
			});
		}
		
		// Show or hide the Reset zoom button
		resetZoomButton = chart.resetZoomButton;
		if (displayButton && !resetZoomButton) {
			chart.showResetZoom();
		} else if (!displayButton && isObject(resetZoomButton)) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}
		

		// Redraw
		if (hasZoomed) {
			chart.redraw(
				pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
			);
		}
	},

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is called
	 * on mouse move, and the distance to pan is computed from chartX compared to
	 * the first chartX position in the dragging operation.
	 */
	pan: function (e, panning) {

		var chart = this,
			hoverPoints = chart.hoverPoints,
			doRedraw;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
			var mousePos = e[isX ? 'chartX' : 'chartY'],
				axis = chart[isX ? 'xAxis' : 'yAxis'][0],
				startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
				halfPointRange = (axis.pointRange || 0) / 2,
				extremes = axis.getExtremes(),
				newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
				newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange;

			if (axis.series.length && newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {
				axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
				doRedraw = true;
			}

			chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
		});

		if (doRedraw) {
			chart.redraw(false);
		}
		css(chart.container, { cursor: 'move' });
	},

	/**
	 * Show the title and subtitle of the chart
	 *
	 * @param titleOptions {Object} New title options
	 * @param subtitleOptions {Object} New subtitle options
	 *
	 */
	setTitle: function (titleOptions, subtitleOptions) {
		var chart = this,
			options = chart.options,
			chartTitleOptions,
			chartSubtitleOptions;

		chartTitleOptions = options.title = merge(options.title, titleOptions);
		chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				chart[name] = title = title.destroy(); // remove old
			}
			
			if (chartTitleOptions && chartTitleOptions.text && !title) {
				chart[name] = chart.renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': PREFIX + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.css(chartTitleOptions.style)
				.add();
			}	
		});
		chart.layOutTitles();
	},

	/**
	 * Lay out the chart titles and cache the full offset height for use in getMargins
	 */
	layOutTitles: function () {
		var titleOffset = 0,
			title = this.title,
			subtitle = this.subtitle,
			options = this.options,
			titleOptions = options.title,
			subtitleOptions = options.subtitle,
			autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

		if (title) {
			title
				.css({ width: (titleOptions.width || autoWidth) + PX })
				.align(extend({ y: 15 }, titleOptions), false, 'spacingBox');
			
			if (!titleOptions.floating && !titleOptions.verticalAlign) {
				titleOffset = title.getBBox().height;

				// Adjust for browser consistency + backwards compat after #776 fix
				if (titleOffset >= 18 && titleOffset <= 25) {
					titleOffset = 15; 
				}
			}
		}
		if (subtitle) {
			subtitle
				.css({ width: (subtitleOptions.width || autoWidth) + PX })
				.align(extend({ y: titleOffset + titleOptions.margin }, subtitleOptions), false, 'spacingBox');
			
			if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
				titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
			}
		}

		this.titleOffset = titleOffset; // used in getMargins
	},

	/**
	 * Get chart width and height according to options and container size
	 */
	getChartSize: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderTo = chart.renderToClone || chart.renderTo;

		// get inner width and height from jQuery (#824)
		chart.containerWidth = adapterRun(renderTo, 'width');
		chart.containerHeight = adapterRun(renderTo, 'height');
		
		chart.chartWidth = mathMax(0, optionsChart.width || chart.containerWidth || 600); // #1393, 1460
		chart.chartHeight = mathMax(0, pick(optionsChart.height,
			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
			chart.containerHeight > 19 ? chart.containerHeight : 400));
	},

	/**
	 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
	 * size computation on chart.render and chart.redraw
	 */
	cloneRenderTo: function (revert) {
		var clone = this.renderToClone,
			container = this.container;
		
		// Destroy the clone and bring the container back to the real renderTo div
		if (revert) {
			if (clone) {
				this.renderTo.appendChild(container);
				discardElement(clone);
				delete this.renderToClone;
			}
		
		// Set up the clone
		} else {
			if (container && container.parentNode === this.renderTo) {
				this.renderTo.removeChild(container); // do not clone this
			}
			this.renderToClone = clone = this.renderTo.cloneNode(0);
			css(clone, {
				position: ABSOLUTE,
				top: '-9999px',
				display: 'block' // #833
			});
			doc.body.appendChild(clone);
			if (container) {
				clone.appendChild(container);
			}
		}
	},

	/**
	 * Get the containing element, determine the size and create the inner container
	 * div to hold the chart
	 */
	getContainer: function () {
		var chart = this,
			container,
			optionsChart = chart.options.chart,
			chartWidth,
			chartHeight,
			renderTo,
			indexAttrName = 'data-highcharts-chart',
			oldChartIndex,
			containerId;

		chart.renderTo = renderTo = optionsChart.renderTo;
		containerId = PREFIX + idCounter++;

		if (isString(renderTo)) {
			chart.renderTo = renderTo = doc.getElementById(renderTo);
		}
		
		// Display an error if the renderTo is wrong
		if (!renderTo) {
			error(13, true);
		}
		
		// If the container already holds a chart, destroy it
		oldChartIndex = pInt(attr(renderTo, indexAttrName));
		if (!isNaN(oldChartIndex) && charts[oldChartIndex]) {
			charts[oldChartIndex].destroy();
		}		
		
		// Make a reference to the chart from the div
		attr(renderTo, indexAttrName, chart.index);

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of a node
		// that has display:none. We need to temporarily move it out to a visible
		// state to determine the size, else the legend and tooltips won't render
		// properly
		if (!renderTo.offsetWidth) {
			chart.cloneRenderTo();
		}

		// get the width and height
		chart.getChartSize();
		chartWidth = chart.chartWidth;
		chartHeight = chart.chartHeight;

		// create the inner container
		chart.container = container = createElement(DIV, {
				className: PREFIX + 'container' +
					(optionsChart.className ? ' ' + optionsChart.className : ''),
				id: containerId
			}, extend({
				position: RELATIVE,
				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
					// content overflow in IE
				width: chartWidth + PX,
				height: chartHeight + PX,
				textAlign: 'left',
				lineHeight: 'normal', // #427
				zIndex: 0, // #1072
				'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
			}, optionsChart.style),
			chart.renderToClone || renderTo
		);

		// cache the cursor (#1650)
		chart._cursor = container.style.cursor;

		chart.renderer =
			optionsChart.forExport ? // force SVG, used for SVG export
				new SVGRenderer(container, chartWidth, chartHeight, true) :
				new Renderer(container, chartWidth, chartHeight);

		if (useCanVG) {
			// If we need canvg library, extend and configure the renderer
			// to get the tracker for translating mouse events
			chart.renderer.create(chart, container, chartWidth, chartHeight);
		}
	},

	/**
	 * Calculate margins by rendering axis labels in a preliminary position. Title,
	 * subtitle and legend have already been rendered at this stage, but will be
	 * moved into their final positions
	 */
	getMargins: function () {
		var chart = this,
			spacing = chart.spacing,
			axisOffset,
			legend = chart.legend,
			margin = chart.margin,
			legendOptions = chart.options.legend,
			legendMargin = pick(legendOptions.margin, 10),
			legendX = legendOptions.x,
			legendY = legendOptions.y,
			align = legendOptions.align,
			verticalAlign = legendOptions.verticalAlign,
			titleOffset = chart.titleOffset;

		chart.resetMargins();
		axisOffset = chart.axisOffset;

		// Adjust for title and subtitle
		if (titleOffset && !defined(margin[0])) {
			chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
		}
		
		// Adjust for legend
		if (legend.display && !legendOptions.floating) {
			if (align === 'right') { // horizontal alignment handled first
				if (!defined(margin[1])) {
					chart.marginRight = mathMax(
						chart.marginRight,
						legend.legendWidth - legendX + legendMargin + spacing[1]
					);
				}
			} else if (align === 'left') {
				if (!defined(margin[3])) {
					chart.plotLeft = mathMax(
						chart.plotLeft,
						legend.legendWidth + legendX + legendMargin + spacing[3]
					);
				}

			} else if (verticalAlign === 'top') {
				if (!defined(margin[0])) {
					chart.plotTop = mathMax(
						chart.plotTop,
						legend.legendHeight + legendY + legendMargin + spacing[0]
					);
				}

			} else if (verticalAlign === 'bottom') {
				if (!defined(margin[2])) {
					chart.marginBottom = mathMax(
						chart.marginBottom,
						legend.legendHeight - legendY + legendMargin + spacing[2]
					);
				}
			}
		}

		// adjust for scroller
		if (chart.extraBottomMargin) {
			chart.marginBottom += chart.extraBottomMargin;
		}
		if (chart.extraTopMargin) {
			chart.plotTop += chart.extraTopMargin;
		}

		// pre-render axes to get labels offset width
		if (chart.hasCartesianSeries) {
			each(chart.axes, function (axis) {
				axis.getOffset();
			});
		}
		
		if (!defined(margin[3])) {
			chart.plotLeft += axisOffset[3];
		}
		if (!defined(margin[0])) {
			chart.plotTop += axisOffset[0];
		}
		if (!defined(margin[2])) {
			chart.marginBottom += axisOffset[2];
		}
		if (!defined(margin[1])) {
			chart.marginRight += axisOffset[1];
		}

		chart.setChartSize();

	},

	/**
	 * Add the event handlers necessary for auto resizing
	 *
	 */
	initReflow: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderTo = chart.renderTo,
			reflowTimeout;
			
		function reflow(e) {
			var width = optionsChart.width || adapterRun(renderTo, 'width'),
				height = optionsChart.height || adapterRun(renderTo, 'height'),
				target = e ? e.target : win; // #805 - MooTools doesn't supply e
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (!chart.hasUserSize && width && height && (target === win || target === doc)) {
				
				if (width !== chart.containerWidth || height !== chart.containerHeight) {
					clearTimeout(reflowTimeout);
					chart.reflowTimeout = reflowTimeout = setTimeout(function () {
						if (chart.container) { // It may have been destroyed in the meantime (#1257)
							chart.setSize(width, height, false);
							chart.hasUserSize = null;
						}
					}, 100);
				}
				chart.containerWidth = width;
				chart.containerHeight = height;
			}
		}
		chart.reflow = reflow;
		addEvent(win, 'resize', reflow);
		addEvent(chart, 'destroy', function () {
			removeEvent(win, 'resize', reflow);
		});
	},

	/**
	 * Resize the chart to a given width and height
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Object|Boolean} animation
	 */
	setSize: function (width, height, animation) {
		var chart = this,
			chartWidth,
			chartHeight,
			fireEndResize;

		// Handle the isResizing counter
		chart.isResizing += 1;
		fireEndResize = function () {
			if (chart) {
				fireEvent(chart, 'endResize', null, function () {
					chart.isResizing -= 1;
				});
			}
		};

		// set the animation for the current process
		setAnimation(animation, chart);

		chart.oldChartHeight = chart.chartHeight;
		chart.oldChartWidth = chart.chartWidth;
		if (defined(width)) {
			chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
			chart.hasUserSize = !!chartWidth;
		}
		if (defined(height)) {
			chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
		}

		css(chart.container, {
			width: chartWidth + PX,
			height: chartHeight + PX
		});
		chart.setChartSize(true);
		chart.renderer.setSize(chartWidth, chartHeight, animation);

		// handle axes
		chart.maxTicks = null;
		each(chart.axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		// make sure non-cartesian series are also handled
		each(chart.series, function (serie) {
			serie.isDirty = true;
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		chart.getMargins();

		chart.redraw(animation);


		chart.oldChartHeight = null;
		fireEvent(chart, 'resize');

		// fire endResize and set isResizing back
		// If animation is disabled, fire without delay
		if (globalAnimation === false) {
			fireEndResize();
		} else { // else set a timeout with the animation duration
			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
		}
	},

	/**
	 * Set the public chart properties. This is done before and after the pre-render
	 * to determine margin sizes
	 */
	setChartSize: function (skipAxes) {
		var chart = this,
			inverted = chart.inverted,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			optionsChart = chart.options.chart,
			spacing = chart.spacing,
			clipOffset = chart.clipOffset,
			clipX,
			clipY,
			plotLeft,
			plotTop,
			plotWidth,
			plotHeight,
			plotBorderWidth;

		chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
		chart.plotTop = plotTop = mathRound(chart.plotTop);
		chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
		chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;
		
		chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

		// Set boxes used for alignment
		chart.spacingBox = renderer.spacingBox = {
			x: spacing[3],
			y: spacing[0],
			width: chartWidth - spacing[3] - spacing[1],
			height: chartHeight - spacing[0] - spacing[2]
		};
		chart.plotBox = renderer.plotBox = {
			x: plotLeft,
			y: plotTop,
			width: plotWidth,
			height: plotHeight
		};

		plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
		clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
		clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
		chart.clipBox = {
			x: clipX, 
			y: clipY, 
			width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
			height: mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY)
		};

		if (!skipAxes) {
			each(chart.axes, function (axis) {
				axis.setAxisSize();
				axis.setAxisTranslation();
			});
		}
	},

	/**
	 * Initial margins before auto size margins are applied
	 */
	resetMargins: function () {
		var chart = this,
			spacing = chart.spacing,
			margin = chart.margin;

		chart.plotTop = pick(margin[0], spacing[0]);
		chart.marginRight = pick(margin[1], spacing[1]);
		chart.marginBottom = pick(margin[2], spacing[2]);
		chart.plotLeft = pick(margin[3], spacing[3]);
		chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
		chart.clipOffset = [0, 0, 0, 0];
	},

	/**
	 * Draw the borders and backgrounds for chart and plot area
	 */
	drawChartBox: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			chartBackground = chart.chartBackground,
			plotBackground = chart.plotBackground,
			plotBorder = chart.plotBorder,
			plotBGImage = chart.plotBGImage,
			chartBorderWidth = optionsChart.borderWidth || 0,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			plotBorderWidth = optionsChart.plotBorderWidth || 0,
			mgn,
			bgAttr,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			plotBox = chart.plotBox,
			clipRect = chart.clipRect,
			clipBox = chart.clipBox;

		// Chart area
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		if (chartBorderWidth || chartBackgroundColor) {
			if (!chartBackground) {
				
				bgAttr = {
					fill: chartBackgroundColor || NONE
				};
				if (chartBorderWidth) { // #980
					bgAttr.stroke = optionsChart.borderColor;
					bgAttr['stroke-width'] = chartBorderWidth;
				}
				chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
						optionsChart.borderRadius, chartBorderWidth)
					.attr(bgAttr)
					.add()
					.shadow(optionsChart.shadow);

			} else { // resize
				chartBackground.animate(
					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
				);
			}
		}


		// Plot background
		if (plotBackgroundColor) {
			if (!plotBackground) {
				chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
					.attr({
						fill: plotBackgroundColor
					})
					.add()
					.shadow(optionsChart.plotShadow);
			} else {
				plotBackground.animate(plotBox);
			}
		}
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
					.add();
			} else {
				plotBGImage.animate(plotBox);
			}
		}
		
		// Plot clip
		if (!clipRect) {
			chart.clipRect = renderer.clipRect(clipBox);
		} else {
			clipRect.animate({
				width: clipBox.width,
				height: clipBox.height
			});
		}

		// Plot area border
		if (plotBorderWidth) {
			if (!plotBorder) {
				chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
					.attr({
						stroke: optionsChart.plotBorderColor,
						'stroke-width': plotBorderWidth,
						zIndex: 1
					})
					.add();
			} else {
				plotBorder.animate(
					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
				);
			}
		}

		// reset
		chart.isDirtyBox = false;
	},

	/**
	 * Detect whether a certain chart property is needed based on inspecting its options
	 * and series. This mainly applies to the chart.invert property, and in extensions to 
	 * the chart.angular and chart.polar properties.
	 */
	propFromSeries: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			klass,
			seriesOptions = chart.options.series,
			i,
			value;
			
			
		each(['inverted', 'angular', 'polar'], function (key) {
			
			// The default series type's class
			klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
			
			// Get the value from available chart-wide properties
			value = (
				chart[key] || // 1. it is set before
				optionsChart[key] || // 2. it is set in the options
				(klass && klass.prototype[key]) // 3. it's default series class requires it
			);
	
			// 4. Check if any the chart's series require it
			i = seriesOptions && seriesOptions.length;
			while (!value && i--) {
				klass = seriesTypes[seriesOptions[i].type];
				if (klass && klass.prototype[key]) {
					value = true;
				}
			}
	
			// Set the chart property
			chart[key] = value;	
		});
		
	},

	/**
	 * Link two or more series together. This is done initially from Chart.render,
	 * and after Chart.addSeries and Series.remove.
	 */
	linkSeries: function () {
		var chart = this,
			chartSeries = chart.series;

		// Reset links
		each(chartSeries, function (series) {
			series.linkedSeries.length = 0;
		});

		// Apply new links
		each(chartSeries, function (series) {
			var linkedTo = series.options.linkedTo;
			if (isString(linkedTo)) {
				if (linkedTo === ':previous') {
					linkedTo = chart.series[series.index - 1];
				} else {
					linkedTo = chart.get(linkedTo);
				}
				if (linkedTo) {
					linkedTo.linkedSeries.push(series);
					series.linkedParent = linkedTo;
				}
			}
		});
	},

	/**
	 * Render all graphics for the chart
	 */
	render: function () {
		var chart = this,
			axes = chart.axes,
			renderer = chart.renderer,
			options = chart.options;

		var labels = options.labels,
			credits = options.credits,
			creditsHref;

		// Title
		chart.setTitle();


		// Legend
		chart.legend = new Legend(chart, options.legend);

		chart.getStacks(); // render stacks

		// Get margins by pre-rendering axes
		// set axes scales
		each(axes, function (axis) {
			axis.setScale();
		});

		chart.getMargins();

		chart.maxTicks = null; // reset for second pass
		each(axes, function (axis) {
			axis.setTickPositions(true); // update to reflect the new margins
			axis.setMaxTicks();
		});
		chart.adjustTickAmounts();
		chart.getMargins(); // second pass to check for new labels


		// Draw the borders and backgrounds
		chart.drawChartBox();		


		// Axes
		if (chart.hasCartesianSeries) {
			each(axes, function (axis) {
				axis.render();
			});
		}

		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		each(chart.series, function (serie) {
			serie.translate();
			serie.setTooltipPoints();
			serie.render();
		});

		// Labels
		if (labels.items) {
			each(labels.items, function (label) {
				var style = extend(labels.style, label.style),
					x = pInt(style.left) + chart.plotLeft,
					y = pInt(style.top) + chart.plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				renderer.text(
					label.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}

		// Credits
		if (credits.enabled && !chart.credits) {
			creditsHref = credits.href;
			chart.credits = renderer.text(
				credits.text,
				0,
				0
			)
			.on('click', function () {
				if (creditsHref) {
					location.href = creditsHref;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			.css(credits.style)
			.add()
			.align(credits.position);
		}

		// Set flag
		chart.hasRendered = true;

	},

	/**
	 * Clean up memory usage
	 */
	destroy: function () {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			container = chart.container,
			i,
			parentNode = container && container.parentNode;
			
		// fire the chart.destoy event
		fireEvent(chart, 'destroy');
		
		// Delete the chart from charts lookup array
		charts[chart.index] = UNDEFINED;
		chart.renderTo.removeAttribute('data-highcharts-chart');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
				'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
				'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
			var prop = chart[name];

			if (prop && prop.destroy) {
				chart[name] = prop.destroy();
			}
		});

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

		}

		// clean it all up
		for (i in chart) {
			delete chart[i];
		}

	},


	/**
	 * VML namespaces can't be added until after complete. Listening
	 * for Perini's doScroll hack is not enough.
	 */
	isReadyToRender: function () {
		var chart = this;

		// Note: in spite of JSLint's complaints, win == win.top is required
		/*jslint eqeq: true*/
		if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
		/*jslint eqeq: false*/
			if (useCanVG) {
				// Delay rendering until canvg library is downloaded and ready
				CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
			} else {
				doc.attachEvent('onreadystatechange', function () {
					doc.detachEvent('onreadystatechange', chart.firstRender);
					if (doc.readyState === 'complete') {
						chart.firstRender();
					}
				});
			}
			return false;
		}
		return true;
	},

	/**
	 * Prepare for first rendering after all data are loaded
	 */
	firstRender: function () {
		var chart = this,
			options = chart.options,
			callback = chart.callback;

		// Check whether the chart is ready to render
		if (!chart.isReadyToRender()) {
			return;
		}

		// Create the container
		chart.getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');

		
		chart.resetMargins();
		chart.setChartSize();

		// Set the common chart properties (mainly invert) from the given series
		chart.propFromSeries();

		// get axes
		chart.getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			chart.initSeries(serieOptions);
		});

		chart.linkSeries();

		// Run an event after axes and series are initialized, but before render. At this stage,
		// the series data is indexed and cached in the xData and yData arrays, so we can access
		// those before rendering. Used in Highstock. 
		fireEvent(chart, 'beforeRender'); 

		// depends on inverted and on margins being set
		chart.pointer = new Pointer(chart, options);

		chart.render();

		// add canvas
		chart.renderer.draw();
		// run callbacks
		if (callback) {
			callback.apply(chart, [chart]);
		}
		each(chart.callbacks, function (fn) {
			fn.apply(chart, [chart]);
		});
		
		
		// If the chart was rendered outside the top container, put it back in
		chart.cloneRenderTo(true);

		fireEvent(chart, 'load');

	},

	/**
	* Creates arrays for spacing and margin from given options.
	*/
	splashArray: function (target, options) {
		var oVar = options[target],
			tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

		return [pick(options[target + 'Top'], tArray[0]),
				pick(options[target + 'Right'], tArray[1]),
				pick(options[target + 'Bottom'], tArray[2]),
				pick(options[target + 'Left'], tArray[3])];
	}
}; // end Chart

// Hook for exporting module
Chart.prototype.callbacks = [];
/**
 * The Point object and prototype. Inheritable and used as base for PiePoint
 */
var Point = function () {};
Point.prototype = {

	/**
	 * Initialize the point
	 * @param {Object} series The series object containing this point
	 * @param {Object} options The data in either number, array or object format
	 */
	init: function (series, options, x) {

		var point = this,
			colors;
		point.series = series;
		point.applyOptions(options, x);
		point.pointAttr = {};

		if (series.options.colorByPoint) {
			colors = series.options.colors || series.chart.options.colors;
			point.color = point.color || colors[series.colorCounter++];
			// loop back to zero
			if (series.colorCounter === colors.length) {
				series.colorCounter = 0;
			}
		}

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra properties.
	 * This is called on point init or from point.update.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			pointValKey = series.pointValKey;

		options = Point.prototype.optionsToObject.call(this, options);

		// copy options directly to point
		extend(point, options);
		point.options = point.options ? extend(point.options, options) : options;
			
		// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
		if (pointValKey) {
			point.y = point[pointValKey];
		}
		
		// If no x is set by now, get auto incremented value. All points must have an
		// x value, however the y value can be null to create a gap in the series
		if (point.x === UNDEFINED && series) {
			point.x = x === UNDEFINED ? series.autoIncrement() : x;
		}
		
		return point;
	},

	/**
	 * Transform number or array configs into objects
	 */
	optionsToObject: function (options) {
		var ret,
			series = this.series,
			pointArrayMap = series.pointArrayMap || ['y'],
			valueCount = pointArrayMap.length,
			firstItemType,
			i = 0,
			j = 0;

		if (typeof options === 'number' || options === null) {
			ret = { y: options };

		} else if (isArray(options)) {
			ret = {};
			// with leading x value
			if (options.length > valueCount) {
				firstItemType = typeof options[0];
				if (firstItemType === 'string') {
					ret.name = options[0];
				} else if (firstItemType === 'number') {
					ret.x = options[0];
				}
				i++;
			}
			while (j < valueCount) {
				ret[pointArrayMap[j++]] = options[i++];
			}			
		} else if (typeof options === 'object') {
			ret = options;

			// This is the fastest way to detect if there are individual point dataLabels that need 
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}

			// Same approach as above for markers
			if (options.marker) {
				series._hasPointMarkers = true;
			}
		}
		return ret;
	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in series.data.
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			hoverPoints = chart.hoverPoints,
			prop;

		chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
			if (!hoverPoints.length) {
				chart.hoverPoints = null;
			}

		}
		if (point === chart.hoverPoint) {
			point.onMouseOut();
		}
		
		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip formatters
	 */
	getLabelConfig: function () {
		var point = this;
		return {
			x: point.category,
			y: point.y,
			key: point.name || point.category,
			series: point.series,
			point: point,
			percentage: point.percentage,
			total: point.total || point.stackTotal
		};
	},

	/**
	 * Toggle the selection status of a point
	 * @param {Boolean} selected Whether to select or unselect the point.
	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the defalut handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			point.selected = point.options.selected = selected;
			series.options.data[inArray(point, series.data)] = point.options;
			
			point.setState(selected && SELECT_STATE);

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = loopPoint.options.selected = false;
						series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
						loopPoint.setState(NORMAL_STATE);
						loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	/**
	 * Runs on mouse over the point
	 */
	onMouseOver: function (e) {
		var point = this,
			series = point.series,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// set normal state to previous series
		if (hoverPoint && hoverPoint !== point) {
			hoverPoint.onMouseOut();
		}

		// trigger the event
		point.firePointEvent('mouseOver');

		// update the tooltip
		if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.refresh(point, e);
		}

		// hover this
		point.setState(HOVER_STATE);
		chart.hoverPoint = point;
	},
	
	/**
	 * Runs on mouse out from the point
	 */
	onMouseOut: function () {
		var chart = this.series.chart,
			hoverPoints = chart.hoverPoints;
		
		if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887
			this.firePointEvent('mouseOut');
	
			this.setState();
			chart.hoverPoint = null;
		}
	},

	/**
	 * Extendable method for formatting each point's tooltip line
	 *
	 * @return {String} A string to be concatenated in to the common tooltip text
	 */
	tooltipFormatter: function (pointFormat) {
		
		// Insert options for valueDecimals, valuePrefix, and valueSuffix
		var series = this.series,
			seriesTooltipOptions = series.tooltipOptions,
			valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
			valuePrefix = seriesTooltipOptions.valuePrefix || '',
			valueSuffix = seriesTooltipOptions.valueSuffix || '';
			
		// Loop over the point array map and replace unformatted values with sprintf formatting markup
		each(series.pointArrayMap || ['y'], function (key) {
			key = '{point.' + key; // without the closing bracket
			if (valuePrefix || valueSuffix) {
				pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
			}
			pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
		});
		
		return format(pointFormat, {
			point: this,
			series: this.series
		});
	},

	/**
	 * Update the point with new options (typically x/y data) and optionally redraw the series.
	 *
	 * @param {Object} options Point options as defined in the series.data array
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 */
	update: function (options, redraw, animation) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			data = series.data,
			chart = series.chart,
			seriesOptions = series.options;

		redraw = pick(redraw, true);

		// fire the event with a default handler of doing the update
		point.firePointEvent('update', { options: options }, function () {

			point.applyOptions(options);

			// update visuals
			if (isObject(options)) {
				series.getAttribs();
				if (graphic) {
					if (options.marker && options.marker.symbol) {
						point.graphic = graphic.destroy();
					} else {
						graphic.attr(point.pointAttr[point.state || '']);
					}
				}
			}

			// record changes in the parallel arrays
			i = inArray(point, data);
			series.xData[i] = point.x;
			series.yData[i] = series.toYData ? series.toYData(point) : point.y;
			series.zData[i] = point.z;
			seriesOptions.data[i] = point.options;

			// redraw
			series.isDirty = series.isDirtyData = true;
			if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
				chart.isDirtyBox = true;
			}
			
			if (seriesOptions.legendType === 'point') { // #1831, #1885
				chart.legend.destroyItem(point);
			}
			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	remove: function (redraw, animation) {
		var point = this,
			series = point.series,
			points = series.points,
			chart = series.chart,
			i,
			data = series.data;

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// fire the event with a default handler of removing the point
		point.firePointEvent('remove', null, function () {

			// splice all the parallel arrays
			i = inArray(point, data);
			if (data.length === points.length) {
				points.splice(i, 1);			
			}
			data.splice(i, 1);
			series.options.data.splice(i, 1);
			series.xData.splice(i, 1);
			series.yData.splice(i, 1);
			series.zData.splice(i, 1);

			point.destroy();


			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				chart.redraw();
			}
		});


	},

	/**
	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
	 * causes a name clash in MooTools
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	},
	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events,
				eventType;

			point.events = events;

			for (eventType in events) {
				addEvent(point, eventType, events[eventType]);
			}
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state
	 * @param {String} state
	 */
	setState: function (state) {
		var point = this,
			plotX = point.plotX,
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states,
			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
			normalDisabled = markerOptions && !markerOptions.enabled,
			markerStateOptions = markerOptions && markerOptions.states[state],
			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			pointMarker = point.marker || {},
			chart = series.chart,
			radius,
			newSymbol,
			pointAttr = point.pointAttr;

		state = state || NORMAL_STATE; // empty string

		if (
				// already has this state
				state === point.state ||
				// selected points don't respond to hover
				(point.selected && state !== SELECT_STATE) ||
				// series' state options is disabled
				(stateOptions[state] && stateOptions[state].enabled === false) ||
				// point marker's state options is disabled
				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))

			) {
			return;
		}

		// apply hover styles to the existing point
		if (point.graphic) {
			radius = markerOptions && point.graphic.symbolName && pointAttr[state].r;
			point.graphic.attr(merge(
				pointAttr[state],
				radius ? { // new symbol attributes (#507, #612)
					x: plotX - radius,
					y: plotY - radius,
					width: 2 * radius,
					height: 2 * radius
				} : {}
			));
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state && markerStateOptions) {
				radius = markerStateOptions.radius;
				newSymbol = pointMarker.symbol || series.symbol;

				// If the point has another symbol than the previous one, throw away the 
				// state marker graphic and force a new one (#1459)
				if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {				
					stateMarkerGraphic = stateMarkerGraphic.destroy();
				}

				// Add a new state marker graphic
				if (!stateMarkerGraphic) {
					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
						newSymbol,
						plotX - radius,
						plotY - radius,
						2 * radius,
						2 * radius
					)
					.attr(pointAttr[state])
					.add(series.markerGroup);
					stateMarkerGraphic.currentSymbol = newSymbol;
				
				// Move the existing graphic
				} else {
					stateMarkerGraphic.attr({ // #1054
						x: plotX - radius,
						y: plotY - radius
					});
				}
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY) ? 'show' : 'hide']();
			}
		}

		point.state = state;
	}
};

/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
var Series = function () {};

Series.prototype = {

	isCartesian: true,
	type: 'line',
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	requireSorting: true,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'lineColor',
		'stroke-width': 'lineWidth',
		fill: 'fillColor',
		r: 'radius'
	},
	colorCounter: 0,
	init: function (chart, options) {
		var series = this,
			eventType,
			events,
			chartSeries = chart.series;

		series.chart = chart;
		series.options = options = series.setOptions(options); // merge with plotOptions
		series.linkedSeries = [];

		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			name: options.name,
			state: NORMAL_STATE,
			pointAttr: {},
			visible: options.visible !== false, // true by default
			selected: options.selected === true // false by default
		});
		
		// special
		if (useCanVG) {
			options.animation = false;
		}

		// register event listeners
		events = options.events;
		for (eventType in events) {
			addEvent(series, eventType, events[eventType]);
		}
		if (
			(events && events.click) ||
			(options.point && options.point.events && options.point.events.click) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// set the data
		series.setData(options.data, false);
		
		// Mark cartesian
		if (series.isCartesian) {
			chart.hasCartesianSeries = true;
		}

		// Register it in the chart
		chartSeries.push(series);
		series._i = chartSeries.length - 1;
		
		// Sort series according to index option (#248, #1123)
		stableSort(chartSeries, function (a, b) {
			return pick(a.options.index, a._i) - pick(b.options.index, a._i);
		});
		each(chartSeries, function (series, i) {
			series.index = i;
			series.name = series.name || 'Series ' + (i + 1);
		});

	},
	
	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the series
	 * in the axis.series array
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;
			
		if (series.isCartesian) {
			
			each(['xAxis', 'yAxis'], function (AXIS) { // repeat for xAxis and yAxis
				
				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					
					axisOptions = axis.options;
					
					// apply if the series xAxis or yAxis option mathches the number of the 
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {
						
						// register this series in the axis.series lookup
						axis.series.push(series);
						
						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;
						
						// mark dirty for redraw
						axis.isDirty = true;
					}
				});

				// The series needs an X and an Y axis
				if (!series[AXIS]) {
					error(18, true);
				}

			});
		}
	},


	/**
	 * Return an auto incremented x value based on the pointStart and pointInterval options.
	 * This is only used if an x value is not given for the point that calls autoIncrement.
	 */
	autoIncrement: function () {
		var series = this,
			options = series.options,
			xIncrement = series.xIncrement;

		xIncrement = pick(xIncrement, options.pointStart, 0);

		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

		series.xIncrement = xIncrement + series.pointInterval;
		return xIncrement;
	},

	/**
	 * Divide the series data into segments divided by null values.
	 */
	getSegments: function () {
		var series = this,
			lastNull = -1,
			segments = [],
			i,
			points = series.points,
			pointsLength = points.length;

		if (pointsLength) { // no action required for []
			
			// if connect nulls, just remove null points
			if (series.options.connectNulls) {
				i = pointsLength;
				while (i--) {
					if (points[i].y === null) {
						points.splice(i, 1);
					}
				}
				if (points.length) {
					segments = [points];
				}
				
			// else, split on null points
			} else {
				each(points, function (point, i) {
					if (point.y === null) {
						if (i > lastNull + 1) {
							segments.push(points.slice(lastNull + 1, i));
						}
						lastNull = i;
					} else if (i === pointsLength - 1) { // last value
						segments.push(points.slice(lastNull + 1, i + 1));
					}
				});
			}
		}
		
		// register it
		series.segments = segments;
	},
	
	/**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
	setOptions: function (itemOptions) {
		var chart = this.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			typeOptions = plotOptions[this.type],
			options;

		this.userOptions = itemOptions;

		options = merge(
			typeOptions,
			plotOptions.series,
			itemOptions
		);
		
		// the tooltip options are merged between global and series specific options
		this.tooltipOptions = merge(chartOptions.tooltip, options.tooltip);
		
		// Delte marker object if not allowed (#1125)
		if (typeOptions.marker === null) {
			delete options.marker;
		}
		
		return options;

	},
	/**
	 * Get the series' color
	 */
	getColor: function () {
		var options = this.options,
			userOptions = this.userOptions,
			defaultColors = this.chart.options.colors,
			counters = this.chart.counters,
			color,
			colorIndex;

		color = options.color || defaultPlotOptions[this.type].color;

		if (!color && !options.colorByPoint) {
			if (defined(userOptions._colorIndex)) { // after Series.update()
				colorIndex = userOptions._colorIndex;
			} else {
				userOptions._colorIndex = counters.color;
				colorIndex = counters.color++;
			}
			color = defaultColors[colorIndex];
		}
		
		this.color = color;
		counters.wrapColor(defaultColors.length);
	},
	/**
	 * Get the series' symbol
	 */
	getSymbol: function () {
		var series = this,
			userOptions = series.userOptions,
			seriesMarkerOption = series.options.marker,
			chart = series.chart,
			defaultSymbols = chart.options.symbols,
			counters = chart.counters,
			symbolIndex;

		series.symbol = seriesMarkerOption.symbol;
		if (!series.symbol) {
			if (defined(userOptions._symbolIndex)) { // after Series.update()
				symbolIndex = userOptions._symbolIndex;
			} else {
				userOptions._symbolIndex = counters.symbol;
				symbolIndex = counters.symbol++;
			}
			series.symbol = defaultSymbols[symbolIndex];
		}

		// don't substract radius in image symbols (#604)
		if (/^url/.test(series.symbol)) {
			seriesMarkerOption.radius = 0;
		}
		counters.wrapSymbol(defaultSymbols.length);
	},

	/**
	 * Get the series' symbol in the legend. This method should be overridable to create custom 
	 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	 * 
	 * @param {Object} legend The legend object
	 */
	drawLegendSymbol: function (legend) {
		
		var options = this.options,
			markerOptions = options.marker,
			radius,
			legendOptions = legend.options,
			legendSymbol,
			symbolWidth = legendOptions.symbolWidth,
			renderer = this.chart.renderer,
			legendItemGroup = this.legendGroup,
			verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize).b * 0.3),
			attr;
			
		// Draw the line
		if (options.lineWidth) {
			attr = {
				'stroke-width': options.lineWidth
			};
			if (options.dashStyle) {
				attr.dashstyle = options.dashStyle;
			}
			this.legendLine = renderer.path([
				M,
				0,
				verticalCenter,
				L,
				symbolWidth,
				verticalCenter
			])
			.attr(attr)
			.add(legendItemGroup);
		}
		
		// Draw the marker
		if (markerOptions && markerOptions.enabled) {
			radius = markerOptions.radius;
			this.legendSymbol = legendSymbol = renderer.symbol(
				this.symbol,
				(symbolWidth / 2) - radius,
				verticalCenter - radius,
				2 * radius,
				2 * radius
			)
			.add(legendItemGroup);
			legendSymbol.isMarker = true;
		}
	},

	/**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			seriesOptions = series.options,
			data = series.data,
			graph = series.graph,
			area = series.area,
			chart = series.chart,
			xData = series.xData,
			yData = series.yData,
			zData = series.zData,
			names = series.names,
			currentShift = (graph && graph.shift) || 0,
			dataOptions = seriesOptions.data,
			point,
			isInTheMiddle,
			x,
			i;

		setAnimation(animation, chart);

		// Make graph animate sideways
		if (shift) {
			each([graph, area, series.graphNeg, series.areaNeg], function (shape) {
				if (shape) {
					shape.shift = currentShift + 1;
				}
			});
		}
		if (area) {
			area.isArea = true; // needed in animation, both with and without shift
		}
		
		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		x = point.x;

		// Get the insertion point
		i = xData.length;
		if (series.requireSorting && x < xData[i - 1]) {
			isInTheMiddle = true;
			while (i && xData[i - 1] > x) {
				i--;
			}
		}
		
		xData.splice(i, 0, x);
		yData.splice(i, 0, series.toYData ? series.toYData(point) : point.y);
		zData.splice(i, 0, point.z);
		if (names) {
			names[x] = point.name;
		}
		dataOptions.splice(i, 0, options);

		if (isInTheMiddle) {
			series.data.splice(i, 0, null);
			series.processData();
		}
		
		// Generate points to be added to the legend (#1329) 
		if (seriesOptions.legendType === 'point') {
			series.generatePoints();
		}

		// Shift the first point off the parallel arrays
		// todo: consider series.removePoint(i) method
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				xData.shift();
				yData.shift();
				zData.shift();
				dataOptions.shift();
			}
		}

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;
		if (redraw) {
			series.getAttribs(); // #1937
			chart.redraw();
		}
	},

	/**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
	setData: function (data, redraw) {
		var series = this,
			oldData = series.points,
			options = series.options,
			chart = series.chart,
			firstPoint = null,
			xAxis = series.xAxis,
			names = xAxis && xAxis.categories && !xAxis.categories.length ? [] : null,
			i;

		// reset properties
		series.xIncrement = null;
		series.pointRange = xAxis && xAxis.categories ? 1 : options.pointRange;

		series.colorCounter = 0; // for series with colorByPoint (#1547)
		
		// parallel arrays
		var xData = [],
			yData = [],
			zData = [],
			dataLength = data ? data.length : [],
			turboThreshold = pick(options.turboThreshold, 1000),
			pt,
			pointArrayMap = series.pointArrayMap,
			valueCount = pointArrayMap && pointArrayMap.length,
			hasToYData = !!series.toYData;

		// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
		// first value is tested, and we assume that all the rest are defined the same
		// way. Although the 'for' loops are similar, they are repeated inside each
		// if-else conditional for max performance.
		if (turboThreshold && dataLength > turboThreshold) { 
			
			// find the first non-null point
			i = 0;
			while (firstPoint === null && i < dataLength) {
				firstPoint = data[i];
				i++;
			}
		
		
			if (isNumber(firstPoint)) { // assume all points are numbers
				var x = pick(options.pointStart, 0),
					pointInterval = pick(options.pointInterval, 1);

				for (i = 0; i < dataLength; i++) {
					xData[i] = x;
					yData[i] = data[i];
					x += pointInterval;
				}
				series.xIncrement = x;
			} else if (isArray(firstPoint)) { // assume all points are arrays
				if (valueCount) { // [x, low, high] or [x, o, h, l, c]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt.slice(1, valueCount + 1);
					}
				} else { // [x, y]
					for (i = 0; i < dataLength; i++) {
						pt = data[i];
						xData[i] = pt[0];
						yData[i] = pt[1];
					}
				}
			} else {
				error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
			}
		} else {
			for (i = 0; i < dataLength; i++) {
				if (data[i] !== UNDEFINED) { // stray commas in oldIE
					pt = { series: series };
					series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
					xData[i] = pt.x;
					yData[i] = hasToYData ? series.toYData(pt) : pt.y;
					zData[i] = pt.z;
					if (names && pt.name) {
						names[pt.x] = pt.name; // #2046
					}
				}
			}
		}
		
		// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON		
		if (isString(yData[0])) {
			error(14, true);
		} 

		series.data = [];
		series.options.data = data;
		series.xData = xData;
		series.yData = yData;
		series.zData = zData;
		series.names = names;

		// destroy old points
		i = (oldData && oldData.length) || 0;
		while (i--) {
			if (oldData[i] && oldData[i].destroy) {
				oldData[i].destroy();
			}
		}

		// reset minRange (#878)
		if (xAxis) {
			xAxis.minRange = xAxis.userMinRange;
		}

		// redraw
		series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	},

	/**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

	remove: function (redraw, animation) {
		var series = this,
			chart = series.chart;
		redraw = pick(redraw, true);

		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
			series.isRemoving = true;

			// fire the event with a default handler of removing the point
			fireEvent(series, 'remove', null, function () {


				// destroy elements
				series.destroy();


				// redraw
				chart.isDirtyLegend = chart.isDirtyBox = true;
				chart.linkSeries();
				
				if (redraw) {
					chart.redraw(animation);
				}
			});

		}
		series.isRemoving = false;
	},

	/**
	 * Process the data by cropping away unused data points if the series is longer
	 * than the crop threshold. This saves computing time for lage series.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation below
			processedYData = series.yData,
			dataLength = processedXData.length,
			croppedData,
			cropStart = 0,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			isCartesian = series.isCartesian;

		// If the series data or axes haven't changed, don't go through this. Return false to pass
		// the message on to override methods like in data grouping. 
		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
			return false;
		}
		

		// optionally filter out points outside the plot area
		if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
			var min = xAxis.min,
				max = xAxis.max;

			// it's outside current extremes
			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
				processedXData = [];
				processedYData = [];
			
			// only crop if it's actually spilling out
			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
				croppedData = this.cropData(series.xData, series.yData, min, max);
				processedXData = croppedData.xData;
				processedYData = croppedData.yData;
				cropStart = croppedData.start;
				cropped = true;
			}
		}
		
		
		// Find the closest distance between processed points
		for (i = processedXData.length - 1; i >= 0; i--) {
			distance = processedXData[i] - processedXData[i - 1];
			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
				closestPointRange = distance;

			// Unsorted data is not supported by the line tooltip, as well as data grouping and 
			// navigation in Stock charts (#725) and width calculation of columns (#1900)
			} else if (distance < 0 && series.requireSorting) {
				error(15);
			}
		}

		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;

		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = closestPointRange || 1;
		}
		series.closestPointRange = closestPointRange;
		
	},

	/**
	 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
	 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
	 */
	cropData: function (xData, yData, min, max) {
		var dataLength = xData.length,
			cropStart = 0,
			cropEnd = dataLength,
			cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
			i;

		// iterate up to find slice start
		for (i = 0; i < dataLength; i++) {
			if (xData[i] >= min) {
				cropStart = mathMax(0, i - cropShoulder);
				break;
			}
		}

		// proceed to find slice end
		for (; i < dataLength; i++) {
			if (xData[i] > max) {
				cropEnd = i + cropShoulder;
				break;
			}
		}

		return {
			xData: xData.slice(cropStart, cropEnd),
			yData: yData.slice(cropStart, cropEnd),
			start: cropStart,
			end: cropEnd
		};
	},


	/**
	 * Generate the data point after the data has been processed by cropping away
	 * unused points and optionally grouped in Highcharts Stock.
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			pointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				if (data[cursor]) {
					point = data[cursor];
				} else if (dataOptions[cursor] !== UNDEFINED) { // #970
					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
				}
				points[i] = point;
			} else {
				// splat the y data in case of ohlc data array
				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
			}
		}

		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
		// swithching view from non-grouped data to grouped data (#637)	
		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
			for (i = 0; i < dataLength; i++) {
				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
					data[i].plotX = UNDEFINED; // #1003
				}
			}
		}

		series.data = data;
		series.points = points;
	},

	/**
	 * Adds series' points value to corresponding stack
	 */
	setStackedPoints: function () {
		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
			return;
		}

		var series = this,
			xData = series.processedXData,
			yData = series.processedYData,
			stackedYData = [],
			yDataLength = yData.length,
			seriesOptions = series.options,
			threshold = seriesOptions.threshold,
			stackOption = seriesOptions.stack,
			stacking = seriesOptions.stacking,
			stackKey = series.stackKey,
			negKey = '-' + stackKey,
			negStacks = series.negStacks,
			yAxis = series.yAxis,
			stacks = yAxis.stacks,
			oldStacks = yAxis.oldStacks,
			isNegative,
			stack,
			other,
			key,
			i,
			x,
			y;

		// loop over the non-null y values and read them into a local array
		for (i = 0; i < yDataLength; i++) {
			x = xData[i];
			y = yData[i];

			// Read stacked values into a stack based on the x value,
			// the sign of y and the stack key. Stacking is also handled for null values (#739)
			isNegative = negStacks && y < threshold;
			key = isNegative ? negKey : stackKey;

			// Create empty object for this stack if it doesn't exist yet
			if (!stacks[key]) {
				stacks[key] = {};
			}

			// Initialize StackItem for this x
			if (!stacks[key][x]) {
				if (oldStacks[key] && oldStacks[key][x]) {
					stacks[key][x] = oldStacks[key][x];
					stacks[key][x].total = null;
				} else {
					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption, stacking);
				}
			}

			// If the StackItem doesn't exist, create it first
			stack = stacks[key][x];
			stack.points[series.index] = [stack.cum || 0];

			// Add value to the stack total
			if (stacking === 'percent') {
				
				// Percent stacked column, totals are the same for the positive and negative stacks
				other = isNegative ? stackKey : negKey;
				if (negStacks && stacks[other] && stacks[other][x]) {
					other = stacks[other][x];
					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

				// Percent stacked areas					
				} else {
					stack.total += mathAbs(y) || 0;
				}
			} else {
				stack.total += y || 0;
			}

			stack.cum = (stack.cum || 0) + (y || 0);

			stack.points[series.index].push(stack.cum);
			stackedYData[i] = stack.cum;

		}

		if (stacking === 'percent') {
			yAxis.usePercentage = true;
		}

		this.stackedYData = stackedYData; // To be used in getExtremes
		
		// Reset old stacks
		yAxis.oldStacks = {};
	},

	/**
	 * Iterate over all stacks and compute the absolute values to percent
	 */
	setPercentStacks: function () {
		var series = this,
			stackKey = series.stackKey,
			stacks = series.yAxis.stacks;
		
		each([stackKey, '-' + stackKey], function (key) {
			var i = series.xData.length,
				x,
				stack,
				pointExtremes,
				totalFactor;

			while (i--) {
				x = series.xData[i];
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[series.index];
				if (pointExtremes) {
					totalFactor = stack.total ? 100 / stack.total : 0;
					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
					series.stackedYData[i] = pointExtremes[1];
				}
			}
		});
	},

	/**
	 * Calculate Y extremes for visible data
	 */
	getExtremes: function () {
		var xAxis = this.xAxis,
			yAxis = this.yAxis,
			xData = this.processedXData,
			yData = this.stackedYData || this.processedYData,
			yDataLength = yData.length,
			activeYData = [],
			activeCounter = 0,
			xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
			xMin = xExtremes.min,
			xMax = xExtremes.max,
			validValue,
			withinRange,
			dataMin,
			dataMax,
			x,
			y,
			i,
			j;

		for (i = 0; i < yDataLength; i++) {
			
			x = xData[i];
			y = yData[i];

			// For points within the visible range, including the first point outside the
			// visible range, consider y extremes
			validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
			withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin && 
				(xData[i - 1] || x) <= xMax);

			if (validValue && withinRange) {

				j = y.length;
				if (j) { // array, like ohlc or range data
					while (j--) {
						if (y[j] !== null) {
							activeYData[activeCounter++] = y[j];
						}
					}
				} else {
					activeYData[activeCounter++] = y;
				}
			}
		}
		this.dataMin = pick(dataMin, arrayMin(activeYData));
		this.dataMax = pick(dataMax, arrayMax(activeYData));
	},

	/**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			i,
			pointPlacement = options.pointPlacement,
			dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
			threshold = options.threshold;

		
		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],
				pointStack,
				stackValues;

			// Discard disallowed y values for log axes
			if (yAxis.isLog && yValue <= 0) {
				point.y = yValue = null;
			}
			
			// Get the plotX translation
			point.plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591
			

			// Calculate the bottom y value for stacked series
			if (stacking && series.visible && stack && stack[xValue]) {

				pointStack = stack[xValue];
				stackValues = pointStack.points[series.index];
				yBottom = stackValues[0];
				yValue = stackValues[1];

				if (yBottom === 0) {
					yBottom = pick(threshold, yAxis.min);
				}
				if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
					yBottom = null;
				}

				point.percentage = stacking === 'percent' && yValue;
				point.total = point.stackTotal = pointStack.total;
				point.stackY = yValue;

				// Place the stack label
				pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
				
			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ? 
				yAxis.translate(yBottom, 0, 1, 0, 1) :
				null;
				
			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = (typeof yValue === 'number' && yValue !== Infinity) ? 
				//mathRound(yAxis.translate(yValue, 0, 1, 0, 1) * 10) / 10 : // Math.round fixes #591
				yAxis.translate(yValue, 0, 1, 0, 1) : 
				UNDEFINED;
			
			// Set client related positions for mouse tracking
			point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : point.plotX; // #1514
				
			point.negative = point.y < (threshold || 0);

			// some API data
			point.category = categories && categories[point.x] !== UNDEFINED ?
				categories[point.x] : point.x;


		}

		// now that we have the cropped data, build the segments
		series.getSegments();
	},
	/**
	 * Memoize tooltip texts and positions
	 */
	setTooltipPoints: function (renew) {
		var series = this,
			points = [],
			pointsLength,
			low,
			high,
			xAxis = series.xAxis,
			xExtremes = xAxis && xAxis.getExtremes(),
			axisLength = xAxis ? (xAxis.tooltipLen || xAxis.len) : series.chart.plotSizeX, // tooltipLen and tooltipPosName used in polar
			point,
			pointX,
			nextPoint,
			i,
			tooltipPoints = []; // a lookup array for each pixel in the x dimension

		// don't waste resources if tracker is disabled
		if (series.options.enableMouseTracking === false) {
			return;
		}

		// renew
		if (renew) {
			series.tooltipPoints = null;
		}

		// concat segments to overcome null values
		each(series.segments || series.points, function (segment) {
			points = points.concat(segment);
		});

		// Reverse the points in case the X axis is reversed
		if (xAxis && xAxis.reversed) {
			points = points.reverse();
		}

		// Polar needs additional shaping
		if (series.orderTooltipPoints) {
			series.orderTooltipPoints(points);
		}

		// Assign each pixel position to the nearest point
		pointsLength = points.length;
		for (i = 0; i < pointsLength; i++) {
			point = points[i];
			pointX = point.x;
			if (pointX >= xExtremes.min && pointX <= xExtremes.max) { // #1149
				nextPoint = points[i + 1];
				
				// Set this range's low to the last range's high plus one
				low = high === UNDEFINED ? 0 : high + 1;
				// Now find the new high
				high = points[i + 1] ?
					mathMin(mathMax(0, mathFloor( // #2070
						(point.clientX + (nextPoint ? (nextPoint.wrappedClientX || nextPoint.clientX) : axisLength)) / 2
					)), axisLength) :
					axisLength;

				while (low >= 0 && low <= high) {
					tooltipPoints[low++] = point;
				}
			}
		}
		series.tooltipPoints = tooltipPoints;
	},

	/**
	 * Format the header of the tooltip
	 */
	tooltipHeaderFormatter: function (point) {
		var series = this,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat,
			dateTimeLabelFormats = tooltipOptions.dateTimeLabelFormats,
			xAxis = series.xAxis,
			isDateTime = xAxis && xAxis.options.type === 'datetime',
			headerFormat = tooltipOptions.headerFormat,
			closestPointRange = xAxis && xAxis.closestPointRange,
			n;
			
		// Guess the best date format based on the closest point distance (#568)
		if (isDateTime && !xDateFormat) {
			if (closestPointRange) {
				for (n in timeUnits) {
					if (timeUnits[n] >= closestPointRange) {
						xDateFormat = dateTimeLabelFormats[n];
						break;
					}
				}
			} else {
				xDateFormat = dateTimeLabelFormats.day;
			}
		}
		
		// Insert the header date format if any
		if (isDateTime && xDateFormat && isNumber(point.key)) {
			headerFormat = headerFormat.replace('{point.key}', '{point.key:' + xDateFormat + '}');
		}
		
		return format(headerFormat, {
			point: point,
			series: series
		});
	},

	/**
	 * Series mouse over handler
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState(HOVER_STATE);
		chart.hoverSeries = series;
	},

	/**
	 * Series mouse out handler
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
		chart.hoverSeries = null;
	},

	/**
	 * Animate in the series
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			clipRect,
			markerClipRect,
			animation = series.options.animation,
			clipBox = chart.clipBox,
			inverted = chart.inverted,
			sharedClipKey;

		// Animation option is set to true
		if (animation && !isObject(animation)) {
			animation = defaultPlotOptions[series.type].animation;
		}
		sharedClipKey = '_sharedClip' + animation.duration + animation.easing;

		// Initialize the animation. Set up the clipping rectangle.
		if (init) { 
			
			// If a clipping rectangle with the same properties is currently present in the chart, use that. 
			clipRect = chart[sharedClipKey];
			markerClipRect = chart[sharedClipKey + 'm'];
			if (!clipRect) {
				chart[sharedClipKey] = clipRect = renderer.clipRect(
					extend(clipBox, { width: 0 })
				);
				
				chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
					-99, // include the width of the first marker
					inverted ? -chart.plotLeft : -chart.plotTop, 
					99,
					inverted ? chart.chartWidth : chart.chartHeight
				);
			}
			series.group.clip(clipRect);
			series.markerGroup.clip(markerClipRect);
			series.sharedClipKey = sharedClipKey;

		// Run the animation
		} else { 
			clipRect = chart[sharedClipKey];
			if (clipRect) {
				clipRect.animate({
					width: chart.plotSizeX
				}, animation);
				chart[sharedClipKey + 'm'].animate({
					width: chart.plotSizeX + 99
				}, animation);
			}

			// Delete this function to allow it only once
			series.animate = null;
			
			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
			// which should be available to the user).
			series.animationTimeout = setTimeout(function () {
				series.afterAnimate();
			}, animation.duration);
		}
	},
	
	/**
	 * This runs after animation to land on the final plot clipping
	 */
	afterAnimate: function () {
		var chart = this.chart,
			sharedClipKey = this.sharedClipKey,
			group = this.group;
			
		if (group && this.options.clip !== false) {
			group.clip(chart.clipRect);
			this.markerGroup.clip(); // no clip
		}
		
		// Remove the shared clipping rectancgle when all series are shown		
		setTimeout(function () {
			if (sharedClipKey && chart[sharedClipKey]) {
				chart[sharedClipKey] = chart[sharedClipKey].destroy();
				chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
			}
		}, 100);
	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			plotX,
			plotY,
			i,
			point,
			radius,
			symbol,
			isImage,
			graphic,
			options = series.options,
			seriesMarkerOptions = options.marker,
			pointMarkerOptions,
			enabled,
			isInside,
			markerGroup = series.markerGroup;

		if (seriesMarkerOptions.enabled || series._hasPointMarkers) {
			
			i = points.length;
			while (i--) {
				point = points[i];
				plotX = mathFloor(point.plotX); // #1843
				plotY = point.plotY;
				graphic = point.graphic;
				pointMarkerOptions = point.marker || {};
				enabled = (seriesMarkerOptions.enabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
				isInside = chart.isInsidePlot(mathRound(plotX), plotY, chart.inverted); // #1858
				
				// only draw the point if y is defined
				if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

					// shortcuts
					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
					radius = pointAttr.r;
					symbol = pick(pointMarkerOptions.symbol, series.symbol);
					isImage = symbol.indexOf('url') === 0;

					if (graphic) { // update
						graphic
							.attr({ // Since the marker group isn't clipped, each individual marker must be toggled
								visibility: isInside ? (hasSVG ? 'inherit' : VISIBLE) : HIDDEN
							})
							.animate(extend({
								x: plotX - radius,
								y: plotY - radius
							}, graphic.symbolName ? { // don't apply to image symbols #507
								width: 2 * radius,
								height: 2 * radius
							} : {}));
					} else if (isInside && (radius > 0 || isImage)) {
						point.graphic = graphic = chart.renderer.symbol(
							symbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius
						)
						.attr(pointAttr)
						.add(markerGroup);
					}
					
				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			}
		}

	},

	/**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
	convertAttribs: function (options, base1, base2, base3) {
		var conversion = this.pointAttrToOptions,
			attr,
			option,
			obj = {};

		options = options || {};
		base1 = base1 || {};
		base2 = base2 || {};
		base3 = base3 || {};

		for (attr in conversion) {
			option = conversion[attr];
			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
		}
		return obj;
	},

	/**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
	getAttribs: function () {
		var series = this,
			seriesOptions = series.options,
			normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
			stateOptions = normalOptions.states,
			stateOptionsHover = stateOptions[HOVER_STATE],
			pointStateOptionsHover,
			seriesColor = series.color,
			normalDefaults = {
				stroke: seriesColor,
				fill: seriesColor
			},
			points = series.points || [], // #927
			i,
			point,
			seriesPointAttr = [],
			pointAttr,
			pointAttrToOptions = series.pointAttrToOptions,
			hasPointSpecificOptions,
			negativeColor = seriesOptions.negativeColor,
			defaultLineColor = normalOptions.lineColor,
			key;

		// series type specific modifications
		if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

			// if no hover radius is given, default to normal radius + 2
			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
			
		} else { // column, bar, pie

			// if no hover color is given, brighten the normal color
			stateOptionsHover.color = stateOptionsHover.color ||
				Color(stateOptionsHover.color || seriesColor)
					.brighten(stateOptionsHover.brightness).get();
		}

		// general point attributes for the series normal state
		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
		each([HOVER_STATE, SELECT_STATE], function (state) {
			seriesPointAttr[state] =
					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
		});

		// set it
		series.pointAttr = seriesPointAttr;


		// Generate the point-specific attribute collections if specific point
		// options are given. If not, create a referance to the series wide point
		// attributes
		i = points.length;
		while (i--) {
			point = points[i];
			normalOptions = (point.options && point.options.marker) || point.options;
			if (normalOptions && normalOptions.enabled === false) {
				normalOptions.radius = 0;
			}
			
			if (point.negative && negativeColor) {
				point.color = point.fillColor = negativeColor;
			}
			
			hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

			// check if the point has specific visual options
			if (point.options) {
				for (key in pointAttrToOptions) {
					if (defined(normalOptions[pointAttrToOptions[key]])) {
						hasPointSpecificOptions = true;
					}
				}
			}

			// a specific marker config object is defined for the individual point:
			// create it's own attribute collection
			if (hasPointSpecificOptions) {
				normalOptions = normalOptions || {};
				pointAttr = [];
				stateOptions = normalOptions.states || {}; // reassign for individual point
				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

				// Handle colors for column and pies
				if (!seriesOptions.marker) { // column, bar, point
					// if no hover color is given, brighten the normal color
					pointStateOptionsHover.color =
						Color(pointStateOptionsHover.color || point.color)
							.brighten(pointStateOptionsHover.brightness ||
								stateOptionsHover.brightness).get();

				}

				// normal point state inherits series wide normal state
				pointAttr[NORMAL_STATE] = series.convertAttribs(extend({
					color: point.color, // #868
					fillColor: point.color, // Individual point color or negative color markers (#2219)
					lineColor: defaultLineColor === null ? point.color : UNDEFINED // Bubbles take point color, line markers use white
				}, normalOptions), seriesPointAttr[NORMAL_STATE]);

				// inherit from point normal and series hover
				pointAttr[HOVER_STATE] = series.convertAttribs(
					stateOptions[HOVER_STATE],
					seriesPointAttr[HOVER_STATE],
					pointAttr[NORMAL_STATE]
				);
				
				// inherit from point normal and series hover
				pointAttr[SELECT_STATE] = series.convertAttribs(
					stateOptions[SELECT_STATE],
					seriesPointAttr[SELECT_STATE],
					pointAttr[NORMAL_STATE]
				);


			// no marker config object is created: copy a reference to the series-wide
			// attribute collection
			} else {
				pointAttr = seriesPointAttr;
			}

			point.pointAttr = pointAttr;

		}

	},
	/**
	 * Update the series with a new set of options
	 */
	update: function (newOptions, redraw) {
		var chart = this.chart,
			// must use user options when changing type because this.options is merged
			// in with type specific plotOptions
			oldOptions = this.userOptions,
			oldType = this.type,
			proto = seriesTypes[oldType].prototype,
			n;

		// Do the merge, with some forced options
		newOptions = merge(oldOptions, {
			animation: false,
			index: this.index,
			pointStart: this.xData[0] // when updating after addPoint
		}, { data: this.options.data }, newOptions);

		// Destroy the series and reinsert methods from the type prototype
		this.remove(false);
		for (n in proto) { // Overwrite series-type specific methods (#2270)
			if (proto.hasOwnProperty(n)) {
				this[n] = UNDEFINED;
			}
		}
		extend(this, seriesTypes[newOptions.type || oldType].prototype);
		

		this.init(chart, newOptions);
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	},

	/**
	 * Clear DOM objects and free up memory
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			issue134 = /AppleWebKit\/533/.test(userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			prop,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);
		
		// erase from axes
		each(['xAxis', 'yAxis'], function (AXIS) {
			axis = series[AXIS];
			if (axis) {
				erase(axis.series, series);
				axis.isDirty = axis.forceRedraw = true;
				axis.stacks = {}; // Rebuild stacks when updating (#2229)
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// Clear the animation timeout if we are destroying the series during initial animation
		clearTimeout(series.animationTimeout);

		// destroy all SVGElements associated to the series
		each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',
				'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {
			if (series[prop]) {

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
					'hide' :
					'destroy';

				series[prop][destroy]();
			}
		});

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);

		// clear all members
		for (prop in series) {
			delete series[prop];
		}
	},

	/**
	 * Draw the data labels
	 */
	drawDataLabels: function () {
		
		var series = this,
			seriesOptions = series.options,
			options = seriesOptions.dataLabels,
			points = series.points,
			pointOptions,
			generalOptions,
			str,
			dataLabelsGroup;
		
		if (options.enabled || series._hasPointLabels) {
						
			// Process default alignment of data labels for columns
			if (series.dlProcessOptions) {
				series.dlProcessOptions(options);
			}

			// Create a separate group for the data labels to avoid rotation
			dataLabelsGroup = series.plotGroup(
				'dataLabelsGroup', 
				'data-labels', 
				series.visible ? VISIBLE : HIDDEN, 
				options.zIndex || 6
			);
			
			// Make the labels for each point
			generalOptions = options;
			each(points, function (point) {
				
				var enabled,
					dataLabel = point.dataLabel,
					labelConfig,
					attr,
					name,
					rotation,
					connector = point.connector,
					isNew = true;
				
				// Determine if each data label is enabled
				pointOptions = point.options && point.options.dataLabels;
				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282
				
				
				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && !enabled) {
					point.dataLabel = dataLabel.destroy();
				
				// Individual labels are disabled if the are explicitly disabled 
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {
					
					// Create individual options structure that can be extended without 
					// affecting others
					options = merge(generalOptions, pointOptions);

					rotation = options.rotation;
					
					// Get the string
					labelConfig = point.getLabelConfig();
					str = options.format ?
						format(options.format, labelConfig) : 
						options.formatter.call(labelConfig, options);
					
					// Determine the color
					options.style.color = pick(options.color, options.style.color, series.color, 'black');
	
					
					// update existing label
					if (dataLabel) {
						
						if (defined(str)) {
							dataLabel
								.attr({
									text: str
								});
							isNew = false;
						
						} else { // #1437 - the label is shown conditionally
							point.dataLabel = dataLabel = dataLabel.destroy();
							if (connector) {
								point.connector = connector.destroy();
							}
						}
						
					// create new label
					} else if (defined(str)) {
						attr = {
							//align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius || 0,
							rotation: rotation,
							padding: options.padding,
							zIndex: 1
						};
						// Remove unused attributes (#947)
						for (name in attr) {
							if (attr[name] === UNDEFINED) {
								delete attr[name];
							}
						}
						
						dataLabel = point.dataLabel = series.chart.renderer[rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							0,
							-999,
							null,
							null,
							null,
							options.useHTML
						)
						.attr(attr)
						.css(options.style)
						.add(dataLabelsGroup)
						.shadow(options.shadow);
						
					}
					
					if (dataLabel) {
						// Now the data label is created and placed at 0,0, so we need to align it
						series.alignDataLabel(point, dataLabel, options, null, isNew);
					}
				}
			});
		}
	},
	
	/**
	 * Align each individual data label
	 */
	alignDataLabel: function (point, dataLabel, options, alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			plotX = pick(point.plotX, -999),
			plotY = pick(point.plotY, -999),
			bBox = dataLabel.getBBox(),
			visible = this.visible && chart.isInsidePlot(point.plotX, point.plotY, inverted),
			alignAttr; // the final position;
				
		if (visible) {

			// The alignment box is a singular point
			alignTo = extend({
				x: inverted ? chart.plotWidth - plotY : plotX,
				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
				width: 0,
				height: 0
			}, alignTo);
			
			// Add the text size for alignment calculation
			extend(options, {
				width: bBox.width,
				height: bBox.height
			});

			// Allow a hook for changing alignment in the last moment, then do the alignment
			if (options.rotation) { // Fancy box alignment isn't supported for rotated text
				alignAttr = {
					align: options.align,
					x: alignTo.x + options.x + alignTo.width / 2,
					y: alignTo.y + options.y + alignTo.height / 2
				};
				dataLabel[isNew ? 'attr' : 'animate'](alignAttr);
			} else {
				dataLabel.align(options, null, alignTo);
				alignAttr = dataLabel.alignAttr;

				// Handle justify or crop
				if (pick(options.overflow, 'justify') === 'justify') { // docs: overflow: justify, also crop only applies when not justify
					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
				
				} else if (pick(options.crop, true)) {
					// Now check that the data label is within the plot area
					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
				
				}
			}		
		}

		// Show or hide based on the final aligned position
		if (!visible) {
			dataLabel.attr({ y: -999 });
		}
				
	},
	
	/**
	 * If data labels fall partly outside the plot area, align them back in, in a way that
	 * doesn't hide the point.
	 */
	justifyDataLabel: function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
		var chart = this.chart,
			align = options.align,
			verticalAlign = options.verticalAlign,
			off,
			justified;

		// Off left
		off = alignAttr.x;
		if (off < 0) {
			if (align === 'right') {
				options.align = 'left';
			} else {
				options.x = -off;
			}
			justified = true;
		}

		// Off right
		off = alignAttr.x + bBox.width;
		if (off > chart.plotWidth) {
			if (align === 'left') {
				options.align = 'right';
			} else {
				options.x = chart.plotWidth - off;
			}
			justified = true;
		}

		// Off top
		off = alignAttr.y;
		if (off < 0) {
			if (verticalAlign === 'bottom') {
				options.verticalAlign = 'top';
			} else {
				options.y = -off;
			}
			justified = true;
		}

		// Off bottom
		off = alignAttr.y + bBox.height;
		if (off > chart.plotHeight) {
			if (verticalAlign === 'top') {
				options.verticalAlign = 'bottom';
			} else {
				options.y = chart.plotHeight - off;
			}
			justified = true;
		}
		
		if (justified) {
			dataLabel.placed = !isNew;
			dataLabel.align(options, null, alignTo);
		}
	},
	
	/**
	 * Return the graph path of a segment
	 */
	getSegmentPath: function (segment) {		
		var series = this,
			segmentPath = [],
			step = series.options.step;
			
		// build the segment line
		each(segment, function (point, i) {
			
			var plotX = point.plotX,
				plotY = point.plotY,
				lastPoint;

			if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
				segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

			} else {

				// moveTo or lineTo
				segmentPath.push(i ? L : M);

				// step line?
				if (step && i) {
					lastPoint = segment[i - 1];
					if (step === 'right') {
						segmentPath.push(
							lastPoint.plotX,
							plotY
						);
						
					} else if (step === 'center') {
						segmentPath.push(
							(lastPoint.plotX + plotX) / 2,
							lastPoint.plotY,
							(lastPoint.plotX + plotX) / 2,
							plotY
						);
						
					} else {
						segmentPath.push(
							plotX,
							lastPoint.plotY
						);
					}
				}

				// normal line to next point
				segmentPath.push(
					point.plotX,
					point.plotY
				);
			}
		});
		
		return segmentPath;
	},

	/**
	 * Get the graph path
	 */
	getGraphPath: function () {
		var series = this,
			graphPath = [],
			segmentPath,
			singlePoints = []; // used in drawTracker

		// Divide into segments and build graph and area paths
		each(series.segments, function (segment) {
			
			segmentPath = series.getSegmentPath(segment);
			
			// add the segment to the graph, or a single point for tracking
			if (segment.length > 1) {
				graphPath = graphPath.concat(segmentPath);
			} else {
				singlePoints.push(segment[0]);
			}
		});

		// Record it for use in drawGraph and drawTracker, and return graphPath
		series.singlePoints = singlePoints;
		series.graphPath = graphPath;
		
		return graphPath;
		
	},
	
	/**
	 * Draw the actual graph
	 */
	drawGraph: function () {
		var series = this,
			options = this.options,
			props = [['graph', options.lineColor || this.color]],
			lineWidth = options.lineWidth,
			dashStyle =  options.dashStyle,
			graphPath = this.getGraphPath(),
			negativeColor = options.negativeColor;
			
		if (negativeColor) {
			props.push(['graphNeg', negativeColor]);
		}
		
		// draw the graph
		each(props, function (prop, i) {
			var graphKey = prop[0],
				graph = series[graphKey],
				attribs;
			
			if (graph) {
				stop(graph); // cancel running animations, #459
				graph.animate({ d: graphPath });
	
			} else if (lineWidth && graphPath.length) { // #1487
				attribs = {
					stroke: prop[1],
					'stroke-width': lineWidth,
					zIndex: 1 // #1069
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				} else {
					attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
				}

				series[graphKey] = series.chart.renderer.path(graphPath)
					.attr(attribs)
					.add(series.group)
					.shadow(!i && options.shadow);
			}
		});
	},
	
	/**
	 * Clip the graphs into the positive and negative coloured graphs
	 */
	clipNeg: function () {
		var options = this.options,
			chart = this.chart,
			renderer = chart.renderer,
			negativeColor = options.negativeColor || options.negativeFillColor,
			translatedThreshold,
			posAttr,
			negAttr,
			graph = this.graph,
			area = this.area,
			posClip = this.posClip,
			negClip = this.negClip,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			chartSizeMax = mathMax(chartWidth, chartHeight),
			yAxis = this.yAxis,
			above,
			below;
		
		if (negativeColor && (graph || area)) {
			translatedThreshold = mathRound(yAxis.toPixels(options.threshold || 0, true));
			above = {
				x: 0,
				y: 0,
				width: chartSizeMax,
				height: translatedThreshold
			};
			below = {
				x: 0,
				y: translatedThreshold,
				width: chartSizeMax,
				height: chartSizeMax
			};
			
			if (chart.inverted) {

				above.height = below.y = chart.plotWidth - translatedThreshold;
				if (renderer.isVML) {
					above = {
						x: chart.plotWidth - translatedThreshold - chart.plotLeft,
						y: 0,
						width: chartWidth,
						height: chartHeight
					};
					below = {
						x: translatedThreshold + chart.plotLeft - chartWidth,
						y: 0,
						width: chart.plotLeft + translatedThreshold,
						height: chartWidth
					};
				}
			}
			
			if (yAxis.reversed) {
				posAttr = below;
				negAttr = above;
			} else {
				posAttr = above;
				negAttr = below;
			}
		
			if (posClip) { // update
				posClip.animate(posAttr);
				negClip.animate(negAttr);
			} else {
				
				this.posClip = posClip = renderer.clipRect(posAttr);
				this.negClip = negClip = renderer.clipRect(negAttr);
				
				if (graph && this.graphNeg) {
					graph.clip(posClip);
					this.graphNeg.clip(negClip);	
				}
				
				if (area) {
					area.clip(posClip);
					this.areaNeg.clip(negClip);
				} 
			} 
		}	
	},

	/**
	 * Initialize and perform group inversion on series.group and series.markerGroup
	 */
	invertGroups: function () {
		var series = this,
			chart = series.chart;

		// Pie, go away (#1736)
		if (!series.xAxis) {
			return;
		}
		
		// A fixed size is needed for inversion to work
		function setInvert() {			
			var size = {
				width: series.yAxis.len,
				height: series.xAxis.len
			};
			
			each(['group', 'markerGroup'], function (groupName) {
				if (series[groupName]) {
					series[groupName].attr(size).invert();
				}
			});
		}

		addEvent(chart, 'resize', setInvert); // do it on resize
		addEvent(series, 'destroy', function () {
			removeEvent(chart, 'resize', setInvert);
		});

		// Do it now
		setInvert(); // do it now
		
		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},
	
	/**
	 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and 
	 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
	 */
	plotGroup: function (prop, name, visibility, zIndex, parent) {
		var group = this[prop],
			isNew = !group;
		
		// Generate it on first call
		if (isNew) {	
			this[prop] = group = this.chart.renderer.g(name)
				.attr({
					visibility: visibility,
					zIndex: zIndex || 0.1 // IE8 needs this
				})
				.add(parent);
		}
		// Place it on first and subsequent (redraw) calls
		group[isNew ? 'attr' : 'animate'](this.getPlotBox());
		return group;		
	},

	/**
	 * Get the translation and scale for the plot area of this series
	 */
	getPlotBox: function () {
		return {
			translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft, 
			translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop,
			scaleX: 1, // #1623
			scaleY: 1
		};
	},
	
	/**
	 * Render the graph and markers
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			animation = options.animation,
			doAnimation = animation && !!series.animate && 
				chart.renderer.isSVG, // this animation doesn't work in IE8 quirks when the group div is hidden,
				// and looks bad in other oldIE
			visibility = series.visible ? VISIBLE : HIDDEN,
			zIndex = options.zIndex,
			hasRendered = series.hasRendered,
			chartSeriesGroup = chart.seriesGroup;
		
		// the group
		group = series.plotGroup(
			'group', 
			'series', 
			visibility, 
			zIndex, 
			chartSeriesGroup
		);
		
		series.markerGroup = series.plotGroup(
			'markerGroup', 
			'markers', 
			visibility, 
			zIndex, 
			chartSeriesGroup
		);
		
		// initiate the animation
		if (doAnimation) {
			series.animate(true);
		}

		// cache attributes for shapes
		series.getAttribs();

		// SVGRenderer needs to know this before drawing elements (#1089, #1795)
		group.inverted = series.isCartesian ? chart.inverted : false;
		
		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
			series.clipNeg();
		}

		// draw the data labels (inn pies they go before the points)
		series.drawDataLabels();
		
		// draw the points
		series.drawPoints();


		// draw the mouse tracking area
		if (series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}
		
		// Handle inverted series and tracker groups
		if (chart.inverted) {
			series.invertGroups();
		}
		
		// Initial clipping, must be defined after inverting groups for VML
		if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
			group.clip(chart.clipRect);
		}

		// Run the animation
		if (doAnimation) {
			series.animate();
		} else if (!hasRendered) {
			series.afterAnimate();
		}

		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.hasRendered = true;
	},
	
	/**
	 * Redraw the series after an update in the axes.
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
			group = series.group,
			xAxis = series.xAxis,
			yAxis = series.yAxis;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: pick(xAxis && xAxis.left, chart.plotLeft),
				translateY: pick(yAxis && yAxis.top, chart.plotTop)
			});
		}

		series.translate();
		series.setTooltipPoints(true);

		series.render();
		if (wasDirtyData) {
			fireEvent(series, 'updatedData');
		}
	},

	/**
	 * Set the state of the graph
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			graphNeg = series.graphNeg,
			stateOptions = options.states,
			lineWidth = options.lineWidth,
			attribs;

		state = state || NORMAL_STATE;

		if (series.state !== state) {
			series.state = state;

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				attribs = {
					'stroke-width': lineWidth
				};
				// use attr because animate will cause any other animation on the graph to stop
				graph.attr(attribs);
				if (graphNeg) {
					graphNeg.attr(attribs);
				}
			}
		}
	},

	/**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *        the visibility is toggled.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			showOrHide,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
		showOrHide = vis ? 'show' : 'hide';

		// show or hide elements
		each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
			if (series[key]) {
				series[key][showOrHide]();
			}
		});

		
		// hide tooltip (#1361)
		if (chart.hoverSeries === series) {
			series.onMouseOut();
		}


		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		// show or hide linked series
		each(series.linkedSeries, function (otherSeries) {
			otherSeries.setVisible(vis, false);
		});

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the graph
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the graph
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *        UNDEFINED, the selection state is toggled.
	 */
	select: function (selected) {
		var series = this;
		// if called without an argument, toggle
		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTracker: function () {
		var series = this,
			options = series.options,
			trackByArea = options.trackByArea,
			trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			pointer = chart.pointer,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			singlePoints = series.singlePoints,
			singlePoint,
			i,
			onMouseOver = function () {
				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}
			};

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength && !trackByArea) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === M) { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
				}
				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// handle single points
		for (i = 0; i < singlePoints.length; i++) {
			singlePoint = singlePoints[i];
			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
		}
		
		

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });

		} else { // create
				
			series.tracker = renderer.path(trackerPath)
				.attr({
					'stroke-linejoin': 'round', // #1225
					visibility: series.visible ? VISIBLE : HIDDEN,
					stroke: TRACKER_FILL,
					fill: trackByArea ? TRACKER_FILL : NONE,
					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
					zIndex: 2
				})
				.add(series.group);
				
			// The tracker is added to the series group, which is clipped, but is covered 
			// by the marker group. So the marker group also needs to capture events.
			each([series.tracker, series.markerGroup], function (tracker) {
				tracker.addClass(PREFIX + 'tracker')
					.on('mouseover', onMouseOver)
					.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
					.css(css);

				if (hasTouch) {
					tracker.on('touchstart', onMouseOver);
				} 
			});
		}

	}

}; // end Series prototype


/**
 * LineSeries object
 */
var LineSeries = extendClass(Series);
seriesTypes.line = LineSeries;

/**
 * Set the default options for area
 */
defaultPlotOptions.area = merge(defaultSeriesOptions, {
	threshold: 0
	// trackByArea: false,
	// lineColor: null, // overrides color, but lets fillColor be unaltered
	// fillOpacity: 0.75,
	// fillColor: null
});

/**
 * AreaSeries object
 */
var AreaSeries = extendClass(Series, {
	type: 'area',
	
	/**
	 * For stacks, don't split segments on null values. Instead, draw null values with 
	 * no marker. Also insert dummy points for any X position that exists in other series
	 * in the stack.
	 */ 
	getSegments: function () {
		var segments = [],
			segment = [],
			keys = [],
			xAxis = this.xAxis,
			yAxis = this.yAxis,
			stack = yAxis.stacks[this.stackKey],
			pointMap = {},
			plotX,
			plotY,
			points = this.points,
			connectNulls = this.options.connectNulls,
			val,
			i,
			x;

		if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
			// Create a map where we can quickly look up the points by their X value.
			for (i = 0; i < points.length; i++) {
				pointMap[points[i].x] = points[i];
			}

			// Sort the keys (#1651)
			for (x in stack) {
				keys.push(+x);
			}
			keys.sort(function (a, b) {
				return a - b;
			});

			each(keys, function (x) {
				if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
					return;

				// The point exists, push it to the segment
				} else if (pointMap[x]) {
					segment.push(pointMap[x]);

				// There is no point for this X value in this series, so we 
				// insert a dummy point in order for the areas to be drawn
				// correctly.
				} else {
					plotX = xAxis.translate(x);
					val = stack[x].percent ? (stack[x].total ? stack[x].cum * 100 / stack[x].total : 0) : stack[x].cum; // #1991
					plotY = yAxis.toPixels(val, true);
					segment.push({ 
						y: null, 
						plotX: plotX,
						clientX: plotX, 
						plotY: plotY, 
						yBottom: plotY,
						onMouseOver: noop
					});
				}
			});

			if (segment.length) {
				segments.push(segment);
			}

		} else {
			Series.prototype.getSegments.call(this);
			segments = this.segments;
		}

		this.segments = segments;
	},
	
	/**
	 * Extend the base Series getSegmentPath method by adding the path for the area.
	 * This path is pushed to the series.areaPath property.
	 */
	getSegmentPath: function (segment) {
		
		var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
			areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
			i,
			options = this.options,
			segLength = segmentPath.length,
			translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
			yBottom;
		
		if (segLength === 3) { // for animation from 1 to two points
			areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
		}
		if (options.stacking && !this.closedStacks) {
			
			// Follow stack back. Todo: implement areaspline. A general solution could be to 
			// reverse the entire graphPath of the previous series, though may be hard with
			// splines and with series with different extremes
			for (i = segment.length - 1; i >= 0; i--) {

				yBottom = pick(segment[i].yBottom, translatedThreshold);
			
				// step line?
				if (i < segment.length - 1 && options.step) {
					areaSegmentPath.push(segment[i + 1].plotX, yBottom);
				}
				
				areaSegmentPath.push(segment[i].plotX, yBottom);
			}

		} else { // follow zero line back
			this.closeSegment(areaSegmentPath, segment, translatedThreshold);
		}
		this.areaPath = this.areaPath.concat(areaSegmentPath);
		return segmentPath;
	},
	
	/**
	 * Extendable method to close the segment path of an area. This is overridden in polar 
	 * charts.
	 */
	closeSegment: function (path, segment, translatedThreshold) {
		path.push(
			L,
			segment[segment.length - 1].plotX,
			translatedThreshold,
			L,
			segment[0].plotX,
			translatedThreshold
		);
	},
	
	/**
	 * Draw the graph and the underlying area. This method calls the Series base
	 * function and adds the area. The areaPath is calculated in the getSegmentPath
	 * method called from Series.prototype.drawGraph.
	 */
	drawGraph: function () {
		
		// Define or reset areaPath
		this.areaPath = [];
		
		// Call the base method
		Series.prototype.drawGraph.apply(this);
		
		// Define local variables
		var series = this,
			areaPath = this.areaPath,
			options = this.options,
			negativeColor = options.negativeColor,
			negativeFillColor = options.negativeFillColor,
			props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
		
		if (negativeColor || negativeFillColor) {
			props.push(['areaNeg', negativeColor, negativeFillColor]);
		}
		
		each(props, function (prop) {
			var areaKey = prop[0],
				area = series[areaKey];
				
			// Create or update the area
			if (area) { // update
				area.animate({ d: areaPath });
	
			} else { // create
				series[areaKey] = series.chart.renderer.path(areaPath)
					.attr({
						fill: pick(
							prop[2],
							Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
						),
						zIndex: 0 // #1069
					}).add(series.group);
			}
		});
	},
	
	/**
	 * Get the series' symbol in the legend
	 * 
	 * @param {Object} legend The legend object
	 * @param {Object} item The series (this) or point
	 */
	drawLegendSymbol: function (legend, item) {
		
		item.legendSymbol = this.chart.renderer.rect(
			0,
			legend.baseline - 11,
			legend.options.symbolWidth,
			12,
			2
		).attr({
			zIndex: 3
		}).add(item.legendGroup);		
		
	}
});

seriesTypes.area = AreaSeries;/**
 * Set the default options for spline
 */
defaultPlotOptions.spline = merge(defaultSeriesOptions);

/**
 * SplineSeries object
 */
var SplineSeries = extendClass(Series, {
	type: 'spline',

	/**
	 * Get the spline segment from a given point's previous neighbour to the given point
	 */
	getPointSpline: function (segment, point, i) {
		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = segment[i - 1],
			nextPoint = segment[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		// find control points
		if (lastPoint && nextPoint) {
		
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// have the two control points make a straight line through main point
			correction = ((rightContY - leftContY) * (rightContX - plotX)) /
				(rightContX - leftContX) + plotY - rightContY;

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = mathMax(lastY, plotY);
				rightContY = 2 * plotY - leftContY; // mirror of left control point
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = mathMin(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = mathMax(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = mathMin(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

		}
		
		// Visualize control points for debugging
		/*
		if (leftContX) {
			this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'red',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'red',
					'stroke-width': 1
				})
				.add();
			this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'green',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'green',
					'stroke-width': 1
				})
				.add();
		}
		*/

		// moveTo or lineTo
		if (!i) {
			ret = [M, plotX, plotY];
		} else { // curve from last point to this
			ret = [
				'C',
				lastPoint.rightContX || lastPoint.plotX,
				lastPoint.rightContY || lastPoint.plotY,
				leftContX || plotX,
				leftContY || plotY,
				plotX,
				plotY
			];
			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
		}
		return ret;
	}
});
seriesTypes.spline = SplineSeries;

/**
 * Set the default options for areaspline
 */
defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

/**
 * AreaSplineSeries object
 */
var areaProto = AreaSeries.prototype,
	AreaSplineSeries = extendClass(SplineSeries, {
		type: 'areaspline',
		closedStacks: true, // instead of following the previous graph back, follow the threshold back
		
		// Mix in methods from the area series
		getSegmentPath: areaProto.getSegmentPath,
		closeSegment: areaProto.closeSegment,
		drawGraph: areaProto.drawGraph,
		drawLegendSymbol: areaProto.drawLegendSymbol
	});
seriesTypes.areaspline = AreaSplineSeries;

/**
 * Set the default options for column
 */
defaultPlotOptions.column = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	borderRadius: 0,
	//colorByPoint: undefined,
	groupPadding: 0.2,
	//grouping: true,
	marker: null, // point options are specified in the base options
	pointPadding: 0.1,
	//pointWidth: null,
	minPointLength: 0,
	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		},
		select: {
			color: '#C0C0C0',
			borderColor: '#000000',
			shadow: false
		}
	},
	dataLabels: {
		align: null, // auto
		verticalAlign: null, // auto
		y: null
	},
	stickyTracking: false,
	threshold: 0
});

/**
 * ColumnSeries object
 */
var ColumnSeries = extendClass(Series, {
	type: 'column',
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color',
		r: 'borderRadius'
	},
	cropShoulder: 0,
	trackerGroups: ['group', 'dataLabelsGroup'],
	negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
		// point is substracted from previous (#1910)
	
	/**
	 * Initialize the series
	 */
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	 * pointWidth etc. 
	 */
	getColumnMetrics: function () {

		var series = this,
			options = series.options,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			reversedXAxis = xAxis.reversed,
			stackKey,
			stackGroups = {},
			columnIndex,
			columnCount = 0;

		// Get the total number of column type series.
		// This is called on every series. Consider moving this logic to a
		// chart.orderStacks() function and call it on init, addSeries and removeSeries
		if (options.grouping === false) {
			columnCount = 1;
		} else {
			each(series.chart.series, function (otherSeries) {
				var otherOptions = otherSeries.options,
					otherYAxis = otherSeries.yAxis;
				if (otherSeries.type === series.type && otherSeries.visible &&
						yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
					if (otherOptions.stacking) {
						stackKey = otherSeries.stackKey;
						if (stackGroups[stackKey] === UNDEFINED) {
							stackGroups[stackKey] = columnCount++;
						}
						columnIndex = stackGroups[stackKey];
					} else if (otherOptions.grouping !== false) { // #1162
						columnIndex = columnCount++;
					}
					otherSeries.columnIndex = columnIndex;
				}
			});
		}

		var categoryWidth = mathMin(
				mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || 1), 
				xAxis.len // #1535
			),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / columnCount,
			optionPointWidth = options.pointWidth,
			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
				pointOffsetWidth * options.pointPadding,
			pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
			colIndex = (reversedXAxis ? 
				columnCount - (series.columnIndex || 0) : // #1251
				series.columnIndex) || 0,
			pointXOffset = pointPadding + (groupPadding + colIndex *
				pointOffsetWidth - (categoryWidth / 2)) *
				(reversedXAxis ? -1 : 1);

		// Save it for reading in linked series (Error bars particularly)
		return (series.columnMetrics = { 
			width: pointWidth, 
			offset: pointXOffset 
		});
			
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			borderWidth = options.borderWidth,
			yAxis = series.yAxis,
			threshold = options.threshold,
			translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5),
			metrics = series.getColumnMetrics(),
			pointWidth = metrics.width,
			seriesBarW = series.barW = mathCeil(mathMax(pointWidth, 1 + 2 * borderWidth)), // rounded and postprocessed for border width
			pointXOffset = series.pointXOffset = metrics.offset,
			xCrisp = -(borderWidth % 2 ? 0.5 : 0),
			yCrisp = borderWidth % 2 ? 0.5 : 1;

		if (chart.renderer.isVML && chart.inverted) {
			yCrisp += 1;
		}

		Series.prototype.translate.apply(series);

		// record the new values
		each(series.points, function (point) {
			var yBottom = pick(point.yBottom, translatedThreshold),
				plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)
				barX = point.plotX + pointXOffset,
				barW = seriesBarW,
				barY = mathMin(plotY, yBottom),
				right,
				bottom,
				fromTop,
				fromLeft,
				barH = mathMax(plotY, yBottom) - barY;

			// Handle options.minPointLength
			if (mathAbs(barH) < minPointLength) {
				if (minPointLength) {
					barH = minPointLength;
					barY =
						mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
							yBottom - minPointLength : // keep position
							translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)
				}
			}

			// Cache for access in polar
			point.barX = barX;
			point.pointWidth = pointWidth;


			// Round off to obtain crisp edges
			fromLeft = mathAbs(barX) < 0.5;
			right = mathRound(barX + barW) + xCrisp;
			barX = mathRound(barX) + xCrisp;
			barW = right - barX;

			fromTop = mathAbs(barY) < 0.5;
			bottom = mathRound(barY + barH) + yCrisp;
			barY = mathRound(barY) + yCrisp;
			barH = bottom - barY;

			// Top and left edges are exceptions
			if (fromLeft) {
				barX += 1;
				barW -= 1;
			}
			if (fromTop) {
				barY -= 1;
				barH += 1;
			}

			// Register shape type and arguments to be used in drawPoints
			point.shapeType = 'rect';
			point.shapeArgs = {
				x: barX,
				y: barY,
				width: barW,
				height: barH
			};
		});

	},

	getSymbol: noop,
	
	/**
	 * Use a solid rectangle like the area series types
	 */
	drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,
	
	
	/**
	 * Columns have no graph
	 */
	drawGraph: noop,

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
	drawPoints: function () {
		var series = this,
			options = series.options,
			renderer = series.chart.renderer,
			shapeArgs;


		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY,
				graphic = point.graphic;

			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
				shapeArgs = point.shapeArgs;
				
				if (graphic) { // update
					stop(graphic);
					graphic.animate(merge(shapeArgs));

				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
						.add(series.group)
						.shadow(options.shadow, null, options.stacking && !options.borderRadius);
				}

			} else if (graphic) {
				point.graphic = graphic.destroy(); // #1269
			}
		});
	},

	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */
	drawTracker: function () {
		var series = this,
			chart = series.chart,
			pointer = chart.pointer,
			cursor = series.options.cursor,
			css = cursor && { cursor: cursor },
			onMouseOver = function (e) {
				var target = e.target,
					point;

				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}
				while (target && !point) {
					point = target.point;
					target = target.parentNode;
				}
				if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
					point.onMouseOver(e);
				}
			};

		// Add reference to the point
		each(series.points, function (point) {
			if (point.graphic) {
				point.graphic.element.point = point;
			}
			if (point.dataLabel) {
				point.dataLabel.element.point = point;
			}
		});

		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			each(series.trackerGroups, function (key) {
				if (series[key]) { // we don't always have dataLabelsGroup
					series[key]
						.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);
					if (hasTouch) {
						series[key].on('touchstart', onMouseOver);
					}
				}
			});
			series._hasTracking = true;
		}
	},
	
	/** 
	 * Override the basic data label alignment by adjusting for the position of the column
	 */
	alignDataLabel: function (point, dataLabel, options,  alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
			below = point.below || (point.plotY > pick(this.translatedThreshold, chart.plotSizeY)),
			inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?
		
		// Align to the column itself, or the top of it
		if (dlBox) { // Area range uses this method but not alignTo
			alignTo = merge(dlBox);
			if (inverted) {
				alignTo = {
					x: chart.plotWidth - alignTo.y - alignTo.height,
					y: chart.plotHeight - alignTo.x - alignTo.width,
					width: alignTo.height,
					height: alignTo.width
				};
			}
				
			// Compute the alignment box
			if (!inside) {
				if (inverted) {
					alignTo.x += below ? 0 : alignTo.width;
					alignTo.width = 0;
				} else {
					alignTo.y += below ? alignTo.height : 0;
					alignTo.height = 0;
				}
			}
		}
		
		// When alignment is undefined (typically columns and bars), display the individual 
		// point below or above the point depending on the threshold
		options.align = pick(
			options.align, 
			!inverted || inside ? 'center' : below ? 'right' : 'left'
		);
		options.verticalAlign = pick(
			options.verticalAlign, 
			inverted || inside ? 'middle' : below ? 'top' : 'bottom'
		);
		
		// Call the parent method
		Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
	},


	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			yAxis = this.yAxis,
			options = series.options,
			inverted = this.chart.inverted,
			attr = {},
			translatedThreshold;

		if (hasSVG) { // VML is too slow anyway
			if (init) {
				attr.scaleY = 0.001;
				translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
				if (inverted) {
					attr.translateX = translatedThreshold - yAxis.len;
				} else {
					attr.translateY = translatedThreshold;
				}
				series.group.attr(attr);

			} else { // run the animation
				
				attr.scaleY = 1;
				attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
				series.group.animate(attr, series.options.animation);

				// delete this function to allow it only once
				series.animate = null;
			}
		}
	},
	
	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});
seriesTypes.column = ColumnSeries;
/**
 * Set the default options for bar
 */
defaultPlotOptions.bar = merge(defaultPlotOptions.column);
/**
 * The Bar series class
 */
var BarSeries = extendClass(ColumnSeries, {
	type: 'bar',
	inverted: true
});
seriesTypes.bar = BarSeries;

/**
 * Set the default options for scatter
 */
defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	lineWidth: 0,
	tooltip: {
		headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>',
		followPointer: true
	},
	stickyTracking: false
});

/**
 * The scatter series class
 */
var ScatterSeries = extendClass(Series, {
	type: 'scatter',
	sorted: false,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['markerGroup'],

	drawTracker: ColumnSeries.prototype.drawTracker,
	
	setTooltipPoints: noop
});
seriesTypes.scatter = ScatterSeries;

/**
 * Set the default options for pie
 */
defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	center: [null, null],
	clip: false,
	colorByPoint: true, // always true for pies
	dataLabels: {
		// align: null,
		// connectorWidth: 1,
		// connectorColor: point.color,
		// connectorPadding: 5,
		distance: 30,
		enabled: true,
		formatter: function () {
			return this.point.name;
		}
		// softConnector: true,
		//y: 0
	},
	ignoreHiddenPoint: true,
	//innerSize: 0,
	legendType: 'point',
	marker: null, // point options are specified in the base options
	size: null,
	showInLegend: false,
	slicedOffset: 10,
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		}
	},
	stickyTracking: false,
	tooltip: {
		followPointer: true
	}
});

/**
 * Extended point object for pies
 */
var PiePoint = extendClass(Point, {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		// Disallow negative values (#1530)
		if (point.y < 0) {
			point.y = null;
		}

		//visible: options.visible !== false,
		extend(point, {
			visible: point.visible !== false,
			name: pick(point.name, 'Slice')
		});

		// add event listener for select
		toggleSlice = function (e) {
			point.slice(e.type === 'select');
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis) {
		var point = this,
			series = point.series,
			chart = series.chart,
			method;

		// if called without an argument, toggle visibility
		point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data
		
		method = vis ? 'show' : 'hide';

		// Show and hide associated elements
		each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
			if (point[key]) {
				point[key][method]();
			}
		});

		if (point.legendItem) {
			chart.legend.colorizeItem(point, vis);
		}
		
		// Handle ignore hidden slices
		if (!series.isDirty && series.options.ignoreHiddenPoint) {
			series.isDirty = true;
			chart.redraw();
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			translation;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

		translation = sliced ? point.slicedTranslation : {
			translateX: 0,
			translateY: 0
		};

		point.graphic.animate(translation);
		
		if (point.shadowGroup) {
			point.shadowGroup.animate(translation);
		}

	}
});

/**
 * The Pie series class
 */
var PieSeries = {
	type: 'pie',
	isCartesian: false,
	pointClass: PiePoint,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['group', 'dataLabelsGroup'],
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color'
	},

	/**
	 * Pies have one color each point
	 */
	getColor: noop,

	/**
	 * Animate the pies in
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			startAngleRad = series.startAngleRad;

		if (!init) {
			each(points, function (point) {
				var graphic = point.graphic,
					args = point.shapeArgs;

				if (graphic) {
					// start values
					graphic.attr({
						r: series.center[3] / 2, // animate from inner radius (#779)
						start: startAngleRad,
						end: startAngleRad
					});

					// animate
					graphic.animate({
						r: args.r,
						start: args.start,
						end: args.end
					}, series.options.animation);
				}
			});

			// delete this function to allow it only once
			series.animate = null;
		}
	},

	/**
	 * Extend the basic setData method by running processData and generatePoints immediately,
	 * in order to access the points from the legend.
	 */
	setData: function (data, redraw) {
		Series.prototype.setData.call(this, data, false);
		this.processData();
		this.generatePoints();
		if (pick(redraw, true)) {
			this.chart.redraw();
		} 
	},

	/**
	 * Extend the generatePoints method by adding total and percentage properties to each point
	 */
	generatePoints: function () {
		var i,
			total = 0,
			points,
			len,
			point,
			ignoreHiddenPoint = this.options.ignoreHiddenPoint;

		Series.prototype.generatePoints.call(this);

		// Populate local vars
		points = this.points;
		len = points.length;
		
		// Get the total sum
		for (i = 0; i < len; i++) {
			point = points[i];
			total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
		}
		this.total = total;

		// Set each point's properties
		for (i = 0; i < len; i++) {
			point = points[i];
			point.percentage = total > 0 ? (point.y / total) * 100 : 0;
			point.total = total;
		}
		
	},
	
	/**
	 * Get the center of the pie based on the size and center options relative to the  
	 * plot area. Borrowed by the polar and gauge series types.
	 */
	getCenter: function () {
		
		var options = this.options,
			chart = this.chart,
			slicingRoom = 2 * (options.slicedOffset || 0),
			handleSlicingRoom,
			plotWidth = chart.plotWidth - 2 * slicingRoom,
			plotHeight = chart.plotHeight - 2 * slicingRoom,
			centerOption = options.center,
			positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
			smallestSize = mathMin(plotWidth, plotHeight),
			isPercent;
		
		return map(positions, function (length, i) {
			isPercent = /%$/.test(length);
			handleSlicingRoom = i < 2 || (i === 2 && isPercent);
			return (isPercent ?
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 4: innerSize, relative to smallestSize
				[plotWidth, plotHeight, smallestSize, smallestSize][i] *
					pInt(length) / 100 :
				length) + (handleSlicingRoom ? slicingRoom : 0);
		});
	},
	
	/**
	 * Do translation for pie slices
	 */
	translate: function (positions) {
		this.generatePoints();
		
		var series = this,
			cumulative = 0,
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + options.borderWidth,
			start,
			end,
			angle,
			startAngle = options.startAngle || 0,
			startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
			endAngleRad = series.endAngleRad = mathPI / 180 * ((options.endAngle || (startAngle + 360)) - 90), // docs
			circ = endAngleRad - startAngleRad, //2 * mathPI,
			points = series.points,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance,
			ignoreHiddenPoint = options.ignoreHiddenPoint,
			i,
			len = points.length,
			point;

		// Get positions - either an integer or a percentage string must be given.
		// If positions are passed as a parameter, we're in a recursive loop for adjusting
		// space for data labels.
		if (!positions) {
			series.center = positions = series.getCenter();
		}

		// utility for getting the x value from a given y, used for anticollision logic in data labels
		series.getX = function (y, left) {

			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));

			return positions[0] +
				(left ? -1 : 1) *
				(mathCos(angle) * (positions[2] / 2 + labelDistance));
		};

		// Calculate the geometry for each point
		for (i = 0; i < len; i++) {
			
			point = points[i];
			
			// set start and end angle
			start = startAngleRad + (cumulative * circ);
			if (!ignoreHiddenPoint || point.visible) {
				cumulative += point.percentage / 100;
			}
			end = startAngleRad + (cumulative * circ);

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: mathRound(start * precision) / precision,
				end: mathRound(end * precision) / precision
			};

			// center for the sliced out slice
			angle = (end + start) / 2;
			if (angle > 0.75 * circ) {
				angle -= 2 * mathPI;
			}
			point.slicedTranslation = {
				translateX: mathRound(mathCos(angle) * slicedOffset),
				translateY: mathRound(mathSin(angle) * slicedOffset)
			};

			// set the anchor point for tooltips
			radiusX = mathCos(angle) * positions[2] / 2;
			radiusY = mathSin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];
			
			point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
			point.angle = angle;

			// set the anchor point for data labels
			connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
			point.labelPos = [
				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				labelDistance < 0 ? // alignment
					'center' :
					point.half ? 'right' : 'left', // alignment
				angle // center angle
			];

		}
	},

	setTooltipPoints: noop,
	drawGraph: null,

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			//center,
			graphic,
			//group,
			shadow = series.options.shadow,
			shadowGroup,
			shapeArgs;

		if (shadow && !series.shadowGroup) {
			series.shadowGroup = renderer.g('shadow')
				.add(series.group);
		}

		// draw the slices
		each(series.points, function (point) {
			graphic = point.graphic;
			shapeArgs = point.shapeArgs;
			shadowGroup = point.shadowGroup;

			// put the shadow behind all points
			if (shadow && !shadowGroup) {
				shadowGroup = point.shadowGroup = renderer.g('shadow')
					.add(series.shadowGroup);
			}

			// if the point is sliced, use special translation, else use plot area traslation
			groupTranslation = point.sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			//group.translate(groupTranslation[0], groupTranslation[1]);
			if (shadowGroup) {
				shadowGroup.attr(groupTranslation);
			}

			// draw the slice
			if (graphic) {
				graphic.animate(extend(shapeArgs, groupTranslation));
			} else {
				point.graphic = graphic = renderer.arc(shapeArgs)
					.setRadialReference(series.center)
					.attr(
						point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
					)
					.attr({ 'stroke-linejoin': 'round' })
					.attr(groupTranslation)
					.add(series.group)
					.shadow(shadow, shadowGroup);	
			}

			// detect point specific visibility
			if (point.visible === false) {
				point.setVisible(false);
			}

		});

	},

	/**
	 * Utility for sorting data labels
	 */
	sortByAngle: function (points, sign) {
		points.sort(function (a, b) {
			return a.angle !== undefined && (b.angle - a.angle) * sign;
		});
	},

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	drawDataLabels: function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			connector,
			connectorPath,
			softConnector = pick(options.softConnector, true),
			distanceOption = options.distance,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			outside = distanceOption > 0,
			dataLabel,
			dataLabelWidth,
			labelPos,
			labelHeight,
			halves = [// divide the points into right and left halves for anti collision
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			rankArr,
			i,
			j,
			overflow = [0, 0, 0, 0], // top, right, bottom, left
			sort = function (a, b) {
				return b.y - a.y;
			};

		// get out if not enabled
		if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
			return;
		}

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		// arrange points for detection collision
		each(data, function (point) {
			if (point.dataLabel) { // it may have been cancelled in the base method (#407)
				halves[point.half].push(point);
			}
		});

		// assume equal label heights
		i = 0;
		while (!labelHeight && data[i]) { // #1569
			labelHeight = data[i] && data[i].dataLabel && (data[i].dataLabel.getBBox().height || 21); // 21 is for #968
			i++;
		}

		/* Loop over the points in each half, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		i = 2;
		while (i--) {

			var slots = [],
				slotsLength,
				usedSlots = [],
				points = halves[i],
				pos,
				length = points.length,
				slotIndex;
				
			// Sort by angle
			series.sortByAngle(points, i - 0.5);

			// Only do anti-collision when we are outside the pie and have connectors (#856)
			if (distanceOption > 0) {
				
				// build the slots
				for (pos = centerY - radius - distanceOption; pos <= centerY + radius + distanceOption; pos += labelHeight) {
					slots.push(pos);
					
					// visualize the slot
					/*
					var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
						slotY = pos + chart.plotTop;
					if (!isNaN(slotX)) {
						chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
							.attr({
								'stroke-width': 1,
								stroke: 'silver'
							})
							.add();
						chart.renderer.text('Slot '+ (slots.length - 1), slotX, slotY + 4)
							.attr({
								fill: 'silver'
							}).add();
					}
					*/
				}
				slotsLength = slots.length;
	
				// if there are more values than available slots, remove lowest values
				if (length > slotsLength) {
					// create an array for sorting and ranking the points within each quarter
					rankArr = [].concat(points);
					rankArr.sort(sort);
					j = length;
					while (j--) {
						rankArr[j].rank = j;
					}
					j = length;
					while (j--) {
						if (points[j].rank >= slotsLength) {
							points.splice(j, 1);
						}
					}
					length = points.length;
				}
	
				// The label goes to the nearest open slot, but not closer to the edge than
				// the label's index.
				for (j = 0; j < length; j++) {
	
					point = points[j];
					labelPos = point.labelPos;
	
					var closest = 9999,
						distance,
						slotI;
	
					// find the closest slot index
					for (slotI = 0; slotI < slotsLength; slotI++) {
						distance = mathAbs(slots[slotI] - labelPos[1]);
						if (distance < closest) {
							closest = distance;
							slotIndex = slotI;
						}
					}
	
					// if that slot index is closer to the edges of the slots, move it
					// to the closest appropriate slot
					if (slotIndex < j && slots[j] !== null) { // cluster at the top
						slotIndex = j;
					} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
						slotIndex = slotsLength - length + j;
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					} else {
						// Slot is taken, find next free slot below. In the next run, the next slice will find the
						// slot above these, because it is the closest one
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					}
	
					usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
					slots[slotIndex] = null; // mark as taken
				}
				// sort them in order to fill in from the top
				usedSlots.sort(sort);
			}

			// now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {
				
				var slot, naturalY;

				point = points[j];
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				visibility = point.visible === false ? HIDDEN : VISIBLE;
				naturalY = labelPos[1];
				
				if (distanceOption > 0) {
					slot = usedSlots.pop();
					slotIndex = slot.i;

					// if the slot next to currrent slot is free, the y value is allowed
					// to fall back to the natural position
					y = slot.y;
					if ((naturalY > y && slots[slotIndex + 1] !== null) ||
							(naturalY < y &&  slots[slotIndex - 1] !== null)) {
						y = naturalY;
					}
					
				} else {
					y = naturalY;
				}

				// get the x - use the natural x position for first and last slot, to prevent the top
				// and botton slice connectors from touching each other on either side
				x = options.justify ? 
					seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
					series.getX(slotIndex === 0 || slotIndex === slots.length - 1 ? naturalY : y, i);
				
			
				// Record the placement and visibility
				dataLabel._attr = {
					visibility: visibility,
					align: labelPos[6]
				};
				dataLabel._pos = {
					x: x + options.x +
						({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
					y: y + options.y - 10 // 10 is for the baseline (label vs text)
				};
				dataLabel.connX = x;
				dataLabel.connY = y;
				
						
				// Detect overflowing data labels
				if (this.options.size === null) {
					dataLabelWidth = dataLabel.width;
					// Overflow left
					if (x - dataLabelWidth < connectorPadding) {
						overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);
						
					// Overflow right
					} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
						overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
					}
					
					// Overflow top
					if (y - labelHeight / 2 < 0) {
						overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);
						
					// Overflow left
					} else if (y + labelHeight / 2 > plotHeight) {
						overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
					}
				}
			} // for each point
		} // for each half
		
		// Do not apply the final placement and draw the connectors until we have verified
		// that labels are not spilling over. 
		if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
			
			// Place the labels in the final position
			this.placeDataLabels();
			
			// Draw the connectors
			if (outside && connectorWidth) {
				each(this.points, function (point) {
					connector = point.connector;
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;
					
					if (dataLabel && dataLabel._pos) {
						visibility = dataLabel._attr.visibility;
						x = dataLabel.connX;
						y = dataLabel.connY;
						connectorPath = softConnector ? [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							'C',
							x, y, // first break, next to the label
							2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						] : [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							L,
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						];
		
						if (connector) {
							connector.animate({ d: connectorPath });
							connector.attr('visibility', visibility);
		
						} else {
							point.connector = connector = series.chart.renderer.path(connectorPath).attr({
								'stroke-width': connectorWidth,
								stroke: options.connectorColor || point.color || '#606060',
								visibility: visibility
							})
							.add(series.group);
						}
					} else if (connector) {
						point.connector = connector.destroy();
					}
				});
			}			
		}
	},
	
	/**
	 * Verify whether the data labels are allowed to draw, or we should run more translation and data
	 * label positioning to keep them inside the plot area. Returns true when data labels are ready 
	 * to draw.
	 */
	verifyDataLabelOverflow: function (overflow) {
		
		var center = this.center,
			options = this.options,
			centerOption = options.center,
			minSize = options.minSize || 80,
			newSize = minSize,
			ret;
			
		// Handle horizontal size and center
		if (centerOption[0] !== null) { // Fixed center
			newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);
			
		} else { // Auto center
			newSize = mathMax(
				center[2] - overflow[1] - overflow[3], // horizontal overflow					
				minSize
			);
			center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
		}
		
		// Handle vertical size and center
		if (centerOption[1] !== null) { // Fixed center
			newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);
			
		} else { // Auto center
			newSize = mathMax(
				mathMin(
					newSize,		
					center[2] - overflow[0] - overflow[2] // vertical overflow
				),
				minSize
			);
			center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
		}
		
		// If the size must be decreased, we need to run translate and drawDataLabels again
		if (newSize < center[2]) {
			center[2] = newSize;
			this.translate(center);
			each(this.points, function (point) {
				if (point.dataLabel) {
					point.dataLabel._pos = null; // reset
				}
			});
			this.drawDataLabels();
			
		// Else, return true to indicate that the pie and its labels is within the plot area
		} else {
			ret = true;
		}
		return ret;
	},
	
	/**
	 * Perform the final placement of the data labels after we have verified that they
	 * fall within the plot area.
	 */
	placeDataLabels: function () {
		each(this.points, function (point) {
			var dataLabel = point.dataLabel,
				_pos;
			
			if (dataLabel) {
				_pos = dataLabel._pos;
				if (_pos) {
					dataLabel.attr(dataLabel._attr);			
					dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
					dataLabel.moved = true;
				} else if (dataLabel) {
					dataLabel.attr({ y: -999 });
				}
			}
		});
	},
	
	alignDataLabel: noop,

	/**
	 * Draw point specific tracker objects. Inherit directly from column series.
	 */
	drawTracker: ColumnSeries.prototype.drawTracker,

	/**
	 * Use a simple symbol from column prototype
	 */
	drawLegendSymbol: AreaSeries.prototype.drawLegendSymbol,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: noop

};
PieSeries = extendClass(Series, PieSeries);
seriesTypes.pie = PieSeries;


// global variables
extend(Highcharts, {
	
	// Constructors
	Axis: Axis,
	Chart: Chart,
	Color: Color,
	Legend: Legend,
	Pointer: Pointer,
	Point: Point,
	Tick: Tick,
	Tooltip: Tooltip,
	Renderer: Renderer,
	Series: Series,
	SVGElement: SVGElement,
	SVGRenderer: SVGRenderer,
	
	// Various
	arrayMin: arrayMin,
	arrayMax: arrayMax,
	charts: charts,
	dateFormat: dateFormat,
	format: format,
	pathAnim: pathAnim,
	getOptions: getOptions,
	hasBidiBug: hasBidiBug,
	isTouchDevice: isTouchDevice,
	numberFormat: numberFormat,
	seriesTypes: seriesTypes,
	setOptions: setOptions,
	addEvent: addEvent,
	removeEvent: removeEvent,
	createElement: createElement,
	discardElement: discardElement,
	css: css,
	each: each,
	extend: extend,
	map: map,
	merge: merge,
	pick: pick,
	splat: splat,
	extendClass: extendClass,
	pInt: pInt,
	wrap: wrap,
	svg: hasSVG,
	canvas: useCanVG,
	vml: !hasSVG && !useCanVG,
	product: PRODUCT,
	version: VERSION
});
}());

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJwbHVnaW5zL3VlZGl0b3IvdGhpcmQtcGFydHkvaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLnNyYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PUNsb3N1cmVDb21waWxlcj09XG4vLyBAY29tcGlsYXRpb25fbGV2ZWwgU0lNUExFX09QVElNSVpBVElPTlNcblxuLyoqXG4gKiBAbGljZW5zZSBIaWdoY2hhcnRzIEpTIHYzLjAuNiAoMjAxMy0xMC0wNClcbiAqXG4gKiAoYykgMjAwOS0yMDEzIFRvcnN0ZWluIEjDuG5zaVxuICpcbiAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4gKi9cblxuLy8gSlNMaW50IG9wdGlvbnM6XG4vKmdsb2JhbCBIaWdoY2hhcnRzLCBkb2N1bWVudCwgd2luZG93LCBuYXZpZ2F0b3IsIHNldEludGVydmFsLCBjbGVhckludGVydmFsLCBjbGVhclRpbWVvdXQsIHNldFRpbWVvdXQsIGxvY2F0aW9uLCBqUXVlcnksICQsIGNvbnNvbGUsIGVhY2gsIGdyZXAgKi9cblxuKGZ1bmN0aW9uICgpIHtcbi8vIGVuY2Fwc3VsYXRlZCB2YXJpYWJsZXNcbnZhciBVTkRFRklORUQsXG5cdGRvYyA9IGRvY3VtZW50LFxuXHR3aW4gPSB3aW5kb3csXG5cdG1hdGggPSBNYXRoLFxuXHRtYXRoUm91bmQgPSBtYXRoLnJvdW5kLFxuXHRtYXRoRmxvb3IgPSBtYXRoLmZsb29yLFxuXHRtYXRoQ2VpbCA9IG1hdGguY2VpbCxcblx0bWF0aE1heCA9IG1hdGgubWF4LFxuXHRtYXRoTWluID0gbWF0aC5taW4sXG5cdG1hdGhBYnMgPSBtYXRoLmFicyxcblx0bWF0aENvcyA9IG1hdGguY29zLFxuXHRtYXRoU2luID0gbWF0aC5zaW4sXG5cdG1hdGhQSSA9IG1hdGguUEksXG5cdGRlZzJyYWQgPSBtYXRoUEkgKiAyIC8gMzYwLFxuXG5cblx0Ly8gc29tZSB2YXJpYWJsZXNcblx0dXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0aXNPcGVyYSA9IHdpbi5vcGVyYSxcblx0aXNJRSA9IC9tc2llL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc09wZXJhLFxuXHRkb2NNb2RlOCA9IGRvYy5kb2N1bWVudE1vZGUgPT09IDgsXG5cdGlzV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCksXG5cdGlzRmlyZWZveCA9IC9GaXJlZm94Ly50ZXN0KHVzZXJBZ2VudCksXG5cdGlzVG91Y2hEZXZpY2UgPSAvKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KHVzZXJBZ2VudCksXG5cdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdGhhc1NWRyA9ICEhZG9jLmNyZWF0ZUVsZW1lbnROUyAmJiAhIWRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdCxcblx0aGFzQmlkaUJ1ZyA9IGlzRmlyZWZveCAmJiBwYXJzZUludCh1c2VyQWdlbnQuc3BsaXQoJ0ZpcmVmb3gvJylbMV0sIDEwKSA8IDQsIC8vIGlzc3VlICMzOFxuXHR1c2VDYW5WRyA9ICFoYXNTVkcgJiYgIWlzSUUgJiYgISFkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblx0UmVuZGVyZXIsXG5cdGhhc1RvdWNoID0gZG9jLmRvY3VtZW50RWxlbWVudC5vbnRvdWNoc3RhcnQgIT09IFVOREVGSU5FRCxcblx0c3ltYm9sU2l6ZXMgPSB7fSxcblx0aWRDb3VudGVyID0gMCxcblx0Z2FyYmFnZUJpbixcblx0ZGVmYXVsdE9wdGlvbnMsXG5cdGRhdGVGb3JtYXQsIC8vIGZ1bmN0aW9uXG5cdGdsb2JhbEFuaW1hdGlvbixcblx0cGF0aEFuaW0sXG5cdHRpbWVVbml0cyxcblx0bm9vcCA9IGZ1bmN0aW9uICgpIHt9LFxuXHRjaGFydHMgPSBbXSxcblx0UFJPRFVDVCA9ICdIaWdoY2hhcnRzJyxcblx0VkVSU0lPTiA9ICczLjAuNicsXG5cblx0Ly8gc29tZSBjb25zdGFudHMgZm9yIGZyZXF1ZW50bHkgdXNlZCBzdHJpbmdzXG5cdERJViA9ICdkaXYnLFxuXHRBQlNPTFVURSA9ICdhYnNvbHV0ZScsXG5cdFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcblx0SElEREVOID0gJ2hpZGRlbicsXG5cdFBSRUZJWCA9ICdoaWdoY2hhcnRzLScsXG5cdFZJU0lCTEUgPSAndmlzaWJsZScsXG5cdFBYID0gJ3B4Jyxcblx0Tk9ORSA9ICdub25lJyxcblx0TSA9ICdNJyxcblx0TCA9ICdMJyxcblx0Lypcblx0ICogRW1waXJpY2FsIGxvd2VzdCBwb3NzaWJsZSBvcGFjaXRpZXMgZm9yIFRSQUNLRVJfRklMTFxuXHQgKiBJRTY6IDAuMDAyXG5cdCAqIElFNzogMC4wMDJcblx0ICogSUU4OiAwLjAwMlxuXHQgKiBJRTk6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0ICogSUUxMDogMC4wMDAxIChleHBvcnRpbmcgb25seSlcblx0ICogRkY6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0ICogQ2hyb21lOiAwLjAwMDAwMVxuXHQgKiBTYWZhcmk6IDAuMDAwMDAxXG5cdCAqIE9wZXJhOiAwLjAwMDAwMDAwMDAxICh1bmxpbWl0ZWQpXG5cdCAqL1xuXHRUUkFDS0VSX0ZJTEwgPSAncmdiYSgxOTIsMTkyLDE5MiwnICsgKGhhc1NWRyA/IDAuMDAwMSA6IDAuMDAyKSArICcpJywgLy8gaW52aXNpYmxlIGJ1dCBjbGlja2FibGVcblx0Ly9UUkFDS0VSX0ZJTEwgPSAncmdiYSgxOTIsMTkyLDE5MiwwLjUpJyxcblx0Tk9STUFMX1NUQVRFID0gJycsXG5cdEhPVkVSX1NUQVRFID0gJ2hvdmVyJyxcblx0U0VMRUNUX1NUQVRFID0gJ3NlbGVjdCcsXG5cdE1JTExJU0VDT05EID0gJ21pbGxpc2Vjb25kJyxcblx0U0VDT05EID0gJ3NlY29uZCcsXG5cdE1JTlVURSA9ICdtaW51dGUnLFxuXHRIT1VSID0gJ2hvdXInLFxuXHREQVkgPSAnZGF5Jyxcblx0V0VFSyA9ICd3ZWVrJyxcblx0TU9OVEggPSAnbW9udGgnLFxuXHRZRUFSID0gJ3llYXInLFxuXG5cdC8vIGNvbnN0YW50cyBmb3IgYXR0cmlidXRlc1xuXHRMSU5FQVJfR1JBRElFTlQgPSAnbGluZWFyR3JhZGllbnQnLFxuXHRTVE9QUyA9ICdzdG9wcycsXG5cdFNUUk9LRV9XSURUSCA9ICdzdHJva2Utd2lkdGgnLFxuXG5cdC8vIHRpbWUgbWV0aG9kcywgY2hhbmdlZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBVVEMgaXMgdXNlZFxuXHRtYWtlVGltZSxcblx0Z2V0TWludXRlcyxcblx0Z2V0SG91cnMsXG5cdGdldERheSxcblx0Z2V0RGF0ZSxcblx0Z2V0TW9udGgsXG5cdGdldEZ1bGxZZWFyLFxuXHRzZXRNaW51dGVzLFxuXHRzZXRIb3Vycyxcblx0c2V0RGF0ZSxcblx0c2V0TW9udGgsXG5cdHNldEZ1bGxZZWFyLFxuXG5cblx0Ly8gbG9va3VwIG92ZXIgdGhlIHR5cGVzIGFuZCB0aGUgYXNzb2NpYXRlZCBjbGFzc2VzXG5cdHNlcmllc1R5cGVzID0ge307XG5cbi8vIFRoZSBIaWdoY2hhcnRzIG5hbWVzcGFjZVxud2luLkhpZ2hjaGFydHMgPSB3aW4uSGlnaGNoYXJ0cyA/IGVycm9yKDE2LCB0cnVlKSA6IHt9O1xuXG4vKipcbiAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCB0aGUgbWVtYmVycyBvZiBhbm90aGVyXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGFkZCB0byB0aGUgZmlyc3Qgb25lXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG5cdHZhciBuO1xuXHRpZiAoIWEpIHtcblx0XHRhID0ge307XG5cdH1cblx0Zm9yIChuIGluIGIpIHtcblx0XHRhW25dID0gYltuXTtcblx0fVxuXHRyZXR1cm4gYTtcbn1cblx0XG4vKipcbiAqIERlZXAgbWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0cyBhbmQgcmV0dXJuIGEgdGhpcmQgb2JqZWN0LlxuICogUHJldmlvdXNseSB0aGlzIGZ1bmN0aW9uIHJlZGlyZWN0ZWQgdG8galF1ZXJ5LmV4dGVuZCh0cnVlKSwgYnV0IHRoaXMgaGFkIHR3byBsaW1pdGF0aW9ucy5cbiAqIEZpcnN0LCBpdCBkZWVwIG1lcmdlZCBhcnJheXMsIHdoaWNoIGxlYWQgdG8gd29ya2Fyb3VuZHMgaW4gSGlnaGNoYXJ0cy4gU2Vjb25kLFxuICogaXQgY29waWVkIHByb3BlcnRpZXMgZnJvbSBleHRlbmRlZCBwcm90b3R5cGVzLiBcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG5cdHZhciBpLFxuXHRcdGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0cmV0ID0ge30sXG5cdFx0ZG9Db3B5ID0gZnVuY3Rpb24gKGNvcHksIG9yaWdpbmFsKSB7XG5cdFx0XHR2YXIgdmFsdWUsIGtleTtcblxuXHRcdFx0Ly8gQW4gb2JqZWN0IGlzIHJlcGxhY2luZyBhIHByaW1pdGl2ZVxuXHRcdFx0aWYgKHR5cGVvZiBjb3B5ICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoa2V5IGluIG9yaWdpbmFsKSB7XG5cdFx0XHRcdGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBvcmlnaW5hbFtrZXldO1xuXG5cdFx0XHRcdFx0Ly8gQ29weSB0aGUgY29udGVudHMgb2Ygb2JqZWN0cywgYnV0IG5vdCBhcnJheXMgb3IgRE9NIG5vZGVzXG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJ1xuXHRcdFx0XHRcdFx0XHQmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRjb3B5W2tleV0gPSBkb0NvcHkoY29weVtrZXldIHx8IHt9LCB2YWx1ZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFByaW1pdGl2ZXMgYW5kIGFycmF5cyBhcmUgY29waWVkIG92ZXIgZGlyZWN0bHlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29weVtrZXldID0gb3JpZ2luYWxba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH07XG5cblx0Ly8gRm9yIGVhY2ggYXJndW1lbnQsIGV4dGVuZCB0aGUgcmV0dXJuXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdHJldCA9IGRvQ29weShyZXQsIGFyZ3VtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFRha2UgYW4gYXJyYXkgYW5kIHR1cm4gaW50byBhIGhhc2ggd2l0aCBldmVuIG51bWJlciBhcmd1bWVudHMgYXMga2V5cyBhbmQgb2RkIG51bWJlcnMgYXNcbiAqIHZhbHVlcy4gQWxsb3dzIGNyZWF0aW5nIGNvbnN0YW50cyBmb3IgY29tbW9ubHkgdXNlZCBzdHlsZSBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzIGV0Yy5cbiAqIEF2b2lkIGl0IGluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIHNpdHVhdGlvbnMgbGlrZSBsb29waW5nXG4gKi9cbmZ1bmN0aW9uIGhhc2goKSB7XG5cdHZhciBpID0gMCxcblx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuXHRcdG9iaiA9IHt9O1xuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0b2JqW2FyZ3NbaSsrXV0gPSBhcmdzW2ldO1xuXHR9XG5cdHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIHBhcnNlSW50XG4gKiBAcGFyYW0ge09iamVjdH0gc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1hZyBNYWduaXR1ZGVcbiAqL1xuZnVuY3Rpb24gcEludChzLCBtYWcpIHtcblx0cmV0dXJuIHBhcnNlSW50KHMsIG1hZyB8fCAxMCk7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IHNcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcocykge1xuXHRyZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBudW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcblx0cmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gbG9nMmxpbihudW0pIHtcblx0cmV0dXJuIG1hdGgubG9nKG51bSkgLyBtYXRoLkxOMTA7XG59XG5mdW5jdGlvbiBsaW4ybG9nKG51bSkge1xuXHRyZXR1cm4gbWF0aC5wb3coMTAsIG51bSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGxhc3Qgb2NjdXJlbmNlIG9mIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge01peGVkfSBpdGVtXG4gKi9cbmZ1bmN0aW9uIGVyYXNlKGFyciwgaXRlbSkge1xuXHR2YXIgaSA9IGFyci5sZW5ndGg7XG5cdHdoaWxlIChpLS0pIHtcblx0XHRpZiAoYXJyW2ldID09PSBpdGVtKSB7XG5cdFx0XHRhcnIuc3BsaWNlKGksIDEpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdC8vcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQuIExpa2UgTW9vVG9vbHMnICQuZGVmaW5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuZnVuY3Rpb24gZGVmaW5lZChvYmopIHtcblx0cmV0dXJuIG9iaiAhPT0gVU5ERUZJTkVEICYmIG9iaiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBTZXQgb3IgZ2V0IGFuIGF0dHJpYnV0ZSBvciBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcy4gQ2FuJ3QgdXNlIGpRdWVyeSBhdHRyIGJlY2F1c2VcbiAqIGl0IGF0dGVtcHRzIHRvIHNldCBleHBhbmRvIHByb3BlcnRpZXMgb24gdGhlIFNWRyBlbGVtZW50LCB3aGljaCBpcyBub3QgYWxsb3dlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdG8gcmVjZWl2ZSB0aGUgYXR0cmlidXRlKHMpXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3AgVGhlIHByb3BlcnR5IG9yIGFuIGFiamVjdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgaWYgYSBzaW5nbGUgcHJvcGVydHkgaXMgc2V0XG4gKi9cbmZ1bmN0aW9uIGF0dHIoZWxlbSwgcHJvcCwgdmFsdWUpIHtcblx0dmFyIGtleSxcblx0XHRzZXRBdHRyaWJ1dGUgPSAnc2V0QXR0cmlidXRlJyxcblx0XHRyZXQ7XG5cblx0Ly8gaWYgdGhlIHByb3AgaXMgYSBzdHJpbmdcblx0aWYgKGlzU3RyaW5nKHByb3ApKSB7XG5cdFx0Ly8gc2V0IHRoZSB2YWx1ZVxuXHRcdGlmIChkZWZpbmVkKHZhbHVlKSkge1xuXG5cdFx0XHRlbGVtW3NldEF0dHJpYnV0ZV0ocHJvcCwgdmFsdWUpO1xuXG5cdFx0Ly8gZ2V0IHRoZSB2YWx1ZVxuXHRcdH0gZWxzZSBpZiAoZWxlbSAmJiBlbGVtLmdldEF0dHJpYnV0ZSkgeyAvLyBlbGVtIG5vdCBkZWZpbmVkIHdoZW4gcHJpbnRpbmcgcGllIGRlbW8uLi5cblx0XHRcdHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlKHByb3ApO1xuXHRcdH1cblxuXHQvLyBlbHNlIGlmIHByb3AgaXMgZGVmaW5lZCwgaXQgaXMgYSBoYXNoIG9mIGtleS92YWx1ZSBwYWlyc1xuXHR9IGVsc2UgaWYgKGRlZmluZWQocHJvcCkgJiYgaXNPYmplY3QocHJvcCkpIHtcblx0XHRmb3IgKGtleSBpbiBwcm9wKSB7XG5cdFx0XHRlbGVtW3NldEF0dHJpYnV0ZV0oa2V5LCBwcm9wW2tleV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGFuIGFycmF5LCBhbmQgaWYgbm90LCBtYWtlIGl0IGludG8gYW4gYXJyYXkuIExpa2VcbiAqIE1vb1Rvb2xzJyAkLnNwbGF0LlxuICovXG5mdW5jdGlvbiBzcGxhdChvYmopIHtcblx0cmV0dXJuIGlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IGlzIGRlZmluZWQuIExpa2UgTW9vVG9vbHMnICQucGljay5cbiAqL1xuZnVuY3Rpb24gcGljaygpIHtcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0aSxcblx0XHRhcmcsXG5cdFx0bGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGFyZyA9IGFyZ3NbaV07XG5cdFx0aWYgKHR5cGVvZiBhcmcgIT09ICd1bmRlZmluZWQnICYmIGFyZyAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZztcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgQ1NTIG9uIGEgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIFN0eWxlIG9iamVjdCB3aXRoIGNhbWVsIGNhc2UgcHJvcGVydHkgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY3NzKGVsLCBzdHlsZXMpIHtcblx0aWYgKGlzSUUpIHtcblx0XHRpZiAoc3R5bGVzICYmIHN0eWxlcy5vcGFjaXR5ICE9PSBVTkRFRklORUQpIHtcblx0XHRcdHN0eWxlcy5maWx0ZXIgPSAnYWxwaGEob3BhY2l0eT0nICsgKHN0eWxlcy5vcGFjaXR5ICogMTAwKSArICcpJztcblx0XHR9XG5cdH1cblx0ZXh0ZW5kKGVsLnN0eWxlLCBzdHlsZXMpO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIGFuZCBzdHlsZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gbm9wYWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJpYnMsIHN0eWxlcywgcGFyZW50LCBub3BhZCkge1xuXHR2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuXHRpZiAoYXR0cmlicykge1xuXHRcdGV4dGVuZChlbCwgYXR0cmlicyk7XG5cdH1cblx0aWYgKG5vcGFkKSB7XG5cdFx0Y3NzKGVsLCB7cGFkZGluZzogMCwgYm9yZGVyOiBOT05FLCBtYXJnaW46IDB9KTtcblx0fVxuXHRpZiAoc3R5bGVzKSB7XG5cdFx0Y3NzKGVsLCBzdHlsZXMpO1xuXHR9XG5cdGlmIChwYXJlbnQpIHtcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHR9XG5cdHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBFeHRlbmQgYSBwcm90b3R5cGVkIGNsYXNzIGJ5IG5ldyBtZW1iZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gbWVtYmVyc1xuICovXG5mdW5jdGlvbiBleHRlbmRDbGFzcyhwYXJlbnQsIG1lbWJlcnMpIHtcblx0dmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHt9O1xuXHRvYmplY3QucHJvdG90eXBlID0gbmV3IHBhcmVudCgpO1xuXHRleHRlbmQob2JqZWN0LnByb3RvdHlwZSwgbWVtYmVycyk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGFuZCByZXR1cm4gYSBzdHJpbmcgYmFzZWQgb24gaW5wdXQgc2V0dGluZ3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgVGhlIGlucHV0IG51bWJlciB0byBmb3JtYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFscyBUaGUgYW1vdW50IG9mIGRlY2ltYWxzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVjUG9pbnQgVGhlIGRlY2ltYWwgcG9pbnQsIGRlZmF1bHRzIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gdGhlIGxhbmcgb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHRob3VzYW5kc1NlcCBUaGUgdGhvdXNhbmRzIHNlcGFyYXRvciwgZGVmYXVsdHMgdG8gdGhlIG9uZSBnaXZlbiBpbiB0aGUgbGFuZyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG51bWJlckZvcm1hdChudW1iZXIsIGRlY2ltYWxzLCBkZWNQb2ludCwgdGhvdXNhbmRzU2VwKSB7XG5cdHZhciBsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHQvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldC90ZWNoYmxvZy9hcnRpY2xlL2phdmFzY3JpcHRfZXF1aXZhbGVudF9mb3JfcGhwc19udW1iZXJfZm9ybWF0L1xuXHRcdG4gPSArbnVtYmVyIHx8IDAsXG5cdFx0YyA9IGRlY2ltYWxzID09PSAtMSA/XG5cdFx0XHQobi50b1N0cmluZygpLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aCA6IC8vIHByZXNlcnZlIGRlY2ltYWxzXG5cdFx0XHQoaXNOYU4oZGVjaW1hbHMgPSBtYXRoQWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHMpLFxuXHRcdGQgPSBkZWNQb2ludCA9PT0gdW5kZWZpbmVkID8gbGFuZy5kZWNpbWFsUG9pbnQgOiBkZWNQb2ludCxcblx0XHR0ID0gdGhvdXNhbmRzU2VwID09PSB1bmRlZmluZWQgPyBsYW5nLnRob3VzYW5kc1NlcCA6IHRob3VzYW5kc1NlcCxcblx0XHRzID0gbiA8IDAgPyBcIi1cIiA6IFwiXCIsXG5cdFx0aSA9IFN0cmluZyhwSW50KG4gPSBtYXRoQWJzKG4pLnRvRml4ZWQoYykpKSxcblx0XHRqID0gaS5sZW5ndGggPiAzID8gaS5sZW5ndGggJSAzIDogMDtcblxuXHRyZXR1cm4gcyArIChqID8gaS5zdWJzdHIoMCwgaikgKyB0IDogXCJcIikgKyBpLnN1YnN0cihqKS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZywgXCIkMVwiICsgdCkgK1xuXHRcdChjID8gZCArIG1hdGhBYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiBcIlwiKTtcbn1cblxuLyoqXG4gKiBQYWQgYSBzdHJpbmcgdG8gYSBnaXZlbiBsZW5ndGggYnkgYWRkaW5nIDAgdG8gdGhlIGJlZ2lubmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBwYWQobnVtYmVyLCBsZW5ndGgpIHtcblx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHRoZSByZW1haW5pbmcgbGVuZ3RoICsxIGFuZCBqb2luIGl0IHdpdGggMCdzXG5cdHJldHVybiBuZXcgQXJyYXkoKGxlbmd0aCB8fCAyKSArIDEgLSBTdHJpbmcobnVtYmVyKS5sZW5ndGgpLmpvaW4oMCkgKyBudW1iZXI7XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHksIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IHRoZSBtZXRob2QgYmVsb25ncyB0byBcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgQSB3cmFwcGVyIGZ1bmN0aW9uIGNhbGxiYWNrLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogYXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLCBleGNlcHQgdGhhdCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaXMgdW5zaGlmdGVkIGFuZCBwYXNzZWQgYXMgdGhlIGZpcnN0IFxuICogYXJndW1lbnQuIFxuICovXG5mdW5jdGlvbiB3cmFwKG9iaiwgbWV0aG9kLCBmdW5jKSB7XG5cdHZhciBwcm9jZWVkID0gb2JqW21ldGhvZF07XG5cdG9ialttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRhcmdzLnVuc2hpZnQocHJvY2VlZCk7XG5cdFx0cmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogQmFzZWQgb24gaHR0cDovL3d3dy5waHAubmV0L21hbnVhbC9lbi9mdW5jdGlvbi5zdHJmdGltZS5waHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwaXRhbGl6ZVxuICovXG5kYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdGltZXN0YW1wLCBjYXBpdGFsaXplKSB7XG5cdGlmICghZGVmaW5lZCh0aW1lc3RhbXApIHx8IGlzTmFOKHRpbWVzdGFtcCkpIHtcblx0XHRyZXR1cm4gJ0ludmFsaWQgZGF0ZSc7XG5cdH1cblx0Zm9ybWF0ID0gcGljayhmb3JtYXQsICclWS0lbS0lZCAlSDolTTolUycpO1xuXG5cdHZhciBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKSxcblx0XHRrZXksIC8vIHVzZWQgaW4gZm9yIGNvbnN0dWN0IGJlbG93XG5cdFx0Ly8gZ2V0IHRoZSBiYXNpYyB0aW1lIHZhbHVlc1xuXHRcdGhvdXJzID0gZGF0ZVtnZXRIb3Vyc10oKSxcblx0XHRkYXkgPSBkYXRlW2dldERheV0oKSxcblx0XHRkYXlPZk1vbnRoID0gZGF0ZVtnZXREYXRlXSgpLFxuXHRcdG1vbnRoID0gZGF0ZVtnZXRNb250aF0oKSxcblx0XHRmdWxsWWVhciA9IGRhdGVbZ2V0RnVsbFllYXJdKCksXG5cdFx0bGFuZyA9IGRlZmF1bHRPcHRpb25zLmxhbmcsXG5cdFx0bGFuZ1dlZWtkYXlzID0gbGFuZy53ZWVrZGF5cyxcblxuXHRcdC8vIExpc3QgYWxsIGZvcm1hdCBrZXlzLiBDdXN0b20gZm9ybWF0cyBjYW4gYmUgYWRkZWQgZnJvbSB0aGUgb3V0c2lkZS4gXG5cdFx0cmVwbGFjZW1lbnRzID0gZXh0ZW5kKHtcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHQnYSc6IGxhbmdXZWVrZGF5c1tkYXldLnN1YnN0cigwLCAzKSwgLy8gU2hvcnQgd2Vla2RheSwgbGlrZSAnTW9uJ1xuXHRcdFx0J0EnOiBsYW5nV2Vla2RheXNbZGF5XSwgLy8gTG9uZyB3ZWVrZGF5LCBsaWtlICdNb25kYXknXG5cdFx0XHQnZCc6IHBhZChkYXlPZk1vbnRoKSwgLy8gVHdvIGRpZ2l0IGRheSBvZiB0aGUgbW9udGgsIDAxIHRvIDMxXG5cdFx0XHQnZSc6IGRheU9mTW9udGgsIC8vIERheSBvZiB0aGUgbW9udGgsIDEgdGhyb3VnaCAzMVxuXG5cdFx0XHQvLyBXZWVrIChub25lIGltcGxlbWVudGVkKVxuXHRcdFx0Ly8nVyc6IHdlZWtOdW1iZXIoKSxcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdCdiJzogbGFuZy5zaG9ydE1vbnRoc1ttb250aF0sIC8vIFNob3J0IG1vbnRoLCBsaWtlICdKYW4nXG5cdFx0XHQnQic6IGxhbmcubW9udGhzW21vbnRoXSwgLy8gTG9uZyBtb250aCwgbGlrZSAnSmFudWFyeSdcblx0XHRcdCdtJzogcGFkKG1vbnRoICsgMSksIC8vIFR3byBkaWdpdCBtb250aCBudW1iZXIsIDAxIHRocm91Z2ggMTJcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0J3knOiBmdWxsWWVhci50b1N0cmluZygpLnN1YnN0cigyLCAyKSwgLy8gVHdvIGRpZ2l0cyB5ZWFyLCBsaWtlIDA5IGZvciAyMDA5XG5cdFx0XHQnWSc6IGZ1bGxZZWFyLCAvLyBGb3VyIGRpZ2l0cyB5ZWFyLCBsaWtlIDIwMDlcblxuXHRcdFx0Ly8gVGltZVxuXHRcdFx0J0gnOiBwYWQoaG91cnMpLCAvLyBUd28gZGlnaXRzIGhvdXJzIGluIDI0aCBmb3JtYXQsIDAwIHRocm91Z2ggMjNcblx0XHRcdCdJJzogcGFkKChob3VycyAlIDEyKSB8fCAxMiksIC8vIFR3byBkaWdpdHMgaG91cnMgaW4gMTJoIGZvcm1hdCwgMDAgdGhyb3VnaCAxMVxuXHRcdFx0J2wnOiAoaG91cnMgJSAxMikgfHwgMTIsIC8vIEhvdXJzIGluIDEyaCBmb3JtYXQsIDEgdGhyb3VnaCAxMlxuXHRcdFx0J00nOiBwYWQoZGF0ZVtnZXRNaW51dGVzXSgpKSwgLy8gVHdvIGRpZ2l0cyBtaW51dGVzLCAwMCB0aHJvdWdoIDU5XG5cdFx0XHQncCc6IGhvdXJzIDwgMTIgPyAnQU0nIDogJ1BNJywgLy8gVXBwZXIgY2FzZSBBTSBvciBQTVxuXHRcdFx0J1AnOiBob3VycyA8IDEyID8gJ2FtJyA6ICdwbScsIC8vIExvd2VyIGNhc2UgQU0gb3IgUE1cblx0XHRcdCdTJzogcGFkKGRhdGUuZ2V0U2Vjb25kcygpKSwgLy8gVHdvIGRpZ2l0cyBzZWNvbmRzLCAwMCB0aHJvdWdoICA1OVxuXHRcdFx0J0wnOiBwYWQobWF0aFJvdW5kKHRpbWVzdGFtcCAlIDEwMDApLCAzKSAvLyBNaWxsaXNlY29uZHMgKG5hbWluZyBmcm9tIFJ1YnkpXG5cdFx0fSwgSGlnaGNoYXJ0cy5kYXRlRm9ybWF0cyk7XG5cblxuXHQvLyBkbyB0aGUgcmVwbGFjZXNcblx0Zm9yIChrZXkgaW4gcmVwbGFjZW1lbnRzKSB7XG5cdFx0d2hpbGUgKGZvcm1hdC5pbmRleE9mKCclJyArIGtleSkgIT09IC0xKSB7IC8vIHJlZ2V4IHdvdWxkIGRvIGl0IGluIG9uZSBsaW5lLCBidXQgdGhpcyBpcyBmYXN0ZXJcblx0XHRcdGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCclJyArIGtleSwgdHlwZW9mIHJlcGxhY2VtZW50c1trZXldID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZW1lbnRzW2tleV0odGltZXN0YW1wKSA6IHJlcGxhY2VtZW50c1trZXldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBPcHRpb25hbGx5IGNhcGl0YWxpemUgdGhlIHN0cmluZyBhbmQgcmV0dXJuXG5cdHJldHVybiBjYXBpdGFsaXplID8gZm9ybWF0LnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgZm9ybWF0LnN1YnN0cigxKSA6IGZvcm1hdDtcbn07XG5cbi8qKiBcbiAqIEZvcm1hdCBhIHNpbmdsZSB2YXJpYWJsZS4gU2ltaWxhciB0byBzcHJpbnRmLCB3aXRob3V0IHRoZSAlIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2luZ2xlKGZvcm1hdCwgdmFsKSB7XG5cdHZhciBmbG9hdFJlZ2V4ID0gL2YkLyxcblx0XHRkZWNSZWdleCA9IC9cXC4oWzAtOV0pLyxcblx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRkZWNpbWFscztcblxuXHRpZiAoZmxvYXRSZWdleC50ZXN0KGZvcm1hdCkpIHsgLy8gZmxvYXRcblx0XHRkZWNpbWFscyA9IGZvcm1hdC5tYXRjaChkZWNSZWdleCk7XG5cdFx0ZGVjaW1hbHMgPSBkZWNpbWFscyA/IGRlY2ltYWxzWzFdIDogLTE7XG5cdFx0dmFsID0gbnVtYmVyRm9ybWF0KFxuXHRcdFx0dmFsLFxuXHRcdFx0ZGVjaW1hbHMsXG5cdFx0XHRsYW5nLmRlY2ltYWxQb2ludCxcblx0XHRcdGZvcm1hdC5pbmRleE9mKCcsJykgPiAtMSA/IGxhbmcudGhvdXNhbmRzU2VwIDogJydcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IGRhdGVGb3JtYXQoZm9ybWF0LCB2YWwpO1xuXHR9XG5cdHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc3RyaW5nIGFjY29yZGluZyB0byBhIHN1YnNldCBvZiB0aGUgcnVsZXMgb2YgUHl0aG9uJ3MgU3RyaW5nLmZvcm1hdCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChzdHIsIGN0eCkge1xuXHR2YXIgc3BsaXR0ZXIgPSAneycsXG5cdFx0aXNJbnNpZGUgPSBmYWxzZSxcblx0XHRzZWdtZW50LFxuXHRcdHZhbHVlQW5kRm9ybWF0LFxuXHRcdHBhdGgsXG5cdFx0aSxcblx0XHRsZW4sXG5cdFx0cmV0ID0gW10sXG5cdFx0dmFsLFxuXHRcdGluZGV4O1xuXHRcblx0d2hpbGUgKChpbmRleCA9IHN0ci5pbmRleE9mKHNwbGl0dGVyKSkgIT09IC0xKSB7XG5cdFx0XG5cdFx0c2VnbWVudCA9IHN0ci5zbGljZSgwLCBpbmRleCk7XG5cdFx0aWYgKGlzSW5zaWRlKSB7IC8vIHdlJ3JlIG9uIHRoZSBjbG9zaW5nIGJyYWNrZXQgbG9va2luZyBiYWNrXG5cdFx0XHRcblx0XHRcdHZhbHVlQW5kRm9ybWF0ID0gc2VnbWVudC5zcGxpdCgnOicpO1xuXHRcdFx0cGF0aCA9IHZhbHVlQW5kRm9ybWF0LnNoaWZ0KCkuc3BsaXQoJy4nKTsgLy8gZ2V0IGZpcnN0IGFuZCBsZWF2ZSBmb3JtYXRcblx0XHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXHRcdFx0dmFsID0gY3R4O1xuXG5cdFx0XHQvLyBBc3NpZ24gZGVlcGVyIHBhdGhzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFsID0gdmFsW3BhdGhbaV1dO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JtYXQgdGhlIHJlcGxhY2VtZW50XG5cdFx0XHRpZiAodmFsdWVBbmRGb3JtYXQubGVuZ3RoKSB7XG5cdFx0XHRcdHZhbCA9IGZvcm1hdFNpbmdsZSh2YWx1ZUFuZEZvcm1hdC5qb2luKCc6JyksIHZhbCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1c2ggdGhlIHJlc3VsdCBhbmQgYWR2YW5jZSB0aGUgY3Vyc29yXG5cdFx0XHRyZXQucHVzaCh2YWwpO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldC5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XG5cdFx0fVxuXHRcdHN0ciA9IHN0ci5zbGljZShpbmRleCArIDEpOyAvLyB0aGUgcmVzdFxuXHRcdGlzSW5zaWRlID0gIWlzSW5zaWRlOyAvLyB0b2dnbGVcblx0XHRzcGxpdHRlciA9IGlzSW5zaWRlID8gJ30nIDogJ3snOyAvLyBub3cgbG9vayBmb3IgbmV4dCBtYXRjaGluZyBicmFja2V0XG5cdH1cblx0cmV0LnB1c2goc3RyKTtcblx0cmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1hZ25pdHVkZSBvZiBhIG51bWJlclxuICovXG5mdW5jdGlvbiBnZXRNYWduaXR1ZGUobnVtKSB7XG5cdHJldHVybiBtYXRoLnBvdygxMCwgbWF0aEZsb29yKG1hdGgubG9nKG51bSkgLyBtYXRoLkxOMTApKTtcbn1cblxuLyoqXG4gKiBUYWtlIGFuIGludGVydmFsIGFuZCBub3JtYWxpemUgaXQgdG8gbXVsdGlwbGVzIG9mIDEsIDIsIDIuNSBhbmQgNVxuICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG4gKiBAcGFyYW0ge0FycmF5fSBtdWx0aXBsZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYWduaXR1ZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChpbnRlcnZhbCwgbXVsdGlwbGVzLCBtYWduaXR1ZGUsIG9wdGlvbnMpIHtcblx0dmFyIG5vcm1hbGl6ZWQsIGk7XG5cblx0Ly8gcm91bmQgdG8gYSB0ZW5mb2xkIG9mIDEsIDIsIDIuNSBvciA1XG5cdG1hZ25pdHVkZSA9IHBpY2sobWFnbml0dWRlLCAxKTtcblx0bm9ybWFsaXplZCA9IGludGVydmFsIC8gbWFnbml0dWRlO1xuXG5cdC8vIG11bHRpcGxlcyBmb3IgYSBsaW5lYXIgc2NhbGVcblx0aWYgKCFtdWx0aXBsZXMpIHtcblx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgMi41LCA1LCAxMF07XG5cblx0XHQvLyB0aGUgYWxsb3dEZWNpbWFscyBvcHRpb25cblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93RGVjaW1hbHMgPT09IGZhbHNlKSB7XG5cdFx0XHRpZiAobWFnbml0dWRlID09PSAxKSB7XG5cdFx0XHRcdG11bHRpcGxlcyA9IFsxLCAyLCA1LCAxMF07XG5cdFx0XHR9IGVsc2UgaWYgKG1hZ25pdHVkZSA8PSAwLjEpIHtcblx0XHRcdFx0bXVsdGlwbGVzID0gWzEgLyBtYWduaXR1ZGVdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIG5vcm1hbGl6ZSB0aGUgaW50ZXJ2YWwgdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGVcblx0Zm9yIChpID0gMDsgaSA8IG11bHRpcGxlcy5sZW5ndGg7IGkrKykge1xuXHRcdGludGVydmFsID0gbXVsdGlwbGVzW2ldO1xuXHRcdGlmIChub3JtYWxpemVkIDw9IChtdWx0aXBsZXNbaV0gKyAobXVsdGlwbGVzW2kgKyAxXSB8fCBtdWx0aXBsZXNbaV0pKSAvIDIpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIG11bHRpcGx5IGJhY2sgdG8gdGhlIGNvcnJlY3QgbWFnbml0dWRlXG5cdGludGVydmFsICo9IG1hZ25pdHVkZTtcblxuXHRyZXR1cm4gaW50ZXJ2YWw7XG59XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsaXplZCB0aWNrIGludGVydmFsIGZvciBkYXRlcy4gUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGhcbiAqIHVuaXQgcmFuZ2UgKGludGVydmFsKSwgY291bnQgYW5kIG5hbWUuIFVzZWQgdG8gcHJlcGFyZSBkYXRhIGZvciBnZXRUaW1lVGlja3MuIFxuICogUHJldmlvdXNseSB0aGlzIGxvZ2ljIHdhcyBwYXJ0IG9mIGdldFRpbWVUaWNrcywgYnV0IGFzIGdldFRpbWVUaWNrcyBub3cgcnVuc1xuICogb2Ygc2VnbWVudHMgaW4gc3RvY2sgY2hhcnRzLCB0aGUgbm9ybWFsaXppbmcgbG9naWMgd2FzIGV4dHJhY3RlZCBpbiBvcmRlciB0byBcbiAqIHByZXZlbnQgaXQgZm9yIHJ1bm5pbmcgb3ZlciBhZ2FpbiBmb3IgZWFjaCBzZWdtZW50IGhhdmluZyB0aGUgc2FtZSBpbnRlcnZhbC4gXG4gKiAjNjYyLCAjNjk3LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lVGlja0ludGVydmFsKHRpY2tJbnRlcnZhbCwgdW5pdHNPcHRpb24pIHtcblx0dmFyIHVuaXRzID0gdW5pdHNPcHRpb24gfHwgW1tcblx0XHRcdFx0TUlMTElTRUNPTkQsIC8vIHVuaXQgbmFtZVxuXHRcdFx0XHRbMSwgMiwgNSwgMTAsIDIwLCAyNSwgNTAsIDEwMCwgMjAwLCA1MDBdIC8vIGFsbG93ZWQgbXVsdGlwbGVzXG5cdFx0XHRdLCBbXG5cdFx0XHRcdFNFQ09ORCxcblx0XHRcdFx0WzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdFx0XHRdLCBbXG5cdFx0XHRcdE1JTlVURSxcblx0XHRcdFx0WzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdFx0XHRdLCBbXG5cdFx0XHRcdEhPVVIsXG5cdFx0XHRcdFsxLCAyLCAzLCA0LCA2LCA4LCAxMl1cblx0XHRcdF0sIFtcblx0XHRcdFx0REFZLFxuXHRcdFx0XHRbMSwgMl1cblx0XHRcdF0sIFtcblx0XHRcdFx0V0VFSyxcblx0XHRcdFx0WzEsIDJdXG5cdFx0XHRdLCBbXG5cdFx0XHRcdE1PTlRILFxuXHRcdFx0XHRbMSwgMiwgMywgNCwgNl1cblx0XHRcdF0sIFtcblx0XHRcdFx0WUVBUixcblx0XHRcdFx0bnVsbFxuXHRcdFx0XV0sXG5cdFx0dW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdLCAvLyBkZWZhdWx0IHVuaXQgaXMgeWVhcnNcblx0XHRpbnRlcnZhbCA9IHRpbWVVbml0c1t1bml0WzBdXSxcblx0XHRtdWx0aXBsZXMgPSB1bml0WzFdLFxuXHRcdGNvdW50LFxuXHRcdGk7XG5cdFx0XG5cdC8vIGxvb3AgdGhyb3VnaCB0aGUgdW5pdHMgdG8gZmluZCB0aGUgb25lIHRoYXQgYmVzdCBmaXRzIHRoZSB0aWNrSW50ZXJ2YWxcblx0Zm9yIChpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dW5pdCA9IHVuaXRzW2ldO1xuXHRcdGludGVydmFsID0gdGltZVVuaXRzW3VuaXRbMF1dO1xuXHRcdG11bHRpcGxlcyA9IHVuaXRbMV07XG5cblxuXHRcdGlmICh1bml0c1tpICsgMV0pIHtcblx0XHRcdC8vIGxlc3NUaGFuIGlzIGluIHRoZSBtaWRkbGUgYmV0d2VlbiB0aGUgaGlnaGVzdCBtdWx0aXBsZSBhbmQgdGhlIG5leHQgdW5pdC5cblx0XHRcdHZhciBsZXNzVGhhbiA9IChpbnRlcnZhbCAqIG11bHRpcGxlc1ttdWx0aXBsZXMubGVuZ3RoIC0gMV0gK1xuXHRcdFx0XHRcdFx0dGltZVVuaXRzW3VuaXRzW2kgKyAxXVswXV0pIC8gMjtcblxuXHRcdFx0Ly8gYnJlYWsgYW5kIGtlZXAgdGhlIGN1cnJlbnQgdW5pdFxuXHRcdFx0aWYgKHRpY2tJbnRlcnZhbCA8PSBsZXNzVGhhbikge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBwcmV2ZW50IDIuNSB5ZWFycyBpbnRlcnZhbHMsIHRob3VnaCAyNSwgMjUwIGV0Yy4gYXJlIGFsbG93ZWRcblx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHNbWUVBUl0gJiYgdGlja0ludGVydmFsIDwgNSAqIGludGVydmFsKSB7XG5cdFx0bXVsdGlwbGVzID0gWzEsIDIsIDVdO1xuXHR9XG5cblx0Ly8gZ2V0IHRoZSBjb3VudFxuXHRjb3VudCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChcblx0XHR0aWNrSW50ZXJ2YWwgLyBpbnRlcnZhbCwgXG5cdFx0bXVsdGlwbGVzLFxuXHRcdHVuaXRbMF0gPT09IFlFQVIgPyBnZXRNYWduaXR1ZGUodGlja0ludGVydmFsIC8gaW50ZXJ2YWwpIDogMSAvLyAjMTkxM1xuXHQpO1xuXHRcblx0cmV0dXJuIHtcblx0XHR1bml0UmFuZ2U6IGludGVydmFsLFxuXHRcdGNvdW50OiBjb3VudCxcblx0XHR1bml0TmFtZTogdW5pdFswXVxuXHR9O1xufVxuXG4vKipcbiAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgdG8gYSB0aW1lIHVuaXQgdGhhdCBtYWtlcyBzZW5zZSwgZm9yIGV4YW1wbGVcbiAqIG9uIHRoZSBmaXJzdCBvZiBlYWNoIG1vbnRoIG9yIG9uIGV2ZXJ5IE1vbmRheS4gUmV0dXJuIGFuIGFycmF5XG4gKiB3aXRoIHRoZSB0aW1lIHBvc2l0aW9ucy4gVXNlZCBpbiBkYXRldGltZSBheGVzIGFzIHdlbGwgYXMgZm9yIGdyb3VwaW5nXG4gKiBkYXRhIG9uIGEgZGF0ZXRpbWUgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsaXplZEludGVydmFsIFRoZSBpbnRlcnZhbCBpbiBheGlzIHZhbHVlcyAobXMpIGFuZCB0aGUgY291bnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gaW4gYXhpcyB2YWx1ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggVGhlIG1heGltdW0gaW4gYXhpcyB2YWx1ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mV2Vla1xuICovXG5mdW5jdGlvbiBnZXRUaW1lVGlja3Mobm9ybWFsaXplZEludGVydmFsLCBtaW4sIG1heCwgc3RhcnRPZldlZWspIHtcblx0dmFyIHRpY2tQb3NpdGlvbnMgPSBbXSxcblx0XHRpLFxuXHRcdGhpZ2hlclJhbmtzID0ge30sXG5cdFx0dXNlVVRDID0gZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLnVzZVVUQyxcblx0XHRtaW5ZZWFyLCAvLyB1c2VkIGluIG1vbnRocyBhbmQgeWVhcnMgYXMgYSBiYXNpcyBmb3IgRGF0ZS5VVEMoKVxuXHRcdG1pbkRhdGUgPSBuZXcgRGF0ZShtaW4pLFxuXHRcdGludGVydmFsID0gbm9ybWFsaXplZEludGVydmFsLnVuaXRSYW5nZSxcblx0XHRjb3VudCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC5jb3VudDtcblxuXHRpZiAoZGVmaW5lZChtaW4pKSB7IC8vICMxMzAwXG5cdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0c1tTRUNPTkRdKSB7IC8vIHNlY29uZFxuXHRcdFx0bWluRGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG5cdFx0XHRtaW5EYXRlLnNldFNlY29uZHMoaW50ZXJ2YWwgPj0gdGltZVVuaXRzW01JTlVURV0gPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZS5nZXRTZWNvbmRzKCkgLyBjb3VudCkpO1xuXHRcdH1cblx0XG5cdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0c1tNSU5VVEVdKSB7IC8vIG1pbnV0ZVxuXHRcdFx0bWluRGF0ZVtzZXRNaW51dGVzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHNbSE9VUl0gPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRNaW51dGVzXSgpIC8gY291bnQpKTtcblx0XHR9XG5cdFxuXHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHNbSE9VUl0pIHsgLy8gaG91clxuXHRcdFx0bWluRGF0ZVtzZXRIb3Vyc10oaW50ZXJ2YWwgPj0gdGltZVVuaXRzW0RBWV0gPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRIb3Vyc10oKSAvIGNvdW50KSk7XG5cdFx0fVxuXHRcblx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzW0RBWV0pIHsgLy8gZGF5XG5cdFx0XHRtaW5EYXRlW3NldERhdGVdKGludGVydmFsID49IHRpbWVVbml0c1tNT05USF0gPyAxIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXREYXRlXSgpIC8gY291bnQpKTtcblx0XHR9XG5cdFxuXHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHNbTU9OVEhdKSB7IC8vIG1vbnRoXG5cdFx0XHRtaW5EYXRlW3NldE1vbnRoXShpbnRlcnZhbCA+PSB0aW1lVW5pdHNbWUVBUl0gPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRNb250aF0oKSAvIGNvdW50KSk7XG5cdFx0XHRtaW5ZZWFyID0gbWluRGF0ZVtnZXRGdWxsWWVhcl0oKTtcblx0XHR9XG5cdFxuXHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHNbWUVBUl0pIHsgLy8geWVhclxuXHRcdFx0bWluWWVhciAtPSBtaW5ZZWFyICUgY291bnQ7XG5cdFx0XHRtaW5EYXRlW3NldEZ1bGxZZWFyXShtaW5ZZWFyKTtcblx0XHR9XG5cdFxuXHRcdC8vIHdlZWsgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBydW5zIG91dHNpZGUgdGhlIGhpZXJhcmNoeVxuXHRcdGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzW1dFRUtdKSB7XG5cdFx0XHQvLyBnZXQgc3RhcnQgb2YgY3VycmVudCB3ZWVrLCBpbmRlcGVuZGVudCBvZiBjb3VudFxuXHRcdFx0bWluRGF0ZVtzZXREYXRlXShtaW5EYXRlW2dldERhdGVdKCkgLSBtaW5EYXRlW2dldERheV0oKSArXG5cdFx0XHRcdHBpY2soc3RhcnRPZldlZWssIDEpKTtcblx0XHR9XG5cdFxuXHRcblx0XHQvLyBnZXQgdGljayBwb3NpdGlvbnNcblx0XHRpID0gMTtcblx0XHRtaW5ZZWFyID0gbWluRGF0ZVtnZXRGdWxsWWVhcl0oKTtcblx0XHR2YXIgdGltZSA9IG1pbkRhdGUuZ2V0VGltZSgpLFxuXHRcdFx0bWluTW9udGggPSBtaW5EYXRlW2dldE1vbnRoXSgpLFxuXHRcdFx0bWluRGF0ZURhdGUgPSBtaW5EYXRlW2dldERhdGVdKCksXG5cdFx0XHR0aW1lem9uZU9mZnNldCA9IHVzZVVUQyA/IFxuXHRcdFx0XHQwIDogXG5cdFx0XHRcdCgyNCAqIDM2MDAgKiAxMDAwICsgbWluRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwKSAlICgyNCAqIDM2MDAgKiAxMDAwKTsgLy8gIzk1MFxuXHRcblx0XHQvLyBpdGVyYXRlIGFuZCBhZGQgdGljayBwb3NpdGlvbnMgYXQgYXBwcm9wcmlhdGUgdmFsdWVzXG5cdFx0d2hpbGUgKHRpbWUgPCBtYXgpIHtcblx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaCh0aW1lKTtcblx0XG5cdFx0XHQvLyBpZiB0aGUgaW50ZXJ2YWwgaXMgeWVhcnMsIHVzZSBEYXRlLlVUQyB0byBpbmNyZWFzZSB5ZWFyc1xuXHRcdFx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHNbWUVBUl0pIHtcblx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIgKyBpICogY291bnQsIDApO1xuXHRcblx0XHRcdC8vIGlmIHRoZSBpbnRlcnZhbCBpcyBtb250aHMsIHVzZSBEYXRlLlVUQyB0byBpbmNyZWFzZSBtb250aHNcblx0XHRcdH0gZWxzZSBpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0c1tNT05USF0pIHtcblx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIsIG1pbk1vbnRoICsgaSAqIGNvdW50KTtcblx0XG5cdFx0XHQvLyBpZiB3ZSdyZSB1c2luZyBnbG9iYWwgdGltZSwgdGhlIGludGVydmFsIGlzIG5vdCBmaXhlZCBhcyBpdCBqdW1wc1xuXHRcdFx0Ly8gb25lIGhvdXIgYXQgdGhlIERTVCBjcm9zc292ZXJcblx0XHRcdH0gZWxzZSBpZiAoIXVzZVVUQyAmJiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0c1tEQVldIHx8IGludGVydmFsID09PSB0aW1lVW5pdHNbV0VFS10pKSB7XG5cdFx0XHRcdHRpbWUgPSBtYWtlVGltZShtaW5ZZWFyLCBtaW5Nb250aCwgbWluRGF0ZURhdGUgK1xuXHRcdFx0XHRcdGkgKiBjb3VudCAqIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzW0RBWV0gPyAxIDogNykpO1xuXHRcblx0XHRcdC8vIGVsc2UsIHRoZSBpbnRlcnZhbCBpcyBmaXhlZCBhbmQgd2UgdXNlIHNpbXBsZSBhZGRpdGlvblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGltZSArPSBpbnRlcnZhbCAqIGNvdW50O1xuXHRcdFx0fVxuXHRcblx0XHRcdGkrKztcblx0XHR9XG5cdFxuXHRcdC8vIHB1c2ggdGhlIGxhc3QgdGltZVxuXHRcdHRpY2tQb3NpdGlvbnMucHVzaCh0aW1lKTtcblxuXG5cdFx0Ly8gbWFyayBuZXcgZGF5cyBpZiB0aGUgdGltZSBpcyBkaXZpZGlibGUgYnkgZGF5ICgjMTY0OSwgIzE3NjApXG5cdFx0ZWFjaChncmVwKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJ2YWwgPD0gdGltZVVuaXRzW0hPVVJdICYmIHRpbWUgJSB0aW1lVW5pdHNbREFZXSA9PT0gdGltZXpvbmVPZmZzZXQ7XG5cdFx0fSksIGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHRoaWdoZXJSYW5rc1t0aW1lXSA9IERBWTtcblx0XHR9KTtcblx0fVxuXG5cblx0Ly8gcmVjb3JkIGluZm9ybWF0aW9uIG9uIHRoZSBjaG9zZW4gdW5pdCAtIGZvciBkeW5hbWljIGxhYmVsIGZvcm1hdHRlclxuXHR0aWNrUG9zaXRpb25zLmluZm8gPSBleHRlbmQobm9ybWFsaXplZEludGVydmFsLCB7XG5cdFx0aGlnaGVyUmFua3M6IGhpZ2hlclJhbmtzLFxuXHRcdHRvdGFsUmFuZ2U6IGludGVydmFsICogY291bnRcblx0fSk7XG5cblx0cmV0dXJuIHRpY2tQb3NpdGlvbnM7XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRoYXQgY29udGFpbnMgdmFyaXVvcyBjb3VudGVycyB0aGF0IGFyZSBsb2NhbCB0byB0aGUgY2hhcnQuXG4gKi9cbmZ1bmN0aW9uIENoYXJ0Q291bnRlcnMoKSB7XG5cdHRoaXMuY29sb3IgPSAwO1xuXHR0aGlzLnN5bWJvbCA9IDA7XG59XG5cbkNoYXJ0Q291bnRlcnMucHJvdG90eXBlID0gIHtcblx0LyoqXG5cdCAqIFdyYXBzIHRoZSBjb2xvciBjb3VudGVyIGlmIGl0IHJlYWNoZXMgdGhlIHNwZWNpZmllZCBsZW5ndGguXG5cdCAqL1xuXHR3cmFwQ29sb3I6IGZ1bmN0aW9uIChsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5jb2xvciA+PSBsZW5ndGgpIHtcblx0XHRcdHRoaXMuY29sb3IgPSAwO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogV3JhcHMgdGhlIHN5bWJvbCBjb3VudGVyIGlmIGl0IHJlYWNoZXMgdGhlIHNwZWNpZmllZCBsZW5ndGguXG5cdCAqL1xuXHR3cmFwU3ltYm9sOiBmdW5jdGlvbiAobGVuZ3RoKSB7XG5cdFx0aWYgKHRoaXMuc3ltYm9sID49IGxlbmd0aCkge1xuXHRcdFx0dGhpcy5zeW1ib2wgPSAwO1xuXHRcdH1cblx0fVxufTtcblxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRoYXQgc29ydHMgYW4gb2JqZWN0IGFycmF5IGFuZCBrZWVwaW5nIHRoZSBvcmRlciBvZiBlcXVhbCBpdGVtcy5cbiAqIEVDTUEgc2NyaXB0IHN0YW5kYXJkIGRvZXMgbm90IHNwZWNpZnkgdGhlIGJlaGF2aW91ciB3aGVuIGl0ZW1zIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIHNvcnRGdW5jdGlvbikge1xuXHR2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCxcblx0XHRzb3J0VmFsdWUsXG5cdFx0aTtcblxuXHQvLyBBZGQgaW5kZXggdG8gZWFjaCBpdGVtXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGFycltpXS5zc19pID0gaTsgLy8gc3RhYmxlIHNvcnQgaW5kZXhcblx0fVxuXG5cdGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0c29ydFZhbHVlID0gc29ydEZ1bmN0aW9uKGEsIGIpO1xuXHRcdHJldHVybiBzb3J0VmFsdWUgPT09IDAgPyBhLnNzX2kgLSBiLnNzX2kgOiBzb3J0VmFsdWU7XG5cdH0pO1xuXG5cdC8vIFJlbW92ZSBpbmRleCBmcm9tIGl0ZW1zXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGRlbGV0ZSBhcnJbaV0uc3NfaTsgLy8gc3RhYmxlIHNvcnQgaW5kZXhcblx0fVxufVxuXG4vKipcbiAqIE5vbi1yZWN1cnNpdmUgbWV0aG9kIHRvIGZpbmQgdGhlIGxvd2VzdCBtZW1iZXIgb2YgYW4gYXJyYXkuIE1hdGgubWluIHJhaXNlcyBhIG1heGltdW1cbiAqIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZCBlcnJvciBpbiBDaHJvbWUgd2hlbiB0cnlpbmcgdG8gYXBwbHkgbW9yZSB0aGFuIDE1MC4wMDAgcG9pbnRzLiBUaGlzXG4gKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNaW4oZGF0YSkge1xuXHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdG1pbiA9IGRhdGFbMF07XG5cblx0d2hpbGUgKGktLSkge1xuXHRcdGlmIChkYXRhW2ldIDwgbWluKSB7XG5cdFx0XHRtaW4gPSBkYXRhW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIE5vbi1yZWN1cnNpdmUgbWV0aG9kIHRvIGZpbmQgdGhlIGxvd2VzdCBtZW1iZXIgb2YgYW4gYXJyYXkuIE1hdGgubWluIHJhaXNlcyBhIG1heGltdW1cbiAqIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZCBlcnJvciBpbiBDaHJvbWUgd2hlbiB0cnlpbmcgdG8gYXBwbHkgbW9yZSB0aGFuIDE1MC4wMDAgcG9pbnRzLiBUaGlzXG4gKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXgoZGF0YSkge1xuXHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdG1heCA9IGRhdGFbMF07XG5cblx0d2hpbGUgKGktLSkge1xuXHRcdGlmIChkYXRhW2ldID4gbWF4KSB7XG5cdFx0XHRtYXggPSBkYXRhW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRoYXQgZGVzdHJveXMgYW55IFNWR0VsZW1lbnQgb3IgVk1MRWxlbWVudCB0aGF0IGFyZSBwcm9wZXJ0aWVzIG9uIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBJdCBsb29wcyBhbGwgcHJvcGVydGllcyBhbmQgaW52b2tlcyBkZXN0cm95IGlmIHRoZXJlIGlzIGEgZGVzdHJveSBtZXRob2QuIFRoZSBwcm9wZXJ0eSBpc1xuICogdGhlbiBkZWxldGUnZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gVGhlIG9iamVjdCB0byBkZXN0cm95IHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBFeGNlcHRpb24sIGRvIG5vdCBkZXN0cm95IHRoaXMgcHJvcGVydHksIG9ubHkgZGVsZXRlIGl0LlxuICovXG5mdW5jdGlvbiBkZXN0cm95T2JqZWN0UHJvcGVydGllcyhvYmosIGV4Y2VwdCkge1xuXHR2YXIgbjtcblx0Zm9yIChuIGluIG9iaikge1xuXHRcdC8vIElmIHRoZSBvYmplY3QgaXMgbm9uLW51bGwgYW5kIGRlc3Ryb3kgaXMgZGVmaW5lZFxuXHRcdGlmIChvYmpbbl0gJiYgb2JqW25dICE9PSBleGNlcHQgJiYgb2JqW25dLmRlc3Ryb3kpIHtcblx0XHRcdC8vIEludm9rZSB0aGUgZGVzdHJveVxuXHRcdFx0b2JqW25dLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHQvLyBEZWxldGUgdGhlIHByb3BlcnR5IGZyb20gdGhlIG9iamVjdC5cblx0XHRkZWxldGUgb2JqW25dO1xuXHR9XG59XG5cblxuLyoqXG4gKiBEaXNjYXJkIGFuIGVsZW1lbnQgYnkgbW92aW5nIGl0IHRvIHRoZSBiaW4gYW5kIGRlbGV0ZVxuICogQHBhcmFtIHtPYmplY3R9IFRoZSBIVE1MIG5vZGUgdG8gZGlzY2FyZFxuICovXG5mdW5jdGlvbiBkaXNjYXJkRWxlbWVudChlbGVtZW50KSB7XG5cdC8vIGNyZWF0ZSBhIGdhcmJhZ2UgYmluIGVsZW1lbnQsIG5vdCBwYXJ0IG9mIHRoZSBET01cblx0aWYgKCFnYXJiYWdlQmluKSB7XG5cdFx0Z2FyYmFnZUJpbiA9IGNyZWF0ZUVsZW1lbnQoRElWKTtcblx0fVxuXG5cdC8vIG1vdmUgdGhlIG5vZGUgYW5kIGVtcHR5IGJpblxuXHRpZiAoZWxlbWVudCkge1xuXHRcdGdhcmJhZ2VCaW4uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdH1cblx0Z2FyYmFnZUJpbi5pbm5lckhUTUwgPSAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGVycm9yIG1lc3NhZ2VzIGZvciBkZWJ1Z2dpbmcsIHdpdGggbGlua3MgdG8gb25saW5lIGV4cGxhbmF0aW9uIFxuICovXG5mdW5jdGlvbiBlcnJvcihjb2RlLCBzdG9wKSB7XG5cdHZhciBtc2cgPSAnSGlnaGNoYXJ0cyBlcnJvciAjJyArIGNvZGUgKyAnOiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzLycgKyBjb2RlO1xuXHRpZiAoc3RvcCkge1xuXHRcdHRocm93IG1zZztcblx0fSBlbHNlIGlmICh3aW4uY29uc29sZSkge1xuXHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBGaXggSlMgcm91bmQgb2ZmIGZsb2F0IGVycm9yc1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICovXG5mdW5jdGlvbiBjb3JyZWN0RmxvYXQobnVtKSB7XG5cdHJldHVybiBwYXJzZUZsb2F0KFxuXHRcdG51bS50b1ByZWNpc2lvbigxNClcblx0KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGdsb2JhbCBhbmltYXRpb24gdG8gZWl0aGVyIGEgZ2l2ZW4gdmFsdWUsIG9yIGZhbGwgYmFjayB0byB0aGVcbiAqIGdpdmVuIGNoYXJ0J3MgYW5pbWF0aW9uIG9wdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KSB7XG5cdGdsb2JhbEFuaW1hdGlvbiA9IHBpY2soYW5pbWF0aW9uLCBjaGFydC5hbmltYXRpb24pO1xufVxuXG4vKipcbiAqIFRoZSB0aW1lIHVuaXQgbG9va3VwXG4gKi9cbi8qanNsaW50IHdoaXRlOiB0cnVlKi9cbnRpbWVVbml0cyA9IGhhc2goXG5cdE1JTExJU0VDT05ELCAxLFxuXHRTRUNPTkQsIDEwMDAsXG5cdE1JTlVURSwgNjAwMDAsXG5cdEhPVVIsIDM2MDAwMDAsXG5cdERBWSwgMjQgKiAzNjAwMDAwLFxuXHRXRUVLLCA3ICogMjQgKiAzNjAwMDAwLFxuXHRNT05USCwgMzEgKiAyNCAqIDM2MDAwMDAsXG5cdFlFQVIsIDMxNTU2OTUyMDAwXG4pO1xuLypqc2xpbnQgd2hpdGU6IGZhbHNlKi9cbi8qKlxuICogUGF0aCBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobSB1c2VkIGFjcm9zcyBhZGFwdGVyc1xuICovXG5wYXRoQW5pbSA9IHtcblx0LyoqXG5cdCAqIFByZXBhcmUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgc28gdGhhdCB0aGUgcGF0aCBjYW4gYmUgYW5pbWF0ZWQgb25lIHRvIG9uZVxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKGVsZW0sIGZyb21ELCB0b0QpIHtcblx0XHRmcm9tRCA9IGZyb21EIHx8ICcnO1xuXHRcdHZhciBzaGlmdCA9IGVsZW0uc2hpZnQsXG5cdFx0XHRiZXppZXIgPSBmcm9tRC5pbmRleE9mKCdDJykgPiAtMSxcblx0XHRcdG51bVBhcmFtcyA9IGJlemllciA/IDcgOiAzLFxuXHRcdFx0ZW5kTGVuZ3RoLFxuXHRcdFx0c2xpY2UsXG5cdFx0XHRpLFxuXHRcdFx0c3RhcnQgPSBmcm9tRC5zcGxpdCgnICcpLFxuXHRcdFx0ZW5kID0gW10uY29uY2F0KHRvRCksIC8vIGNvcHlcblx0XHRcdHN0YXJ0QmFzZUxpbmUsXG5cdFx0XHRlbmRCYXNlTGluZSxcblx0XHRcdHNpeGlmeSA9IGZ1bmN0aW9uIChhcnIpIHsgLy8gaW4gc3BsaW5lcyBtYWtlIG1vdmUgcG9pbnRzIGhhdmUgc2l4IHBhcmFtZXRlcnMgbGlrZSBiZXppZXIgY3VydmVzXG5cdFx0XHRcdGkgPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGFycltpXSA9PT0gTSkge1xuXHRcdFx0XHRcdFx0YXJyLnNwbGljZShpICsgMSwgMCwgYXJyW2kgKyAxXSwgYXJyW2kgKyAyXSwgYXJyW2kgKyAxXSwgYXJyW2kgKyAyXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKGJlemllcikge1xuXHRcdFx0c2l4aWZ5KHN0YXJ0KTtcblx0XHRcdHNpeGlmeShlbmQpO1xuXHRcdH1cblxuXHRcdC8vIHB1bGwgb3V0IHRoZSBiYXNlIGxpbmVzIGJlZm9yZSBwYWRkaW5nXG5cdFx0aWYgKGVsZW0uaXNBcmVhKSB7XG5cdFx0XHRzdGFydEJhc2VMaW5lID0gc3RhcnQuc3BsaWNlKHN0YXJ0Lmxlbmd0aCAtIDYsIDYpO1xuXHRcdFx0ZW5kQmFzZUxpbmUgPSBlbmQuc3BsaWNlKGVuZC5sZW5ndGggLSA2LCA2KTtcblx0XHR9XG5cblx0XHQvLyBpZiBzaGlmdGluZyBwb2ludHMsIHByZXBlbmQgYSBkdW1teSBwb2ludCB0byB0aGUgZW5kIHBhdGhcblx0XHRpZiAoc2hpZnQgPD0gZW5kLmxlbmd0aCAvIG51bVBhcmFtcyAmJiBzdGFydC5sZW5ndGggPT09IGVuZC5sZW5ndGgpIHtcblx0XHRcdHdoaWxlIChzaGlmdC0tKSB7XG5cdFx0XHRcdGVuZCA9IFtdLmNvbmNhdChlbmQpLnNwbGljZSgwLCBudW1QYXJhbXMpLmNvbmNhdChlbmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbGVtLnNoaWZ0ID0gMDsgLy8gcmVzZXQgZm9yIGZvbGxvd2luZyBhbmltYXRpb25zXG5cblx0XHQvLyBjb3B5IGFuZCBhcHBlbmQgbGFzdCBwb2ludCB1bnRpbCB0aGUgbGVuZ3RoIG1hdGNoZXMgdGhlIGVuZCBsZW5ndGhcblx0XHRpZiAoc3RhcnQubGVuZ3RoKSB7XG5cdFx0XHRlbmRMZW5ndGggPSBlbmQubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKHN0YXJ0Lmxlbmd0aCA8IGVuZExlbmd0aCkge1xuXG5cdFx0XHRcdC8vYmV6aWVyICYmIHNpeGlmeShzdGFydCk7XG5cdFx0XHRcdHNsaWNlID0gW10uY29uY2F0KHN0YXJ0KS5zcGxpY2Uoc3RhcnQubGVuZ3RoIC0gbnVtUGFyYW1zLCBudW1QYXJhbXMpO1xuXHRcdFx0XHRpZiAoYmV6aWVyKSB7IC8vIGRpc2FibGUgZmlyc3QgY29udHJvbCBwb2ludFxuXHRcdFx0XHRcdHNsaWNlW251bVBhcmFtcyAtIDZdID0gc2xpY2VbbnVtUGFyYW1zIC0gMl07XG5cdFx0XHRcdFx0c2xpY2VbbnVtUGFyYW1zIC0gNV0gPSBzbGljZVtudW1QYXJhbXMgLSAxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydCA9IHN0YXJ0LmNvbmNhdChzbGljZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHN0YXJ0QmFzZUxpbmUpIHsgLy8gYXBwZW5kIHRoZSBiYXNlIGxpbmVzIGZvciBhcmVhc1xuXHRcdFx0c3RhcnQgPSBzdGFydC5jb25jYXQoc3RhcnRCYXNlTGluZSk7XG5cdFx0XHRlbmQgPSBlbmQuY29uY2F0KGVuZEJhc2VMaW5lKTtcblx0XHR9XG5cdFx0cmV0dXJuIFtzdGFydCwgZW5kXTtcblx0fSxcblxuXHQvKipcblx0ICogSW50ZXJwb2xhdGUgZWFjaCB2YWx1ZSBvZiB0aGUgcGF0aCBhbmQgcmV0dXJuIHRoZSBhcnJheVxuXHQgKi9cblx0c3RlcDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBvcywgY29tcGxldGUpIHtcblx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRpID0gc3RhcnQubGVuZ3RoLFxuXHRcdFx0c3RhcnRWYWw7XG5cblx0XHRpZiAocG9zID09PSAxKSB7IC8vIGxhbmQgb24gdGhlIGZpbmFsIHBhdGggd2l0aG91dCBhZGp1c3RtZW50IHBvaW50cyBhcHBlbmRlZCBpbiB0aGUgZW5kc1xuXHRcdFx0cmV0ID0gY29tcGxldGU7XG5cblx0XHR9IGVsc2UgaWYgKGkgPT09IGVuZC5sZW5ndGggJiYgcG9zIDwgMSkge1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzdGFydFZhbCA9IHBhcnNlRmxvYXQoc3RhcnRbaV0pO1xuXHRcdFx0XHRyZXRbaV0gPVxuXHRcdFx0XHRcdGlzTmFOKHN0YXJ0VmFsKSA/IC8vIGEgbGV0dGVyIGluc3RydWN0aW9uIGxpa2UgTSBvciBMXG5cdFx0XHRcdFx0XHRzdGFydFtpXSA6XG5cdFx0XHRcdFx0XHRwb3MgKiAocGFyc2VGbG9hdChlbmRbaV0gLSBzdGFydFZhbCkpICsgc3RhcnRWYWw7XG5cblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBpZiBhbmltYXRpb24gaXMgZmluaXNoZWQgb3IgbGVuZ3RoIG5vdCBtYXRjaGluZywgbGFuZCBvbiByaWdodCB2YWx1ZVxuXHRcdFx0cmV0ID0gZW5kO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG59O1xuXG4oZnVuY3Rpb24gKCQpIHtcblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IEhpZ2hjaGFydHNBZGFwdGVyIGZvciBqUXVlcnlcblx0ICovXG5cdHdpbi5IaWdoY2hhcnRzQWRhcHRlciA9IHdpbi5IaWdoY2hhcnRzQWRhcHRlciB8fCAoJCAmJiB7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgYWRhcHRlciBieSBhcHBseWluZyBzb21lIGV4dGVuc2lvbnMgdG8galF1ZXJ5XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHBhdGhBbmltKSB7XG5cdFx0XHRcblx0XHRcdC8vIGV4dGVuZCB0aGUgYW5pbWF0ZSBmdW5jdGlvbiB0byBhbGxvdyBTVkcgYW5pbWF0aW9uc1xuXHRcdFx0dmFyIEZ4ID0gJC5meCxcblx0XHRcdFx0U3RlcCA9IEZ4LnN0ZXAsXG5cdFx0XHRcdGRTZXR0ZXIsXG5cdFx0XHRcdFR3ZWVuID0gJC5Ud2Vlbixcblx0XHRcdFx0cHJvcEhvb2tzID0gVHdlZW4gJiYgVHdlZW4ucHJvcEhvb2tzLFxuXHRcdFx0XHRvcGFjaXR5SG9vayA9ICQuY3NzSG9va3Mub3BhY2l0eTtcblx0XHRcdFxuXHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovLyogYWxsb3cgdW51c2VkIHBhcmFtIHggaW4gdGhpcyBmdW5jdGlvbiAqL1xuXHRcdFx0JC5leHRlbmQoJC5lYXNpbmcsIHtcblx0XHRcdFx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XG5cdFx0XHQvLyBleHRlbmQgc29tZSBtZXRob2RzIHRvIGNoZWNrIGZvciBlbGVtLmF0dHIsIHdoaWNoIG1lYW5zIGl0IGlzIGEgSGlnaGNoYXJ0cyBTVkcgb2JqZWN0XG5cdFx0XHQkLmVhY2goWydjdXInLCAnX2RlZmF1bHQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ29wYWNpdHknXSwgZnVuY3Rpb24gKGksIGZuKSB7XG5cdFx0XHRcdHZhciBvYmogPSBTdGVwLFxuXHRcdFx0XHRcdGJhc2UsXG5cdFx0XHRcdFx0ZWxlbTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gSGFuZGxlIGRpZmZlcmVudCBwYXJlbnQgb2JqZWN0c1xuXHRcdFx0XHRpZiAoZm4gPT09ICdjdXInKSB7XG5cdFx0XHRcdFx0b2JqID0gRngucHJvdG90eXBlOyAvLyAnY3VyJywgdGhlIGdldHRlciwgcmVsYXRlcyB0byBGeC5wcm90b3R5cGVcblx0XHRcdFx0XG5cdFx0XHRcdH0gZWxzZSBpZiAoZm4gPT09ICdfZGVmYXVsdCcgJiYgVHdlZW4pIHsgLy8galF1ZXJ5IDEuOCBtb2RlbFxuXHRcdFx0XHRcdG9iaiA9IHByb3BIb29rc1tmbl07XG5cdFx0XHRcdFx0Zm4gPSAnc2V0Jztcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQvLyBPdmVyd3JpdGUgdGhlIG1ldGhvZFxuXHRcdFx0XHRiYXNlID0gb2JqW2ZuXTtcblx0XHRcdFx0aWYgKGJhc2UpIHsgLy8gc3RlcC53aWR0aCBhbmQgc3RlcC5oZWlnaHQgZG9uJ3QgZXhpc3QgaW4galF1ZXJ5IDwgMS43XG5cdFx0XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBleHRlbmRlZCBmdW5jdGlvbiByZXBsYWNlbWVudFxuXHRcdFx0XHRcdG9ialtmbl0gPSBmdW5jdGlvbiAoZngpIHtcblx0XHRcblx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgZG9lcyBub3QgdXNlIGZ4IGFyZ3VtZW50XG5cdFx0XHRcdFx0XHRmeCA9IGkgPyBmeCA6IHRoaXM7XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHJ1biBhbmltYXRpb25zIG9uIHRleHR1YWwgcHJvcGVydGllcyBsaWtlIGFsaWduICgjMTgyMSlcblx0XHRcdFx0XHRcdGlmIChmeC5wcm9wID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0XHRcdC8vIHNob3J0Y3V0XG5cdFx0XHRcdFx0XHRlbGVtID0gZnguZWxlbTtcblx0XHRcblx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS4gVGhlIG90aGVyIG9uZXMgYXJlIHNldHRlcnNcblx0XHRcdFx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYSB2YWx1ZSBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uYXR0ciA/IC8vIGlzIFNWRyBlbGVtZW50IHdyYXBwZXJcblx0XHRcdFx0XHRcdFx0ZWxlbS5hdHRyKGZ4LnByb3AsIGZuID09PSAnY3VyJyA/IFVOREVGSU5FRCA6IGZ4Lm5vdykgOiAvLyBhcHBseSB0aGUgU1ZHIHdyYXBwZXIncyBtZXRob2Rcblx0XHRcdFx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyB1c2UgalF1ZXJ5J3MgYnVpbHQtaW4gbWV0aG9kXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgb3BhY2l0eSBnZXR0ZXIsIG5lZWRlZCBmb3IgZmFkaW5nIG9wYWNpdHkgd2l0aCBJRTkgYW5kIGpRdWVyeSAxLjEwK1xuXHRcdFx0d3JhcChvcGFjaXR5SG9vaywgJ2dldCcsIGZ1bmN0aW9uIChwcm9jZWVkLCBlbGVtLCBjb21wdXRlZCkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5hdHRyID8gKGVsZW0ub3BhY2l0eSB8fCAwKSA6IHByb2NlZWQuY2FsbCh0aGlzLCBlbGVtLCBjb21wdXRlZCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBEZWZpbmUgdGhlIHNldHRlciBmdW5jdGlvbiBmb3IgZCAocGF0aCBkZWZpbml0aW9ucylcblx0XHRcdGRTZXR0ZXIgPSBmdW5jdGlvbiAoZngpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBmeC5lbGVtLFxuXHRcdFx0XHRcdGVuZHM7XG5cdFx0XG5cdFx0XHRcdC8vIE5vcm1hbGx5IHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHNldCBpbiBzdGF0ZSA9PSAwLCBidXQgc29tZXRpbWVzLFxuXHRcdFx0XHQvLyBmb3IgcmVhc29ucyB1bmtub3duLCB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBQZXJoYXBzIHN0YXRlID09IDAgaXMgc2tpcHBlZFxuXHRcdFx0XHQvLyBpbiB0aGVzZSBjYXNlc1xuXHRcdFx0XHRpZiAoIWZ4LnN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRlbmRzID0gcGF0aEFuaW0uaW5pdChlbGVtLCBlbGVtLmQsIGVsZW0udG9EKTtcblx0XHRcdFx0XHRmeC5zdGFydCA9IGVuZHNbMF07XG5cdFx0XHRcdFx0ZnguZW5kID0gZW5kc1sxXTtcblx0XHRcdFx0XHRmeC5zdGFydGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZSBlYWNoIHZhbHVlIG9mIHRoZSBwYXRoXG5cdFx0XHRcdGVsZW0uYXR0cignZCcsIHBhdGhBbmltLnN0ZXAoZnguc3RhcnQsIGZ4LmVuZCwgZngucG9zLCBlbGVtLnRvRCkpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8galF1ZXJ5IDEuOCBzdHlsZVxuXHRcdFx0aWYgKFR3ZWVuKSB7XG5cdFx0XHRcdHByb3BIb29rcy5kID0ge1xuXHRcdFx0XHRcdHNldDogZFNldHRlclxuXHRcdFx0XHR9O1xuXHRcdFx0Ly8gcHJlIDEuOFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYW5pbWF0ZSBwYXRoc1xuXHRcdFx0XHRTdGVwLmQgPSBkU2V0dGVyO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFV0aWxpdHkgZm9yIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LiBQYXJhbWV0ZXJzIGFyZSByZXZlcnNlZCBjb21wYXJlZCB0byBqUXVlcnkuXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuZWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID9cblx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbW9kZXJuIGJyb3dzZXJzXG5cdFx0XHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJyLCBmbik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gOiBcblx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbGVnYWN5XG5cdFx0XHRcdFx0dmFyIGkgPSAwLCBcblx0XHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWdpc3RlciBIaWdoY2hhcnRzIGFzIGEgcGx1Z2luIGluIHRoZSByZXNwZWN0aXZlIGZyYW1ld29ya1xuXHRcdFx0ICovXG5cdFx0XHQkLmZuLmhpZ2hjaGFydHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBjb25zdHIgPSAnQ2hhcnQnLCAvLyBkZWZhdWx0IGNvbnN0cnVjdG9yXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRvcHRpb25zLFxuXHRcdFx0XHRcdHJldCxcblx0XHRcdFx0XHRjaGFydDtcblxuXHRcdFx0XHRpZiAoaXNTdHJpbmcoYXJnc1swXSkpIHtcblx0XHRcdFx0XHRjb25zdHIgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucyA9IGFyZ3NbMF07XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjaGFydFxuXHRcdFx0XHRpZiAob3B0aW9ucyAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0Lypqc2xpbnQgdW51c2VkOmZhbHNlKi9cblx0XHRcdFx0XHRvcHRpb25zLmNoYXJ0ID0gb3B0aW9ucy5jaGFydCB8fCB7fTtcblx0XHRcdFx0XHRvcHRpb25zLmNoYXJ0LnJlbmRlclRvID0gdGhpc1swXTtcblx0XHRcdFx0XHRjaGFydCA9IG5ldyBIaWdoY2hhcnRzW2NvbnN0cl0ob3B0aW9ucywgYXJnc1sxXSk7XG5cdFx0XHRcdFx0cmV0ID0gdGhpcztcblx0XHRcdFx0XHQvKmpzbGludCB1bnVzZWQ6dHJ1ZSovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaGVuIGNhbGxlZCB3aXRob3V0IHBhcmFtZXRlcnMgb3Igd2l0aCB0aGUgcmV0dXJuIGFyZ3VtZW50LCBnZXQgYSBwcmVkZWZpbmVkIGNoYXJ0XG5cdFx0XHRcdGlmIChvcHRpb25zID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRyZXQgPSBjaGFydHNbYXR0cih0aGlzWzBdLCAnZGF0YS1oaWdoY2hhcnRzLWNoYXJ0JyldO1xuXHRcdFx0XHR9XHRcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHRcblx0XHQvKipcblx0XHQgKiBEb3dubG9hZHMgYSBzY3JpcHQgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgd2hlbiBkb25lLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzY3JpcHRMb2NhdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICovXG5cdFx0Z2V0U2NyaXB0OiAkLmdldFNjcmlwdCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIGluZGV4IG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIG5vdCBmb3VuZFxuXHRcdCAqL1xuXHRcdGluQXJyYXk6ICQuaW5BcnJheSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIGRpcmVjdCBsaW5rIHRvIGpRdWVyeSBtZXRob2RzLiBNb29Ub29scyBhbmQgUHJvdG90eXBlIGFkYXB0ZXJzIG11c3QgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggY2FzZSBvZiBtZXRob2QuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIEhUTUwgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgV2hpY2ggbWV0aG9kIHRvIHJ1biBvbiB0aGUgd3JhcHBlZCBlbGVtZW50XG5cdFx0ICovXG5cdFx0YWRhcHRlclJ1bjogZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuICQoZWxlbSlbbWV0aG9kXSgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdGdyZXA6ICQuZ3JlcCxcblx0XG5cdFx0LyoqXG5cdFx0ICogTWFwIGFuIGFycmF5XG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRtYXA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG5cdFx0XHQvL3JldHVybiBqUXVlcnkubWFwKGFyciwgZm4pO1xuXHRcdFx0dmFyIHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSBmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgb2YgdGhlIHBhZ2Vcblx0XHQgKi9cblx0XHRvZmZzZXQ6IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0cmV0dXJuICQoZWwpLm9mZnNldCgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBBIEhUTUwgZWxlbWVudCBvciBjdXN0b20gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0eXBlXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGV2ZW50IGhhbmRsZXJcblx0XHQgKi9cblx0XHRhZGRFdmVudDogZnVuY3Rpb24gKGVsLCBldmVudCwgZm4pIHtcblx0XHRcdCQoZWwpLmJpbmQoZXZlbnQsIGZuKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmUgZXZlbnQgYWRkZWQgd2l0aCBhZGRFdmVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBUaGUgZXZlbnQgdHlwZS4gTGVhdmUgYmxhbmsgdG8gcmVtb3ZlIGFsbCBldmVudHMuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlXG5cdFx0ICovXG5cdFx0cmVtb3ZlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBqUXVlcnkgaXNzdWUgd2l0aCB1bmJpbmRpbmcgY3VzdG9tIGV2ZW50czpcblx0XHRcdC8vIGh0dHA6Ly9mb3J1bS5qUXVlcnkuY29tL3RvcGljL2phdmFzY3JpcHQtZXJyb3Itd2hlbi11bmJpbmRpbmctYS1jdXN0b20tZXZlbnQtdXNpbmctalF1ZXJ5LTEtNC0yXG5cdFx0XHR2YXIgZnVuYyA9IGRvYy5yZW1vdmVFdmVudExpc3RlbmVyID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50Jztcblx0XHRcdGlmIChkb2NbZnVuY10gJiYgZWwgJiYgIWVsW2Z1bmNdKSB7XG5cdFx0XHRcdGVsW2Z1bmNdID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHR9XG5cdFxuXHRcdFx0JChlbCkudW5iaW5kKGV2ZW50VHlwZSwgaGFuZGxlcik7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmlyZSBhbiBldmVudCBvbiBhIGN1c3RvbSBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3VtZW50c1xuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRGdW5jdGlvblxuXHRcdCAqL1xuXHRcdGZpcmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBldmVudEFyZ3VtZW50cywgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KHR5cGUpLFxuXHRcdFx0XHRkZXRhY2hlZFR5cGUgPSAnZGV0YWNoZWQnICsgdHlwZSxcblx0XHRcdFx0ZGVmYXVsdFByZXZlbnRlZDtcblx0XG5cdFx0XHQvLyBSZW1vdmUgd2FybmluZ3MgaW4gQ2hyb21lIHdoZW4gYWNjZXNzaW5nIGxheWVyWCBhbmQgbGF5ZXJZLiBBbHRob3VnaCBIaWdoY2hhcnRzXG5cdFx0XHQvLyBuZXZlciB1c2VzIHRoZXNlIHByb3BlcnRpZXMsIENocm9tZSBpbmNsdWRlcyB0aGVtIGluIHRoZSBkZWZhdWx0IGNsaWNrIGV2ZW50IGFuZFxuXHRcdFx0Ly8gcmFpc2VzIHRoZSB3YXJuaW5nIHdoZW4gdGhleSBhcmUgY29waWVkIG92ZXIgaW4gdGhlIGV4dGVuZCBzdGF0ZW1lbnQgYmVsb3cuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVG8gYXZvaWQgcHJvYmxlbXMgaW4gSUUgKHNlZSAjMTAxMCkgd2hlcmUgd2UgY2Fubm90IGRlbGV0ZSB0aGUgcHJvcGVydGllcyBhbmQgYXZvaWRcblx0XHRcdC8vIHRlc3RpbmcgaWYgdGhleSBhcmUgdGhlcmUgKHdhcm5pbmcgaW4gY2hyb21lKSB0aGUgb25seSBvcHRpb24gaXMgdG8gdGVzdCBpZiBydW5uaW5nIElFLlxuXHRcdFx0aWYgKCFpc0lFICYmIGV2ZW50QXJndW1lbnRzKSB7XG5cdFx0XHRcdGRlbGV0ZSBldmVudEFyZ3VtZW50cy5sYXllclg7XG5cdFx0XHRcdGRlbGV0ZSBldmVudEFyZ3VtZW50cy5sYXllclk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0ZXh0ZW5kKGV2ZW50LCBldmVudEFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0Ly8gUHJldmVudCBqUXVlcnkgZnJvbSB0cmlnZ2VyaW5nIHRoZSBvYmplY3QgbWV0aG9kIHRoYXQgaXMgbmFtZWQgdGhlXG5cdFx0XHQvLyBzYW1lIGFzIHRoZSBldmVudC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBldmVudCBpcyAnc2VsZWN0JywgalF1ZXJ5XG5cdFx0XHQvLyBhdHRlbXB0cyBjYWxsaW5nIGVsLnNlbGVjdCBhbmQgaXQgZ29lcyBpbnRvIGEgbG9vcC5cblx0XHRcdGlmIChlbFt0eXBlXSkge1xuXHRcdFx0XHRlbFtkZXRhY2hlZFR5cGVdID0gZWxbdHlwZV07XG5cdFx0XHRcdGVsW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBXcmFwIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24gaW4gdHJ5L2NhdGNoIGJsb2NrcyBpblxuXHRcdFx0Ly8gb3JkZXIgdG8gcHJldmVudCBKUyBlcnJvcnMgd2hlbiBjYW5jZWxsaW5nIGV2ZW50cyBvbiBub24tRE9NXG5cdFx0XHQvLyBvYmplY3RzLiAjNjE1LlxuXHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovXG5cdFx0XHQkLmVhY2goWydwcmV2ZW50RGVmYXVsdCcsICdzdG9wUHJvcGFnYXRpb24nXSwgZnVuY3Rpb24gKGksIGZuKSB7XG5cdFx0XHRcdHZhciBiYXNlID0gZXZlbnRbZm5dO1xuXHRcdFx0XHRldmVudFtmbl0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGJhc2UuY2FsbChldmVudCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0aWYgKGZuID09PSAncHJldmVudERlZmF1bHQnKSB7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcblx0XHRcdC8vIHRyaWdnZXIgaXRcblx0XHRcdCQoZWwpLnRyaWdnZXIoZXZlbnQpO1xuXHRcblx0XHRcdC8vIGF0dGFjaCB0aGUgbWV0aG9kXG5cdFx0XHRpZiAoZWxbZGV0YWNoZWRUeXBlXSkge1xuXHRcdFx0XHRlbFt0eXBlXSA9IGVsW2RldGFjaGVkVHlwZV07XG5cdFx0XHRcdGVsW2RldGFjaGVkVHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChkZWZhdWx0RnVuY3Rpb24gJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmICFkZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdGRlZmF1bHRGdW5jdGlvbihldmVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRlbnNpb24gbWV0aG9kIG5lZWRlZCBmb3IgTW9vVG9vbHNcblx0XHQgKi9cblx0XHR3YXNoTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciByZXQgPSBlLm9yaWdpbmFsRXZlbnQgfHwgZTtcblx0XHRcdFxuXHRcdFx0Ly8gY29tcHV0ZWQgYnkgalF1ZXJ5LCBuZWVkZWQgYnkgSUU4XG5cdFx0XHRpZiAocmV0LnBhZ2VYID09PSBVTkRFRklORUQpIHsgLy8gIzEyMzZcblx0XHRcdFx0cmV0LnBhZ2VYID0gZS5wYWdlWDtcblx0XHRcdFx0cmV0LnBhZ2VZID0gZS5wYWdlWTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBBbmltYXRlIGEgSFRNTCBlbGVtZW50IG9yIFNWRyBlbGVtZW50IHdyYXBwZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgalF1ZXJ5LWxpa2UgYW5pbWF0aW9uIG9wdGlvbnM6IGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGVsLCBwYXJhbXMsIG9wdGlvbnMpIHtcblx0XHRcdHZhciAkZWwgPSAkKGVsKTtcblx0XHRcdGlmICghZWwuc3R5bGUpIHtcblx0XHRcdFx0ZWwuc3R5bGUgPSB7fTsgLy8gIzE4ODFcblx0XHRcdH1cblx0XHRcdGlmIChwYXJhbXMuZCkge1xuXHRcdFx0XHRlbC50b0QgPSBwYXJhbXMuZDsgLy8ga2VlcCB0aGUgYXJyYXkgZm9ybSBmb3IgcGF0aHMsIHVzZWQgaW4gJC5meC5zdGVwLmRcblx0XHRcdFx0cGFyYW1zLmQgPSAxOyAvLyBiZWNhdXNlIGluIGpRdWVyeSwgYW5pbWF0aW5nIHRvIGFuIGFycmF5IGhhcyBhIGRpZmZlcmVudCBtZWFuaW5nXG5cdFx0XHR9XG5cdFxuXHRcdFx0JGVsLnN0b3AoKTtcblx0XHRcdGlmIChwYXJhbXMub3BhY2l0eSAhPT0gVU5ERUZJTkVEICYmIGVsLmF0dHIpIHtcblx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgKz0gJ3B4JzsgLy8gZm9yY2UgalF1ZXJ5IHRvIHVzZSBzYW1lIGxvZ2ljIGFzIHdpZHRoIGFuZCBoZWlnaHQgKCMyMTYxKVxuXHRcdFx0fVxuXHRcdFx0JGVsLmFuaW1hdGUocGFyYW1zLCBvcHRpb25zKTtcblx0XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTdG9wIHJ1bm5pbmcgYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c3RvcDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHQkKGVsKS5zdG9wKCk7XG5cdFx0fVxuXHR9KTtcbn0od2luLmpRdWVyeSkpO1xuXG5cbi8vIGNoZWNrIGZvciBhIGN1c3RvbSBIaWdoY2hhcnRzQWRhcHRlciBkZWZpbmVkIHByaW9yIHRvIHRoaXMgZmlsZVxudmFyIGdsb2JhbEFkYXB0ZXIgPSB3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIsXG5cdGFkYXB0ZXIgPSBnbG9iYWxBZGFwdGVyIHx8IHt9O1xuXHRcbi8vIEluaXRpYWxpemUgdGhlIGFkYXB0ZXJcbmlmIChnbG9iYWxBZGFwdGVyKSB7XG5cdGdsb2JhbEFkYXB0ZXIuaW5pdC5jYWxsKGdsb2JhbEFkYXB0ZXIsIHBhdGhBbmltKTtcbn1cblxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucy4gSWYgdGhlIEhpZ2hjaGFydHNBZGFwdGVyIGlzIG5vdCBkZWZpbmVkLCBhZGFwdGVyIGlzIGFuIGVtcHR5IG9iamVjdFxuLy8gYW5kIGFsbCB0aGUgdXRpbGl0eSBmdW5jdGlvbnMgd2lsbCBiZSBudWxsLiBJbiB0aGF0IGNhc2UgdGhleSBhcmUgcG9wdWxhdGVkIGJ5IHRoZVxuLy8gZGVmYXVsdCBhZGFwdGVycyBiZWxvdy5cbnZhciBhZGFwdGVyUnVuID0gYWRhcHRlci5hZGFwdGVyUnVuLFxuXHRnZXRTY3JpcHQgPSBhZGFwdGVyLmdldFNjcmlwdCxcblx0aW5BcnJheSA9IGFkYXB0ZXIuaW5BcnJheSxcblx0ZWFjaCA9IGFkYXB0ZXIuZWFjaCxcblx0Z3JlcCA9IGFkYXB0ZXIuZ3JlcCxcblx0b2Zmc2V0ID0gYWRhcHRlci5vZmZzZXQsXG5cdG1hcCA9IGFkYXB0ZXIubWFwLFxuXHRhZGRFdmVudCA9IGFkYXB0ZXIuYWRkRXZlbnQsXG5cdHJlbW92ZUV2ZW50ID0gYWRhcHRlci5yZW1vdmVFdmVudCxcblx0ZmlyZUV2ZW50ID0gYWRhcHRlci5maXJlRXZlbnQsXG5cdHdhc2hNb3VzZUV2ZW50ID0gYWRhcHRlci53YXNoTW91c2VFdmVudCxcblx0YW5pbWF0ZSA9IGFkYXB0ZXIuYW5pbWF0ZSxcblx0c3RvcCA9IGFkYXB0ZXIuc3RvcDtcblxuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEhhbmRsZSB0aGUgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhclxuXG5kZWZhdWx0TGFiZWxPcHRpb25zID0ge1xuXHRlbmFibGVkOiB0cnVlLFxuXHQvLyByb3RhdGlvbjogMCxcblx0Ly8gYWxpZ246ICdjZW50ZXInLFxuXHR4OiAwLFxuXHR5OiAxNSxcblx0Lypmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0fSwqL1xuXHRzdHlsZToge1xuXHRcdGNvbG9yOiAnIzY2NicsXG5cdFx0Y3Vyc29yOiAnZGVmYXVsdCcsXG5cdFx0Zm9udFNpemU6ICcxMXB4Jyxcblx0XHRsaW5lSGVpZ2h0OiAnMTRweCdcblx0fVxufTtcblxuZGVmYXVsdE9wdGlvbnMgPSB7XG5cdGNvbG9yczogWycjMmY3ZWQ4JywgJyMwZDIzM2EnLCAnIzhiYmMyMScsICcjOTEwMDAwJywgJyMxYWFkY2UnLCAnIzQ5Mjk3MCcsXG5cdFx0JyNmMjhmNDMnLCAnIzc3YTFlNScsICcjYzQyNTI1JywgJyNhNmM5NmEnXSxcblx0c3ltYm9sczogWydjaXJjbGUnLCAnZGlhbW9uZCcsICdzcXVhcmUnLCAndHJpYW5nbGUnLCAndHJpYW5nbGUtZG93biddLFxuXHRsYW5nOiB7XG5cdFx0bG9hZGluZzogJ0xvYWRpbmcuLi4nLFxuXHRcdG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLFxuXHRcdFx0XHQnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG5cdFx0c2hvcnRNb250aHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHR3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdGRlY2ltYWxQb2ludDogJy4nLFxuXHRcdG51bWVyaWNTeW1ib2xzOiBbJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJ10sIC8vIFNJIHByZWZpeGVzIHVzZWQgaW4gYXhpcyBsYWJlbHNcblx0XHRyZXNldFpvb206ICdSZXNldCB6b29tJyxcblx0XHRyZXNldFpvb21UaXRsZTogJ1Jlc2V0IHpvb20gbGV2ZWwgMToxJyxcblx0XHR0aG91c2FuZHNTZXA6ICcsJ1xuXHR9LFxuXHRnbG9iYWw6IHtcblx0XHR1c2VVVEM6IHRydWUsXG5cdFx0Y2FudmFzVG9vbHNVUkw6ICdodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS8zLjAuNi9tb2R1bGVzL2NhbnZhcy10b29scy5qcycsXG5cdFx0Vk1MUmFkaWFsR3JhZGllbnRVUkw6ICdodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS8zLjAuNi9nZngvdm1sLXJhZGlhbC1ncmFkaWVudC5wbmcnXG5cdH0sXG5cdGNoYXJ0OiB7XG5cdFx0Ly9hbmltYXRpb246IHRydWUsXG5cdFx0Ly9hbGlnblRpY2tzOiBmYWxzZSxcblx0XHQvL3JlZmxvdzogdHJ1ZSxcblx0XHQvL2NsYXNzTmFtZTogbnVsbCxcblx0XHQvL2V2ZW50czogeyBsb2FkLCBzZWxlY3Rpb24gfSxcblx0XHQvL21hcmdpbjogW251bGxdLFxuXHRcdC8vbWFyZ2luVG9wOiBudWxsLFxuXHRcdC8vbWFyZ2luUmlnaHQ6IG51bGwsXG5cdFx0Ly9tYXJnaW5Cb3R0b206IG51bGwsXG5cdFx0Ly9tYXJnaW5MZWZ0OiBudWxsLFxuXHRcdGJvcmRlckNvbG9yOiAnIzQ1NzJBNycsXG5cdFx0Ly9ib3JkZXJXaWR0aDogMCxcblx0XHRib3JkZXJSYWRpdXM6IDUsXG5cdFx0ZGVmYXVsdFNlcmllc1R5cGU6ICdsaW5lJyxcblx0XHRpZ25vcmVIaWRkZW5TZXJpZXM6IHRydWUsXG5cdFx0Ly9pbnZlcnRlZDogZmFsc2UsXG5cdFx0Ly9zaGFkb3c6IGZhbHNlLFxuXHRcdHNwYWNpbmc6IFsxMCwgMTAsIDE1LCAxMF0sXG5cdFx0Ly9zcGFjaW5nVG9wOiAxMCxcblx0XHQvL3NwYWNpbmdSaWdodDogMTAsXG5cdFx0Ly9zcGFjaW5nQm90dG9tOiAxNSxcblx0XHQvL3NwYWNpbmdMZWZ0OiAxMCxcblx0XHRzdHlsZToge1xuXHRcdFx0Zm9udEZhbWlseTogJ1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgVmVyZGFuYSwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsIC8vIGRlZmF1bHQgZm9udFxuXHRcdFx0Zm9udFNpemU6ICcxMnB4J1xuXHRcdH0sXG5cdFx0YmFja2dyb3VuZENvbG9yOiAnI0ZGRkZGRicsXG5cdFx0Ly9wbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHRcdHBsb3RCb3JkZXJDb2xvcjogJyNDMEMwQzAnLFxuXHRcdC8vcGxvdEJvcmRlcldpZHRoOiAwLFxuXHRcdC8vcGxvdFNoYWRvdzogZmFsc2UsXG5cdFx0Ly96b29tVHlwZTogJydcblx0XHRyZXNldFpvb21CdXR0b246IHtcblx0XHRcdHRoZW1lOiB7XG5cdFx0XHRcdHpJbmRleDogMjBcblx0XHRcdH0sXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRhbGlnbjogJ3JpZ2h0Jyxcblx0XHRcdFx0eDogLTEwLFxuXHRcdFx0XHQvL3ZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdFx0XHR5OiAxMFxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVsYXRpdmVUbzogJ3Bsb3QnXG5cdFx0fVxuXHR9LFxuXHR0aXRsZToge1xuXHRcdHRleHQ6ICdDaGFydCB0aXRsZScsXG5cdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdC8vIGZsb2F0aW5nOiBmYWxzZSxcblx0XHRtYXJnaW46IDE1LFxuXHRcdC8vIHg6IDAsXG5cdFx0Ly8gdmVydGljYWxBbGlnbjogJ3RvcCcsXG5cdFx0Ly8geTogbnVsbCxcblx0XHRzdHlsZToge1xuXHRcdFx0Y29sb3I6ICcjMjc0YjZkJywvLyMzRTU3NkYnLFxuXHRcdFx0Zm9udFNpemU6ICcxNnB4J1xuXHRcdH1cblxuXHR9LFxuXHRzdWJ0aXRsZToge1xuXHRcdHRleHQ6ICcnLFxuXHRcdGFsaWduOiAnY2VudGVyJyxcblx0XHQvLyBmbG9hdGluZzogZmFsc2Vcblx0XHQvLyB4OiAwLFxuXHRcdC8vIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdC8vIHk6IG51bGwsXG5cdFx0c3R5bGU6IHtcblx0XHRcdGNvbG9yOiAnIzRkNzU5ZSdcblx0XHR9XG5cdH0sXG5cblx0cGxvdE9wdGlvbnM6IHtcblx0XHRsaW5lOiB7IC8vIGJhc2Ugc2VyaWVzIG9wdGlvbnNcblx0XHRcdGFsbG93UG9pbnRTZWxlY3Q6IGZhbHNlLFxuXHRcdFx0c2hvd0NoZWNrYm94OiBmYWxzZSxcblx0XHRcdGFuaW1hdGlvbjoge1xuXHRcdFx0XHRkdXJhdGlvbjogMTAwMFxuXHRcdFx0fSxcblx0XHRcdC8vY29ubmVjdE51bGxzOiBmYWxzZSxcblx0XHRcdC8vY3Vyc29yOiAnZGVmYXVsdCcsXG5cdFx0XHQvL2NsaXA6IHRydWUsXG5cdFx0XHQvL2Rhc2hTdHlsZTogbnVsbCxcblx0XHRcdC8vZW5hYmxlTW91c2VUcmFja2luZzogdHJ1ZSxcblx0XHRcdGV2ZW50czoge30sXG5cdFx0XHQvL2xlZ2VuZEluZGV4OiAwLFxuXHRcdFx0bGluZVdpZHRoOiAyLFxuXHRcdFx0Ly9zaGFkb3c6IGZhbHNlLFxuXHRcdFx0Ly8gc3RhY2tpbmc6IG51bGwsXG5cdFx0XHRtYXJrZXI6IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0Ly9zeW1ib2w6IG51bGwsXG5cdFx0XHRcdGxpbmVXaWR0aDogMCxcblx0XHRcdFx0cmFkaXVzOiA0LFxuXHRcdFx0XHRsaW5lQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0Ly9maWxsQ29sb3I6IG51bGwsXG5cdFx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IHRydWVcblx0XHRcdFx0XHRcdC8vcmFkaXVzOiBiYXNlICsgMlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRmaWxsQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0XHRcdGxpbmVDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiAyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cG9pbnQ6IHtcblx0XHRcdFx0ZXZlbnRzOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRhdGFMYWJlbHM6IG1lcmdlKGRlZmF1bHRMYWJlbE9wdGlvbnMsIHtcblx0XHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0XHRlbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueSA9PT0gbnVsbCA/ICcnIDogbnVtYmVyRm9ybWF0KHRoaXMueSwgLTEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJywgLy8gYWJvdmUgc2luZ3VsYXIgcG9pbnRcblx0XHRcdFx0eTogMFxuXHRcdFx0XHQvLyBiYWNrZ3JvdW5kQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRcdFx0Ly8gYm9yZGVyQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRcdFx0Ly8gYm9yZGVyUmFkaXVzOiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIGJvcmRlcldpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIHBhZGRpbmc6IDMsXG5cdFx0XHRcdC8vIHNoYWRvdzogZmFsc2Vcblx0XHRcdH0pLFxuXHRcdFx0Y3JvcFRocmVzaG9sZDogMzAwLCAvLyBkcmF3IHBvaW50cyBvdXRzaWRlIHRoZSBwbG90IGFyZWEgd2hlbiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpcyBsZXNzIHRoYW4gdGhpc1xuXHRcdFx0cG9pbnRSYW5nZTogMCxcblx0XHRcdC8vcG9pbnRTdGFydDogMCxcblx0XHRcdC8vcG9pbnRJbnRlcnZhbDogMSxcblx0XHRcdHNob3dJbkxlZ2VuZDogdHJ1ZSxcblx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIHRoZSBlbnRpcmUgc2VyaWVzXG5cdFx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdFx0Ly9lbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0XHQvL2xpbmVXaWR0aDogYmFzZSArIDEsXG5cdFx0XHRcdFx0bWFya2VyOiB7XG5cdFx0XHRcdFx0XHQvLyBsaW5lV2lkdGg6IGJhc2UgKyAxLFxuXHRcdFx0XHRcdFx0Ly8gcmFkaXVzOiBiYXNlICsgMVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0bWFya2VyOiB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3RpY2t5VHJhY2tpbmc6IHRydWVcblx0XHRcdC8vdG9vbHRpcDoge1xuXHRcdFx0XHQvL3BvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7c2VyaWVzLmNvbG9yfVwiPntzZXJpZXMubmFtZX08L3NwYW4+OiA8Yj57cG9pbnQueX08L2I+J1xuXHRcdFx0XHQvL3ZhbHVlRGVjaW1hbHM6IG51bGwsXG5cdFx0XHRcdC8veERhdGVGb3JtYXQ6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdFx0Ly92YWx1ZVByZWZpeDogJycsXG5cdFx0XHRcdC8veVN1ZmZpeDogJydcdFx0XHRcdFxuXHRcdFx0Ly99XG5cdFx0XHQvLyB0dXJib1RocmVzaG9sZDogMTAwMFxuXHRcdFx0Ly8gekluZGV4OiBudWxsXG5cdFx0fVxuXHR9LFxuXHRsYWJlbHM6IHtcblx0XHQvL2l0ZW1zOiBbXSxcblx0XHRzdHlsZToge1xuXHRcdFx0Ly9mb250OiBkZWZhdWx0Rm9udCxcblx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdGNvbG9yOiAnIzNFNTc2Ridcblx0XHR9XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdC8vZmxvYXRpbmc6IGZhbHNlLFxuXHRcdGxheW91dDogJ2hvcml6b250YWwnLFxuXHRcdGxhYmVsRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXHRcdH0sXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0Ym9yZGVyQ29sb3I6ICcjOTA5MDkwJyxcblx0XHRib3JkZXJSYWRpdXM6IDUsXG5cdFx0bmF2aWdhdGlvbjoge1xuXHRcdFx0Ly8gYW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0YWN0aXZlQ29sb3I6ICcjMjc0YjZkJyxcblx0XHRcdC8vIGFycm93U2l6ZTogMTJcblx0XHRcdGluYWN0aXZlQ29sb3I6ICcjQ0NDJ1xuXHRcdFx0Ly8gc3R5bGU6IHt9IC8vIHRleHQgc3R5bGVzXG5cdFx0fSxcblx0XHQvLyBtYXJnaW46IDEwLFxuXHRcdC8vIHJldmVyc2VkOiBmYWxzZSxcblx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdC8vIGJhY2tncm91bmRDb2xvcjogbnVsbCxcblx0XHQvKnN0eWxlOiB7XG5cdFx0XHRwYWRkaW5nOiAnNXB4J1xuXHRcdH0sKi9cblx0XHRpdGVtU3R5bGU6IHtcblx0XHRcdGN1cnNvcjogJ3BvaW50ZXInLFxuXHRcdFx0Y29sb3I6ICcjMjc0YjZkJyxcblx0XHRcdGZvbnRTaXplOiAnMTJweCdcblx0XHR9LFxuXHRcdGl0ZW1Ib3ZlclN0eWxlOiB7XG5cdFx0XHQvL2N1cnNvcjogJ3BvaW50ZXInLCByZW1vdmVkIGFzIG9mICM2MDFcblx0XHRcdGNvbG9yOiAnIzAwMCdcblx0XHR9LFxuXHRcdGl0ZW1IaWRkZW5TdHlsZToge1xuXHRcdFx0Y29sb3I6ICcjQ0NDJ1xuXHRcdH0sXG5cdFx0aXRlbUNoZWNrYm94U3R5bGU6IHtcblx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdHdpZHRoOiAnMTNweCcsIC8vIGZvciBJRSBwcmVjaXNpb25cblx0XHRcdGhlaWdodDogJzEzcHgnXG5cdFx0fSxcblx0XHQvLyBpdGVtV2lkdGg6IHVuZGVmaW5lZCxcblx0XHRzeW1ib2xXaWR0aDogMTYsXG5cdFx0c3ltYm9sUGFkZGluZzogNSxcblx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcblx0XHQvLyB3aWR0aDogdW5kZWZpbmVkLFxuXHRcdHg6IDAsXG5cdFx0eTogMCxcblx0XHR0aXRsZToge1xuXHRcdFx0Ly90ZXh0OiBudWxsLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnXG5cdFx0XHR9XG5cdFx0fVx0XHRcdFxuXHR9LFxuXG5cdGxvYWRpbmc6IHtcblx0XHQvLyBoaWRlRHVyYXRpb246IDEwMCxcblx0XHRsYWJlbFN0eWxlOiB7XG5cdFx0XHRmb250V2VpZ2h0OiAnYm9sZCcsXG5cdFx0XHRwb3NpdGlvbjogUkVMQVRJVkUsXG5cdFx0XHR0b3A6ICcxZW0nXG5cdFx0fSxcblx0XHQvLyBzaG93RHVyYXRpb246IDAsXG5cdFx0c3R5bGU6IHtcblx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdHRleHRBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcDoge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0YW5pbWF0aW9uOiBoYXNTVkcsXG5cdFx0Ly9jcm9zc2hhaXJzOiBudWxsLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgLjg1KScsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0Ym9yZGVyUmFkaXVzOiAzLFxuXHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7IFxuXHRcdFx0bWlsbGlzZWNvbmQ6ICclQSwgJWIgJWUsICVIOiVNOiVTLiVMJyxcblx0XHRcdHNlY29uZDogJyVBLCAlYiAlZSwgJUg6JU06JVMnLFxuXHRcdFx0bWludXRlOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRob3VyOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRkYXk6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdHdlZWs6ICdXZWVrIGZyb20gJUEsICViICVlLCAlWScsXG5cdFx0XHRtb250aDogJyVCICVZJyxcblx0XHRcdHllYXI6ICclWSdcblx0XHR9LFxuXHRcdC8vZm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuXHRcdGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+e3BvaW50LmtleX08L3NwYW4+PGJyLz4nLFxuXHRcdHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7c2VyaWVzLmNvbG9yfVwiPntzZXJpZXMubmFtZX08L3NwYW4+OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLFxuXHRcdHNoYWRvdzogdHJ1ZSxcblx0XHQvL3NoYXJlZDogZmFsc2UsXG5cdFx0c25hcDogaXNUb3VjaERldmljZSA/IDI1IDogMTAsXG5cdFx0c3R5bGU6IHtcblx0XHRcdGNvbG9yOiAnIzMzMzMzMycsXG5cdFx0XHRjdXJzb3I6ICdkZWZhdWx0Jyxcblx0XHRcdGZvbnRTaXplOiAnMTJweCcsXG5cdFx0XHRwYWRkaW5nOiAnOHB4Jyxcblx0XHRcdHdoaXRlU3BhY2U6ICdub3dyYXAnXG5cdFx0fVxuXHRcdC8veERhdGVGb3JtYXQ6ICclQSwgJWIgJWUsICVZJyxcblx0XHQvL3ZhbHVlRGVjaW1hbHM6IG51bGwsXG5cdFx0Ly92YWx1ZVByZWZpeDogJycsXG5cdFx0Ly92YWx1ZVN1ZmZpeDogJydcblx0fSxcblxuXHRjcmVkaXRzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHR0ZXh0OiAnSGlnaGNoYXJ0cy5jb20nLFxuXHRcdGhyZWY6ICdodHRwOi8vd3d3LmhpZ2hjaGFydHMuY29tJyxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0YWxpZ246ICdyaWdodCcsXG5cdFx0XHR4OiAtMTAsXG5cdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcblx0XHRcdHk6IC01XG5cdFx0fSxcblx0XHRzdHlsZToge1xuXHRcdFx0Y3Vyc29yOiAncG9pbnRlcicsXG5cdFx0XHRjb2xvcjogJyM5MDkwOTAnLFxuXHRcdFx0Zm9udFNpemU6ICc5cHgnXG5cdFx0fVxuXHR9XG59O1xuXG5cblxuXG4vLyBTZXJpZXMgZGVmYXVsdHNcbnZhciBkZWZhdWx0UGxvdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucy5wbG90T3B0aW9ucyxcblx0ZGVmYXVsdFNlcmllc09wdGlvbnMgPSBkZWZhdWx0UGxvdE9wdGlvbnMubGluZTtcblxuLy8gc2V0IHRoZSBkZWZhdWx0IHRpbWUgbWV0aG9kc1xuc2V0VGltZU1ldGhvZHMoKTtcblxuXG5cbi8qKlxuICogU2V0IHRoZSB0aW1lIG1ldGhvZHMgZ2xvYmFsbHkgYmFzZWQgb24gdGhlIHVzZVVUQyBvcHRpb24uIFRpbWUgbWV0aG9kIGNhbiBiZSBlaXRoZXJcbiAqIGxvY2FsIHRpbWUgb3IgVVRDIChkZWZhdWx0KS5cbiAqL1xuZnVuY3Rpb24gc2V0VGltZU1ldGhvZHMoKSB7XG5cdHZhciB1c2VVVEMgPSBkZWZhdWx0T3B0aW9ucy5nbG9iYWwudXNlVVRDLFxuXHRcdEdFVCA9IHVzZVVUQyA/ICdnZXRVVEMnIDogJ2dldCcsXG5cdFx0U0VUID0gdXNlVVRDID8gJ3NldFVUQycgOiAnc2V0JztcblxuXHRtYWtlVGltZSA9IHVzZVVUQyA/IERhdGUuVVRDIDogZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdHllYXIsXG5cdFx0XHRtb250aCxcblx0XHRcdHBpY2soZGF0ZSwgMSksXG5cdFx0XHRwaWNrKGhvdXJzLCAwKSxcblx0XHRcdHBpY2sobWludXRlcywgMCksXG5cdFx0XHRwaWNrKHNlY29uZHMsIDApXG5cdFx0KS5nZXRUaW1lKCk7XG5cdH07XG5cdGdldE1pbnV0ZXMgPSAgR0VUICsgJ01pbnV0ZXMnO1xuXHRnZXRIb3VycyA9ICAgIEdFVCArICdIb3Vycyc7XG5cdGdldERheSA9ICAgICAgR0VUICsgJ0RheSc7XG5cdGdldERhdGUgPSAgICAgR0VUICsgJ0RhdGUnO1xuXHRnZXRNb250aCA9ICAgIEdFVCArICdNb250aCc7XG5cdGdldEZ1bGxZZWFyID0gR0VUICsgJ0Z1bGxZZWFyJztcblx0c2V0TWludXRlcyA9ICBTRVQgKyAnTWludXRlcyc7XG5cdHNldEhvdXJzID0gICAgU0VUICsgJ0hvdXJzJztcblx0c2V0RGF0ZSA9ICAgICBTRVQgKyAnRGF0ZSc7XG5cdHNldE1vbnRoID0gICAgU0VUICsgJ01vbnRoJztcblx0c2V0RnVsbFllYXIgPSBTRVQgKyAnRnVsbFllYXInO1xuXG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGN1c3RvbSBvcHRpb25zIGFuZCByZXR1cm4gdGhlIG5ldyBvcHRpb25zIHN0cnVjdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG5ldyBjdXN0b20gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XG5cdC8vIFB1bGwgb3V0IGF4aXMgb3B0aW9ucyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgcmVzcGVjdGl2ZSBkZWZhdWx0IGF4aXMgb3B0aW9ucyBcblx0LypkZWZhdWx0WEF4aXNPcHRpb25zID0gbWVyZ2UoZGVmYXVsdFhBeGlzT3B0aW9ucywgb3B0aW9ucy54QXhpcyk7XG5cdGRlZmF1bHRZQXhpc09wdGlvbnMgPSBtZXJnZShkZWZhdWx0WUF4aXNPcHRpb25zLCBvcHRpb25zLnlBeGlzKTtcblx0b3B0aW9ucy54QXhpcyA9IG9wdGlvbnMueUF4aXMgPSBVTkRFRklORUQ7Ki9cblx0XG5cdC8vIE1lcmdlIGluIHRoZSBkZWZhdWx0IG9wdGlvbnNcblx0ZGVmYXVsdE9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdFxuXHQvLyBBcHBseSBVVENcblx0c2V0VGltZU1ldGhvZHMoKTtcblxuXHRyZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB1cGRhdGVkIGRlZmF1bHQgb3B0aW9ucy4gTWVyZWx5IGV4cG9zaW5nIGRlZmF1bHRPcHRpb25zIGZvciBvdXRzaWRlIG1vZHVsZXNcbiAqIGlzbid0IGVub3VnaCBiZWNhdXNlIHRoZSBzZXRPcHRpb25zIG1ldGhvZCBjcmVhdGVzIGEgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcblx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xufVxuXG5cbi8qKlxuICogSGFuZGxlIGNvbG9yIG9wZXJhdGlvbnMuIFRoZSBvYmplY3QgbWV0aG9kcyBhcmUgY2hhaW5hYmxlLlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBpbnB1dCBjb2xvciBpbiBlaXRoZXIgcmJnYSBvciBoZXggZm9ybWF0XG4gKi9cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQvLyBkZWNsYXJlIHZhcmlhYmxlc1xuXHR2YXIgcmdiYSA9IFtdLCByZXN1bHQsIHN0b3BzO1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgaW5wdXQgY29sb3IgdG8gcmdiYSBhcnJheVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcblx0ICovXG5cdGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcblxuXHRcdC8vIEdyYWRpZW50c1xuXHRcdGlmIChpbnB1dCAmJiBpbnB1dC5zdG9wcykge1xuXHRcdFx0c3RvcHMgPSBtYXAoaW5wdXQuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG5cdFx0XHRcdHJldHVybiBDb2xvcihzdG9wWzFdKTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gU29saWQgY29sb3JzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHJnYmFcblx0XHRcdHJlc3VsdCA9IC9yZ2JhXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XT8oPzpcXC5bMC05XSspPylcXHMqXFwpLy5leGVjKGlucHV0KTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSksIHBJbnQocmVzdWx0WzJdKSwgcEludChyZXN1bHRbM10pLCBwYXJzZUZsb2F0KHJlc3VsdFs0XSwgMTApXTtcblx0XHRcdH0gZWxzZSB7IFxuXHRcdFx0XHQvLyBoZXhcblx0XHRcdFx0cmVzdWx0ID0gLyMoW2EtZkEtRjAtOV17Mn0pKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkvLmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSwgMTYpLCBwSW50KHJlc3VsdFsyXSwgMTYpLCBwSW50KHJlc3VsdFszXSwgMTYpLCAxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZ2Jcblx0XHRcdFx0XHRyZXN1bHQgPSAvcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdHJnYmEgPSBbcEludChyZXN1bHRbMV0pLCBwSW50KHJlc3VsdFsyXSksIHBJbnQocmVzdWx0WzNdKSwgMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVx0XHRcblxuXHR9XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGNvbG9yIGEgc3BlY2lmaWVkIGZvcm1hdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXQoZm9ybWF0KSB7XG5cdFx0dmFyIHJldDtcblxuXHRcdGlmIChzdG9wcykge1xuXHRcdFx0cmV0ID0gbWVyZ2UoaW5wdXQpO1xuXHRcdFx0cmV0LnN0b3BzID0gW10uY29uY2F0KHJldC5zdG9wcyk7XG5cdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCwgaSkge1xuXHRcdFx0XHRyZXQuc3RvcHNbaV0gPSBbcmV0LnN0b3BzW2ldWzBdLCBzdG9wLmdldChmb3JtYXQpXTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gaXQncyBOYU4gaWYgZ3JhZGllbnQgY29sb3JzIG9uIGEgY29sdW1uIGNoYXJ0XG5cdFx0fSBlbHNlIGlmIChyZ2JhICYmICFpc05hTihyZ2JhWzBdKSkge1xuXHRcdFx0aWYgKGZvcm1hdCA9PT0gJ3JnYicpIHtcblx0XHRcdFx0cmV0ID0gJ3JnYignICsgcmdiYVswXSArICcsJyArIHJnYmFbMV0gKyAnLCcgKyByZ2JhWzJdICsgJyknO1xuXHRcdFx0fSBlbHNlIGlmIChmb3JtYXQgPT09ICdhJykge1xuXHRcdFx0XHRyZXQgPSByZ2JhWzNdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0ID0gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSBpbnB1dDtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBCcmlnaHRlbiB0aGUgY29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG5cdCAqL1xuXHRmdW5jdGlvbiBicmlnaHRlbihhbHBoYSkge1xuXHRcdGlmIChzdG9wcykge1xuXHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0c3RvcC5icmlnaHRlbihhbHBoYSk7XG5cdFx0XHR9KTtcblx0XHRcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGFscGhhKSAmJiBhbHBoYSAhPT0gMCkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHJnYmFbaV0gKz0gcEludChhbHBoYSAqIDI1NSk7XG5cblx0XHRcdFx0aWYgKHJnYmFbaV0gPCAwKSB7XG5cdFx0XHRcdFx0cmdiYVtpXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJnYmFbaV0gPiAyNTUpIHtcblx0XHRcdFx0XHRyZ2JhW2ldID0gMjU1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB0byBhIGdpdmVuIGFscGhhIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0T3BhY2l0eShhbHBoYSkge1xuXHRcdHJnYmFbM10gPSBhbHBoYTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGluaXRpYWxpemU6IHBhcnNlIHRoZSBpbnB1dFxuXHRpbml0KGlucHV0KTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRyZXR1cm4ge1xuXHRcdGdldDogZ2V0LFxuXHRcdGJyaWdodGVuOiBicmlnaHRlbixcblx0XHRyZ2JhOiByZ2JhLFxuXHRcdHNldE9wYWNpdHk6IHNldE9wYWNpdHlcblx0fTtcbn07XG5cblxuLyoqXG4gKiBBIHdyYXBwZXIgb2JqZWN0IGZvciBTVkcgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gU1ZHRWxlbWVudCgpIHt9XG5cblNWR0VsZW1lbnQucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgU1ZHIHJlbmRlcmVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChyZW5kZXJlciwgbm9kZU5hbWUpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXM7XG5cdFx0d3JhcHBlci5lbGVtZW50ID0gbm9kZU5hbWUgPT09ICdzcGFuJyA/XG5cdFx0XHRjcmVhdGVFbGVtZW50KG5vZGVOYW1lKSA6XG5cdFx0XHRkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgbm9kZU5hbWUpO1xuXHRcdHdyYXBwZXIucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHQvKipcblx0XHQgKiBBIGNvbGxlY3Rpb24gb2YgYXR0cmlidXRlIHNldHRlcnMuIFRoZXNlIG1ldGhvZHMsIGlmIGRlZmluZWQsIGFyZSBjYWxsZWQgcmlnaHQgYmVmb3JlIGEgY2VydGFpblxuXHRcdCAqIGF0dHJpYnV0ZSBpcyBzZXQgb24gYW4gZWxlbWVudCB3cmFwcGVyLiBSZXR1cm5pbmcgZmFsc2UgcHJldmVudHMgdGhlIGRlZmF1bHQgYXR0cmlidXRlXG5cdFx0ICogc2V0dGVyIHRvIHJ1bi4gUmV0dXJuaW5nIGEgdmFsdWUgY2F1c2VzIHRoZSBkZWZhdWx0IHNldHRlciB0byBzZXQgdGhhdCB2YWx1ZS4gVXNlZCBpblxuXHRcdCAqIFJlbmRlcmVyLmxhYmVsLlxuXHRcdCAqL1xuXHRcdHdyYXBwZXIuYXR0clNldHRlcnMgPSB7fTtcblx0fSxcblx0LyoqXG5cdCAqIERlZmF1bHQgYmFzZSBmb3IgYW5pbWF0aW9uXG5cdCAqL1xuXHRvcGFjaXR5OiAxLFxuXHQvKipcblx0ICogQW5pbWF0ZSBhIGdpdmVuIGF0dHJpYnV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zIFRoZSBzYW1lIG9wdGlvbnMgYXMgaW4galF1ZXJ5IGFuaW1hdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSBGdW5jdGlvbiB0byBwZXJmb3JtIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uXG5cdCAqL1xuXHRhbmltYXRlOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zLCBjb21wbGV0ZSkge1xuXHRcdHZhciBhbmltT3B0aW9ucyA9IHBpY2sob3B0aW9ucywgZ2xvYmFsQW5pbWF0aW9uLCB0cnVlKTtcblx0XHRzdG9wKHRoaXMpOyAvLyBzdG9wIHJlZ2FyZGxlc3Mgb2YgYW5pbWF0aW9uIGFjdHVhbGx5IHJ1bm5pbmcsIG9yIHJldmVydGluZyB0byAuYXR0ciAoIzYwNylcblx0XHRpZiAoYW5pbU9wdGlvbnMpIHtcblx0XHRcdGFuaW1PcHRpb25zID0gbWVyZ2UoYW5pbU9wdGlvbnMpO1xuXHRcdFx0aWYgKGNvbXBsZXRlKSB7IC8vIGFsbG93cyB1c2luZyBhIGNhbGxiYWNrIHdpdGggdGhlIGdsb2JhbCBhbmltYXRpb24gd2l0aG91dCBvdmVyd3JpdGluZyBpdFxuXHRcdFx0XHRhbmltT3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuXHRcdFx0fVxuXHRcdFx0YW5pbWF0ZSh0aGlzLCBwYXJhbXMsIGFuaW1PcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hdHRyKHBhcmFtcyk7XG5cdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdC8qKlxuXHQgKiBTZXQgb3IgZ2V0IGEgZ2l2ZW4gYXR0cmlidXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaGFzaFxuXHQgKiBAcGFyYW0ge01peGVkfFVuZGVmaW5lZH0gdmFsXG5cdCAqL1xuXHRhdHRyOiBmdW5jdGlvbiAoaGFzaCwgdmFsKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0a2V5LFxuXHRcdFx0dmFsdWUsXG5cdFx0XHRyZXN1bHQsXG5cdFx0XHRpLFxuXHRcdFx0Y2hpbGQsXG5cdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIEFuZHJvaWQyIHJlcXVpcmVzIGxvd2VyIGZvciBcInRleHRcIlxuXHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0c2tpcEF0dHIsXG5cdFx0XHR0aXRsZU5vZGUsXG5cdFx0XHRhdHRyU2V0dGVycyA9IHdyYXBwZXIuYXR0clNldHRlcnMsXG5cdFx0XHRzaGFkb3dzID0gd3JhcHBlci5zaGFkb3dzLFxuXHRcdFx0aGFzU2V0U3ltYm9sU2l6ZSxcblx0XHRcdGRvVHJhbnNmb3JtLFxuXHRcdFx0cmV0ID0gd3JhcHBlcjtcblxuXHRcdC8vIHNpbmdsZSBrZXktdmFsdWUgcGFpclxuXHRcdGlmIChpc1N0cmluZyhoYXNoKSAmJiBkZWZpbmVkKHZhbCkpIHtcblx0XHRcdGtleSA9IGhhc2g7XG5cdFx0XHRoYXNoID0ge307XG5cdFx0XHRoYXNoW2tleV0gPSB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBhcyBhIGdldHRlcjogZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHNlY29uZCBpcyB1bmRlZmluZWRcblx0XHRpZiAoaXNTdHJpbmcoaGFzaCkpIHtcblx0XHRcdGtleSA9IGhhc2g7XG5cdFx0XHRpZiAobm9kZU5hbWUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGtleSA9IHsgeDogJ2N4JywgeTogJ2N5JyB9W2tleV0gfHwga2V5O1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHJva2VXaWR0aCcpIHtcblx0XHRcdFx0a2V5ID0gJ3N0cm9rZS13aWR0aCc7XG5cdFx0XHR9XG5cdFx0XHRyZXQgPSBhdHRyKGVsZW1lbnQsIGtleSkgfHwgd3JhcHBlcltrZXldIHx8IDA7XG5cdFx0XHRpZiAoa2V5ICE9PSAnZCcgJiYga2V5ICE9PSAndmlzaWJpbGl0eScgJiYga2V5ICE9PSAnZmlsbCcpIHsgLy8gJ2QnIGlzIHN0cmluZyBpbiBhbmltYXRpb24gc3RlcFxuXHRcdFx0XHRyZXQgPSBwYXJzZUZsb2F0KHJldCk7XG5cdFx0XHR9XG5cblx0XHQvLyBzZXR0ZXJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKGtleSBpbiBoYXNoKSB7XG5cdFx0XHRcdHNraXBBdHRyID0gZmFsc2U7IC8vIHJlc2V0XG5cdFx0XHRcdHZhbHVlID0gaGFzaFtrZXldO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBhIHNwZWNpZmljIGF0dHJpYnV0ZSBzZXR0ZXJcblx0XHRcdFx0cmVzdWx0ID0gYXR0clNldHRlcnNba2V5XSAmJiBhdHRyU2V0dGVyc1trZXldLmNhbGwod3JhcHBlciwgdmFsdWUsIGtleSk7XG5cblx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRpZiAocmVzdWx0ICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gcmVzdWx0OyAvLyB0aGUgYXR0cmlidXRlIHNldHRlciBoYXMgcmV0dXJuZWQgYSBuZXcgdmFsdWUgdG8gc2V0XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHQvLyBwYXRoc1xuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdkJykge1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmpvaW4pIHsgLy8gam9pbiBwYXRoXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuam9pbignICcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKC8oTmFOfCB7Mn18XiQpLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9ICdNIDAgMCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3dyYXBwZXIuZCA9IHZhbHVlOyAvLyBzaG9ydGN1dCBmb3IgYW5pbWF0aW9uc1xuXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGNoaWxkIHRzcGFucyB4IHZhbHVlc1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAneCcgJiYgbm9kZU5hbWUgPT09ICd0ZXh0Jykge1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHggdmFsdWVzIGFyZSBlcXVhbCwgdGhlIHRzcGFuIHJlcHJlc2VudHMgYSBsaW5lYnJlYWtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHIoY2hpbGQsICd4JykgPT09IGF0dHIoZWxlbWVudCwgJ3gnKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vY2hpbGQuc2V0QXR0cmlidXRlKCd4JywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdGF0dHIoY2hpbGQsICd4JywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHdyYXBwZXIucm90YXRpb24gJiYgKGtleSA9PT0gJ3gnIHx8IGtleSA9PT0gJ3knKSkge1xuXHRcdFx0XHRcdFx0ZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gYXBwbHkgZ3JhZGllbnRzXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdmaWxsJykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSByZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5KTtcblxuXHRcdFx0XHRcdC8vIGNpcmNsZSB4IGFuZCB5XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ2NpcmNsZScgJiYgKGtleSA9PT0gJ3gnIHx8IGtleSA9PT0gJ3knKSkge1xuXHRcdFx0XHRcdFx0a2V5ID0geyB4OiAnY3gnLCB5OiAnY3knIH1ba2V5XSB8fCBrZXk7XG5cblx0XHRcdFx0XHQvLyByZWN0YW5nbGUgYm9yZGVyIHJhZGl1c1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICdyZWN0JyAmJiBrZXkgPT09ICdyJykge1xuXHRcdFx0XHRcdFx0YXR0cihlbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRcdHJ4OiB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0cnk6IHZhbHVlXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHNraXBBdHRyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIHRyYW5zbGF0aW9uIGFuZCB0ZXh0IHJvdGF0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICd0cmFuc2xhdGVYJyB8fCBrZXkgPT09ICd0cmFuc2xhdGVZJyB8fCBrZXkgPT09ICdyb3RhdGlvbicgfHxcblx0XHRcdFx0XHRcdFx0a2V5ID09PSAndmVydGljYWxBbGlnbicgfHwga2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSB7XG5cdFx0XHRcdFx0XHRkb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRza2lwQXR0ciA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBhcHBseSBvcGFjaXR5IGFzIHN1Ym5vZGUgKHJlcXVpcmVkIGJ5IGxlZ2FjeSBXZWJLaXQgYW5kIEJhdGlrKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3Ryb2tlJykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSByZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5KTtcblxuXHRcdFx0XHRcdC8vIGVtdWxhdGUgVk1MJ3MgZGFzaHN0eWxlIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdkYXNoc3R5bGUnKSB7XG5cdFx0XHRcdFx0XHRrZXkgPSAnc3Ryb2tlLWRhc2hhcnJheSc7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT09ICdzb2xpZCcpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBOT05FO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZGFzaGRvdGRvdCcsICczLDEsMSwxLDEsMSwnKVxuXHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2hkb3QnLCAnMywxLDEsMScpXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZG90JywgJzEsMSwnKVxuXHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2gnLCAnMywxLCcpXG5cdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoJ2xvbmdkYXNoJywgJzgsMywnKVxuXHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9kb3QvZywgJzEsMywnKVxuXHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCdkYXNoJywgJzQsMywnKVxuXHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC8sJC8sICcnKVxuXHRcdFx0XHRcdFx0XHRcdC5zcGxpdCgnLCcpOyAvLyBlbmRpbmcgY29tbWFcblxuXHRcdFx0XHRcdFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVbaV0gPSBwSW50KHZhbHVlW2ldKSAqIHBpY2soaGFzaFsnc3Ryb2tlLXdpZHRoJ10sIHdyYXBwZXJbJ3N0cm9rZS13aWR0aCddKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmpvaW4oJywnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElFOS9Nb29Ub29scyBjb21ibzogTW9vVG9vbHMgcmV0dXJucyBvYmplY3RzIGluc3RlYWQgb2YgbnVtYmVycyBhbmQgSUU5IEJldGEgMlxuXHRcdFx0XHRcdC8vIGlzIHVuYWJsZSB0byBjYXN0IHRoZW0uIFRlc3QgYWdhaW4gd2l0aCBmaW5hbCBJRTkuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICd3aWR0aCcpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gcEludCh2YWx1ZSk7XG5cblx0XHRcdFx0XHQvLyBUZXh0IGFsaWdubWVudFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdFx0XHRrZXkgPSAndGV4dC1hbmNob3InO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB7IGxlZnQ6ICdzdGFydCcsIGNlbnRlcjogJ21pZGRsZScsIHJpZ2h0OiAnZW5kJyB9W3ZhbHVlXTtcblxuXHRcdFx0XHRcdC8vIFRpdGxlIHJlcXVpcmVzIGEgc3Vibm9kZSwgIzQzMVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAndGl0bGUnKSB7XG5cdFx0XHRcdFx0XHR0aXRsZU5vZGUgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aXRsZScpWzBdO1xuXHRcdFx0XHRcdFx0aWYgKCF0aXRsZU5vZGUpIHtcblx0XHRcdFx0XHRcdFx0dGl0bGVOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0aXRsZScpO1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlTm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aXRsZU5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBqUXVlcnkgYW5pbWF0ZSBjaGFuZ2VzIGNhc2Vcblx0XHRcdFx0XHRpZiAoa2V5ID09PSAnc3Ryb2tlV2lkdGgnKSB7XG5cdFx0XHRcdFx0XHRrZXkgPSAnc3Ryb2tlLXdpZHRoJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJbiBDaHJvbWUvV2luIDwgNiBhcyB3ZWxsIGFzIEJhdGlrLCB0aGUgc3Ryb2tlIGF0dHJpYnV0ZSBjYW4ndCBiZSBzZXQgd2hlbiB0aGUgc3Ryb2tlLVxuXHRcdFx0XHRcdC8vIHdpZHRoIGlzIDAuICMxMzY5XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ3N0cm9rZS13aWR0aCcgfHwga2V5ID09PSAnc3Ryb2tlJykge1xuXHRcdFx0XHRcdFx0d3JhcHBlcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBPbmx5IGFwcGx5IHRoZSBzdHJva2UgYXR0cmlidXRlIGlmIHRoZSBzdHJva2Ugd2lkdGggaXMgZGVmaW5lZCBhbmQgbGFyZ2VyIHRoYW4gMFxuXHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIuc3Ryb2tlICYmIHdyYXBwZXJbJ3N0cm9rZS13aWR0aCddKSB7XG5cdFx0XHRcdFx0XHRcdGF0dHIoZWxlbWVudCwgJ3N0cm9rZScsIHdyYXBwZXIuc3Ryb2tlKTtcblx0XHRcdFx0XHRcdFx0YXR0cihlbGVtZW50LCAnc3Ryb2tlLXdpZHRoJywgd3JhcHBlclsnc3Ryb2tlLXdpZHRoJ10pO1xuXHRcdFx0XHRcdFx0XHR3cmFwcGVyLmhhc1N0cm9rZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0cm9rZS13aWR0aCcgJiYgdmFsdWUgPT09IDAgJiYgd3JhcHBlci5oYXNTdHJva2UpIHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuXHRcdFx0XHRcdFx0XHR3cmFwcGVyLmhhc1N0cm9rZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHN5bWJvbHNcblx0XHRcdFx0XHRpZiAod3JhcHBlci5zeW1ib2xOYW1lICYmIC9eKHh8eXx3aWR0aHxoZWlnaHR8cnxzdGFydHxlbmR8aW5uZXJSfGFuY2hvclh8YW5jaG9yWSkvLnRlc3Qoa2V5KSkge1xuXG5cblx0XHRcdFx0XHRcdGlmICghaGFzU2V0U3ltYm9sU2l6ZSkge1xuXHRcdFx0XHRcdFx0XHR3cmFwcGVyLnN5bWJvbEF0dHIoaGFzaCk7XG5cdFx0XHRcdFx0XHRcdGhhc1NldFN5bWJvbFNpemUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGxldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKHNoYWRvd3MgJiYgL14od2lkdGh8aGVpZ2h0fHZpc2liaWxpdHl8eHx5fGR8dHJhbnNmb3JtfGN4fGN5fHIpJC8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0XHRpID0gc2hhZG93cy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRcdGF0dHIoXG5cdFx0XHRcdFx0XHRcdFx0c2hhZG93c1tpXSxcblx0XHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdFx0a2V5ID09PSAnaGVpZ2h0JyA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtYXRoTWF4KHZhbHVlIC0gKHNoYWRvd3NbaV0uY3V0SGVpZ2h0IHx8IDApLCAwKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHZhbGlkYXRlIGhlaWdodHNcblx0XHRcdFx0XHRpZiAoKGtleSA9PT0gJ3dpZHRoJyB8fCBrZXkgPT09ICdoZWlnaHQnKSAmJiBub2RlTmFtZSA9PT0gJ3JlY3QnICYmIHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlY29yZCBmb3IgYW5pbWF0aW9uIGFuZCBxdWljayBhY2Nlc3Mgd2l0aG91dCBwb2xsaW5nIHRoZSBET01cblx0XHRcdFx0XHR3cmFwcGVyW2tleV0gPSB2YWx1ZTtcblxuXG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ3RleHQnKSB7XG5cdFx0XHRcdFx0XHQvLyBEZWxldGUgYkJveCBtZW1vIHdoZW4gdGhlIHRleHQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB3cmFwcGVyLnRleHRTdHIpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHdyYXBwZXIuYkJveDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdyYXBwZXIudGV4dFN0ciA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIuYWRkZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuYnVpbGRUZXh0KHdyYXBwZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNraXBBdHRyKSB7XG5cdFx0XHRcdFx0XHRhdHRyKGVsZW1lbnQsIGtleSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRyYW5zZm9ybS4gRG8gdGhpcyBvdXRzaWRlIHRoZSBsb29wIHRvIHByZXZlbnQgcmVkdW5kYW50IHVwZGF0aW5nIGZvciBiYXRjaCBzZXR0aW5nXG5cdFx0XHQvLyBvZiBhdHRyaWJ1dGVzLlxuXHRcdFx0aWYgKGRvVHJhbnNmb3JtKSB7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEFkZCBhIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuXHQgKi9cblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGN1cnJlbnRDbGFzc05hbWUgPSBhdHRyKGVsZW1lbnQsICdjbGFzcycpIHx8ICcnO1xuXG5cdFx0aWYgKGN1cnJlbnRDbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuXHRcdFx0YXR0cihlbGVtZW50LCAnY2xhc3MnLCBjdXJyZW50Q2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8qIGhhc0NsYXNzIGFuZCByZW1vdmVDbGFzcyBhcmUgbm90ICh5ZXQpIG5lZWRlZFxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdHJldHVybiBhdHRyKHRoaXMuZWxlbWVudCwgJ2NsYXNzJykuaW5kZXhPZihjbGFzc05hbWUpICE9PSAtMTtcblx0fSxcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRhdHRyKHRoaXMuZWxlbWVudCwgJ2NsYXNzJywgYXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycpLnJlcGxhY2UoY2xhc3NOYW1lLCAnJykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQqL1xuXG5cdC8qKlxuXHQgKiBJZiBvbmUgb2YgdGhlIHN5bWJvbCBzaXplIGFmZmVjdGluZyBwYXJhbWV0ZXJzIGFyZSBjaGFuZ2VkLFxuXHQgKiBjaGVjayBhbGwgdGhlIG90aGVycyBvbmx5IG9uY2UgZm9yIGVhY2ggY2FsbCB0byBhbiBlbGVtZW50J3Ncblx0ICogLmF0dHIoKSBtZXRob2Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGhhc2hcblx0ICovXG5cdHN5bWJvbEF0dHI6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzO1xuXG5cdFx0ZWFjaChbJ3gnLCAneScsICdyJywgJ3N0YXJ0JywgJ2VuZCcsICd3aWR0aCcsICdoZWlnaHQnLCAnaW5uZXJSJywgJ2FuY2hvclgnLCAnYW5jaG9yWSddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR3cmFwcGVyW2tleV0gPSBwaWNrKGhhc2hba2V5XSwgd3JhcHBlcltrZXldKTtcblx0XHR9KTtcblxuXHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRkOiB3cmFwcGVyLnJlbmRlcmVyLnN5bWJvbHNbd3JhcHBlci5zeW1ib2xOYW1lXShcblx0XHRcdFx0d3JhcHBlci54LFxuXHRcdFx0XHR3cmFwcGVyLnksXG5cdFx0XHRcdHdyYXBwZXIud2lkdGgsXG5cdFx0XHRcdHdyYXBwZXIuaGVpZ2h0LFxuXHRcdFx0XHR3cmFwcGVyXG5cdFx0XHQpXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGx5IGEgY2xpcHBpbmcgcGF0aCB0byB0aGlzIG9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcblx0ICovXG5cdGNsaXA6IGZ1bmN0aW9uIChjbGlwUmVjdCkge1xuXHRcdHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBSZWN0ID8gJ3VybCgnICsgdGhpcy5yZW5kZXJlci51cmwgKyAnIycgKyBjbGlwUmVjdC5pZCArICcpJyA6IE5PTkUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG5lZWRlZCBmb3IgZHJhd2luZyBhIHJlY3RhbmdsZSBjcmlzcGx5IGFuZCByZXR1cm4gdGhlXG5cdCAqIGNhbGN1bGF0ZWQgYXR0cmlidXRlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3Ryb2tlV2lkdGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdGNyaXNwOiBmdW5jdGlvbiAoc3Ryb2tlV2lkdGgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGtleSxcblx0XHRcdGF0dHJpYnMgPSB7fSxcblx0XHRcdHZhbHVlcyA9IHt9LFxuXHRcdFx0bm9ybWFsaXplcjtcblxuXHRcdHN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggfHwgd3JhcHBlci5zdHJva2VXaWR0aCB8fCAod3JhcHBlci5hdHRyICYmIHdyYXBwZXIuYXR0cignc3Ryb2tlLXdpZHRoJykpIHx8IDA7XG5cdFx0bm9ybWFsaXplciA9IG1hdGhSb3VuZChzdHJva2VXaWR0aCkgJSAyIC8gMjsgLy8gbWF0aFJvdW5kIGJlY2F1c2Ugc3Ryb2tlV2lkdGggY2FuIHNvbWV0aW1lcyBoYXZlIHJvdW5kb2ZmIGVycm9yc1xuXG5cdFx0Ly8gbm9ybWFsaXplIGZvciBjcmlzcCBlZGdlc1xuXHRcdHZhbHVlcy54ID0gbWF0aEZsb29yKHggfHwgd3JhcHBlci54IHx8IDApICsgbm9ybWFsaXplcjtcblx0XHR2YWx1ZXMueSA9IG1hdGhGbG9vcih5IHx8IHdyYXBwZXIueSB8fCAwKSArIG5vcm1hbGl6ZXI7XG5cdFx0dmFsdWVzLndpZHRoID0gbWF0aEZsb29yKCh3aWR0aCB8fCB3cmFwcGVyLndpZHRoIHx8IDApIC0gMiAqIG5vcm1hbGl6ZXIpO1xuXHRcdHZhbHVlcy5oZWlnaHQgPSBtYXRoRmxvb3IoKGhlaWdodCB8fCB3cmFwcGVyLmhlaWdodCB8fCAwKSAtIDIgKiBub3JtYWxpemVyKTtcblx0XHR2YWx1ZXMuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcblxuXHRcdGZvciAoa2V5IGluIHZhbHVlcykge1xuXHRcdFx0aWYgKHdyYXBwZXJba2V5XSAhPT0gdmFsdWVzW2tleV0pIHsgLy8gb25seSBzZXQgYXR0cmlidXRlIGlmIGNoYW5nZWRcblx0XHRcdFx0d3JhcHBlcltrZXldID0gYXR0cmlic1trZXldID0gdmFsdWVzW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF0dHJpYnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBzdHlsZXMgZm9yIHRoZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcblx0ICovXG5cdGNzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqLy8qIGFsbG93IHVudXNlZCBwYXJhbSBhIGluIHRoZSByZWdleHAgZnVuY3Rpb24gYmVsb3cgKi9cblx0XHR2YXIgZWxlbVdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0ZWxlbSA9IGVsZW1XcmFwcGVyLmVsZW1lbnQsXG5cdFx0XHR0ZXh0V2lkdGggPSBzdHlsZXMgJiYgc3R5bGVzLndpZHRoICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnLFxuXHRcdFx0bixcblx0XHRcdHNlcmlhbGl6ZWRDc3MgPSAnJyxcblx0XHRcdGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAnLScgKyBiLnRvTG93ZXJDYXNlKCk7IH07XG5cdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXG5cdFx0Ly8gY29udmVydCBsZWdhY3lcblx0XHRpZiAoc3R5bGVzICYmIHN0eWxlcy5jb2xvcikge1xuXHRcdFx0c3R5bGVzLmZpbGwgPSBzdHlsZXMuY29sb3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWVyZ2UgdGhlIG5ldyBzdHlsZXMgd2l0aCB0aGUgb2xkIG9uZXNcblx0XHRzdHlsZXMgPSBleHRlbmQoXG5cdFx0XHRlbGVtV3JhcHBlci5zdHlsZXMsXG5cdFx0XHRzdHlsZXNcblx0XHQpO1xuXG5cdFx0Ly8gc3RvcmUgb2JqZWN0XG5cdFx0ZWxlbVdyYXBwZXIuc3R5bGVzID0gc3R5bGVzO1xuXG5cblx0XHQvLyBEb24ndCBoYW5kbGUgbGluZSB3cmFwIG9uIGNhbnZhc1xuXHRcdGlmICh1c2VDYW5WRyAmJiB0ZXh0V2lkdGgpIHtcblx0XHRcdGRlbGV0ZSBzdHlsZXMud2lkdGg7XG5cdFx0fVxuXG5cdFx0Ly8gc2VyaWFsaXplIGFuZCBzZXQgc3R5bGUgYXR0cmlidXRlXG5cdFx0aWYgKGlzSUUgJiYgIWhhc1NWRykgeyAvLyBsZWdhY3kgSUUgZG9lc24ndCBzdXBwb3J0IHNldHRpbmcgc3R5bGUgYXR0cmlidXRlXG5cdFx0XHRpZiAodGV4dFdpZHRoKSB7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXMud2lkdGg7XG5cdFx0XHR9XG5cdFx0XHRjc3MoZWxlbVdyYXBwZXIuZWxlbWVudCwgc3R5bGVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChuIGluIHN0eWxlcykge1xuXHRcdFx0XHRzZXJpYWxpemVkQ3NzICs9IG4ucmVwbGFjZSgvKFtBLVpdKS9nLCBoeXBoZW5hdGUpICsgJzonICsgc3R5bGVzW25dICsgJzsnO1xuXHRcdFx0fVxuXHRcdFx0YXR0cihlbGVtLCAnc3R5bGUnLCBzZXJpYWxpemVkQ3NzKTsgLy8gIzE4ODFcblx0XHR9XG5cblxuXHRcdC8vIHJlLWJ1aWxkIHRleHRcblx0XHRpZiAodGV4dFdpZHRoICYmIGVsZW1XcmFwcGVyLmFkZGVkKSB7XG5cdFx0XHRlbGVtV3JhcHBlci5yZW5kZXJlci5idWlsZFRleHQoZWxlbVdyYXBwZXIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtV3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuXHQgKi9cblx0b246IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHR2YXIgc3ZnRWxlbWVudCA9IHRoaXMsXG5cdFx0XHRlbGVtZW50ID0gc3ZnRWxlbWVudC5lbGVtZW50O1xuXHRcdFxuXHRcdC8vIHRvdWNoXG5cdFx0aWYgKGhhc1RvdWNoICYmIGV2ZW50VHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0ZWxlbWVudC5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSkge1x0XHRcdFxuXHRcdFx0XHRzdmdFbGVtZW50LnRvdWNoRXZlbnRGaXJlZCA9IERhdGUubm93KCk7XHRcdFx0XHRcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRoYW5kbGVyLmNhbGwoZWxlbWVudCwgZSk7XG5cdFx0XHR9O1xuXHRcdFx0ZWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPT09IC0xIHx8IERhdGUubm93KCkgLSAoc3ZnRWxlbWVudC50b3VjaEV2ZW50RmlyZWQgfHwgMCkgPiAxMTAwKSB7IC8vICMyMjY5XG5cdFx0XHRcdFx0aGFuZGxlci5jYWxsKGVsZW1lbnQsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1x0XHRcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBzaW1wbGVzdCBwb3NzaWJsZSBldmVudCBtb2RlbCBmb3IgaW50ZXJuYWwgdXNlXG5cdFx0XHRlbGVtZW50WydvbicgKyBldmVudFR5cGVdID0gaGFuZGxlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY29vcmRpbmF0ZXMgbmVlZGVkIHRvIGRyYXcgYSBjb25zaXN0ZW50IHJhZGlhbCBncmFkaWVudCBhY3Jvc3Ncblx0ICogcGllIHNsaWNlcyByZWdhcmRsZXNzIG9mIHBvc2l0aW9uaW5nIGluc2lkZSB0aGUgY2hhcnQuIFRoZSBmb3JtYXQgaXNcblx0ICogW2NlbnRlclgsIGNlbnRlclksIGRpYW1ldGVyXSBpbiBwaXhlbHMuXG5cdCAqL1xuXHRzZXRSYWRpYWxSZWZlcmVuY2U6IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuXHRcdHRoaXMuZWxlbWVudC5yYWRpYWxSZWZlcmVuY2UgPSBjb29yZGluYXRlcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogTW92ZSBhbiBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiBieSB4IGFuZCB5IHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmF0dHIoe1xuXHRcdFx0dHJhbnNsYXRlWDogeCxcblx0XHRcdHRyYW5zbGF0ZVk6IHlcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogSW52ZXJ0IGEgZ3JvdXAsIHJvdGF0ZSBhbmQgZmxpcFxuXHQgKi9cblx0aW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzO1xuXHRcdHdyYXBwZXIuaW52ZXJ0ZWQgPSB0cnVlO1xuXHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGx5IENTUyB0byBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWQgaW4gdGV4dCB3aXRoaW4gU1ZHIHJlbmRlcmluZyBhbmRcblx0ICogYnkgdGhlIFZNTCByZW5kZXJlclxuXHQgKi9cblx0aHRtbENzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHR0ZXh0V2lkdGggPSBzdHlsZXMgJiYgZWxlbWVudC50YWdOYW1lID09PSAnU1BBTicgJiYgc3R5bGVzLndpZHRoO1xuXG5cdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0ZGVsZXRlIHN0eWxlcy53aWR0aDtcblx0XHRcdHdyYXBwZXIudGV4dFdpZHRoID0gdGV4dFdpZHRoO1xuXHRcdFx0d3JhcHBlci51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHR9XG5cblx0XHR3cmFwcGVyLnN0eWxlcyA9IGV4dGVuZCh3cmFwcGVyLnN0eWxlcywgc3R5bGVzKTtcblx0XHRjc3Mod3JhcHBlci5lbGVtZW50LCBzdHlsZXMpO1xuXG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblxuXG5cdC8qKlxuXHQgKiBWTUwgYW5kIHVzZUhUTUwgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0aGUgYm91bmRpbmcgYm94IGJhc2VkIG9uIG9mZnNldHNcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWZyZXNoIFdoZXRoZXIgdG8gZm9yY2UgYSBmcmVzaCB2YWx1ZSBmcm9tIHRoZSBET00gb3IgdG9cblx0ICogdXNlIHRoZSBjYWNoZWQgdmFsdWVcblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGhhc2ggY29udGFpbmluZyB2YWx1ZXMgZm9yIHgsIHksIHdpZHRoIGFuZCBoZWlnaHRcblx0ICovXG5cblx0aHRtbEdldEJCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0YkJveCA9IHdyYXBwZXIuYkJveDtcblxuXHRcdC8vIGZha2luZyBnZXRCQm94IGluIGV4cG9ydGVkIFNWRyBpbiBsZWdhY3kgSUVcblx0XHRpZiAoIWJCb3gpIHtcblx0XHRcdC8vIGZha2luZyBnZXRCQm94IGluIGV4cG9ydGVkIFNWRyBpbiBsZWdhY3kgSUUgKGlzIHRoaXMgYSBkdXBsaWNhdGUgb2YgdGhlIGZpeCBmb3IgIzEwNzk/KVxuXHRcdFx0aWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICd0ZXh0Jykge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gQUJTT0xVVEU7XG5cdFx0XHR9XG5cblx0XHRcdGJCb3ggPSB3cmFwcGVyLmJCb3ggPSB7XG5cdFx0XHRcdHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcblx0XHRcdFx0eTogZWxlbWVudC5vZmZzZXRUb3AsXG5cdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBiQm94O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBWTUwgb3ZlcnJpZGUgcHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIGVsZW1lbnRzIGJhc2VkIG9uIGludGVybmFsXG5cdCAqIHByb3BlcnRpZXMgYmFzZWQgb24gU1ZHIHRyYW5zZm9ybVxuXHQgKi9cblx0aHRtbFVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFsaWduaW5nIG5vbiBhZGRlZCBlbGVtZW50cyBpcyBleHBlbnNpdmVcblx0XHRpZiAoIXRoaXMuYWRkZWQpIHtcblx0XHRcdHRoaXMuYWxpZ25PbkFkZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0ZWxlbSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHRyYW5zbGF0ZVggPSB3cmFwcGVyLnRyYW5zbGF0ZVggfHwgMCxcblx0XHRcdHRyYW5zbGF0ZVkgPSB3cmFwcGVyLnRyYW5zbGF0ZVkgfHwgMCxcblx0XHRcdHggPSB3cmFwcGVyLnggfHwgMCxcblx0XHRcdHkgPSB3cmFwcGVyLnkgfHwgMCxcblx0XHRcdGFsaWduID0gd3JhcHBlci50ZXh0QWxpZ24gfHwgJ2xlZnQnLFxuXHRcdFx0YWxpZ25Db3JyZWN0aW9uID0geyBsZWZ0OiAwLCBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfVthbGlnbl0sXG5cdFx0XHRub25MZWZ0ID0gYWxpZ24gJiYgYWxpZ24gIT09ICdsZWZ0Jyxcblx0XHRcdHNoYWRvd3MgPSB3cmFwcGVyLnNoYWRvd3M7XG5cblx0XHQvLyBhcHBseSB0cmFuc2xhdGVcblx0XHRjc3MoZWxlbSwge1xuXHRcdFx0bWFyZ2luTGVmdDogdHJhbnNsYXRlWCxcblx0XHRcdG1hcmdpblRvcDogdHJhbnNsYXRlWVxuXHRcdH0pO1xuXHRcdGlmIChzaGFkb3dzKSB7IC8vIHVzZWQgaW4gbGFiZWxzL3Rvb2x0aXBcblx0XHRcdGVhY2goc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHRjc3Moc2hhZG93LCB7XG5cdFx0XHRcdFx0bWFyZ2luTGVmdDogdHJhbnNsYXRlWCArIDEsXG5cdFx0XHRcdFx0bWFyZ2luVG9wOiB0cmFuc2xhdGVZICsgMVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGFwcGx5IGludmVyc2lvblxuXHRcdGlmICh3cmFwcGVyLmludmVydGVkKSB7IC8vIHdyYXBwZXIgaXMgYSBncm91cFxuXHRcdFx0ZWFjaChlbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRyZW5kZXJlci5pbnZlcnRDaGlsZChjaGlsZCwgZWxlbSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoZWxlbS50YWdOYW1lID09PSAnU1BBTicpIHtcblxuXHRcdFx0dmFyIHdpZHRoLCBoZWlnaHQsXG5cdFx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdFx0YmFzZWxpbmUsXG5cdFx0XHRcdHJhZGlhbnMgPSAwLFxuXHRcdFx0XHRjb3N0aGV0YSA9IDEsXG5cdFx0XHRcdHNpbnRoZXRhID0gMCxcblx0XHRcdFx0cXVhZCxcblx0XHRcdFx0dGV4dFdpZHRoID0gcEludCh3cmFwcGVyLnRleHRXaWR0aCksXG5cdFx0XHRcdHhDb3JyID0gd3JhcHBlci54Q29yciB8fCAwLFxuXHRcdFx0XHR5Q29yciA9IHdyYXBwZXIueUNvcnIgfHwgMCxcblx0XHRcdFx0Y3VycmVudFRleHRUcmFuc2Zvcm0gPSBbcm90YXRpb24sIGFsaWduLCBlbGVtLmlubmVySFRNTCwgd3JhcHBlci50ZXh0V2lkdGhdLmpvaW4oJywnKTtcblxuXHRcdFx0aWYgKGN1cnJlbnRUZXh0VHJhbnNmb3JtICE9PSB3cmFwcGVyLmNUVCkgeyAvLyBkbyB0aGUgY2FsY3VsYXRpb25zIGFuZCBET00gYWNjZXNzIG9ubHkgaWYgcHJvcGVydGllcyBjaGFuZ2VkXG5cblx0XHRcdFx0aWYgKGRlZmluZWQocm90YXRpb24pKSB7XG5cblx0XHRcdFx0XHRyYWRpYW5zID0gcm90YXRpb24gKiBkZWcycmFkOyAvLyBkZWcgdG8gcmFkXG5cdFx0XHRcdFx0Y29zdGhldGEgPSBtYXRoQ29zKHJhZGlhbnMpO1xuXHRcdFx0XHRcdHNpbnRoZXRhID0gbWF0aFNpbihyYWRpYW5zKTtcblxuXHRcdFx0XHRcdHdyYXBwZXIuc2V0U3BhblJvdGF0aW9uKHJvdGF0aW9uLCBzaW50aGV0YSwgY29zdGhldGEpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3aWR0aCA9IHBpY2sod3JhcHBlci5lbGVtV2lkdGgsIGVsZW0ub2Zmc2V0V2lkdGgpO1xuXHRcdFx0XHRoZWlnaHQgPSBwaWNrKHdyYXBwZXIuZWxlbUhlaWdodCwgZWxlbS5vZmZzZXRIZWlnaHQpO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0ZXh0V2lkdGhcblx0XHRcdFx0aWYgKHdpZHRoID4gdGV4dFdpZHRoICYmIC9bIFxcLV0vLnRlc3QoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCkpIHsgLy8gIzk4MywgIzEyNTRcblx0XHRcdFx0XHRjc3MoZWxlbSwge1xuXHRcdFx0XHRcdFx0d2lkdGg6IHRleHRXaWR0aCArIFBYLFxuXHRcdFx0XHRcdFx0ZGlzcGxheTogJ2Jsb2NrJyxcblx0XHRcdFx0XHRcdHdoaXRlU3BhY2U6ICdub3JtYWwnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0d2lkdGggPSB0ZXh0V2lkdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb3JyZWN0IHggYW5kIHlcblx0XHRcdFx0YmFzZWxpbmUgPSByZW5kZXJlci5mb250TWV0cmljcyhlbGVtLnN0eWxlLmZvbnRTaXplKS5iO1xuXHRcdFx0XHR4Q29yciA9IGNvc3RoZXRhIDwgMCAmJiAtd2lkdGg7XG5cdFx0XHRcdHlDb3JyID0gc2ludGhldGEgPCAwICYmIC1oZWlnaHQ7XG5cblx0XHRcdFx0Ly8gY29ycmVjdCBmb3IgYmFzZWxpbmUgYW5kIGNvcm5lcnMgc3BpbGxpbmcgb3V0IGFmdGVyIHJvdGF0aW9uXG5cdFx0XHRcdHF1YWQgPSBjb3N0aGV0YSAqIHNpbnRoZXRhIDwgMDtcblx0XHRcdFx0eENvcnIgKz0gc2ludGhldGEgKiBiYXNlbGluZSAqIChxdWFkID8gMSAtIGFsaWduQ29ycmVjdGlvbiA6IGFsaWduQ29ycmVjdGlvbik7XG5cdFx0XHRcdHlDb3JyIC09IGNvc3RoZXRhICogYmFzZWxpbmUgKiAocm90YXRpb24gPyAocXVhZCA/IGFsaWduQ29ycmVjdGlvbiA6IDEgLSBhbGlnbkNvcnJlY3Rpb24pIDogMSk7XG5cblx0XHRcdFx0Ly8gY29ycmVjdCBmb3IgdGhlIGxlbmd0aC9oZWlnaHQgb2YgdGhlIHRleHRcblx0XHRcdFx0aWYgKG5vbkxlZnQpIHtcblx0XHRcdFx0XHR4Q29yciAtPSB3aWR0aCAqIGFsaWduQ29ycmVjdGlvbiAqIChjb3N0aGV0YSA8IDAgPyAtMSA6IDEpO1xuXHRcdFx0XHRcdGlmIChyb3RhdGlvbikge1xuXHRcdFx0XHRcdFx0eUNvcnIgLT0gaGVpZ2h0ICogYWxpZ25Db3JyZWN0aW9uICogKHNpbnRoZXRhIDwgMCA/IC0xIDogMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdFx0XHR0ZXh0QWxpZ246IGFsaWduXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY29ycmVjdGlvblxuXHRcdFx0XHR3cmFwcGVyLnhDb3JyID0geENvcnI7XG5cdFx0XHRcdHdyYXBwZXIueUNvcnIgPSB5Q29ycjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgcG9zaXRpb24gd2l0aCBjb3JyZWN0aW9uXG5cdFx0XHRjc3MoZWxlbSwge1xuXHRcdFx0XHRsZWZ0OiAoeCArIHhDb3JyKSArIFBYLFxuXHRcdFx0XHR0b3A6ICh5ICsgeUNvcnIpICsgUFhcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBmb3JjZSByZWZsb3cgaW4gd2Via2l0IHRvIGFwcGx5IHRoZSBsZWZ0IGFuZCB0b3Agb24gdXNlSFRNTCBlbGVtZW50ICgjMTI0OSlcblx0XHRcdGlmIChpc1dlYktpdCkge1xuXHRcdFx0XHRoZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDsgLy8gYXNzaWduZWQgdG8gaGVpZ2h0IGZvciBKU0xpbnQgcHVycG9zZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWNvcmQgY3VycmVudCB0ZXh0IHRyYW5zZm9ybVxuXHRcdFx0d3JhcHBlci5jVFQgPSBjdXJyZW50VGV4dFRyYW5zZm9ybTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgcm90YXRpb24gb2YgYW4gaW5kaXZpZHVhbCBIVE1MIHNwYW5cblx0ICovXG5cdHNldFNwYW5Sb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG5cdFx0dmFyIHJvdGF0aW9uU3R5bGUgPSB7fSxcblx0XHRcdGNzc1RyYW5zZm9ybUtleSA9IGlzSUUgPyAnLW1zLXRyYW5zZm9ybScgOiBpc1dlYktpdCA/ICctd2Via2l0LXRyYW5zZm9ybScgOiBpc0ZpcmVmb3ggPyAnTW96VHJhbnNmb3JtJyA6IGlzT3BlcmEgPyAnLW8tdHJhbnNmb3JtJyA6ICcnO1xuXG5cdFx0cm90YXRpb25TdHlsZVtjc3NUcmFuc2Zvcm1LZXldID0gcm90YXRpb25TdHlsZS50cmFuc2Zvcm0gPSAncm90YXRlKCcgKyByb3RhdGlvbiArICdkZWcpJztcblx0XHRjc3ModGhpcy5lbGVtZW50LCByb3RhdGlvblN0eWxlKTtcblx0fSxcblxuXHQvKipcblx0ICogUHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGJhc2VkIG9uIGludGVybmFsXG5cdCAqIHByb3BlcnRpZXNcblx0ICovXG5cdHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdHRyYW5zbGF0ZVggPSB3cmFwcGVyLnRyYW5zbGF0ZVggfHwgMCxcblx0XHRcdHRyYW5zbGF0ZVkgPSB3cmFwcGVyLnRyYW5zbGF0ZVkgfHwgMCxcblx0XHRcdHNjYWxlWCA9IHdyYXBwZXIuc2NhbGVYLFxuXHRcdFx0c2NhbGVZID0gd3JhcHBlci5zY2FsZVksXG5cdFx0XHRpbnZlcnRlZCA9IHdyYXBwZXIuaW52ZXJ0ZWQsXG5cdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHR0cmFuc2Zvcm07XG5cblx0XHQvLyBmbGlwcGluZyBhZmZlY3RzIHRyYW5zbGF0ZSBhcyBhZGp1c3RtZW50IGZvciBmbGlwcGluZyBhcm91bmQgdGhlIGdyb3VwJ3MgYXhpc1xuXHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0dHJhbnNsYXRlWCArPSB3cmFwcGVyLmF0dHIoJ3dpZHRoJyk7XG5cdFx0XHR0cmFuc2xhdGVZICs9IHdyYXBwZXIuYXR0cignaGVpZ2h0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdHJhbnNsYXRlLiBOZWFybHkgYWxsIHRyYW5zZm9ybWVkIGVsZW1lbnRzIGhhdmUgdHJhbnNsYXRpb24sIHNvIGluc3RlYWRcblx0XHQvLyBvZiBjaGVja2luZyBmb3IgdHJhbnNsYXRlID0gMCwgZG8gaXQgYWx3YXlzICgjMTc2NywgIzE4NDYpLlxuXHRcdHRyYW5zZm9ybSA9IFsndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywnICsgdHJhbnNsYXRlWSArICcpJ107XG5cblx0XHQvLyBhcHBseSByb3RhdGlvblxuXHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0dHJhbnNmb3JtLnB1c2goJ3JvdGF0ZSg5MCkgc2NhbGUoLTEsMSknKTtcblx0XHR9IGVsc2UgaWYgKHJvdGF0aW9uKSB7IC8vIHRleHQgcm90YXRpb25cblx0XHRcdHRyYW5zZm9ybS5wdXNoKCdyb3RhdGUoJyArIHJvdGF0aW9uICsgJyAnICsgKHdyYXBwZXIueCB8fCAwKSArICcgJyArICh3cmFwcGVyLnkgfHwgMCkgKyAnKScpO1xuXHRcdH1cblxuXHRcdC8vIGFwcGx5IHNjYWxlXG5cdFx0aWYgKGRlZmluZWQoc2NhbGVYKSB8fCBkZWZpbmVkKHNjYWxlWSkpIHtcblx0XHRcdHRyYW5zZm9ybS5wdXNoKCdzY2FsZSgnICsgcGljayhzY2FsZVgsIDEpICsgJyAnICsgcGljayhzY2FsZVksIDEpICsgJyknKTtcblx0XHR9XG5cblx0XHRpZiAodHJhbnNmb3JtLmxlbmd0aCkge1xuXHRcdFx0YXR0cih3cmFwcGVyLmVsZW1lbnQsICd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0uam9pbignICcpKTtcblx0XHR9XG5cdH0sXG5cdC8qKlxuXHQgKiBCcmluZyB0aGUgZWxlbWVudCB0byB0aGUgZnJvbnRcblx0ICovXG5cdHRvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHQvKipcblx0ICogQnJlYWsgZG93biBhbGlnbm1lbnQgb3B0aW9ucyBsaWtlIGFsaWduLCB2ZXJ0aWNhbEFsaWduLCB4IGFuZCB5XG5cdCAqIHRvIHggYW5kIHkgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYWxpZ25PcHRpb25zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxpZ25CeVRyYW5zbGF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ1tPYmplY3R9IGJveCBUaGUgYm94IHRvIGFsaWduIHRvLCBuZWVkcyBhIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4gdGhlXG5cdCAqICAgICAgICBib3ggaXMgYSBzdHJpbmcsIGl0IHJlZmVycyB0byBhbiBvYmplY3QgaW4gdGhlIFJlbmRlcmVyLiBGb3IgZXhhbXBsZSwgd2hlblxuXHQgKiAgICAgICAgYm94IGlzICdzcGFjaW5nQm94JywgaXQgcmVmZXJzIHRvIFJlbmRlcmVyLnNwYWNpbmdCb3ggd2hpY2ggaG9sZHMgd2lkdGgsIGhlaWdodFxuXHQgKiAgICAgICAgeCBhbmQgeSBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKi9cblx0YWxpZ246IGZ1bmN0aW9uIChhbGlnbk9wdGlvbnMsIGFsaWduQnlUcmFuc2xhdGUsIGJveCkge1xuXHRcdHZhciBhbGlnbixcblx0XHRcdHZBbGlnbixcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0YXR0cmlicyA9IHt9LFxuXHRcdFx0YWxpZ25Ubyxcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdGFsaWduZWRPYmplY3RzID0gcmVuZGVyZXIuYWxpZ25lZE9iamVjdHM7XG5cblx0XHQvLyBGaXJzdCBjYWxsIG9uIGluc3RhbmNpYXRlXG5cdFx0aWYgKGFsaWduT3B0aW9ucykge1xuXHRcdFx0dGhpcy5hbGlnbk9wdGlvbnMgPSBhbGlnbk9wdGlvbnM7XG5cdFx0XHR0aGlzLmFsaWduQnlUcmFuc2xhdGUgPSBhbGlnbkJ5VHJhbnNsYXRlO1xuXHRcdFx0aWYgKCFib3ggfHwgaXNTdHJpbmcoYm94KSkgeyAvLyBib3hlcyBvdGhlciB0aGFuIHJlbmRlcmVyIGhhbmRsZSB0aGlzIGludGVybmFsbHlcblx0XHRcdFx0dGhpcy5hbGlnblRvID0gYWxpZ25UbyA9IGJveCB8fCAncmVuZGVyZXInO1xuXHRcdFx0XHRlcmFzZShhbGlnbmVkT2JqZWN0cywgdGhpcyk7IC8vIHByZXZlbnQgZHVwbGljYXRlcywgbGlrZSBsZWdlbmRHcm91cCBhZnRlciByZXNpemVcblx0XHRcdFx0YWxpZ25lZE9iamVjdHMucHVzaCh0aGlzKTtcblx0XHRcdFx0Ym94ID0gbnVsbDsgLy8gcmVhc3NpZ24gaXQgYmVsb3dcblx0XHRcdH1cblxuXHRcdC8vIFdoZW4gY2FsbGVkIG9uIHJlc2l6ZSwgbm8gYXJndW1lbnRzIGFyZSBzdXBwbGllZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbGlnbk9wdGlvbnMgPSB0aGlzLmFsaWduT3B0aW9ucztcblx0XHRcdGFsaWduQnlUcmFuc2xhdGUgPSB0aGlzLmFsaWduQnlUcmFuc2xhdGU7XG5cdFx0XHRhbGlnblRvID0gdGhpcy5hbGlnblRvO1xuXHRcdH1cblxuXHRcdGJveCA9IHBpY2soYm94LCByZW5kZXJlclthbGlnblRvXSwgcmVuZGVyZXIpO1xuXG5cdFx0Ly8gQXNzaWduIHZhcmlhYmxlc1xuXHRcdGFsaWduID0gYWxpZ25PcHRpb25zLmFsaWduO1xuXHRcdHZBbGlnbiA9IGFsaWduT3B0aW9ucy52ZXJ0aWNhbEFsaWduO1xuXHRcdHggPSAoYm94LnggfHwgMCkgKyAoYWxpZ25PcHRpb25zLnggfHwgMCk7IC8vIGRlZmF1bHQ6IGxlZnQgYWxpZ25cblx0XHR5ID0gKGJveC55IHx8IDApICsgKGFsaWduT3B0aW9ucy55IHx8IDApOyAvLyBkZWZhdWx0OiB0b3AgYWxpZ25cblxuXHRcdC8vIEFsaWduXG5cdFx0aWYgKGFsaWduID09PSAncmlnaHQnIHx8IGFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0eCArPSAoYm94LndpZHRoIC0gKGFsaWduT3B0aW9ucy53aWR0aCB8fCAwKSkgL1xuXHRcdFx0XHRcdHsgcmlnaHQ6IDEsIGNlbnRlcjogMiB9W2FsaWduXTtcblx0XHR9XG5cdFx0YXR0cmlic1thbGlnbkJ5VHJhbnNsYXRlID8gJ3RyYW5zbGF0ZVgnIDogJ3gnXSA9IG1hdGhSb3VuZCh4KTtcblxuXG5cdFx0Ly8gVmVydGljYWwgYWxpZ25cblx0XHRpZiAodkFsaWduID09PSAnYm90dG9tJyB8fCB2QWxpZ24gPT09ICdtaWRkbGUnKSB7XG5cdFx0XHR5ICs9IChib3guaGVpZ2h0IC0gKGFsaWduT3B0aW9ucy5oZWlnaHQgfHwgMCkpIC9cblx0XHRcdFx0XHQoeyBib3R0b206IDEsIG1pZGRsZTogMiB9W3ZBbGlnbl0gfHwgMSk7XG5cblx0XHR9XG5cdFx0YXR0cmlic1thbGlnbkJ5VHJhbnNsYXRlID8gJ3RyYW5zbGF0ZVknIDogJ3knXSA9IG1hdGhSb3VuZCh5KTtcblxuXHRcdC8vIEFuaW1hdGUgb25seSBpZiBhbHJlYWR5IHBsYWNlZFxuXHRcdHRoaXNbdGhpcy5wbGFjZWQgPyAnYW5pbWF0ZScgOiAnYXR0ciddKGF0dHJpYnMpO1xuXHRcdHRoaXMucGxhY2VkID0gdHJ1ZTtcblx0XHR0aGlzLmFsaWduQXR0ciA9IGF0dHJpYnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBib3VuZGluZyBib3ggKHdpZHRoLCBoZWlnaHQsIHggYW5kIHkpIGZvciB0aGUgZWxlbWVudFxuXHQgKi9cblx0Z2V0QkJveDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGJCb3ggPSB3cmFwcGVyLmJCb3gsXG5cdFx0XHRyZW5kZXJlciA9IHdyYXBwZXIucmVuZGVyZXIsXG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodCxcblx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdHJhZCA9IHJvdGF0aW9uICogZGVnMnJhZDtcblxuXHRcdGlmICghYkJveCkge1xuXHRcdFx0Ly8gU1ZHIGVsZW1lbnRzXG5cdFx0XHRpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OUyB8fCByZW5kZXJlci5mb3JFeHBvcnQpIHtcblx0XHRcdFx0dHJ5IHsgLy8gRmFpbHMgaW4gRmlyZWZveCBpZiB0aGUgY29udGFpbmVyIGhhcyBkaXNwbGF5OiBub25lLlxuXG5cdFx0XHRcdFx0YkJveCA9IGVsZW1lbnQuZ2V0QkJveCA/XG5cdFx0XHRcdFx0XHQvLyBTVkc6IHVzZSBleHRlbmQgYmVjYXVzZSBJRTkgaXMgbm90IGFsbG93ZWQgdG8gY2hhbmdlIHdpZHRoIGFuZCBoZWlnaHQgaW4gY2FzZVxuXHRcdFx0XHRcdFx0Ly8gb2Ygcm90YXRpb24gKGJlbG93KVxuXHRcdFx0XHRcdFx0ZXh0ZW5kKHt9LCBlbGVtZW50LmdldEJCb3goKSkgOlxuXHRcdFx0XHRcdFx0Ly8gQ2FudmFzIHJlbmRlcmVyIGFuZCBsZWdhY3kgSUUgaW4gZXhwb3J0IG1vZGVcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGJCb3ggaXMgbm90IHNldCwgdGhlIHRyeS1jYXRjaCBibG9jayBhYm92ZSBmYWlsZWQuIFRoZSBvdGhlciBjb25kaXRpb25cblx0XHRcdFx0Ly8gaXMgZm9yIE9wZXJhIHRoYXQgcmV0dXJucyBhIHdpZHRoIG9mIC1JbmZpbml0eSBvbiBoaWRkZW4gZWxlbWVudHMuXG5cdFx0XHRcdGlmICghYkJveCB8fCBiQm94LndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdGJCb3ggPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdC8vIFZNTCBSZW5kZXJlciBvciB1c2VIVE1MIHdpdGhpbiBTVkdcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YkJveCA9IHdyYXBwZXIuaHRtbEdldEJCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcnVlIFNWRyBlbGVtZW50cyBhcyB3ZWxsIGFzIEhUTUwgZWxlbWVudHMgaW4gbW9kZXJuIGJyb3dzZXJzIHVzaW5nIHRoZSAudXNlSFRNTCBvcHRpb25cblx0XHRcdC8vIG5lZWQgdG8gY29tcGVuc2F0ZWQgZm9yIHJvdGF0aW9uXG5cdFx0XHRpZiAocmVuZGVyZXIuaXNTVkcpIHtcblx0XHRcdFx0d2lkdGggPSBiQm94LndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBiQm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBXb3JrYXJvdW5kIGZvciB3cm9uZyBib3VuZGluZyBib3ggaW4gSUU5IGFuZCBJRTEwICgjMTEwMSwgIzE1MDUsICMxNjY5KVxuXHRcdFx0XHRpZiAoaXNJRSAmJiBzdHlsZXMgJiYgc3R5bGVzLmZvbnRTaXplID09PSAnMTFweCcgJiYgaGVpZ2h0LnRvUHJlY2lzaW9uKDMpID09PSAnMjIuNycpIHtcblx0XHRcdFx0XHRiQm94LmhlaWdodCA9IGhlaWdodCA9IDE0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRqdXN0IGZvciByb3RhdGVkIHRleHRcblx0XHRcdFx0aWYgKHJvdGF0aW9uKSB7XG5cdFx0XHRcdFx0YkJveC53aWR0aCA9IG1hdGhBYnMoaGVpZ2h0ICogbWF0aFNpbihyYWQpKSArIG1hdGhBYnMod2lkdGggKiBtYXRoQ29zKHJhZCkpO1xuXHRcdFx0XHRcdGJCb3guaGVpZ2h0ID0gbWF0aEFicyhoZWlnaHQgKiBtYXRoQ29zKHJhZCkpICsgbWF0aEFicyh3aWR0aCAqIG1hdGhTaW4ocmFkKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0d3JhcHBlci5iQm94ID0gYkJveDtcblx0XHR9XG5cdFx0cmV0dXJuIGJCb3g7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIGVsZW1lbnRcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hdHRyKHsgdmlzaWJpbGl0eTogVklTSUJMRSB9KTtcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgZWxlbWVudFxuXHQgKi9cblx0aGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmF0dHIoeyB2aXNpYmlsaXR5OiBISURERU4gfSk7XG5cdH0sXG5cblx0ZmFkZU91dDogZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG5cdFx0dmFyIGVsZW1XcmFwcGVyID0gdGhpcztcblx0XHRlbGVtV3JhcHBlci5hbmltYXRlKHtcblx0XHRcdG9wYWNpdHk6IDBcblx0XHR9LCB7XG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb24gfHwgMTUwLFxuXHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0ZWxlbVdyYXBwZXIuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgdGhlIGVsZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R8VW5kZWZpbmVkfSBwYXJlbnQgQ2FuIGJlIGFuIGVsZW1lbnQsIGFuIGVsZW1lbnQgd3JhcHBlciBvciB1bmRlZmluZWRcblx0ICogICAgdG8gYXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSByZW5kZXJlci5ib3guXG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRwYXJlbnRXcmFwcGVyID0gcGFyZW50IHx8IHJlbmRlcmVyLFxuXHRcdFx0cGFyZW50Tm9kZSA9IHBhcmVudFdyYXBwZXIuZWxlbWVudCB8fCByZW5kZXJlci5ib3gsXG5cdFx0XHRjaGlsZE5vZGVzID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHpJbmRleCA9IGF0dHIoZWxlbWVudCwgJ3pJbmRleCcpLFxuXHRcdFx0b3RoZXJFbGVtZW50LFxuXHRcdFx0b3RoZXJaSW5kZXgsXG5cdFx0XHRpLFxuXHRcdFx0aW5zZXJ0ZWQ7XG5cblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHR0aGlzLnBhcmVudEdyb3VwID0gcGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIG1hcmsgYXMgaW52ZXJ0ZWRcblx0XHR0aGlzLnBhcmVudEludmVydGVkID0gcGFyZW50ICYmIHBhcmVudC5pbnZlcnRlZDtcblxuXHRcdC8vIGJ1aWxkIGZvcm1hdHRlZCB0ZXh0XG5cdFx0aWYgKHRoaXMudGV4dFN0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlci5idWlsZFRleHQodGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gbWFyayB0aGUgY29udGFpbmVyIGFzIGhhdmluZyB6IGluZGV4ZWQgY2hpbGRyZW5cblx0XHRpZiAoekluZGV4KSB7XG5cdFx0XHRwYXJlbnRXcmFwcGVyLmhhbmRsZVogPSB0cnVlO1xuXHRcdFx0ekluZGV4ID0gcEludCh6SW5kZXgpO1xuXHRcdH1cblxuXHRcdC8vIGluc2VydCBhY2NvcmRpbmcgdG8gdGhpcyBhbmQgb3RoZXIgZWxlbWVudHMnIHpJbmRleFxuXHRcdGlmIChwYXJlbnRXcmFwcGVyLmhhbmRsZVopIHsgLy8gdGhpcyBlbGVtZW50IG9yIGFueSBvZiBpdHMgc2libGluZ3MgaGFzIGEgeiBpbmRleFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0b3RoZXJFbGVtZW50ID0gY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0b3RoZXJaSW5kZXggPSBhdHRyKG90aGVyRWxlbWVudCwgJ3pJbmRleCcpO1xuXHRcdFx0XHRpZiAob3RoZXJFbGVtZW50ICE9PSBlbGVtZW50ICYmIChcblx0XHRcdFx0XHRcdC8vIGluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIGhpZ2hlciB6SW5kZXhcblx0XHRcdFx0XHRcdHBJbnQob3RoZXJaSW5kZXgpID4gekluZGV4IHx8XG5cdFx0XHRcdFx0XHQvLyBpZiBubyB6SW5kZXggZ2l2ZW4sIGluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIHpJbmRleFxuXHRcdFx0XHRcdFx0KCFkZWZpbmVkKHpJbmRleCkgJiYgZGVmaW5lZChvdGhlclpJbmRleCkpXG5cblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBvdGhlckVsZW1lbnQpO1xuXHRcdFx0XHRcdGluc2VydGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRlZmF1bHQ6IGFwcGVuZCBhdCB0aGUgZW5kXG5cdFx0aWYgKCFpbnNlcnRlZCkge1xuXHRcdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cblx0XHQvLyBtYXJrIGFzIGFkZGVkXG5cdFx0dGhpcy5hZGRlZCA9IHRydWU7XG5cblx0XHQvLyBmaXJlIGFuIGV2ZW50IGZvciBpbnRlcm5hbCBob29rc1xuXHRcdGZpcmVFdmVudCh0aGlzLCAnYWRkJyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdCAqIElzc3VlIDQ5MDsgaW4gVk1MIHJlbW92ZUNoaWxkIHJlc3VsdHMgaW4gT3JwaGFuZWQgbm9kZXMgYWNjb3JkaW5nIHRvIHNJRXZlLCBkaXNjYXJkRWxlbWVudCBkb2VzIG5vdC5cblx0ICovXG5cdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdGhlIGVsZW1lbnQgYW5kIGVsZW1lbnQgd3JhcHBlclxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQgfHwge30sXG5cdFx0XHRzaGFkb3dzID0gd3JhcHBlci5zaGFkb3dzLFxuXHRcdFx0cGFyZW50VG9DbGVhbiA9IHdyYXBwZXIucmVuZGVyZXIuaXNTVkcgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NQQU4nICYmIGVsZW1lbnQucGFyZW50Tm9kZSxcblx0XHRcdGdyYW5kUGFyZW50LFxuXHRcdFx0a2V5LFxuXHRcdFx0aTtcblxuXHRcdC8vIHJlbW92ZSBldmVudHNcblx0XHRlbGVtZW50Lm9uY2xpY2sgPSBlbGVtZW50Lm9ubW91c2VvdXQgPSBlbGVtZW50Lm9ubW91c2VvdmVyID0gZWxlbWVudC5vbm1vdXNlbW92ZSA9IGVsZW1lbnQucG9pbnQgPSBudWxsO1xuXHRcdHN0b3Aod3JhcHBlcik7IC8vIHN0b3AgcnVubmluZyBhbmltYXRpb25zXG5cblx0XHRpZiAod3JhcHBlci5jbGlwUGF0aCkge1xuXHRcdFx0d3JhcHBlci5jbGlwUGF0aCA9IHdyYXBwZXIuY2xpcFBhdGguZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIERlc3Ryb3kgc3RvcHMgaW4gY2FzZSB0aGlzIGlzIGEgZ3JhZGllbnQgb2JqZWN0XG5cdFx0aWYgKHdyYXBwZXIuc3RvcHMpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB3cmFwcGVyLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHdyYXBwZXIuc3RvcHNbaV0gPSB3cmFwcGVyLnN0b3BzW2ldLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdHdyYXBwZXIuc3RvcHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBlbGVtZW50XG5cdFx0d3JhcHBlci5zYWZlUmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cblx0XHQvLyBkZXN0cm95IHNoYWRvd3Ncblx0XHRpZiAoc2hhZG93cykge1xuXHRcdFx0ZWFjaChzaGFkb3dzLCBmdW5jdGlvbiAoc2hhZG93KSB7XG5cdFx0XHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKHNoYWRvdyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBJbiBjYXNlIG9mIHVzZUhUTUwsIGNsZWFuIHVwIGVtcHR5IGNvbnRhaW5lcnMgZW11bGF0aW5nIFNWRyBncm91cHMgKCMxOTYwKS5cblx0XHR3aGlsZSAocGFyZW50VG9DbGVhbiAmJiBwYXJlbnRUb0NsZWFuLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRncmFuZFBhcmVudCA9IHBhcmVudFRvQ2xlYW4ucGFyZW50Tm9kZTtcblx0XHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKHBhcmVudFRvQ2xlYW4pO1xuXHRcdFx0cGFyZW50VG9DbGVhbiA9IGdyYW5kUGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBmcm9tIGFsaWduT2JqZWN0c1xuXHRcdGlmICh3cmFwcGVyLmFsaWduVG8pIHtcblx0XHRcdGVyYXNlKHdyYXBwZXIucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsIHdyYXBwZXIpO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHdyYXBwZXIpIHtcblx0XHRcdGRlbGV0ZSB3cmFwcGVyW2tleV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHNoYWRvdyB0byB0aGUgZWxlbWVudC4gTXVzdCBiZSBkb25lIGFmdGVyIHRoZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET01cblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gc2hhZG93T3B0aW9uc1xuXHQgKi9cblx0c2hhZG93OiBmdW5jdGlvbiAoc2hhZG93T3B0aW9ucywgZ3JvdXAsIGN1dE9mZikge1xuXHRcdHZhciBzaGFkb3dzID0gW10sXG5cdFx0XHRpLFxuXHRcdFx0c2hhZG93LFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHN0cm9rZVdpZHRoLFxuXHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSxcblxuXHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgaW52ZXJ0ZWQgcGxvdCBhcmVhXG5cdFx0XHR0cmFuc2Zvcm07XG5cblxuXHRcdGlmIChzaGFkb3dPcHRpb25zKSB7XG5cdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSA9IChzaGFkb3dPcHRpb25zLm9wYWNpdHkgfHwgMC4xNSkgLyBzaGFkb3dXaWR0aDtcblx0XHRcdHRyYW5zZm9ybSA9IHRoaXMucGFyZW50SW52ZXJ0ZWQgP1xuXHRcdFx0XHQnKC0xLC0xKScgOlxuXHRcdFx0XHQnKCcgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WCwgMSkgKyAnLCAnICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFksIDEpICsgJyknO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8PSBzaGFkb3dXaWR0aDsgaSsrKSB7XG5cdFx0XHRcdHNoYWRvdyA9IGVsZW1lbnQuY2xvbmVOb2RlKDApO1xuXHRcdFx0XHRzdHJva2VXaWR0aCA9IChzaGFkb3dXaWR0aCAqIDIpICsgMSAtICgyICogaSk7XG5cdFx0XHRcdGF0dHIoc2hhZG93LCB7XG5cdFx0XHRcdFx0J2lzU2hhZG93JzogJ3RydWUnLFxuXHRcdFx0XHRcdCdzdHJva2UnOiBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsXG5cdFx0XHRcdFx0J3N0cm9rZS1vcGFjaXR5Jzogc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHQndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZScgKyB0cmFuc2Zvcm0sXG5cdFx0XHRcdFx0J2ZpbGwnOiBOT05FXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoY3V0T2ZmKSB7XG5cdFx0XHRcdFx0YXR0cihzaGFkb3csICdoZWlnaHQnLCBtYXRoTWF4KGF0dHIoc2hhZG93LCAnaGVpZ2h0JykgLSBzdHJva2VXaWR0aCwgMCkpO1xuXHRcdFx0XHRcdHNoYWRvdy5jdXRIZWlnaHQgPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvdywgZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGFkb3dzLnB1c2goc2hhZG93KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaGFkb3dzID0gc2hhZG93cztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxufTtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IFNWRyByZW5kZXJlclxuICovXG52YXIgU1ZHUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblNWR1JlbmRlcmVyLnByb3RvdHlwZSA9IHtcblx0RWxlbWVudDogU1ZHRWxlbWVudCxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgU1ZHUmVuZGVyZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvckV4cG9ydFxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCwgZm9yRXhwb3J0KSB7XG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdGxvYyA9IGxvY2F0aW9uLFxuXHRcdFx0Ym94V3JhcHBlcixcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHRkZXNjO1xuXG5cdFx0Ym94V3JhcHBlciA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3N2ZycpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHZlcnNpb246ICcxLjEnXG5cdFx0XHR9KTtcblx0XHRlbGVtZW50ID0gYm94V3JhcHBlci5lbGVtZW50O1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdC8vIEZvciBicm93c2VycyBvdGhlciB0aGFuIElFLCBhZGQgdGhlIG5hbWVzcGFjZSBhdHRyaWJ1dGUgKCMxOTc4KVxuXHRcdGlmIChjb250YWluZXIuaW5uZXJIVE1MLmluZGV4T2YoJ3htbG5zJykgPT09IC0xKSB7XG5cdFx0XHRhdHRyKGVsZW1lbnQsICd4bWxucycsIFNWR19OUyk7XG5cdFx0fVxuXG5cdFx0Ly8gb2JqZWN0IHByb3BlcnRpZXNcblx0XHRyZW5kZXJlci5pc1NWRyA9IHRydWU7XG5cdFx0cmVuZGVyZXIuYm94ID0gZWxlbWVudDtcblx0XHRyZW5kZXJlci5ib3hXcmFwcGVyID0gYm94V3JhcHBlcjtcblx0XHRyZW5kZXJlci5hbGlnbmVkT2JqZWN0cyA9IFtdO1xuXG5cdFx0Ly8gUGFnZSB1cmwgdXNlZCBmb3IgaW50ZXJuYWwgcmVmZXJlbmNlcy4gIzI0LCAjNjcyLCAjMTA3MFxuXHRcdHJlbmRlcmVyLnVybCA9IChpc0ZpcmVmb3ggfHwgaXNXZWJLaXQpICYmIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpLmxlbmd0aCA/XG5cdFx0XHRsb2MuaHJlZlxuXHRcdFx0XHQucmVwbGFjZSgvIy4qPyQvLCAnJykgLy8gcmVtb3ZlIHRoZSBoYXNoXG5cdFx0XHRcdC5yZXBsYWNlKC8oW1xcKCdcXCldKS9nLCAnXFxcXCQxJykgLy8gZXNjYXBlIHBhcmFudGhlc2VzIGFuZCBxdW90ZXNcblx0XHRcdFx0LnJlcGxhY2UoLyAvZywgJyUyMCcpIDogLy8gcmVwbGFjZSBzcGFjZXMgKG5lZWRlZCBmb3IgU2FmYXJpIG9ubHkpXG5cdFx0XHQnJztcblxuXHRcdC8vIEFkZCBkZXNjcmlwdGlvblxuXHRcdGRlc2MgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2Rlc2MnKS5hZGQoKTtcblx0XHRkZXNjLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKCdDcmVhdGVkIHdpdGggJyArIFBST0RVQ1QgKyAnICcgKyBWRVJTSU9OKSk7XG5cblxuXHRcdHJlbmRlcmVyLmRlZnMgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2RlZnMnKS5hZGQoKTtcblx0XHRyZW5kZXJlci5mb3JFeHBvcnQgPSBmb3JFeHBvcnQ7XG5cdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0ge307IC8vIE9iamVjdCB3aGVyZSBncmFkaWVudCBTdmdFbGVtZW50cyBhcmUgc3RvcmVkXG5cblx0XHRyZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcblxuXG5cblx0XHQvLyBJc3N1ZSAxMTAgd29ya2Fyb3VuZDpcblx0XHQvLyBJbiBGaXJlZm94LCBpZiBhIGRpdiBpcyBwb3NpdGlvbmVkIGJ5IHBlcmNlbnRhZ2UsIGl0cyBwaXhlbCBwb3NpdGlvbiBtYXkgbGFuZFxuXHRcdC8vIGJldHdlZW4gcGl4ZWxzLiBUaGUgY29udGFpbmVyIGl0c2VsZiBkb2Vzbid0IGRpc3BsYXkgdGhpcywgYnV0IGFuIFNWRyBlbGVtZW50XG5cdFx0Ly8gaW5zaWRlIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgZHJhd24gYXQgc3VicGl4ZWwgcHJlY2lzaW9uLiBJbiBvcmRlciB0byBkcmF3XG5cdFx0Ly8gc2hhcnAgbGluZXMsIHRoaXMgbXVzdCBiZSBjb21wZW5zYXRlZCBmb3IuIFRoaXMgZG9lc24ndCBzZWVtIHRvIHdvcmsgaW5zaWRlXG5cdFx0Ly8gaWZyYW1lcyB0aG91Z2ggKGxpa2UgaW4ganNGaWRkbGUpLlxuXHRcdHZhciBzdWJQaXhlbEZpeCwgcmVjdDtcblx0XHRpZiAoaXNGaXJlZm94ICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblx0XHRcdHJlbmRlcmVyLnN1YlBpeGVsRml4ID0gc3ViUGl4ZWxGaXggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNzcyhjb250YWluZXIsIHsgbGVmdDogMCwgdG9wOiAwIH0pO1xuXHRcdFx0XHRyZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRjc3MoY29udGFpbmVyLCB7XG5cdFx0XHRcdFx0bGVmdDogKG1hdGhDZWlsKHJlY3QubGVmdCkgLSByZWN0LmxlZnQpICsgUFgsXG5cdFx0XHRcdFx0dG9wOiAobWF0aENlaWwocmVjdC50b3ApIC0gcmVjdC50b3ApICsgUFhcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBydW4gdGhlIGZpeCBub3dcblx0XHRcdHN1YlBpeGVsRml4KCk7XG5cblx0XHRcdC8vIHJ1biBpdCBvbiByZXNpemVcblx0XHRcdGFkZEV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHN1YlBpeGVsRml4KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERldGVjdCB3aGV0aGVyIHRoZSByZW5kZXJlciBpcyBoaWRkZW4uIFRoaXMgaGFwcGVucyB3aGVuIG9uZSBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG5cdCAqIGhhcyBkaXNwbGF5OiBub25lLiAjNjA4LlxuXHQgKi9cblx0aXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuYm94V3JhcHBlci5nZXRCQm94KCkud2lkdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSByZW5kZXJlciBhbmQgaXRzIGFsbG9jYXRlZCBtZW1iZXJzLlxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRyZW5kZXJlckRlZnMgPSByZW5kZXJlci5kZWZzO1xuXHRcdHJlbmRlcmVyLmJveCA9IG51bGw7XG5cdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IHJlbmRlcmVyLmJveFdyYXBwZXIuZGVzdHJveSgpO1xuXG5cdFx0Ly8gQ2FsbCBkZXN0cm95IG9uIGFsbCBncmFkaWVudCBlbGVtZW50c1xuXHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHJlbmRlcmVyLmdyYWRpZW50cyB8fCB7fSk7XG5cdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0gbnVsbDtcblxuXHRcdC8vIERlZnMgYXJlIG51bGwgaW4gVk1MUmVuZGVyZXJcblx0XHQvLyBPdGhlcndpc2UsIGRlc3Ryb3kgdGhlbSBoZXJlLlxuXHRcdGlmIChyZW5kZXJlckRlZnMpIHtcblx0XHRcdHJlbmRlcmVyLmRlZnMgPSByZW5kZXJlckRlZnMuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBzdWIgcGl4ZWwgZml4IGhhbmRsZXJcblx0XHQvLyBXZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlcmUgaXMgYSBoYW5kbGVyLCBvdGhlcndpc2UgYWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByZWdpc3RlcmVkIGZvciBldmVudCAncmVzaXplJyBhcmUgcmVtb3ZlZFxuXHRcdC8vIFNlZSBpc3N1ZSAjOTgyXG5cdFx0aWYgKHJlbmRlcmVyLnN1YlBpeGVsRml4KSB7XG5cdFx0XHRyZW1vdmVFdmVudCh3aW4sICdyZXNpemUnLCByZW5kZXJlci5zdWJQaXhlbEZpeCk7XG5cdFx0fVxuXG5cdFx0cmVuZGVyZXIuYWxpZ25lZE9iamVjdHMgPSBudWxsO1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZm9yIGFuIFNWRyBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTmFtZVxuXHQgKi9cblx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSBuZXcgdGhpcy5FbGVtZW50KCk7XG5cdFx0d3JhcHBlci5pbml0KHRoaXMsIG5vZGVOYW1lKTtcblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogRHVtbXkgZnVuY3Rpb24gZm9yIHVzZSBpbiBjYW52YXMgcmVuZGVyZXJcblx0ICovXG5cdGRyYXc6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIHNpbXBsZSBIVE1MIHN0cmluZyBpbnRvIFNWRyB0c3BhbnNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHRleHROb2RlIFRoZSBwYXJlbnQgdGV4dCBTVkcgbm9kZVxuXHQgKi9cblx0YnVpbGRUZXh0OiBmdW5jdGlvbiAod3JhcHBlcikge1xuXHRcdHZhciB0ZXh0Tm9kZSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdGZvckV4cG9ydCA9IHJlbmRlcmVyLmZvckV4cG9ydCxcblx0XHRcdGxpbmVzID0gcGljayh3cmFwcGVyLnRleHRTdHIsICcnKS50b1N0cmluZygpXG5cdFx0XHRcdC5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPicpXG5cdFx0XHRcdC5yZXBsYWNlKC88KGl8ZW0pPi9nLCAnPHNwYW4gc3R5bGU9XCJmb250LXN0eWxlOml0YWxpY1wiPicpXG5cdFx0XHRcdC5yZXBsYWNlKC88YS9nLCAnPHNwYW4nKVxuXHRcdFx0XHQucmVwbGFjZSgvPFxcLyhifHN0cm9uZ3xpfGVtfGEpPi9nLCAnPC9zcGFuPicpXG5cdFx0XHRcdC5zcGxpdCgvPGJyLio/Pi9nKSxcblx0XHRcdGNoaWxkTm9kZXMgPSB0ZXh0Tm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0c3R5bGVSZWdleCA9IC9zdHlsZT1cIihbXlwiXSspXCIvLFxuXHRcdFx0aHJlZlJlZ2V4ID0gL2hyZWY9XCIoaHR0cFteXCJdKylcIi8sXG5cdFx0XHRwYXJlbnRYID0gYXR0cih0ZXh0Tm9kZSwgJ3gnKSxcblx0XHRcdHRleHRTdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdHdpZHRoID0gdGV4dFN0eWxlcyAmJiB0ZXh0U3R5bGVzLndpZHRoICYmIHBJbnQodGV4dFN0eWxlcy53aWR0aCksXG5cdFx0XHR0ZXh0TGluZUhlaWdodCA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy5saW5lSGVpZ2h0LFxuXHRcdFx0aSA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG5cdFx0Ly8vIHJlbW92ZSBvbGQgdGV4dFxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHRleHROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaV0pO1xuXHRcdH1cblxuXHRcdGlmICh3aWR0aCAmJiAhd3JhcHBlci5hZGRlZCkge1xuXHRcdFx0dGhpcy5ib3guYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyAvLyBhdHRhY2ggaXQgdG8gdGhlIERPTSB0byByZWFkIG9mZnNldCB3aWR0aFxuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBlbXB0eSBsaW5lIGF0IGVuZFxuXHRcdGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJycpIHtcblx0XHRcdGxpbmVzLnBvcCgpO1xuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIHRoZSBsaW5lc1xuXHRcdGVhY2gobGluZXMsIGZ1bmN0aW9uIChsaW5lLCBsaW5lTm8pIHtcblx0XHRcdHZhciBzcGFucywgc3Bhbk5vID0gMDtcblxuXHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZSgvPHNwYW4vZywgJ3x8fDxzcGFuJykucmVwbGFjZSgvPFxcL3NwYW4+L2csICc8L3NwYW4+fHx8Jyk7XG5cdFx0XHRzcGFucyA9IGxpbmUuc3BsaXQoJ3x8fCcpO1xuXG5cdFx0XHRlYWNoKHNwYW5zLCBmdW5jdGlvbiAoc3Bhbikge1xuXHRcdFx0XHRpZiAoc3BhbiAhPT0gJycgfHwgc3BhbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fSxcblx0XHRcdFx0XHRcdHRzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0c3BhbicpLFxuXHRcdFx0XHRcdFx0c3BhblN0eWxlOyAvLyAjMzkwXG5cdFx0XHRcdFx0aWYgKHN0eWxlUmVnZXgudGVzdChzcGFuKSkge1xuXHRcdFx0XHRcdFx0c3BhblN0eWxlID0gc3Bhbi5tYXRjaChzdHlsZVJlZ2V4KVsxXS5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLCAnJDFmaWxsJDInKTtcblx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdzdHlsZScsIHNwYW5TdHlsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChocmVmUmVnZXgudGVzdChzcGFuKSAmJiAhZm9yRXhwb3J0KSB7IC8vIE5vdCBmb3IgZXhwb3J0IC0gIzE1Mjlcblx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdvbmNsaWNrJywgJ2xvY2F0aW9uLmhyZWY9XFxcIicgKyBzcGFuLm1hdGNoKGhyZWZSZWdleClbMV0gKyAnXFxcIicpO1xuXHRcdFx0XHRcdFx0Y3NzKHRzcGFuLCB7IGN1cnNvcjogJ3BvaW50ZXInIH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNwYW4gPSAoc3Bhbi5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLCAnJykgfHwgJyAnKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLyZndDsvZywgJz4nKTtcblxuXHRcdFx0XHRcdC8vIE5lc3RlZCB0YWdzIGFyZW4ndCBzdXBwb3J0ZWQsIGFuZCBjYXVzZSBjcmFzaCBpbiBTYWZhcmkgKCMxNTk2KVxuXHRcdFx0XHRcdGlmIChzcGFuICE9PSAnICcpIHtcblxuXHRcdFx0XHRcdFx0Ly8gYWRkIHRoZSB0ZXh0IG5vZGVcblx0XHRcdFx0XHRcdHRzcGFuLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShzcGFuKSk7XG5cblx0XHRcdFx0XHRcdGlmICghc3Bhbk5vKSB7IC8vIGZpcnN0IHNwYW4gaW4gYSBsaW5lLCBhbGlnbiBpdCB0byB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVzLnggPSBwYXJlbnRYO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy5keCA9IDA7IC8vICMxNlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBhZGQgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgYXR0cmlidXRlcyk7XG5cblx0XHRcdFx0XHRcdC8vIGZpcnN0IHNwYW4gb24gc3Vic2VxdWVudCBsaW5lLCBhZGQgdGhlIGxpbmUgaGVpZ2h0XG5cdFx0XHRcdFx0XHRpZiAoIXNwYW5ObyAmJiBsaW5lTm8pIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBhbGxvdyBnZXR0aW5nIHRoZSByaWdodCBvZmZzZXQgaGVpZ2h0IGluIGV4cG9ydGluZyBpbiBJRVxuXHRcdFx0XHRcdFx0XHRpZiAoIWhhc1NWRyAmJiBmb3JFeHBvcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRjc3ModHNwYW4sIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIFNldCB0aGUgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQgc2l6ZSBvZiBlaXRoZXJcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIHRleHQgZWxlbWVudCBvciB0aGUgdHNwYW4gZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRhdHRyKFxuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLFxuXHRcdFx0XHRcdFx0XHRcdCdkeScsXG5cdFx0XHRcdFx0XHRcdFx0dGV4dExpbmVIZWlnaHQgfHwgcmVuZGVyZXIuZm9udE1ldHJpY3MoXG5cdFx0XHRcdFx0XHRcdFx0XHQvcHgkLy50ZXN0KHRzcGFuLnN0eWxlLmZvbnRTaXplKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnN0eWxlLmZvbnRTaXplIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dFN0eWxlcy5mb250U2l6ZVxuXHRcdFx0XHRcdFx0XHRcdCkuaCxcblx0XHRcdFx0XHRcdFx0XHQvLyBTYWZhcmkgNi4wLjIgLSB0b28gb3B0aW1pemVkIGZvciBpdHMgb3duIGdvb2QgKCMxNTM5KVxuXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aXRoIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTYWZhcmlcblx0XHRcdFx0XHRcdFx0XHRpc1dlYktpdCAmJiB0c3Bhbi5vZmZzZXRIZWlnaHRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGl0XG5cdFx0XHRcdFx0XHR0ZXh0Tm9kZS5hcHBlbmRDaGlsZCh0c3Bhbik7XG5cblx0XHRcdFx0XHRcdHNwYW5ObysrO1xuXG5cdFx0XHRcdFx0XHQvLyBjaGVjayB3aWR0aCBhbmQgYXBwbHkgc29mdCBicmVha3Ncblx0XHRcdFx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgd29yZHMgPSBzcGFuLnJlcGxhY2UoLyhbXlxcXl0pLS9nLCAnJDEtICcpLnNwbGl0KCcgJyksIC8vICMxMjczXG5cdFx0XHRcdFx0XHRcdFx0dG9vTG9uZyxcblx0XHRcdFx0XHRcdFx0XHRhY3R1YWxXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRjbGlwSGVpZ2h0ID0gd3JhcHBlci5fY2xpcEhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRyZXN0ID0gW10sXG5cdFx0XHRcdFx0XHRcdFx0ZHkgPSBwSW50KHRleHRMaW5lSGVpZ2h0IHx8IDE2KSxcblx0XHRcdFx0XHRcdFx0XHRzb2Z0TGluZU5vID0gMSxcblx0XHRcdFx0XHRcdFx0XHRiQm94O1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICh3b3Jkcy5sZW5ndGggfHwgcmVzdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgd3JhcHBlci5iQm94OyAvLyBkZWxldGUgY2FjaGVcblx0XHRcdFx0XHRcdFx0XHRiQm94ID0gd3JhcHBlci5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHRcdFx0YWN0dWFsV2lkdGggPSBiQm94LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHRvb0xvbmcgPSBhY3R1YWxXaWR0aCA+IHdpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghdG9vTG9uZyB8fCB3b3Jkcy5sZW5ndGggPT09IDEpIHsgLy8gbmV3IGxpbmUgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IHJlc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN0ID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod29yZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNvZnRMaW5lTm8rKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoY2xpcEhlaWdodCAmJiBzb2Z0TGluZU5vICogZHkgPiBjbGlwSGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZHMgPSBbJy4uLiddO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIuYXR0cigndGl0bGUnLCB3cmFwcGVyLnRleHRTdHIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3RzcGFuJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cih0c3Bhbiwge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZHk6IGR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eDogcGFyZW50WFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChzcGFuU3R5bGUpIHsgLy8gIzM5MFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ3N0eWxlJywgc3BhblN0eWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dE5vZGUuYXBwZW5kQ2hpbGQodHNwYW4pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFjdHVhbFdpZHRoID4gd2lkdGgpIHsgLy8gYSBzaW5nbGUgd29yZCBpcyBwcmVzc2luZyBpdCBvdXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoID0gYWN0dWFsV2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gYXBwZW5kIHRvIGV4aXN0aW5nIGxpbmUgdHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnJlbW92ZUNoaWxkKHRzcGFuLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdC51bnNoaWZ0KHdvcmRzLnBvcCgpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4uYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHdvcmRzLmpvaW4oJyAnKS5yZXBsYWNlKC8tIC9nLCAnLScpKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYnV0dG9uIHdpdGggcHJlc2V0IHN0YXRlc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsU3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGhvdmVyU3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXNzZWRTdGF0ZVxuXHQgKi9cblx0YnV0dG9uOiBmdW5jdGlvbiAodGV4dCwgeCwgeSwgY2FsbGJhY2ssIG5vcm1hbFN0YXRlLCBob3ZlclN0YXRlLCBwcmVzc2VkU3RhdGUsIGRpc2FibGVkU3RhdGUpIHtcblx0XHR2YXIgbGFiZWwgPSB0aGlzLmxhYmVsKHRleHQsIHgsIHksIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICdidXR0b24nKSxcblx0XHRcdGN1clN0YXRlID0gMCxcblx0XHRcdHN0YXRlT3B0aW9ucyxcblx0XHRcdHN0YXRlU3R5bGUsXG5cdFx0XHRub3JtYWxTdHlsZSxcblx0XHRcdGhvdmVyU3R5bGUsXG5cdFx0XHRwcmVzc2VkU3R5bGUsXG5cdFx0XHRkaXNhYmxlZFN0eWxlLFxuXHRcdFx0U1RZTEUgPSAnc3R5bGUnLFxuXHRcdFx0dmVydGljYWxHcmFkaWVudCA9IHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDEgfTtcblxuXHRcdC8vIE5vcm1hbCBzdGF0ZSAtIHByZXBhcmUgdGhlIGF0dHJpYnV0ZXNcblx0XHRub3JtYWxTdGF0ZSA9IG1lcmdlKHtcblx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0c3Ryb2tlOiAnI0NDQ0NDQycsXG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFswLCAnI0ZFRkVGRSddLFxuXHRcdFx0XHRcdFsxLCAnI0Y2RjZGNiddXG5cdFx0XHRcdF1cblx0XHRcdH0sXG5cdFx0XHRyOiAyLFxuXHRcdFx0cGFkZGluZzogNSxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnYmxhY2snXG5cdFx0XHR9XG5cdFx0fSwgbm9ybWFsU3RhdGUpO1xuXHRcdG5vcm1hbFN0eWxlID0gbm9ybWFsU3RhdGVbU1RZTEVdO1xuXHRcdGRlbGV0ZSBub3JtYWxTdGF0ZVtTVFlMRV07XG5cblx0XHQvLyBIb3ZlciBzdGF0ZVxuXHRcdGhvdmVyU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFswLCAnI0ZGRiddLFxuXHRcdFx0XHRcdFsxLCAnI0FDRiddXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHR9LCBob3ZlclN0YXRlKTtcblx0XHRob3ZlclN0eWxlID0gaG92ZXJTdGF0ZVtTVFlMRV07XG5cdFx0ZGVsZXRlIGhvdmVyU3RhdGVbU1RZTEVdO1xuXG5cdFx0Ly8gUHJlc3NlZCBzdGF0ZVxuXHRcdHByZXNzZWRTdGF0ZSA9IG1lcmdlKG5vcm1hbFN0YXRlLCB7XG5cdFx0XHRzdHJva2U6ICcjNjhBJyxcblx0XHRcdGZpbGw6IHtcblx0XHRcdFx0bGluZWFyR3JhZGllbnQ6IHZlcnRpY2FsR3JhZGllbnQsXG5cdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0WzAsICcjOUJEJ10sXG5cdFx0XHRcdFx0WzEsICcjQ0RGJ11cblx0XHRcdFx0XVxuXHRcdFx0fVxuXHRcdH0sIHByZXNzZWRTdGF0ZSk7XG5cdFx0cHJlc3NlZFN0eWxlID0gcHJlc3NlZFN0YXRlW1NUWUxFXTtcblx0XHRkZWxldGUgcHJlc3NlZFN0YXRlW1NUWUxFXTtcblxuXHRcdC8vIERpc2FibGVkIHN0YXRlXG5cdFx0ZGlzYWJsZWRTdGF0ZSA9IG1lcmdlKG5vcm1hbFN0YXRlLCB7XG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyNDQ0MnXG5cdFx0XHR9XG5cdFx0fSwgZGlzYWJsZWRTdGF0ZSk7XG5cdFx0ZGlzYWJsZWRTdHlsZSA9IGRpc2FibGVkU3RhdGVbU1RZTEVdO1xuXHRcdGRlbGV0ZSBkaXNhYmxlZFN0YXRlW1NUWUxFXTtcblxuXHRcdC8vIEFkZCB0aGUgZXZlbnRzLiBJRTkgYW5kIElFMTAgbmVlZCBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IHRvIGZ1bmNpdG9uICgjNjY3KS5cblx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3ZlcicgOiAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChjdXJTdGF0ZSAhPT0gMykge1xuXHRcdFx0XHRsYWJlbC5hdHRyKGhvdmVyU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhob3ZlclN0eWxlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3V0JyA6ICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdHN0YXRlT3B0aW9ucyA9IFtub3JtYWxTdGF0ZSwgaG92ZXJTdGF0ZSwgcHJlc3NlZFN0YXRlXVtjdXJTdGF0ZV07XG5cdFx0XHRcdHN0YXRlU3R5bGUgPSBbbm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIHByZXNzZWRTdHlsZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRsYWJlbC5hdHRyKHN0YXRlT3B0aW9ucylcblx0XHRcdFx0XHQuY3NzKHN0YXRlU3R5bGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGFiZWwuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdGxhYmVsLnN0YXRlID0gY3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdGlmICghc3RhdGUpIHtcblx0XHRcdFx0bGFiZWwuYXR0cihub3JtYWxTdGF0ZSlcblx0XHRcdFx0XHQuY3NzKG5vcm1hbFN0eWxlKTtcblx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09IDIpIHtcblx0XHRcdFx0bGFiZWwuYXR0cihwcmVzc2VkU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhwcmVzc2VkU3R5bGUpO1xuXHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gMykge1xuXHRcdFx0XHRsYWJlbC5hdHRyKGRpc2FibGVkU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhkaXNhYmxlZFN0eWxlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIGxhYmVsXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY3VyU3RhdGUgIT09IDMpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGxhYmVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5hdHRyKG5vcm1hbFN0YXRlKVxuXHRcdFx0LmNzcyhleHRlbmQoeyBjdXJzb3I6ICdkZWZhdWx0JyB9LCBub3JtYWxTdHlsZSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYWtlIGEgc3RyYWlnaHQgbGluZSBjcmlzcGVyIGJ5IG5vdCBzcGlsbGluZyBvdXQgdG8gbmVpZ2hib3VyIHBpeGVsc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqL1xuXHRjcmlzcExpbmU6IGZ1bmN0aW9uIChwb2ludHMsIHdpZHRoKSB7XG5cdFx0Ly8gcG9pbnRzIGZvcm1hdDogW00sIDAsIDAsIEwsIDEwMCwgMF1cblx0XHQvLyBub3JtYWxpemUgdG8gYSBjcmlzcCBsaW5lXG5cdFx0aWYgKHBvaW50c1sxXSA9PT0gcG9pbnRzWzRdKSB7XG5cdFx0XHQvLyBTdWJzdHJhY3QgZHVlIHRvICMxMTI5LiBOb3cgYm90dG9tIGFuZCBsZWZ0IGF4aXMgZ3JpZGxpbmVzIGJlaGF2ZSB0aGUgc2FtZS5cblx0XHRcdHBvaW50c1sxXSA9IHBvaW50c1s0XSA9IG1hdGhSb3VuZChwb2ludHNbMV0pIC0gKHdpZHRoICUgMiAvIDIpO1xuXHRcdH1cblx0XHRpZiAocG9pbnRzWzJdID09PSBwb2ludHNbNV0pIHtcblx0XHRcdHBvaW50c1syXSA9IHBvaW50c1s1XSA9IG1hdGhSb3VuZChwb2ludHNbMl0pICsgKHdpZHRoICUgMiAvIDIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIERyYXcgYSBwYXRoXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gU1ZHIHBhdGggaW4gYXJyYXkgZm9ybVxuXHQgKi9cblx0cGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR2YXIgYXR0ciA9IHtcblx0XHRcdGZpbGw6IE5PTkVcblx0XHR9O1xuXHRcdGlmIChpc0FycmF5KHBhdGgpKSB7XG5cdFx0XHRhdHRyLmQgPSBwYXRoO1xuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0ZXh0ZW5kKGF0dHIsIHBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdwYXRoJykuYXR0cihhdHRyKTtcblx0fSxcblxuXHQvKipcblx0ICogRHJhdyBhbmQgcmV0dXJuIGFuIFNWRyBjaXJjbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJhZGl1c1xuXHQgKi9cblx0Y2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcikge1xuXHRcdHZhciBhdHRyID0gaXNPYmplY3QoeCkgP1xuXHRcdFx0eCA6XG5cdFx0XHR7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHI6IHJcblx0XHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdjaXJjbGUnKS5hdHRyKGF0dHIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IGFuZCByZXR1cm4gYW4gYXJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gciBSYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUiBJbm5lciByYWRpdXMgbGlrZSB1c2VkIGluIGRvbnV0IGNoYXJ0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnRpbmcgYW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmRpbmcgYW5nbGVcblx0ICovXG5cdGFyYzogZnVuY3Rpb24gKHgsIHksIHIsIGlubmVyUiwgc3RhcnQsIGVuZCkge1xuXHRcdHZhciBhcmM7XG5cblx0XHRpZiAoaXNPYmplY3QoeCkpIHtcblx0XHRcdHkgPSB4Lnk7XG5cdFx0XHRyID0geC5yO1xuXHRcdFx0aW5uZXJSID0geC5pbm5lclI7XG5cdFx0XHRzdGFydCA9IHguc3RhcnQ7XG5cdFx0XHRlbmQgPSB4LmVuZDtcblx0XHRcdHggPSB4Lng7XG5cdFx0fVxuXG5cdFx0Ly8gQXJjcyBhcmUgZGVmaW5lZCBhcyBzeW1ib2xzIGZvciB0aGUgYWJpbGl0eSB0byBzZXRcblx0XHQvLyBhdHRyaWJ1dGVzIGluIGF0dHIgYW5kIGFuaW1hdGVcblx0XHRhcmMgPSB0aGlzLnN5bWJvbCgnYXJjJywgeCB8fCAwLCB5IHx8IDAsIHIgfHwgMCwgciB8fCAwLCB7XG5cdFx0XHRpbm5lclI6IGlubmVyUiB8fCAwLFxuXHRcdFx0c3RhcnQ6IHN0YXJ0IHx8IDAsXG5cdFx0XHRlbmQ6IGVuZCB8fCAwXG5cdFx0fSk7XG5cdFx0YXJjLnIgPSByOyAvLyAjOTU5XG5cdFx0cmV0dXJuIGFyYztcblx0fSxcblxuXHQvKipcblx0ICogRHJhdyBhbmQgcmV0dXJuIGEgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByIEJvcmRlciBjb3JuZXIgcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aCBBIHN0cm9rZSB3aWR0aCBjYW4gYmUgc3VwcGxpZWQgdG8gYWxsb3cgY3Jpc3AgZHJhd2luZ1xuXHQgKi9cblx0cmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHIsIHN0cm9rZVdpZHRoKSB7XG5cblx0XHRyID0gaXNPYmplY3QoeCkgPyB4LnIgOiByO1xuXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3JlY3QnKS5hdHRyKHtcblx0XHRcdFx0cng6IHIsXG5cdFx0XHRcdHJ5OiByLFxuXHRcdFx0XHRmaWxsOiBOT05FXG5cdFx0XHR9KTtcblx0XHRyZXR1cm4gd3JhcHBlci5hdHRyKFxuXHRcdFx0XHRpc09iamVjdCh4KSA/XG5cdFx0XHRcdFx0eCA6XG5cdFx0XHRcdFx0Ly8gZG8gbm90IGNyaXNwaWZ5IHdoZW4gYW4gb2JqZWN0IGlzIHBhc3NlZCBpbiAoYXMgaW4gY29sdW1uIGNoYXJ0cylcblx0XHRcdFx0XHR3cmFwcGVyLmNyaXNwKHN0cm9rZVdpZHRoLCB4LCB5LCBtYXRoTWF4KHdpZHRoLCAwKSwgbWF0aE1heChoZWlnaHQsIDApKVxuXHRcdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVzaXplIHRoZSBib3ggYW5kIHJlLWFsaWduIGFsbCBhbGlnbmVkIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3aWR0aFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGVpZ2h0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZVxuXHQgKlxuXHQgKi9cblx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGUpIHtcblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0YWxpZ25lZE9iamVjdHMgPSByZW5kZXJlci5hbGlnbmVkT2JqZWN0cyxcblx0XHRcdGkgPSBhbGlnbmVkT2JqZWN0cy5sZW5ndGg7XG5cblx0XHRyZW5kZXJlci53aWR0aCA9IHdpZHRoO1xuXHRcdHJlbmRlcmVyLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHJlbmRlcmVyLmJveFdyYXBwZXJbcGljayhhbmltYXRlLCB0cnVlKSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oe1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHR9KTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGFsaWduZWRPYmplY3RzW2ldLmFsaWduKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBncm91cFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZ3JvdXAgd2lsbCBiZSBnaXZlbiBhIGNsYXNzIG5hbWUgb2YgJ2hpZ2hjaGFydHMte25hbWV9Jy5cblx0ICogICAgIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHN0eWxpbmcgYW5kIHNjcmlwdGluZy5cblx0ICovXG5cdGc6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2cnKTtcblx0XHRyZXR1cm4gZGVmaW5lZChuYW1lKSA/IGVsZW0uYXR0cih7ICdjbGFzcyc6IFBSRUZJWCArIG5hbWUgfSkgOiBlbGVtO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5IGFuIGltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdGltYWdlOiBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGF0dHJpYnMgPSB7XG5cdFx0XHRcdHByZXNlcnZlQXNwZWN0UmF0aW86IE5PTkVcblx0XHRcdH0sXG5cdFx0XHRlbGVtV3JhcHBlcjtcblxuXHRcdC8vIG9wdGlvbmFsIHByb3BlcnRpZXNcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGV4dGVuZChhdHRyaWJzLCB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGVsZW1XcmFwcGVyID0gdGhpcy5jcmVhdGVFbGVtZW50KCdpbWFnZScpLmF0dHIoYXR0cmlicyk7XG5cblx0XHQvLyBzZXQgdGhlIGhyZWYgaW4gdGhlIHhsaW5rIG5hbWVzcGFjZVxuXHRcdGlmIChlbGVtV3JhcHBlci5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKSB7XG5cdFx0XHRlbGVtV3JhcHBlci5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHRcdFx0J2hyZWYnLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjb3VsZCBiZSBleHBvcnRpbmcgaW4gSUVcblx0XHRcdC8vIHVzaW5nIGhyZWYgdGhyb3dzIFwibm90IHN1cHBvcnRlZFwiIGluIGllNyBhbmQgdW5kZXIsIHJlcXVyaWVzIHJlZ2V4IHNoaW0gdG8gZml4IGxhdGVyXG5cdFx0XHRlbGVtV3JhcHBlci5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGMtc3ZnLWhyZWYnLCBzcmMpO1xuXHR9XG5cblx0XHRyZXR1cm4gZWxlbVdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgYSBzeW1ib2wgb3V0IG9mIHByZS1kZWZpbmVkIHNoYXBlIHBhdGhzIGZyb20gdGhlIG5hbWVzcGFjZSAnc3ltYm9sJyBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2xcblx0ICogQHBhcmFtIHtPYmplY3R9IHhcblx0ICogQHBhcmFtIHtPYmplY3R9IHlcblx0ICogQHBhcmFtIHtPYmplY3R9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0c3ltYm9sOiBmdW5jdGlvbiAoc3ltYm9sLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cblx0XHR2YXIgb2JqLFxuXG5cdFx0XHQvLyBnZXQgdGhlIHN5bWJvbCBkZWZpbml0aW9uIGZ1bmN0aW9uXG5cdFx0XHRzeW1ib2xGbiA9IHRoaXMuc3ltYm9sc1tzeW1ib2xdLFxuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGVyZSdzIGEgcGF0aCBkZWZpbmVkIGZvciB0aGlzIHN5bWJvbFxuXHRcdFx0cGF0aCA9IHN5bWJvbEZuICYmIHN5bWJvbEZuKFxuXHRcdFx0XHRtYXRoUm91bmQoeCksXG5cdFx0XHRcdG1hdGhSb3VuZCh5KSxcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0b3B0aW9uc1xuXHRcdFx0KSxcblxuXHRcdFx0aW1hZ2VFbGVtZW50LFxuXHRcdFx0aW1hZ2VSZWdleCA9IC9edXJsXFwoKC4qPylcXCkkLyxcblx0XHRcdGltYWdlU3JjLFxuXHRcdFx0aW1hZ2VTaXplLFxuXHRcdFx0Y2VudGVySW1hZ2U7XG5cblx0XHRpZiAocGF0aCkge1xuXG5cdFx0XHRvYmogPSB0aGlzLnBhdGgocGF0aCk7XG5cdFx0XHQvLyBleHBhbmRvIHByb3BlcnRpZXMgZm9yIHVzZSBpbiBhbmltYXRlIGFuZCBhdHRyXG5cdFx0XHRleHRlbmQob2JqLCB7XG5cdFx0XHRcdHN5bWJvbE5hbWU6IHN5bWJvbCxcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeSxcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0XHRleHRlbmQob2JqLCBvcHRpb25zKTtcblx0XHRcdH1cblxuXG5cdFx0Ly8gaW1hZ2Ugc3ltYm9sc1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2VSZWdleC50ZXN0KHN5bWJvbCkpIHtcblxuXHRcdFx0Ly8gT24gaW1hZ2UgbG9hZCwgc2V0IHRoZSBzaXplIGFuZCBwb3NpdGlvblxuXHRcdFx0Y2VudGVySW1hZ2UgPSBmdW5jdGlvbiAoaW1nLCBzaXplKSB7XG5cdFx0XHRcdGlmIChpbWcuZWxlbWVudCkgeyAvLyBpdCBtYXkgYmUgZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEzOTApXG5cdFx0XHRcdFx0aW1nLmF0dHIoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IHNpemVbMF0sXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHNpemVbMV1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGlmICghaW1nLmFsaWduQnlUcmFuc2xhdGUpIHsgLy8gIzE4NVxuXHRcdFx0XHRcdFx0aW1nLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKCh3aWR0aCAtIHNpemVbMF0pIC8gMiksIC8vICMxMzc4XG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZCgoaGVpZ2h0IC0gc2l6ZVsxXSkgLyAyKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGltYWdlU3JjID0gc3ltYm9sLm1hdGNoKGltYWdlUmVnZXgpWzFdO1xuXHRcdFx0aW1hZ2VTaXplID0gc3ltYm9sU2l6ZXNbaW1hZ2VTcmNdO1xuXG5cdFx0XHQvLyBJcmVhdGUgdGhlIGltYWdlIHN5bmNocm9ub3VzbHksIGFkZCBhdHRyaWJzIGFzeW5jXG5cdFx0XHRvYmogPSB0aGlzLmltYWdlKGltYWdlU3JjKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5XG5cdFx0XHRcdH0pO1xuXHRcdFx0b2JqLmlzSW1nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGltYWdlU2l6ZSkge1xuXHRcdFx0XHRjZW50ZXJJbWFnZShvYmosIGltYWdlU2l6ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbml0aWFsaXplIGltYWdlIHRvIGJlIDAgc2l6ZSBzbyBleHBvcnQgd2lsbCBzdGlsbCBmdW5jdGlvbiBpZiB0aGVyZSdzIG5vIGNhY2hlZCBzaXplcy5cblx0XHRcdFx0Ly9cblx0XHRcdFx0b2JqLmF0dHIoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IEphdmFTY3JpcHQgaW1hZ2UgdG8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0LiBEdWUgdG8gYSBidWcgaW4gSUUgPCA4LFxuXHRcdFx0XHQvLyB0aGUgY3JlYXRlZCBlbGVtZW50IG11c3QgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZSBpbiBvcmRlciB0byBsb2FkICgjMjkyKS5cblx0XHRcdFx0aW1hZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgnaW1nJywge1xuXHRcdFx0XHRcdG9ubG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y2VudGVySW1hZ2Uob2JqLCBzeW1ib2xTaXplc1tpbWFnZVNyY10gPSBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHNyYzogaW1hZ2VTcmNcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvKipcblx0ICogQW4gZXh0ZW5kYWJsZSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBmb3IgZGVmaW5pbmcgc3ltYm9sIHBhdGhzLlxuXHQgKi9cblx0c3ltYm9sczoge1xuXHRcdCdjaXJjbGUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0dmFyIGNwdyA9IDAuMTY2ICogdztcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdE0sIHggKyB3IC8gMiwgeSxcblx0XHRcdFx0J0MnLCB4ICsgdyArIGNwdywgeSwgeCArIHcgKyBjcHcsIHkgKyBoLCB4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHQnQycsIHggLSBjcHcsIHkgKyBoLCB4IC0gY3B3LCB5LCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdCdaJ1xuXHRcdFx0XTtcblx0XHR9LFxuXG5cdFx0J3NxdWFyZSc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLCB4LCB5LFxuXHRcdFx0XHRMLCB4ICsgdywgeSxcblx0XHRcdFx0eCArIHcsIHkgKyBoLFxuXHRcdFx0XHR4LCB5ICsgaCxcblx0XHRcdFx0J1onXG5cdFx0XHRdO1xuXHRcdH0sXG5cblx0XHQndHJpYW5nbGUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRMLCB4ICsgdywgeSArIGgsXG5cdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHQnWidcblx0XHRcdF07XG5cdFx0fSxcblxuXHRcdCd0cmlhbmdsZS1kb3duJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdEwsIHggKyB3LCB5LFxuXHRcdFx0XHR4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHQnWidcblx0XHRcdF07XG5cdFx0fSxcblx0XHQnZGlhbW9uZCc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdEwsIHggKyB3LCB5ICsgaCAvIDIsXG5cdFx0XHRcdHggKyB3IC8gMiwgeSArIGgsXG5cdFx0XHRcdHgsIHkgKyBoIC8gMixcblx0XHRcdFx0J1onXG5cdFx0XHRdO1xuXHRcdH0sXG5cdFx0J2FyYyc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRyYWRpdXMgPSBvcHRpb25zLnIgfHwgdyB8fCBoLFxuXHRcdFx0XHRlbmQgPSBvcHRpb25zLmVuZCAtIDAuMDAxLCAvLyB0byBwcmV2ZW50IGNvcyBhbmQgc2luIG9mIHN0YXJ0IGFuZCBlbmQgZnJvbSBiZWNvbWluZyBlcXVhbCBvbiAzNjAgYXJjcyAocmVsYXRlZDogIzE1NjEpXG5cdFx0XHRcdGlubmVyUmFkaXVzID0gb3B0aW9ucy5pbm5lclIsXG5cdFx0XHRcdG9wZW4gPSBvcHRpb25zLm9wZW4sXG5cdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdGNvc0VuZCA9IG1hdGhDb3MoZW5kKSxcblx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRsb25nQXJjID0gb3B0aW9ucy5lbmQgLSBzdGFydCA8IG1hdGhQSSA/IDAgOiAxO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLFxuXHRcdFx0XHR4ICsgcmFkaXVzICogY29zU3RhcnQsXG5cdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5TdGFydCxcblx0XHRcdFx0J0EnLCAvLyBhcmNUb1xuXHRcdFx0XHRyYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdHJhZGl1cywgLy8geSByYWRpdXNcblx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0bG9uZ0FyYywgLy8gbG9uZyBvciBzaG9ydCBhcmNcblx0XHRcdFx0MSwgLy8gY2xvY2t3aXNlXG5cdFx0XHRcdHggKyByYWRpdXMgKiBjb3NFbmQsXG5cdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdG9wZW4gPyBNIDogTCxcblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zRW5kLFxuXHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdCdBJywgLy8gYXJjVG9cblx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdGlubmVyUmFkaXVzLCAvLyB5IHJhZGl1c1xuXHRcdFx0XHQwLCAvLyBzbGFudGluZ1xuXHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHQwLCAvLyBjbG9ja3dpc2Vcblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zU3RhcnQsXG5cdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LFxuXG5cdFx0XHRcdG9wZW4gPyAnJyA6ICdaJyAvLyBjbG9zZVxuXHRcdFx0XTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlZmluZSBhIGNsaXBwaW5nIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdGNsaXBSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciB3cmFwcGVyLFxuXHRcdFx0aWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKyxcblxuXHRcdFx0Y2xpcFBhdGggPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJykuYXR0cih7XG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fSkuYWRkKHRoaXMuZGVmcyk7XG5cblx0XHR3cmFwcGVyID0gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIDApLmFkZChjbGlwUGF0aCk7XG5cdFx0d3JhcHBlci5pZCA9IGlkO1xuXHRcdHdyYXBwZXIuY2xpcFBhdGggPSBjbGlwUGF0aDtcblxuXHRcdHJldHVybiB3cmFwcGVyO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFRha2UgYSBjb2xvciBhbmQgcmV0dXJuIGl0IGlmIGl0J3MgYSBzdHJpbmcsIG1ha2UgaXQgYSBncmFkaWVudCBpZiBpdCdzIGFcblx0ICogZ3JhZGllbnQgY29uZmlndXJhdGlvbiBvYmplY3QuIFByaW9yIHRvIEhpZ2hzdG9jaywgYW4gYXJyYXkgd2FzIHVzZWQgdG8gZGVmaW5lXG5cdCAqIGEgbGluZWFyIGdyYWRpZW50IHdpdGggcGl4ZWwgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBTVkcuIEluIG5ld2VyIHZlcnNpb25zXG5cdCAqIHdlIGNoYW5nZSB0aGUgY29vcmRpbmF0ZXMgdG8gYXBwbHkgcmVsYXRpdmUgdG8gdGhlIHNoYXBlLCB1c2luZyBjb29yZGluYXRlc1xuXHQgKiAwLTEgd2l0aGluIHRoZSBzaGFwZS4gVG8gcHJlc2VydmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGxpbmVhckdyYWRpZW50XG5cdCAqIGluIHRoaXMgZGVmaW5pdGlvbiBpcyBhbiBvYmplY3Qgb2YgeDEsIHkxLCB4MiBhbmQgeTIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvciBUaGUgY29sb3Igb3IgY29uZmlnIG9iamVjdFxuXHQgKi9cblx0Y29sb3I6IGZ1bmN0aW9uIChjb2xvciwgZWxlbSwgcHJvcCkge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRjb2xvck9iamVjdCxcblx0XHRcdHJlZ2V4UmdiYSA9IC9ecmdiYS8sXG5cdFx0XHRncmFkTmFtZSxcblx0XHRcdGdyYWRBdHRyLFxuXHRcdFx0Z3JhZGllbnRzLFxuXHRcdFx0Z3JhZGllbnRPYmplY3QsXG5cdFx0XHRzdG9wcyxcblx0XHRcdHN0b3BDb2xvcixcblx0XHRcdHN0b3BPcGFjaXR5LFxuXHRcdFx0cmFkaWFsUmVmZXJlbmNlLFxuXHRcdFx0bixcblx0XHRcdGlkLFxuXHRcdFx0a2V5ID0gW107XG5cblx0XHQvLyBBcHBseSBsaW5lYXIgb3IgcmFkaWFsIGdyYWRpZW50c1xuXHRcdGlmIChjb2xvciAmJiBjb2xvci5saW5lYXJHcmFkaWVudCkge1xuXHRcdFx0Z3JhZE5hbWUgPSAnbGluZWFyR3JhZGllbnQnO1xuXHRcdH0gZWxzZSBpZiAoY29sb3IgJiYgY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdGdyYWROYW1lID0gJ3JhZGlhbEdyYWRpZW50Jztcblx0XHR9XG5cblx0XHRpZiAoZ3JhZE5hbWUpIHtcblx0XHRcdGdyYWRBdHRyID0gY29sb3JbZ3JhZE5hbWVdO1xuXHRcdFx0Z3JhZGllbnRzID0gcmVuZGVyZXIuZ3JhZGllbnRzO1xuXHRcdFx0c3RvcHMgPSBjb2xvci5zdG9wcztcblx0XHRcdHJhZGlhbFJlZmVyZW5jZSA9IGVsZW0ucmFkaWFsUmVmZXJlbmNlO1xuXG5cdFx0XHQvLyBLZWVwIDwgMi4yIGtvbXBhdGliaWxpdHlcblx0XHRcdGlmIChpc0FycmF5KGdyYWRBdHRyKSkge1xuXHRcdFx0XHRjb2xvcltncmFkTmFtZV0gPSBncmFkQXR0ciA9IHtcblx0XHRcdFx0XHR4MTogZ3JhZEF0dHJbMF0sXG5cdFx0XHRcdFx0eTE6IGdyYWRBdHRyWzFdLFxuXHRcdFx0XHRcdHgyOiBncmFkQXR0clsyXSxcblx0XHRcdFx0XHR5MjogZ3JhZEF0dHJbM10sXG5cdFx0XHRcdFx0Z3JhZGllbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3JyZWN0IHRoZSByYWRpYWwgZ3JhZGllbnQgZm9yIHRoZSByYWRpYWwgcmVmZXJlbmNlIHN5c3RlbVxuXHRcdFx0aWYgKGdyYWROYW1lID09PSAncmFkaWFsR3JhZGllbnQnICYmIHJhZGlhbFJlZmVyZW5jZSAmJiAhZGVmaW5lZChncmFkQXR0ci5ncmFkaWVudFVuaXRzKSkge1xuXHRcdFx0XHRncmFkQXR0ciA9IG1lcmdlKGdyYWRBdHRyLCB7XG5cdFx0XHRcdFx0Y3g6IChyYWRpYWxSZWZlcmVuY2VbMF0gLSByYWRpYWxSZWZlcmVuY2VbMl0gLyAyKSArIGdyYWRBdHRyLmN4ICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdGN5OiAocmFkaWFsUmVmZXJlbmNlWzFdIC0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gMikgKyBncmFkQXR0ci5jeSAqIHJhZGlhbFJlZmVyZW5jZVsyXSxcblx0XHRcdFx0XHRyOiBncmFkQXR0ci5yICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1aWxkIHRoZSB1bmlxdWUga2V5IHRvIGRldGVjdCB3aGV0aGVyIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgKCMxMjgyKVxuXHRcdFx0Zm9yIChuIGluIGdyYWRBdHRyKSB7XG5cdFx0XHRcdGlmIChuICE9PSAnaWQnKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2gobiwgZ3JhZEF0dHJbbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKG4gaW4gc3RvcHMpIHtcblx0XHRcdFx0a2V5LnB1c2goc3RvcHNbbl0pO1xuXHRcdFx0fVxuXHRcdFx0a2V5ID0ga2V5LmpvaW4oJywnKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBncmFkaWVudCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBjb25maWcgb2JqZWN0IGlzIGNyZWF0ZWQgd2l0aGluIHRoaXMgcmVuZGVyZXJcblx0XHRcdGlmIChncmFkaWVudHNba2V5XSkge1xuXHRcdFx0XHRpZCA9IGdyYWRpZW50c1trZXldLmlkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgaWQgYW5kIGNyZWF0ZSB0aGUgZWxlbWVudFxuXHRcdFx0XHRncmFkQXR0ci5pZCA9IGlkID0gUFJFRklYICsgaWRDb3VudGVyKys7XG5cdFx0XHRcdGdyYWRpZW50c1trZXldID0gZ3JhZGllbnRPYmplY3QgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KGdyYWROYW1lKVxuXHRcdFx0XHRcdC5hdHRyKGdyYWRBdHRyKVxuXHRcdFx0XHRcdC5hZGQocmVuZGVyZXIuZGVmcyk7XG5cblxuXHRcdFx0XHQvLyBUaGUgZ3JhZGllbnQgbmVlZHMgdG8ga2VlcCBhIGxpc3Qgb2Ygc3RvcHMgdG8gYmUgYWJsZSB0byBkZXN0cm95IHRoZW1cblx0XHRcdFx0Z3JhZGllbnRPYmplY3Quc3RvcHMgPSBbXTtcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0XHR2YXIgc3RvcE9iamVjdDtcblx0XHRcdFx0XHRpZiAocmVnZXhSZ2JhLnRlc3Qoc3RvcFsxXSkpIHtcblx0XHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcFsxXTtcblx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RvcE9iamVjdCA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3N0b3AnKS5hdHRyKHtcblx0XHRcdFx0XHRcdG9mZnNldDogc3RvcFswXSxcblx0XHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLFxuXHRcdFx0XHRcdFx0J3N0b3Atb3BhY2l0eSc6IHN0b3BPcGFjaXR5XG5cdFx0XHRcdFx0fSkuYWRkKGdyYWRpZW50T2JqZWN0KTtcblxuXHRcdFx0XHRcdC8vIEFkZCB0aGUgc3RvcCBlbGVtZW50IHRvIHRoZSBncmFkaWVudFxuXHRcdFx0XHRcdGdyYWRpZW50T2JqZWN0LnN0b3BzLnB1c2goc3RvcE9iamVjdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIHJlZmVyZW5jZSB0byB0aGUgZ3JhZGllbnQgb2JqZWN0XG5cdFx0XHRyZXR1cm4gJ3VybCgnICsgcmVuZGVyZXIudXJsICsgJyMnICsgaWQgKyAnKSc7XG5cblx0XHQvLyBXZWJraXQgYW5kIEJhdGlrIGNhbid0IHNob3cgcmdiYS5cblx0XHR9IGVsc2UgaWYgKHJlZ2V4UmdiYS50ZXN0KGNvbG9yKSkge1xuXHRcdFx0Y29sb3JPYmplY3QgPSBDb2xvcihjb2xvcik7XG5cdFx0XHRhdHRyKGVsZW0sIHByb3AgKyAnLW9wYWNpdHknLCBjb2xvck9iamVjdC5nZXQoJ2EnKSk7XG5cblx0XHRcdHJldHVybiBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBvcGFjaXR5IGF0dHJpYnV0ZSBhZGRlZCBhYm92ZS4gRG9lcyBub3QgdGhyb3cgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgdGhlcmUuXG5cdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZShwcm9wICsgJy1vcGFjaXR5Jyk7XG5cblx0XHRcdHJldHVybiBjb2xvcjtcblx0XHR9XG5cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBBZGQgdGV4dCB0byB0aGUgU1ZHIG9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlSFRNTCBVc2UgSFRNTCB0byByZW5kZXIgdGhlIHRleHRcblx0ICovXG5cdHRleHQ6IGZ1bmN0aW9uIChzdHIsIHgsIHksIHVzZUhUTUwpIHtcblxuXHRcdC8vIGRlY2xhcmUgdmFyaWFibGVzXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdGRlZmF1bHRDaGFydFN0eWxlID0gZGVmYXVsdE9wdGlvbnMuY2hhcnQuc3R5bGUsXG5cdFx0XHRmYWtlU1ZHID0gdXNlQ2FuVkcgfHwgKCFoYXNTVkcgJiYgcmVuZGVyZXIuZm9yRXhwb3J0KSxcblx0XHRcdHdyYXBwZXI7XG5cblx0XHRpZiAodXNlSFRNTCAmJiAhcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRyZXR1cm4gcmVuZGVyZXIuaHRtbChzdHIsIHgsIHkpO1xuXHRcdH1cblxuXHRcdHggPSBtYXRoUm91bmQocGljayh4LCAwKSk7XG5cdFx0eSA9IG1hdGhSb3VuZChwaWNrKHksIDApKTtcblxuXHRcdHdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCd0ZXh0Jylcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeSxcblx0XHRcdFx0dGV4dDogc3RyXG5cdFx0XHR9KVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdGZvbnRGYW1pbHk6IGRlZmF1bHRDaGFydFN0eWxlLmZvbnRGYW1pbHksXG5cdFx0XHRcdGZvbnRTaXplOiBkZWZhdWx0Q2hhcnRTdHlsZS5mb250U2l6ZVxuXHRcdFx0fSk7XG5cblx0XHQvLyBQcmV2ZW50IHdyYXBwaW5nIGZyb20gY3JlYXRpbmcgZmFsc2Ugb2Zmc2V0V2lkdGhzIGluIGV4cG9ydCBpbiBsZWdhY3kgSUUgKCMxMDc5LCAjMTA2Mylcblx0XHRpZiAoZmFrZVNWRykge1xuXHRcdFx0d3JhcHBlci5jc3Moe1xuXHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHdyYXBwZXIueCA9IHg7XG5cdFx0d3JhcHBlci55ID0geTtcblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgSFRNTCB0ZXh0IG5vZGUuIFRoaXMgaXMgdXNlZCBieSB0aGUgVk1MIHJlbmRlcmVyIGFzIHdlbGwgYXMgdGhlIFNWR1xuXHQgKiByZW5kZXJlciB0aHJvdWdoIHRoZSB1c2VIVE1MIG9wdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKi9cblx0aHRtbDogZnVuY3Rpb24gKHN0ciwgeCwgeSkge1xuXHRcdHZhciBkZWZhdWx0Q2hhcnRTdHlsZSA9IGRlZmF1bHRPcHRpb25zLmNoYXJ0LnN0eWxlLFxuXHRcdFx0d3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuXHRcdFx0YXR0clNldHRlcnMgPSB3cmFwcGVyLmF0dHJTZXR0ZXJzLFxuXHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcjtcblxuXHRcdC8vIFRleHQgc2V0dGVyXG5cdFx0YXR0clNldHRlcnMudGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9PSBlbGVtZW50LmlubmVySFRNTCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5iQm94O1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gVmFyaW91cyBzZXR0ZXJzIHdoaWNoIHJlbHkgb24gdXBkYXRlIHRyYW5zZm9ybVxuXHRcdGF0dHJTZXR0ZXJzLnggPSBhdHRyU2V0dGVycy55ID0gYXR0clNldHRlcnMuYWxpZ24gPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ2FsaWduJykge1xuXHRcdFx0XHRrZXkgPSAndGV4dEFsaWduJzsgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgU1ZHRWxlbWVudC5hbGlnbiBtZXRob2QuIFNhbWUgYXMgVk1MLlxuXHRcdFx0fVxuXHRcdFx0d3JhcHBlcltrZXldID0gdmFsdWU7XG5cdFx0XHR3cmFwcGVyLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblx0XHR3cmFwcGVyLmF0dHIoe1xuXHRcdFx0XHR0ZXh0OiBzdHIsXG5cdFx0XHRcdHg6IG1hdGhSb3VuZCh4KSxcblx0XHRcdFx0eTogbWF0aFJvdW5kKHkpXG5cdFx0XHR9KVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0d2hpdGVTcGFjZTogJ25vd3JhcCcsXG5cdFx0XHRcdGZvbnRGYW1pbHk6IGRlZmF1bHRDaGFydFN0eWxlLmZvbnRGYW1pbHksXG5cdFx0XHRcdGZvbnRTaXplOiBkZWZhdWx0Q2hhcnRTdHlsZS5mb250U2l6ZVxuXHRcdFx0fSk7XG5cblx0XHQvLyBVc2UgdGhlIEhUTUwgc3BlY2lmaWMgLmNzcyBtZXRob2Rcblx0XHR3cmFwcGVyLmNzcyA9IHdyYXBwZXIuaHRtbENzcztcblxuXHRcdC8vIFRoaXMgaXMgc3BlY2lmaWMgZm9yIEhUTUwgd2l0aGluIFNWR1xuXHRcdGlmIChyZW5kZXJlci5pc1NWRykge1xuXHRcdFx0d3JhcHBlci5hZGQgPSBmdW5jdGlvbiAoc3ZnR3JvdXBXcmFwcGVyKSB7XG5cblx0XHRcdFx0dmFyIGh0bWxHcm91cCxcblx0XHRcdFx0XHRjb250YWluZXIgPSByZW5kZXJlci5ib3gucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRwYXJlbnRHcm91cCxcblx0XHRcdFx0XHRwYXJlbnRzID0gW107XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGEgbW9jayBncm91cCB0byBob2xkIHRoZSBIVE1MIGVsZW1lbnRzXG5cdFx0XHRcdGlmIChzdmdHcm91cFdyYXBwZXIpIHtcblx0XHRcdFx0XHRodG1sR3JvdXAgPSBzdmdHcm91cFdyYXBwZXIuZGl2O1xuXHRcdFx0XHRcdGlmICghaHRtbEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlYWQgdGhlIHBhcmVudCBjaGFpbiBpbnRvIGFuIGFycmF5IGFuZCByZWFkIGZyb20gdG9wIGRvd25cblx0XHRcdFx0XHRcdHBhcmVudEdyb3VwID0gc3ZnR3JvdXBXcmFwcGVyO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHBhcmVudEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdFx0cGFyZW50cy5wdXNoKHBhcmVudEdyb3VwKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHVwIHRvIHRoZSBuZXh0IHBhcmVudCBncm91cFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwLnBhcmVudEdyb3VwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBFbnN1cmUgZHluYW1pY2FsbHkgdXBkYXRpbmcgcG9zaXRpb24gd2hlbiBhbnkgcGFyZW50IGlzIHRyYW5zbGF0ZWRcblx0XHRcdFx0XHRcdGVhY2gocGFyZW50cy5yZXZlcnNlKCksIGZ1bmN0aW9uIChwYXJlbnRHcm91cCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaHRtbEdyb3VwU3R5bGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgSFRNTCBkaXYgYW5kIGFwcGVuZCBpdCB0byB0aGUgcGFyZW50IGRpdiB0byBlbXVsYXRlXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBTVkcgZ3JvdXAgc3RydWN0dXJlXG5cdFx0XHRcdFx0XHRcdGh0bWxHcm91cCA9IHBhcmVudEdyb3VwLmRpdiA9IHBhcmVudEdyb3VwLmRpdiB8fCBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZTogYXR0cihwYXJlbnRHcm91cC5lbGVtZW50LCAnY2xhc3MnKVxuXHRcdFx0XHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRcdFx0XHRcdGxlZnQ6IChwYXJlbnRHcm91cC50cmFuc2xhdGVYIHx8IDApICsgUFgsXG5cdFx0XHRcdFx0XHRcdFx0dG9wOiAocGFyZW50R3JvdXAudHJhbnNsYXRlWSB8fCAwKSArIFBYXG5cdFx0XHRcdFx0XHRcdH0sIGh0bWxHcm91cCB8fCBjb250YWluZXIpOyAvLyB0aGUgdG9wIGdyb3VwIGlzIGFwcGVuZGVkIHRvIGNvbnRhaW5lclxuXG5cdFx0XHRcdFx0XHRcdC8vIFNob3J0Y3V0XG5cdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlID0gaHRtbEdyb3VwLnN0eWxlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNldCBsaXN0ZW5lcnMgdG8gdXBkYXRlIHRoZSBIVE1MIGRpdidzIHBvc2l0aW9uIHdoZW5ldmVyIHRoZSBTVkcgZ3JvdXBcblx0XHRcdFx0XHRcdFx0Ly8gcG9zaXRpb24gaXMgY2hhbmdlZFxuXHRcdFx0XHRcdFx0XHRleHRlbmQocGFyZW50R3JvdXAuYXR0clNldHRlcnMsIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlLmxlZnQgPSB2YWx1ZSArIFBYO1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRodG1sR3JvdXBTdHlsZS50b3AgPSB2YWx1ZSArIFBYO1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aHRtbEdyb3VwID0gY29udGFpbmVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aHRtbEdyb3VwLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0XHRcdC8vIFNoYXJlZCB3aXRoIFZNTDpcblx0XHRcdFx0d3JhcHBlci5hZGRlZCA9IHRydWU7XG5cdFx0XHRcdGlmICh3cmFwcGVyLmFsaWduT25BZGQpIHtcblx0XHRcdFx0XHR3cmFwcGVyLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgdG8gcmV0dXJuIHRoZSBiYXNlbGluZSBvZmZzZXQgYW5kIHRvdGFsIGxpbmUgaGVpZ2h0IGZyb20gdGhlIGZvbnQgc2l6ZVxuXHQgKi9cblx0Zm9udE1ldHJpY3M6IGZ1bmN0aW9uIChmb250U2l6ZSkge1xuXHRcdGZvbnRTaXplID0gcEludChmb250U2l6ZSB8fCAxMSk7XG5cblx0XHQvLyBFbXBpcmljYWwgdmFsdWVzIGZvdW5kIGJ5IGNvbXBhcmluZyBmb250IHNpemUgYW5kIGJvdW5kaW5nIGJveCBoZWlnaHQuXG5cdFx0Ly8gQXBwbGllcyB0byB0aGUgZGVmYXVsdCBmb250IGZhbWlseS4gaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzd4dm43L1xuXHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udFNpemUgPCAyNCA/IGZvbnRTaXplICsgNCA6IG1hdGhSb3VuZChmb250U2l6ZSAqIDEuMiksXG5cdFx0XHRiYXNlbGluZSA9IG1hdGhSb3VuZChsaW5lSGVpZ2h0ICogMC44KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRoOiBsaW5lSGVpZ2h0LFxuXHRcdFx0YjogYmFzZWxpbmVcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYSBsYWJlbCwgYSB0ZXh0IGl0ZW0gdGhhdCBjYW4gaG9sZCBhIGNvbG9yZWQgb3IgZ3JhZGllbnQgYmFja2dyb3VuZFxuXHQgKiBhcyB3ZWxsIGFzIGEgYm9yZGVyIGFuZCBzaGFkb3cuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNoYXBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JYIEluIGNhc2UgdGhlIHNoYXBlIGhhcyBhIHBvaW50ZXIsIGxpa2UgYSBmbGFnLCB0aGlzIGlzIHRoZVxuXHQgKiAgICBjb29yZGluYXRlcyBpdCBzaG91bGQgYmUgcGlubmVkIHRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JZXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYmFzZWxpbmUgV2hldGhlciB0byBwb3NpdGlvbiB0aGUgbGFiZWwgcmVsYXRpdmUgdG8gdGhlIHRleHQgYmFzZWxpbmUsXG5cdCAqICAgIGxpa2UgcmVuZGVyZXIudGV4dCwgb3IgdG8gdGhlIHVwcGVyIGJvcmRlciBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWUgZm9yIHRoZSBncm91cFxuXHQgKi9cblx0bGFiZWw6IGZ1bmN0aW9uIChzdHIsIHgsIHksIHNoYXBlLCBhbmNob3JYLCBhbmNob3JZLCB1c2VIVE1MLCBiYXNlbGluZSwgY2xhc3NOYW1lKSB7XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0d3JhcHBlciA9IHJlbmRlcmVyLmcoY2xhc3NOYW1lKSxcblx0XHRcdHRleHQgPSByZW5kZXJlci50ZXh0KCcnLCAwLCAwLCB1c2VIVE1MKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0ekluZGV4OiAxXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHQvLy5hZGQod3JhcHBlciksXG5cdFx0XHRib3gsXG5cdFx0XHRiQm94LFxuXHRcdFx0YWxpZ25GYWN0b3IgPSAwLFxuXHRcdFx0cGFkZGluZyA9IDMsXG5cdFx0XHRwYWRkaW5nTGVmdCA9IDAsXG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodCxcblx0XHRcdHdyYXBwZXJYLFxuXHRcdFx0d3JhcHBlclksXG5cdFx0XHRjcmlzcEFkanVzdCA9IDAsXG5cdFx0XHRkZWZlcnJlZEF0dHIgPSB7fSxcblx0XHRcdGJhc2VsaW5lT2Zmc2V0LFxuXHRcdFx0YXR0clNldHRlcnMgPSB3cmFwcGVyLmF0dHJTZXR0ZXJzLFxuXHRcdFx0bmVlZHNCb3g7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgYWZ0ZXIgdGhlIGxhYmVsIGlzIGFkZGVkIHRvIHRoZSBET00gKHdoZW4gdGhlIGJvdW5kaW5nIGJveCBpc1xuXHRcdCAqIGF2YWlsYWJsZSksIGFuZCBhZnRlciB0aGUgdGV4dCBvZiB0aGUgbGFiZWwgaXMgdXBkYXRlZCB0byBkZXRlY3QgdGhlIG5ldyBib3VuZGluZ1xuXHRcdCAqIGJveCBhbmQgcmVmbGVjdCBpdCBpbiB0aGUgYm9yZGVyIGJveC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB1cGRhdGVCb3hTaXplKCkge1xuXHRcdFx0dmFyIGJveFgsXG5cdFx0XHRcdGJveFksXG5cdFx0XHRcdHN0eWxlID0gdGV4dC5lbGVtZW50LnN0eWxlO1xuXG5cdFx0XHRiQm94ID0gKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgd3JhcHBlci5zdHlsZXMudGV4dEFsaWduKSAmJlxuXHRcdFx0XHR0ZXh0LmdldEJCb3goKTtcblx0XHRcdHdyYXBwZXIud2lkdGggPSAod2lkdGggfHwgYkJveC53aWR0aCB8fCAwKSArIDIgKiBwYWRkaW5nICsgcGFkZGluZ0xlZnQ7XG5cdFx0XHR3cmFwcGVyLmhlaWdodCA9IChoZWlnaHQgfHwgYkJveC5oZWlnaHQgfHwgMCkgKyAyICogcGFkZGluZztcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBsYWJlbC1zY29wZWQgeSBvZmZzZXRcblx0XHRcdGJhc2VsaW5lT2Zmc2V0ID0gcGFkZGluZyArIHJlbmRlcmVyLmZvbnRNZXRyaWNzKHN0eWxlICYmIHN0eWxlLmZvbnRTaXplKS5iO1xuXG5cdFx0XHRpZiAobmVlZHNCb3gpIHtcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIGJvcmRlciBib3ggaWYgaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0XHRpZiAoIWJveCkge1xuXHRcdFx0XHRcdGJveFggPSBtYXRoUm91bmQoLWFsaWduRmFjdG9yICogcGFkZGluZyk7XG5cdFx0XHRcdFx0Ym94WSA9IGJhc2VsaW5lID8gLWJhc2VsaW5lT2Zmc2V0IDogMDtcblxuXHRcdFx0XHRcdHdyYXBwZXIuYm94ID0gYm94ID0gc2hhcGUgP1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc3ltYm9sKHNoYXBlLCBib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCkgOlxuXHRcdFx0XHRcdFx0cmVuZGVyZXIucmVjdChib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCwgMCwgZGVmZXJyZWRBdHRyW1NUUk9LRV9XSURUSF0pO1xuXHRcdFx0XHRcdGJveC5hZGQod3JhcHBlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBseSB0aGUgYm94IGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCFib3guaXNJbWcpIHsgLy8gIzE2MzBcblx0XHRcdFx0XHRib3guYXR0cihtZXJnZSh7XG5cdFx0XHRcdFx0XHR3aWR0aDogd3JhcHBlci53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogd3JhcHBlci5oZWlnaHRcblx0XHRcdFx0XHR9LCBkZWZlcnJlZEF0dHIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZlcnJlZEF0dHIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gcnVucyBhZnRlciBzZXR0aW5nIHRleHQgb3IgcGFkZGluZywgYnV0IG9ubHkgaWYgcGFkZGluZyBpcyBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdXBkYXRlVGV4dFBhZGRpbmcoKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gd3JhcHBlci5zdHlsZXMsXG5cdFx0XHRcdHRleHRBbGlnbiA9IHN0eWxlcyAmJiBzdHlsZXMudGV4dEFsaWduLFxuXHRcdFx0XHR4ID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nICogKDEgLSBhbGlnbkZhY3RvciksXG5cdFx0XHRcdHk7XG5cblx0XHRcdC8vIGRldGVybWluIHkgYmFzZWQgb24gdGhlIGJhc2VsaW5lXG5cdFx0XHR5ID0gYmFzZWxpbmUgPyAwIDogYmFzZWxpbmVPZmZzZXQ7XG5cblx0XHRcdC8vIGNvbXBlbnNhdGUgZm9yIGFsaWdubWVudFxuXHRcdFx0aWYgKGRlZmluZWQod2lkdGgpICYmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInIHx8IHRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcblx0XHRcdFx0eCArPSB7IGNlbnRlcjogMC41LCByaWdodDogMSB9W3RleHRBbGlnbl0gKiAod2lkdGggLSBiQm94LndpZHRoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIGlmIGFueXRoaW5nIGNoYW5nZWRcblx0XHRcdGlmICh4ICE9PSB0ZXh0LnggfHwgeSAhPT0gdGV4dC55KSB7XG5cdFx0XHRcdHRleHQuYXR0cih7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWNvcmQgY3VycmVudCB2YWx1ZXNcblx0XHRcdHRleHQueCA9IHg7XG5cdFx0XHR0ZXh0LnkgPSB5O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNldCBhIGJveCBhdHRyaWJ1dGUsIG9yIGRlZmVyIGl0IGlmIHRoZSBib3ggaXMgbm90IHlldCBjcmVhdGVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGtleVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJveEF0dHIoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRib3guYXR0cihrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkQXR0cltrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0U2l6ZUFmdGVyQWRkKCkge1xuXHRcdFx0dGV4dC5hZGQod3JhcHBlcik7XG5cdFx0XHR3cmFwcGVyLmF0dHIoe1xuXHRcdFx0XHR0ZXh0OiBzdHIsIC8vIGFsaWdubWVudCBpcyBhdmFpbGFibGUgbm93XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoYm94ICYmIGRlZmluZWQoYW5jaG9yWCkpIHtcblx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHRhbmNob3JYOiBhbmNob3JYLFxuXHRcdFx0XHRcdGFuY2hvclk6IGFuY2hvcllcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQWZ0ZXIgdGhlIHRleHQgZWxlbWVudCBpcyBhZGRlZCwgZ2V0IHRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIGJvcmRlciBib3hcblx0XHQgKiBhbmQgYWRkIGl0IGJlZm9yZSB0aGUgdGV4dCBpbiB0aGUgRE9NLlxuXHRcdCAqL1xuXHRcdGFkZEV2ZW50KHdyYXBwZXIsICdhZGQnLCBnZXRTaXplQWZ0ZXJBZGQpO1xuXG5cdFx0Lypcblx0XHQgKiBBZGQgc3BlY2lmaWMgYXR0cmlidXRlIHNldHRlcnMuXG5cdFx0ICovXG5cblx0XHQvLyBvbmx5IGNoYW5nZSBsb2NhbCB2YXJpYWJsZXNcblx0XHRhdHRyU2V0dGVycy53aWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0d2lkdGggPSB2YWx1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdGF0dHJTZXR0ZXJzLmhlaWdodCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRhdHRyU2V0dGVycy5wYWRkaW5nID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKGRlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBwYWRkaW5nKSB7XG5cdFx0XHRcdHBhZGRpbmcgPSB2YWx1ZTtcblx0XHRcdFx0dXBkYXRlVGV4dFBhZGRpbmcoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdGF0dHJTZXR0ZXJzLnBhZGRpbmdMZWZ0ID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKGRlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBwYWRkaW5nTGVmdCkge1xuXHRcdFx0XHRwYWRkaW5nTGVmdCA9IHZhbHVlO1xuXHRcdFx0XHR1cGRhdGVUZXh0UGFkZGluZygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuXHRcdC8vIGNoYW5nZSBsb2NhbCB2YXJpYWJsZSBhbmQgc2V0IGF0dHJpYnVlIGFzIHdlbGxcblx0XHRhdHRyU2V0dGVycy5hbGlnbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0YWxpZ25GYWN0b3IgPSB7IGxlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSB9W3ZhbHVlXTtcblx0XHRcdHJldHVybiBmYWxzZTsgLy8gcHJldmVudCBzZXR0aW5nIHRleHQtYW5jaG9yIG9uIHRoZSBncm91cFxuXHRcdH07XG5cblx0XHQvLyBhcHBseSB0aGVzZSB0byB0aGUgYm94IGFuZCB0aGUgdGV4dCBhbGlrZVxuXHRcdGF0dHJTZXR0ZXJzLnRleHQgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0dGV4dC5hdHRyKGtleSwgdmFsdWUpO1xuXHRcdFx0dXBkYXRlQm94U2l6ZSgpO1xuXHRcdFx0dXBkYXRlVGV4dFBhZGRpbmcoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gYXBwbHkgdGhlc2UgdG8gdGhlIGJveCBidXQgbm90IHRvIHRoZSB0ZXh0XG5cdFx0YXR0clNldHRlcnNbU1RST0tFX1dJRFRIXSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRuZWVkc0JveCA9IHRydWU7XG5cdFx0XHRjcmlzcEFkanVzdCA9IHZhbHVlICUgMiAvIDI7XG5cdFx0XHRib3hBdHRyKGtleSwgdmFsdWUpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0YXR0clNldHRlcnMuc3Ryb2tlID0gYXR0clNldHRlcnMuZmlsbCA9IGF0dHJTZXR0ZXJzLnIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ2ZpbGwnKSB7XG5cdFx0XHRcdG5lZWRzQm94ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRhdHRyU2V0dGVycy5hbmNob3JYID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdGFuY2hvclggPSB2YWx1ZTtcblx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSArIGNyaXNwQWRqdXN0IC0gd3JhcHBlclgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0YXR0clNldHRlcnMuYW5jaG9yWSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRhbmNob3JZID0gdmFsdWU7XG5cdFx0XHRib3hBdHRyKGtleSwgdmFsdWUgLSB3cmFwcGVyWSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIHJlbmFtZSBhdHRyaWJ1dGVzXG5cdFx0YXR0clNldHRlcnMueCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0d3JhcHBlci54ID0gdmFsdWU7IC8vIGZvciBhbmltYXRpb24gZ2V0dGVyXG5cdFx0XHR2YWx1ZSAtPSBhbGlnbkZhY3RvciAqICgod2lkdGggfHwgYkJveC53aWR0aCkgKyBwYWRkaW5nKTtcblx0XHRcdHdyYXBwZXJYID0gbWF0aFJvdW5kKHZhbHVlKTtcblxuXHRcdFx0d3JhcHBlci5hdHRyKCd0cmFuc2xhdGVYJywgd3JhcHBlclgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0YXR0clNldHRlcnMueSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0d3JhcHBlclkgPSB3cmFwcGVyLnkgPSBtYXRoUm91bmQodmFsdWUpO1xuXHRcdFx0d3JhcHBlci5hdHRyKCd0cmFuc2xhdGVZJywgd3JhcHBlclkpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBSZWRpcmVjdCBjZXJ0YWluIG1ldGhvZHMgdG8gZWl0aGVyIHRoZSBib3ggb3IgdGhlIHRleHRcblx0XHR2YXIgYmFzZUNzcyA9IHdyYXBwZXIuY3NzO1xuXHRcdHJldHVybiBleHRlbmQod3JhcHBlciwge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBQaWNrIHVwIHNvbWUgcHJvcGVydGllcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgdGV4dCBpbnN0ZWFkIG9mIHRoZSB3cmFwcGVyXG5cdFx0XHQgKi9cblx0XHRcdGNzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdFx0XHRpZiAoc3R5bGVzKSB7XG5cdFx0XHRcdFx0dmFyIHRleHRTdHlsZXMgPSB7fTtcblx0XHRcdFx0XHRzdHlsZXMgPSBtZXJnZShzdHlsZXMpOyAvLyBjcmVhdGUgYSBjb3B5IHRvIGF2b2lkIGFsdGVyaW5nIHRoZSBvcmlnaW5hbCBvYmplY3QgKCM1MzcpXG5cdFx0XHRcdFx0ZWFjaChbJ2ZvbnRTaXplJywgJ2ZvbnRXZWlnaHQnLCAnZm9udEZhbWlseScsICdjb2xvcicsICdsaW5lSGVpZ2h0JywgJ3dpZHRoJywgJ3RleHREZWNvcmF0aW9uJywgJ3RleHRTaGFkb3cnXSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0XHRcdGlmIChzdHlsZXNbcHJvcF0gIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHR0ZXh0U3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRleHQuY3NzKHRleHRTdHlsZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBiYXNlQ3NzLmNhbGwod3JhcHBlciwgc3R5bGVzKTtcblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBib3gsIG5vdCB0aGUgZ3JvdXBcblx0XHRcdCAqL1xuXHRcdFx0Z2V0QkJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHdpZHRoOiBiQm94LndpZHRoICsgMiAqIHBhZGRpbmcsXG5cdFx0XHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodCArIDIgKiBwYWRkaW5nLFxuXHRcdFx0XHRcdHg6IGJCb3gueCAtIHBhZGRpbmcsXG5cdFx0XHRcdFx0eTogYkJveC55IC0gcGFkZGluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwbHkgdGhlIHNoYWRvdyB0byB0aGUgYm94XG5cdFx0XHQgKi9cblx0XHRcdHNoYWRvdzogZnVuY3Rpb24gKGIpIHtcblx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdGJveC5zaGFkb3coYik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXN0cm95IGFuZCByZWxlYXNlIG1lbW9yeS5cblx0XHRcdCAqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudCh3cmFwcGVyLCAnYWRkJywgZ2V0U2l6ZUFmdGVyQWRkKTtcblxuXHRcdFx0XHQvLyBBZGRlZCBieSBidXR0b24gaW1wbGVtZW50YXRpb25cblx0XHRcdFx0cmVtb3ZlRXZlbnQod3JhcHBlci5lbGVtZW50LCAnbW91c2VlbnRlcicpO1xuXHRcdFx0XHRyZW1vdmVFdmVudCh3cmFwcGVyLmVsZW1lbnQsICdtb3VzZWxlYXZlJyk7XG5cblx0XHRcdFx0aWYgKHRleHQpIHtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdGJveCA9IGJveC5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2FsbCBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGRlc3Ryb3kgdGhlIHJlc3Rcblx0XHRcdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHdyYXBwZXIpO1xuXG5cdFx0XHRcdC8vIFJlbGVhc2UgbG9jYWwgcG9pbnRlcnMgKCMxMjk4KVxuXHRcdFx0XHR3cmFwcGVyID0gcmVuZGVyZXIgPSB1cGRhdGVCb3hTaXplID0gdXBkYXRlVGV4dFBhZGRpbmcgPSBib3hBdHRyID0gZ2V0U2l6ZUFmdGVyQWRkID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufTsgLy8gZW5kIFNWR1JlbmRlcmVyXG5cblxuLy8gZ2VuZXJhbCByZW5kZXJlclxuUmVuZGVyZXIgPSBTVkdSZW5kZXJlcjtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBTVEFSVCBPRiBJTlRFUk5FVCBFWFBMT1JFUiA8PSA4IFNQRUNJRklDIENPREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBGb3IgYXBwbGljYXRpb25zIGFuZCB3ZWJzaXRlcyB0aGF0IGRvbid0IG5lZWQgSUUgc3VwcG9ydCwgbGlrZSBwbGF0Zm9ybSAgICAqXG4gKiB0YXJnZXRlZCBtb2JpbGUgYXBwcyBhbmQgd2ViIGFwcHMsIHRoaXMgY29kZSBjYW4gYmUgcmVtb3ZlZC4gICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBWTUxSZW5kZXJlciwgVk1MRWxlbWVudDtcbmlmICghaGFzU1ZHICYmICF1c2VDYW5WRykge1xuXG4vKipcbiAqIFRoZSBWTUwgZWxlbWVudCB3cmFwcGVyLlxuICovXG5IaWdoY2hhcnRzLlZNTEVsZW1lbnQgPSBWTUxFbGVtZW50ID0ge1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGEgbmV3IFZNTCBlbGVtZW50IHdyYXBwZXIuIEl0IGJ1aWxkcyB0aGUgbWFya3VwIGFzIGEgc3RyaW5nXG5cdCAqIHRvIG1pbmltaXplIERPTSB0cmFmZmljLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVOYW1lXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAocmVuZGVyZXIsIG5vZGVOYW1lKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0bWFya3VwID0gIFsnPCcsIG5vZGVOYW1lLCAnIGZpbGxlZD1cImZcIiBzdHJva2VkPVwiZlwiJ10sXG5cdFx0XHRzdHlsZSA9IFsncG9zaXRpb246ICcsIEFCU09MVVRFLCAnOyddLFxuXHRcdFx0aXNEaXYgPSBub2RlTmFtZSA9PT0gRElWO1xuXG5cdFx0Ly8gZGl2cyBhbmQgc2hhcGVzIG5lZWQgc2l6ZVxuXHRcdGlmIChub2RlTmFtZSA9PT0gJ3NoYXBlJyB8fCBpc0Rpdikge1xuXHRcdFx0c3R5bGUucHVzaCgnbGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4OycpO1xuXHRcdH1cblx0XHRzdHlsZS5wdXNoKCd2aXNpYmlsaXR5OiAnLCBpc0RpdiA/IEhJRERFTiA6IFZJU0lCTEUpO1xuXG5cdFx0bWFya3VwLnB1c2goJyBzdHlsZT1cIicsIHN0eWxlLmpvaW4oJycpLCAnXCIvPicpO1xuXG5cdFx0Ly8gY3JlYXRlIGVsZW1lbnQgd2l0aCBkZWZhdWx0IGF0dHJpYnV0ZXMgYW5kIHN0eWxlXG5cdFx0aWYgKG5vZGVOYW1lKSB7XG5cdFx0XHRtYXJrdXAgPSBpc0RpdiB8fCBub2RlTmFtZSA9PT0gJ3NwYW4nIHx8IG5vZGVOYW1lID09PSAnaW1nJyA/XG5cdFx0XHRcdG1hcmt1cC5qb2luKCcnKVxuXHRcdFx0XHQ6IHJlbmRlcmVyLnByZXBWTUwobWFya3VwKTtcblx0XHRcdHdyYXBwZXIuZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQobWFya3VwKTtcblx0XHR9XG5cblx0XHR3cmFwcGVyLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cdFx0d3JhcHBlci5hdHRyU2V0dGVycyA9IHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgdGhlIG5vZGUgdG8gdGhlIGdpdmVuIHBhcmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRyZW5kZXJlciA9IHdyYXBwZXIucmVuZGVyZXIsXG5cdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0Ym94ID0gcmVuZGVyZXIuYm94LFxuXHRcdFx0aW52ZXJ0ZWQgPSBwYXJlbnQgJiYgcGFyZW50LmludmVydGVkLFxuXG5cdFx0XHQvLyBnZXQgdGhlIHBhcmVudCBub2RlXG5cdFx0XHRwYXJlbnROb2RlID0gcGFyZW50ID9cblx0XHRcdFx0cGFyZW50LmVsZW1lbnQgfHwgcGFyZW50IDpcblx0XHRcdFx0Ym94O1xuXG5cblx0XHQvLyBpZiB0aGUgcGFyZW50IGdyb3VwIGlzIGludmVydGVkLCBhcHBseSBpbnZlcnNpb24gb24gYWxsIGNoaWxkcmVuXG5cdFx0aWYgKGludmVydGVkKSB7IC8vIG9ubHkgb24gZ3JvdXBzXG5cdFx0XHRyZW5kZXJlci5pbnZlcnRDaGlsZChlbGVtZW50LCBwYXJlbnROb2RlKTtcblx0XHR9XG5cblx0XHQvLyBhcHBlbmQgaXRcblx0XHRwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0Ly8gYWxpZ24gdGV4dCBhZnRlciBhZGRpbmcgdG8gYmUgYWJsZSB0byByZWFkIG9mZnNldFxuXHRcdHdyYXBwZXIuYWRkZWQgPSB0cnVlO1xuXHRcdGlmICh3cmFwcGVyLmFsaWduT25BZGQgJiYgIXdyYXBwZXIuZGVmZXJVcGRhdGVUcmFuc2Zvcm0pIHtcblx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZmlyZSBhbiBldmVudCBmb3IgaW50ZXJuYWwgaG9va3Ncblx0XHRmaXJlRXZlbnQod3JhcHBlciwgJ2FkZCcpO1xuXG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFZNTCBhbHdheXMgdXNlcyBodG1sVXBkYXRlVHJhbnNmb3JtXG5cdCAqL1xuXHR1cGRhdGVUcmFuc2Zvcm06IFNWR0VsZW1lbnQucHJvdG90eXBlLmh0bWxVcGRhdGVUcmFuc2Zvcm0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgcm90YXRpb24gb2YgYSBzcGFuIHdpdGggb2xkSUUncyBmaWx0ZXJcblx0ICovXG5cdHNldFNwYW5Sb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uLCBzaW50aGV0YSwgY29zdGhldGEpIHtcblx0XHQvLyBBZGp1c3QgZm9yIGFsaWdubWVudCBhbmQgcm90YXRpb24uIFJvdGF0aW9uIG9mIHVzZUhUTUwgY29udGVudCBpcyBub3QgeWV0IGltcGxlbWVudGVkXG5cdFx0Ly8gYnV0IGl0IGNhbiBwcm9iYWJseSBiZSBpbXBsZW1lbnRlZCBmb3IgRmlyZWZveCAzLjUrIG9uIHVzZXIgcmVxdWVzdC4gRkYzLjUrXG5cdFx0Ly8gaGFzIHN1cHBvcnQgZm9yIENTUzMgdHJhbnNmb3JtLiBUaGUgZ2V0QkJveCBtZXRob2QgYWxzbyBuZWVkcyB0byBiZSB1cGRhdGVkXG5cdFx0Ly8gdG8gY29tcGVuc2F0ZSBmb3IgdGhlIHJvdGF0aW9uLCBsaWtlIGl0IGN1cnJlbnRseSBkb2VzIGZvciBTVkcuXG5cdFx0Ly8gVGVzdCBjYXNlOiBodHRwOi8vaGlnaGNoYXJ0cy5jb20vdGVzdHMvP2ZpbGU9dGV4dC1yb3RhdGlvblxuXHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdGZpbHRlcjogcm90YXRpb24gPyBbJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPScsIGNvc3RoZXRhLFxuXHRcdFx0XHQnLCBNMTI9JywgLXNpbnRoZXRhLCAnLCBNMjE9Jywgc2ludGhldGEsICcsIE0yMj0nLCBjb3N0aGV0YSxcblx0XHRcdFx0Jywgc2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnKSddLmpvaW4oJycpIDogTk9ORVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN1YnNldCBvZiBhbiBTVkcgcGF0aCBkZWZpbml0aW9uIHRvIGl0cyBWTUwgY291bnRlcnBhcnQuIFRha2VzIGFuIGFycmF5XG5cdCAqIGFzIHRoZSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBzdHJpbmcuXG5cdCAqL1xuXHRwYXRoVG9WTUw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdC8vIGNvbnZlcnQgcGF0aHNcblx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aCxcblx0XHRcdHBhdGggPSBbXSxcblx0XHRcdGNsb2Nrd2lzZTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblxuXHRcdFx0Ly8gTXVsdGlwbHkgYnkgMTAgdG8gYWxsb3cgc3VicGl4ZWwgcHJlY2lzaW9uLlxuXHRcdFx0Ly8gU3Vic3RyYWN0aW5nIGhhbGYgYSBwaXhlbCBzZWVtcyB0byBtYWtlIHRoZSBjb29yZGluYXRlc1xuXHRcdFx0Ly8gYWxpZ24gd2l0aCBTVkcsIGJ1dCB0aGlzIGhhc24ndCBiZWVuIHRlc3RlZCB0aG9yb3VnaGx5XG5cdFx0XHRpZiAoaXNOdW1iZXIodmFsdWVbaV0pKSB7XG5cdFx0XHRcdHBhdGhbaV0gPSBtYXRoUm91bmQodmFsdWVbaV0gKiAxMCkgLSA1O1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZVtpXSA9PT0gJ1onKSB7IC8vIGNsb3NlIHRoZSBwYXRoXG5cdFx0XHRcdHBhdGhbaV0gPSAneCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoW2ldID0gdmFsdWVbaV07XG5cblx0XHRcdFx0Ly8gV2hlbiB0aGUgc3RhcnQgWCBhbmQgZW5kIFggY29vcmRpbmF0ZXMgb2YgYW4gYXJjIGFyZSB0b28gY2xvc2UsXG5cdFx0XHRcdC8vIHRoZXkgYXJlIHJvdW5kZWQgdG8gdGhlIHNhbWUgdmFsdWUgYWJvdmUuIEluIHRoaXMgY2FzZSwgc3Vic3RyYWN0IDEgZnJvbSB0aGUgZW5kIFhcblx0XHRcdFx0Ly8gcG9zaXRpb24uICM3NjAsICMxMzcxLlxuXHRcdFx0XHRpZiAodmFsdWUuaXNBcmMgJiYgKHZhbHVlW2ldID09PSAnd2EnIHx8IHZhbHVlW2ldID09PSAnYXQnKSkge1xuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9IHZhbHVlW2ldID09PSAnd2EnID8gMSA6IC0xOyAvLyAjMTY0MlxuXHRcdFx0XHRcdGlmIChwYXRoW2kgKyA1XSA9PT0gcGF0aFtpICsgN10pIHtcblx0XHRcdFx0XHRcdHBhdGhbaSArIDddIC09IGNsb2Nrd2lzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gU3RhcnQgYW5kIGVuZCBZICgjMTQxMClcblx0XHRcdFx0XHRpZiAocGF0aFtpICsgNl0gPT09IHBhdGhbaSArIDhdKSB7XG5cdFx0XHRcdFx0XHRwYXRoW2kgKyA4XSAtPSBjbG9ja3dpc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIExvb3AgdXAgYWdhaW4gdG8gaGFuZGxlIHBhdGggc2hvcnRjdXRzICgjMjEzMilcblx0XHQvKndoaWxlIChpKysgPCBwYXRoLmxlbmd0aCkge1xuXHRcdFx0aWYgKHBhdGhbaV0gPT09ICdIJykgeyAvLyBob3Jpem9udGFsIGxpbmUgdG9cblx0XHRcdFx0cGF0aFtpXSA9ICdMJztcblx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDIsIDAsIHBhdGhbaSAtIDFdKTtcblx0XHRcdH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJ1YnKSB7IC8vIHZlcnRpY2FsIGxpbmUgdG9cblx0XHRcdFx0cGF0aFtpXSA9ICdMJztcblx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDEsIDAsIHBhdGhbaSAtIDJdKTtcblx0XHRcdH1cblx0XHR9Ki9cblx0XHRyZXR1cm4gcGF0aC5qb2luKCcgJykgfHwgJ3gnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgb3Igc2V0IGF0dHJpYnV0ZXNcblx0ICovXG5cdGF0dHI6IGZ1bmN0aW9uIChoYXNoLCB2YWwpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRrZXksXG5cdFx0XHR2YWx1ZSxcblx0XHRcdGksXG5cdFx0XHRyZXN1bHQsXG5cdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50IHx8IHt9LFxuXHRcdFx0ZWxlbVN0eWxlID0gZWxlbWVudC5zdHlsZSxcblx0XHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcblx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdHN5bWJvbE5hbWUgPSB3cmFwcGVyLnN5bWJvbE5hbWUsXG5cdFx0XHRoYXNTZXRTeW1ib2xTaXplLFxuXHRcdFx0c2hhZG93cyA9IHdyYXBwZXIuc2hhZG93cyxcblx0XHRcdHNraXBBdHRyLFxuXHRcdFx0YXR0clNldHRlcnMgPSB3cmFwcGVyLmF0dHJTZXR0ZXJzLFxuXHRcdFx0cmV0ID0gd3JhcHBlcjtcblxuXHRcdC8vIHNpbmdsZSBrZXktdmFsdWUgcGFpclxuXHRcdGlmIChpc1N0cmluZyhoYXNoKSAmJiBkZWZpbmVkKHZhbCkpIHtcblx0XHRcdGtleSA9IGhhc2g7XG5cdFx0XHRoYXNoID0ge307XG5cdFx0XHRoYXNoW2tleV0gPSB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBhcyBhIGdldHRlciwgdmFsIGlzIHVuZGVmaW5lZFxuXHRcdGlmIChpc1N0cmluZyhoYXNoKSkge1xuXHRcdFx0a2V5ID0gaGFzaDtcblx0XHRcdGlmIChrZXkgPT09ICdzdHJva2VXaWR0aCcgfHwga2V5ID09PSAnc3Ryb2tlLXdpZHRoJykge1xuXHRcdFx0XHRyZXQgPSB3cmFwcGVyLnN0cm9rZXdlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9IHdyYXBwZXJba2V5XTtcblx0XHRcdH1cblxuXHRcdC8vIHNldHRlclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGtleSBpbiBoYXNoKSB7XG5cdFx0XHRcdHZhbHVlID0gaGFzaFtrZXldO1xuXHRcdFx0XHRza2lwQXR0ciA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBhIHNwZWNpZmljIGF0dHJpYnV0ZSBzZXR0ZXJcblx0XHRcdFx0cmVzdWx0ID0gYXR0clNldHRlcnNba2V5XSAmJiBhdHRyU2V0dGVyc1trZXldLmNhbGwod3JhcHBlciwgdmFsdWUsIGtleSk7XG5cblx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG51bGwpIHsgLy8gIzYyMFxuXG5cdFx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHJlc3VsdDsgLy8gdGhlIGF0dHJpYnV0ZSBzZXR0ZXIgaGFzIHJldHVybmVkIGEgbmV3IHZhbHVlIHRvIHNldFxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0Ly8gcHJlcGFyZSBwYXRoc1xuXHRcdFx0XHRcdC8vIHN5bWJvbHNcblx0XHRcdFx0XHRpZiAoc3ltYm9sTmFtZSAmJiAvXih4fHl8cnxzdGFydHxlbmR8d2lkdGh8aGVpZ2h0fGlubmVyUnxhbmNob3JYfGFuY2hvclkpLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRcdC8vIGlmIG9uZSBvZiB0aGUgc3ltYm9sIHNpemUgYWZmZWN0aW5nIHBhcmFtZXRlcnMgYXJlIGNoYW5nZWQsXG5cdFx0XHRcdFx0XHQvLyBjaGVjayBhbGwgdGhlIG90aGVycyBvbmx5IG9uY2UgZm9yIGVhY2ggY2FsbCB0byBhbiBlbGVtZW50J3Ncblx0XHRcdFx0XHRcdC8vIC5hdHRyKCkgbWV0aG9kXG5cdFx0XHRcdFx0XHRpZiAoIWhhc1NldFN5bWJvbFNpemUpIHtcblx0XHRcdFx0XHRcdFx0d3JhcHBlci5zeW1ib2xBdHRyKGhhc2gpO1xuXG5cdFx0XHRcdFx0XHRcdGhhc1NldFN5bWJvbFNpemUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdkJykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBbXTtcblx0XHRcdFx0XHRcdHdyYXBwZXIuZCA9IHZhbHVlLmpvaW4oJyAnKTsgLy8gdXNlZCBpbiBnZXR0ZXIgZm9yIGFuaW1hdGlvblxuXG5cdFx0XHRcdFx0XHRlbGVtZW50LnBhdGggPSB2YWx1ZSA9IHdyYXBwZXIucGF0aFRvVk1MKHZhbHVlKTtcblxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHNoYWRvd3Ncblx0XHRcdFx0XHRcdGlmIChzaGFkb3dzKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBzaGFkb3dzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdFx0XHRcdHNoYWRvd3NbaV0ucGF0aCA9IHNoYWRvd3NbaV0uY3V0T2ZmID8gdGhpcy5jdXRPZmZQYXRoKHZhbHVlLCBzaGFkb3dzW2ldLmN1dE9mZikgOiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIHZpc2liaWxpdHlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3Zpc2liaWxpdHknKSB7XG5cblx0XHRcdFx0XHRcdC8vIGxldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRcdFx0XHRpZiAoc2hhZG93cykge1xuXHRcdFx0XHRcdFx0XHRpID0gc2hhZG93cy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdFx0XHRzaGFkb3dzW2ldLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbnN0ZWFkIG9mIHRvZ2dsaW5nIHRoZSB2aXNpYmlsaXR5IENTUyBwcm9wZXJ0eSwgbW92ZSB0aGUgZGl2IG91dCBvZiB0aGUgdmlld3BvcnQuXG5cdFx0XHRcdFx0XHQvLyBUaGlzIHdvcmtzIGFyb3VuZCAjNjEgYW5kICM1ODZcblx0XHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gJ0RJVicpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSA9PT0gSElEREVOID8gJy05OTllbScgOiAwO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEluIG9yZGVyIHRvIHJlZHJhdywgSUU3IG5lZWRzIHRoZSBkaXYgdG8gYmUgdmlzaWJsZSB3aGVuIHR1Y2tlZCBhd2F5XG5cdFx0XHRcdFx0XHRcdC8vIG91dHNpZGUgdGhlIHZpZXdwb3J0LiBTbyB0aGUgdmlzaWJpbGl0eSBpcyBhY3R1YWxseSBvcHBvc2l0ZSBvZlxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZXhwZWN0ZWQgdmFsdWUuIFRoaXMgYXBwbGllcyB0byB0aGUgdG9vbHRpcCBvbmx5LlxuXHRcdFx0XHRcdFx0XHRpZiAoIWRvY01vZGU4KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbVN0eWxlW2tleV0gPSB2YWx1ZSA/IFZJU0lCTEUgOiBISURERU47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbGVtU3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gZGlyZWN0bHkgbWFwcGVkIHRvIGNzc1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnekluZGV4Jykge1xuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0ZWxlbVN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNraXBBdHRyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIHgsIHksIHdpZHRoLCBoZWlnaHRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGluQXJyYXkoa2V5LCBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSkgIT09IC0xKSB7XG5cblx0XHRcdFx0XHRcdHdyYXBwZXJba2V5XSA9IHZhbHVlOyAvLyB1c2VkIGluIGdldHRlclxuXG5cdFx0XHRcdFx0XHRpZiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScpIHtcblx0XHRcdFx0XHRcdFx0a2V5ID0geyB4OiAnbGVmdCcsIHk6ICd0b3AnIH1ba2V5XTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbWF0aE1heCgwLCB2YWx1ZSk7IC8vIGRvbid0IHNldCB3aWR0aCBvciBoZWlnaHQgYmVsb3cgemVybyAoIzMxMSlcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gY2xpcHBpbmcgcmVjdGFuZ2xlIHNwZWNpYWxcblx0XHRcdFx0XHRcdGlmICh3cmFwcGVyLnVwZGF0ZUNsaXBwaW5nKSB7XG5cdFx0XHRcdFx0XHRcdHdyYXBwZXJba2V5XSA9IHZhbHVlOyAvLyB0aGUga2V5IGlzIG5vdyAnbGVmdCcgb3IgJ3RvcCcgZm9yICd4JyBhbmQgJ3knXG5cdFx0XHRcdFx0XHRcdHdyYXBwZXIudXBkYXRlQ2xpcHBpbmcoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIG5vcm1hbFxuXHRcdFx0XHRcdFx0XHRlbGVtU3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRza2lwQXR0ciA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBjbGFzcyBuYW1lXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdjbGFzcycgJiYgbm9kZU5hbWUgPT09ICdESVYnKSB7XG5cdFx0XHRcdFx0XHQvLyBJRTggU3RhbmRhcmRzIG1vZGUgaGFzIHByb2JsZW1zIHJldHJpZXZpbmcgdGhlIGNsYXNzTmFtZVxuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcblxuXHRcdFx0XHRcdC8vIHN0cm9rZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3Ryb2tlJykge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHJlbmRlcmVyLmNvbG9yKHZhbHVlLCBlbGVtZW50LCBrZXkpO1xuXG5cdFx0XHRcdFx0XHRrZXkgPSAnc3Ryb2tlY29sb3InO1xuXG5cdFx0XHRcdFx0Ly8gc3Ryb2tlIHdpZHRoXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHJva2Utd2lkdGgnIHx8IGtleSA9PT0gJ3N0cm9rZVdpZHRoJykge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5zdHJva2VkID0gdmFsdWUgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRrZXkgPSAnc3Ryb2tld2VpZ2h0Jztcblx0XHRcdFx0XHRcdHdyYXBwZXJba2V5XSA9IHZhbHVlOyAvLyB1c2VkIGluIGdldHRlciwgaXNzdWUgIzExM1xuXHRcdFx0XHRcdFx0aWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSArPSBQWDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGRhc2hTdHlsZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnZGFzaHN0eWxlJykge1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZUVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHJva2UnKVswXSB8fFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVFbGVtZW50KHJlbmRlcmVyLnByZXBWTUwoWyc8c3Ryb2tlLz4nXSksIG51bGwsIG51bGwsIGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0c3Ryb2tlRWxlbVtrZXldID0gdmFsdWUgfHwgJ3NvbGlkJztcblx0XHRcdFx0XHRcdHdyYXBwZXIuZGFzaHN0eWxlID0gdmFsdWU7IC8qIGJlY2F1c2UgY2hhbmdpbmcgc3Ryb2tlLXdpZHRoIHdpbGwgY2hhbmdlIHRoZSBkYXNoIGxlbmd0aFxuXHRcdFx0XHRcdFx0XHRhbmQgY2F1c2UgYW4gZXBpbGVwdGljIGVmZmVjdCAqL1xuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gZmlsbFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnZmlsbCcpIHtcblxuXHRcdFx0XHRcdFx0aWYgKG5vZGVOYW1lID09PSAnU1BBTicpIHsgLy8gdGV4dCBjb2xvclxuXHRcdFx0XHRcdFx0XHRlbGVtU3R5bGUuY29sb3IgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgIT09ICdJTUcnKSB7IC8vICMxMzM2XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuZmlsbGVkID0gdmFsdWUgIT09IE5PTkUgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSByZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5LCB3cmFwcGVyKTtcblxuXHRcdFx0XHRcdFx0XHRrZXkgPSAnZmlsbGNvbG9yJztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9wYWNpdHk6IGRvbid0IGJvdGhlciAtIGFuaW1hdGlvbiBpcyB0b28gc2xvdyBhbmQgZmlsdGVycyBpbnRyb2R1Y2UgYXJ0aWZhY3RzXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdvcGFjaXR5Jykge1xuXHRcdFx0XHRcdFx0Lypjc3MoZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OiB2YWx1ZVxuXHRcdFx0XHRcdFx0fSk7Ki9cblx0XHRcdFx0XHRcdHNraXBBdHRyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIHJvdGF0aW9uIG9uIFZNTCBlbGVtZW50c1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICdzaGFwZScgJiYga2V5ID09PSAncm90YXRpb24nKSB7XG5cblx0XHRcdFx0XHRcdHdyYXBwZXJba2V5XSA9IGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlOyAvLyBzdHlsZSBpcyBmb3IgIzE4NzNcblxuXHRcdFx0XHRcdFx0Ly8gQ29ycmVjdGlvbiBmb3IgdGhlIDF4MSBzaXplIG9mIHRoZSBzaGFwZSBjb250YWluZXIuIFVzZWQgaW4gZ2F1Z2UgbmVlZGxlcy5cblx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUubGVmdCA9IC1tYXRoUm91bmQobWF0aFNpbih2YWx1ZSAqIGRlZzJyYWQpICsgMSkgKyBQWDtcblx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUudG9wID0gbWF0aFJvdW5kKG1hdGhDb3ModmFsdWUgKiBkZWcycmFkKSkgKyBQWDtcblxuXHRcdFx0XHRcdC8vIHRyYW5zbGF0aW9uIGZvciBhbmltYXRpb25cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3RyYW5zbGF0ZVgnIHx8IGtleSA9PT0gJ3RyYW5zbGF0ZVknIHx8IGtleSA9PT0gJ3JvdGF0aW9uJykge1xuXHRcdFx0XHRcdFx0d3JhcHBlcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR3cmFwcGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG5cdFx0XHRcdFx0XHRza2lwQXR0ciA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyB0ZXh0IGZvciByb3RhdGVkIGFuZCBub24tcm90YXRlZCBlbGVtZW50c1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAndGV4dCcpIHtcblx0XHRcdFx0XHRcdHRoaXMuYkJveCA9IG51bGw7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0aWYgKCFza2lwQXR0cikge1xuXHRcdFx0XHRcdFx0aWYgKGRvY01vZGU4KSB7IC8vIElFOCBzZXRBdHRyaWJ1dGUgYnVnXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXR0cihlbGVtZW50LCBrZXksIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGVsZW1lbnQncyBjbGlwcGluZyB0byBhIHByZWRlZmluZWQgcmVjdGFuZ2xlXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGNsaXAgcmVjdGFuZ2xlXG5cdCAqL1xuXHRjbGlwOiBmdW5jdGlvbiAoY2xpcFJlY3QpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRjbGlwTWVtYmVycyxcblx0XHRcdGNzc1JldDtcblxuXHRcdGlmIChjbGlwUmVjdCkge1xuXHRcdFx0Y2xpcE1lbWJlcnMgPSBjbGlwUmVjdC5tZW1iZXJzO1xuXHRcdFx0ZXJhc2UoY2xpcE1lbWJlcnMsIHdyYXBwZXIpOyAvLyBFbnN1cmUgdW5pcXVlIGxpc3Qgb2YgZWxlbWVudHMgKCMxMjU4KVxuXHRcdFx0Y2xpcE1lbWJlcnMucHVzaCh3cmFwcGVyKTtcblx0XHRcdHdyYXBwZXIuZGVzdHJveUNsaXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGVyYXNlKGNsaXBNZW1iZXJzLCB3cmFwcGVyKTtcblx0XHRcdH07XG5cdFx0XHRjc3NSZXQgPSBjbGlwUmVjdC5nZXRDU1Mod3JhcHBlcik7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHdyYXBwZXIuZGVzdHJveUNsaXApIHtcblx0XHRcdFx0d3JhcHBlci5kZXN0cm95Q2xpcCgpO1xuXHRcdFx0fVxuXHRcdFx0Y3NzUmV0ID0geyBjbGlwOiBkb2NNb2RlOCA/ICdpbmhlcml0JyA6ICdyZWN0KGF1dG8pJyB9OyAvLyAjMTIxNFxuXHRcdH1cblxuXHRcdHJldHVybiB3cmFwcGVyLmNzcyhjc3NSZXQpO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBzdHlsZXMgZm9yIHRoZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcblx0ICovXG5cdGNzczogU1ZHRWxlbWVudC5wcm90b3R5cGUuaHRtbENzcyxcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdCAqIElzc3VlIDQ5MDsgaW4gVk1MIHJlbW92ZUNoaWxkIHJlc3VsdHMgaW4gT3JwaGFuZWQgbm9kZXMgYWNjb3JkaW5nIHRvIHNJRXZlLCBkaXNjYXJkRWxlbWVudCBkb2VzIG5vdC5cblx0ICovXG5cdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHQvLyBkaXNjYXJkRWxlbWVudCB3aWxsIGRldGFjaCB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQgYmVmb3JlIGF0dGFjaGluZyBpdFxuXHRcdC8vIHRvIHRoZSBnYXJiYWdlIGJpbi4gVGhlcmVmb3JlIGl0IGlzIGltcG9ydGFudCB0aGF0IHRoZSBub2RlIGlzIGF0dGFjaGVkIGFuZCBoYXZlIHBhcmVudC5cblx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0XHRkaXNjYXJkRWxlbWVudChlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEV4dGVuZCBlbGVtZW50LmRlc3Ryb3kgYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgY2xpcCBtZW1iZXJzIGFycmF5XG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZGVzdHJveUNsaXApIHtcblx0XHRcdHRoaXMuZGVzdHJveUNsaXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gU1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLiBWTUwgb3ZlcnJpZGUgZm9yIG5vcm1hbGl6aW5nIGV2ZW50IHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuXHQgKi9cblx0b246IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHQvLyBzaW1wbGVzdCBwb3NzaWJsZSBldmVudCBtb2RlbCBmb3IgaW50ZXJuYWwgdXNlXG5cdFx0dGhpcy5lbGVtZW50WydvbicgKyBldmVudFR5cGVdID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGV2dCA9IHdpbi5ldmVudDtcblx0XHRcdGV2dC50YXJnZXQgPSBldnQuc3JjRWxlbWVudDtcblx0XHRcdGhhbmRsZXIoZXZ0KTtcblx0XHR9O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbiBzdGFja2VkIGNvbHVtbnMsIGN1dCBvZmYgdGhlIHNoYWRvd3Mgc28gdGhhdCB0aGV5IGRvbid0IG92ZXJsYXBcblx0ICovXG5cdGN1dE9mZlBhdGg6IGZ1bmN0aW9uIChwYXRoLCBsZW5ndGgpIHtcblxuXHRcdHZhciBsZW47XG5cblx0XHRwYXRoID0gcGF0aC5zcGxpdCgvWyAsXS8pO1xuXHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0aWYgKGxlbiA9PT0gOSB8fCBsZW4gPT09IDExKSB7XG5cdFx0XHRwYXRoW2xlbiAtIDRdID0gcGF0aFtsZW4gLSAyXSA9IHBJbnQocGF0aFtsZW4gLSAyXSkgLSAxMCAqIGxlbmd0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguam9pbignICcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBcHBseSBhIGRyb3Agc2hhZG93IGJ5IGNvcHlpbmcgZWxlbWVudHMgYW5kIGdpdmluZyB0aGVtIGRpZmZlcmVudCBzdHJva2VzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IHNoYWRvd09wdGlvbnNcblx0ICovXG5cdHNoYWRvdzogZnVuY3Rpb24gKHNoYWRvd09wdGlvbnMsIGdyb3VwLCBjdXRPZmYpIHtcblx0XHR2YXIgc2hhZG93cyA9IFtdLFxuXHRcdFx0aSxcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRzaGFkb3csXG5cdFx0XHRlbGVtU3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuXHRcdFx0bWFya3VwLFxuXHRcdFx0cGF0aCA9IGVsZW1lbnQucGF0aCxcblx0XHRcdHN0cm9rZVdpZHRoLFxuXHRcdFx0bW9kaWZpZWRQYXRoLFxuXHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eTtcblxuXHRcdC8vIHNvbWUgdGltZXMgZW1wdHkgcGF0aHMgYXJlIG5vdCBzdHJpbmdzXG5cdFx0aWYgKHBhdGggJiYgdHlwZW9mIHBhdGgudmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRwYXRoID0gJ3gnO1xuXHRcdH1cblx0XHRtb2RpZmllZFBhdGggPSBwYXRoO1xuXG5cdFx0aWYgKHNoYWRvd09wdGlvbnMpIHtcblx0XHRcdHNoYWRvd1dpZHRoID0gcGljayhzaGFkb3dPcHRpb25zLndpZHRoLCAzKTtcblx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5ID0gKHNoYWRvd09wdGlvbnMub3BhY2l0eSB8fCAwLjE1KSAvIHNoYWRvd1dpZHRoO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8PSAzOyBpKyspIHtcblxuXHRcdFx0XHRzdHJva2VXaWR0aCA9IChzaGFkb3dXaWR0aCAqIDIpICsgMSAtICgyICogaSk7XG5cblx0XHRcdFx0Ly8gQ3V0IG9mZiBzaGFkb3dzIGZvciBzdGFja2VkIGNvbHVtbiBpdGVtc1xuXHRcdFx0XHRpZiAoY3V0T2ZmKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRQYXRoID0gdGhpcy5jdXRPZmZQYXRoKHBhdGgudmFsdWUsIHN0cm9rZVdpZHRoICsgMC41KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcmt1cCA9IFsnPHNoYXBlIGlzU2hhZG93PVwidHJ1ZVwiIHN0cm9rZXdlaWdodD1cIicsIHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRcdCdcIiBmaWxsZWQ9XCJmYWxzZVwiIHBhdGg9XCInLCBtb2RpZmllZFBhdGgsXG5cdFx0XHRcdFx0J1wiIGNvb3Jkc2l6ZT1cIjEwIDEwXCIgc3R5bGU9XCInLCBlbGVtZW50LnN0eWxlLmNzc1RleHQsICdcIiAvPiddO1xuXG5cdFx0XHRcdHNoYWRvdyA9IGNyZWF0ZUVsZW1lbnQocmVuZGVyZXIucHJlcFZNTChtYXJrdXApLFxuXHRcdFx0XHRcdG51bGwsIHtcblx0XHRcdFx0XHRcdGxlZnQ6IHBJbnQoZWxlbVN0eWxlLmxlZnQpICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFgsIDEpLFxuXHRcdFx0XHRcdFx0dG9wOiBwSW50KGVsZW1TdHlsZS50b3ApICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFksIDEpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoY3V0T2ZmKSB7XG5cdFx0XHRcdFx0c2hhZG93LmN1dE9mZiA9IHN0cm9rZVdpZHRoICsgMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IHRoZSBvcGFjaXR5XG5cdFx0XHRcdG1hcmt1cCA9IFsnPHN0cm9rZSBjb2xvcj1cIicsIHNoYWRvd09wdGlvbnMuY29sb3IgfHwgJ2JsYWNrJywgJ1wiIG9wYWNpdHk9XCInLCBzaGFkb3dFbGVtZW50T3BhY2l0eSAqIGksICdcIi8+J107XG5cdFx0XHRcdGNyZWF0ZUVsZW1lbnQocmVuZGVyZXIucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBzaGFkb3cpO1xuXG5cblx0XHRcdFx0Ly8gaW5zZXJ0IGl0XG5cdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvdywgZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgaXRcblx0XHRcdFx0c2hhZG93cy5wdXNoKHNoYWRvdyk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaGFkb3dzID0gc2hhZG93cztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxufTtcblZNTEVsZW1lbnQgPSBleHRlbmRDbGFzcyhTVkdFbGVtZW50LCBWTUxFbGVtZW50KTtcblxuLyoqXG4gKiBUaGUgVk1MIHJlbmRlcmVyXG4gKi9cbnZhciBWTUxSZW5kZXJlckV4dGVuc2lvbiA9IHsgLy8gaW5oZXJpdCBTVkdSZW5kZXJlclxuXG5cdEVsZW1lbnQ6IFZNTEVsZW1lbnQsXG5cdGlzSUU4OiB1c2VyQWdlbnQuaW5kZXhPZignTVNJRSA4LjAnKSA+IC0xLFxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIFZNTFJlbmRlcmVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjb250YWluZXIsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0Ym94V3JhcHBlcixcblx0XHRcdGJveDtcblxuXHRcdHJlbmRlcmVyLmFsaWduZWRPYmplY3RzID0gW107XG5cblx0XHRib3hXcmFwcGVyID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChESVYpO1xuXHRcdGJveCA9IGJveFdyYXBwZXIuZWxlbWVudDtcblx0XHRib3guc3R5bGUucG9zaXRpb24gPSBSRUxBVElWRTsgLy8gZm9yIGZyZWVmb3JtIGRyYXdpbmcgdXNpbmcgcmVuZGVyZXIgZGlyZWN0bHlcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94V3JhcHBlci5lbGVtZW50KTtcblxuXG5cdFx0Ly8gZ2VuZXJhdGUgdGhlIGNvbnRhaW5pbmcgYm94XG5cdFx0cmVuZGVyZXIuaXNWTUwgPSB0cnVlO1xuXHRcdHJlbmRlcmVyLmJveCA9IGJveDtcblx0XHRyZW5kZXJlci5ib3hXcmFwcGVyID0gYm94V3JhcHBlcjtcblxuXG5cdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cblx0XHQvLyBUaGUgb25seSB3YXkgdG8gbWFrZSBJRTYgYW5kIElFNyBwcmludCBpcyB0byB1c2UgYSBnbG9iYWwgbmFtZXNwYWNlLiBIb3dldmVyLFxuXHRcdC8vIHdpdGggSUU4IHRoZSBvbmx5IHdheSB0byBtYWtlIHRoZSBkeW5hbWljIHNoYXBlcyB2aXNpYmxlIGluIHNjcmVlbiBhbmQgcHJpbnQgbW9kZVxuXHRcdC8vIHNlZW1zIHRvIGJlIHRvIGFkZCB0aGUgeG1sbnMgYXR0cmlidXRlIGFuZCB0aGUgYmVoYXZpb3VyIHN0eWxlIGlubGluZS5cblx0XHRpZiAoIWRvYy5uYW1lc3BhY2VzLmhjdikge1xuXG5cdFx0XHRkb2MubmFtZXNwYWNlcy5hZGQoJ2hjdicsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXG5cdFx0XHQvLyBTZXR1cCBkZWZhdWx0IENTUyAoIzIxNTMpXG5cdFx0XHQoZG9jLnN0eWxlU2hlZXRzLmxlbmd0aCA/IGRvYy5zdHlsZVNoZWV0c1swXSA6IGRvYy5jcmVhdGVTdHlsZVNoZWV0KCkpLmNzc1RleHQgKz1cblx0XHRcdFx0J2hjdlxcXFw6ZmlsbCwgaGN2XFxcXDpwYXRoLCBoY3ZcXFxcOnNoYXBlLCBoY3ZcXFxcOnN0cm9rZScgK1xuXHRcdFx0XHQneyBiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9ICc7XG5cblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogRGV0ZWN0IHdoZXRoZXIgdGhlIHJlbmRlcmVyIGlzIGhpZGRlbi4gVGhpcyBoYXBwZW5zIHdoZW4gb25lIG9mIHRoZSBwYXJlbnQgZWxlbWVudHNcblx0ICogaGFzIGRpc3BsYXk6IG5vbmVcblx0ICovXG5cdGlzSGlkZGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmJveC5vZmZzZXRXaWR0aDtcblx0fSxcblxuXHQvKipcblx0ICogRGVmaW5lIGEgY2xpcHBpbmcgcmVjdGFuZ2xlLiBJbiBWTUwgaXQgaXMgYWNjb21wbGlzaGVkIGJ5IHN0b3JpbmcgdGhlIHZhbHVlc1xuXHQgKiBmb3Igc2V0dGluZyB0aGUgQ1NTIHN0eWxlIHRvIGFsbCBhc3NvY2lhdGVkIG1lbWJlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRjbGlwUmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuXHRcdC8vIGNyZWF0ZSBhIGR1bW15IGVsZW1lbnRcblx0XHR2YXIgY2xpcFJlY3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKSxcblx0XHRcdGlzT2JqID0gaXNPYmplY3QoeCk7XG5cblx0XHQvLyBtaW1pYyBhIHJlY3RhbmdsZSB3aXRoIGl0cyBzdHlsZSBvYmplY3QgZm9yIGF1dG9tYXRpYyB1cGRhdGluZyBpbiBhdHRyXG5cdFx0cmV0dXJuIGV4dGVuZChjbGlwUmVjdCwge1xuXHRcdFx0bWVtYmVyczogW10sXG5cdFx0XHRsZWZ0OiAoaXNPYmogPyB4LnggOiB4KSArIDEsXG5cdFx0XHR0b3A6IChpc09iaiA/IHgueSA6IHkpICsgMSxcblx0XHRcdHdpZHRoOiAoaXNPYmogPyB4LndpZHRoIDogd2lkdGgpIC0gMSxcblx0XHRcdGhlaWdodDogKGlzT2JqID8geC5oZWlnaHQgOiBoZWlnaHQpIC0gMSxcblx0XHRcdGdldENTUzogZnVuY3Rpb24gKHdyYXBwZXIpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLFxuXHRcdFx0XHRcdGlzU2hhcGUgPSBub2RlTmFtZSA9PT0gJ3NoYXBlJyxcblx0XHRcdFx0XHRpbnZlcnRlZCA9IHdyYXBwZXIuaW52ZXJ0ZWQsXG5cdFx0XHRcdFx0cmVjdCA9IHRoaXMsXG5cdFx0XHRcdFx0dG9wID0gcmVjdC50b3AgLSAoaXNTaGFwZSA/IGVsZW1lbnQub2Zmc2V0VG9wIDogMCksXG5cdFx0XHRcdFx0bGVmdCA9IHJlY3QubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyByZWN0LndpZHRoLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0XHRcdHJldCA9IHtcblx0XHRcdFx0XHRcdGNsaXA6ICdyZWN0KCcgK1xuXHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyBsZWZ0IDogdG9wKSArICdweCwnICtcblx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gYm90dG9tIDogcmlnaHQpICsgJ3B4LCcgK1xuXHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyByaWdodCA6IGJvdHRvbSkgKyAncHgsJyArXG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IHRvcCA6IGxlZnQpICsgJ3B4KSdcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIGlzc3VlIDc0IHdvcmthcm91bmRcblx0XHRcdFx0aWYgKCFpbnZlcnRlZCAmJiBkb2NNb2RlOCAmJiBub2RlTmFtZSA9PT0gJ0RJVicpIHtcblx0XHRcdFx0XHRleHRlbmQocmV0LCB7XG5cdFx0XHRcdFx0XHR3aWR0aDogcmlnaHQgKyBQWCxcblx0XHRcdFx0XHRcdGhlaWdodDogYm90dG9tICsgUFhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gdXNlZCBpbiBhdHRyIGFuZCBhbmltYXRpb24gdG8gdXBkYXRlIHRoZSBjbGlwcGluZyBvZiBhbGwgbWVtYmVyc1xuXHRcdFx0dXBkYXRlQ2xpcHBpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0ZWFjaChjbGlwUmVjdC5tZW1iZXJzLCBmdW5jdGlvbiAobWVtYmVyKSB7XG5cdFx0XHRcdFx0bWVtYmVyLmNzcyhjbGlwUmVjdC5nZXRDU1MobWVtYmVyKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblxuXHQvKipcblx0ICogVGFrZSBhIGNvbG9yIGFuZCByZXR1cm4gaXQgaWYgaXQncyBhIHN0cmluZywgbWFrZSBpdCBhIGdyYWRpZW50IGlmIGl0J3MgYVxuXHQgKiBncmFkaWVudCBjb25maWd1cmF0aW9uIG9iamVjdCwgYW5kIGFwcGx5IG9wYWNpdHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvciBUaGUgY29sb3Igb3IgY29uZmlnIG9iamVjdFxuXHQgKi9cblx0Y29sb3I6IGZ1bmN0aW9uIChjb2xvciwgZWxlbSwgcHJvcCwgd3JhcHBlcikge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRjb2xvck9iamVjdCxcblx0XHRcdHJlZ2V4UmdiYSA9IC9ecmdiYS8sXG5cdFx0XHRtYXJrdXAsXG5cdFx0XHRmaWxsVHlwZSxcblx0XHRcdHJldCA9IE5PTkU7XG5cblx0XHQvLyBDaGVjayBmb3IgbGluZWFyIG9yIHJhZGlhbCBncmFkaWVudFxuXHRcdGlmIChjb2xvciAmJiBjb2xvci5saW5lYXJHcmFkaWVudCkge1xuXHRcdFx0ZmlsbFR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdH0gZWxzZSBpZiAoY29sb3IgJiYgY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdGZpbGxUeXBlID0gJ3BhdHRlcm4nO1xuXHRcdH1cblxuXG5cdFx0aWYgKGZpbGxUeXBlKSB7XG5cblx0XHRcdHZhciBzdG9wQ29sb3IsXG5cdFx0XHRcdHN0b3BPcGFjaXR5LFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbG9yLmxpbmVhckdyYWRpZW50IHx8IGNvbG9yLnJhZGlhbEdyYWRpZW50LFxuXHRcdFx0XHR4MSxcblx0XHRcdFx0eTEsXG5cdFx0XHRcdHgyLFxuXHRcdFx0XHR5Mixcblx0XHRcdFx0b3BhY2l0eTEsXG5cdFx0XHRcdG9wYWNpdHkyLFxuXHRcdFx0XHRjb2xvcjEsXG5cdFx0XHRcdGNvbG9yMixcblx0XHRcdFx0ZmlsbEF0dHIgPSAnJyxcblx0XHRcdFx0c3RvcHMgPSBjb2xvci5zdG9wcyxcblx0XHRcdFx0Zmlyc3RTdG9wLFxuXHRcdFx0XHRsYXN0U3RvcCxcblx0XHRcdFx0Y29sb3JzID0gW10sXG5cdFx0XHRcdGFkZEZpbGxOb2RlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIEFkZCB0aGUgZmlsbCBzdWJub2RlLiBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcblx0XHRcdFx0XHQvLyBhcmUgcmV2ZXJzZWQuXG5cdFx0XHRcdFx0bWFya3VwID0gWyc8ZmlsbCBjb2xvcnM9XCInICsgY29sb3JzLmpvaW4oJywnKSArICdcIiBvcGFjaXR5PVwiJywgb3BhY2l0eTIsICdcIiBvOm9wYWNpdHkyPVwiJywgb3BhY2l0eTEsXG5cdFx0XHRcdFx0XHQnXCIgdHlwZT1cIicsIGZpbGxUeXBlLCAnXCIgJywgZmlsbEF0dHIsICdmb2N1cz1cIjEwMCVcIiBtZXRob2Q9XCJhbnlcIiAvPiddO1xuXHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQocmVuZGVyZXIucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBlbGVtKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gRXh0ZW5kIGZyb20gMCB0byAxXG5cdFx0XHRmaXJzdFN0b3AgPSBzdG9wc1swXTtcblx0XHRcdGxhc3RTdG9wID0gc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV07XG5cdFx0XHRpZiAoZmlyc3RTdG9wWzBdID4gMCkge1xuXHRcdFx0XHRzdG9wcy51bnNoaWZ0KFtcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdGZpcnN0U3RvcFsxXVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblx0XHRcdGlmIChsYXN0U3RvcFswXSA8IDEpIHtcblx0XHRcdFx0c3RvcHMucHVzaChbXG5cdFx0XHRcdFx0MSxcblx0XHRcdFx0XHRsYXN0U3RvcFsxXVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcHV0ZSB0aGUgc3RvcHNcblx0XHRcdGVhY2goc3RvcHMsIGZ1bmN0aW9uIChzdG9wLCBpKSB7XG5cdFx0XHRcdGlmIChyZWdleFJnYmEudGVzdChzdG9wWzFdKSkge1xuXHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0c3RvcENvbG9yID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblx0XHRcdFx0XHRzdG9wT3BhY2l0eSA9IGNvbG9yT2JqZWN0LmdldCgnYScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3BbMV07XG5cdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQnVpbGQgdGhlIGNvbG9yIGF0dHJpYnV0ZVxuXHRcdFx0XHRjb2xvcnMucHVzaCgoc3RvcFswXSAqIDEwMCkgKyAnJSAnICsgc3RvcENvbG9yKTtcblxuXHRcdFx0XHQvLyBPbmx5IHN0YXJ0IGFuZCBlbmQgb3BhY2l0aWVzIGFyZSBhbGxvd2VkLCBzbyB3ZSB1c2UgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdFxuXHRcdFx0XHRpZiAoIWkpIHtcblx0XHRcdFx0XHRvcGFjaXR5MSA9IHN0b3BPcGFjaXR5O1xuXHRcdFx0XHRcdGNvbG9yMiA9IHN0b3BDb2xvcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcGFjaXR5MiA9IHN0b3BPcGFjaXR5O1xuXHRcdFx0XHRcdGNvbG9yMSA9IHN0b3BDb2xvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IHRoZSBncmFkaWVudCB0byBmaWxscyBvbmx5LlxuXHRcdFx0aWYgKHByb3AgPT09ICdmaWxsJykge1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBsaW5lYXIgZ3JhZGllbnQgYW5nbGVcblx0XHRcdFx0aWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBncmFkaWVudC54MSB8fCBncmFkaWVudFswXSB8fCAwO1xuXHRcdFx0XHRcdHkxID0gZ3JhZGllbnQueTEgfHwgZ3JhZGllbnRbMV0gfHwgMDtcblx0XHRcdFx0XHR4MiA9IGdyYWRpZW50LngyIHx8IGdyYWRpZW50WzJdIHx8IDA7XG5cdFx0XHRcdFx0eTIgPSBncmFkaWVudC55MiB8fCBncmFkaWVudFszXSB8fCAwO1xuXHRcdFx0XHRcdGZpbGxBdHRyID0gJ2FuZ2xlPVwiJyArICg5MCAgLSBtYXRoLmF0YW4oXG5cdFx0XHRcdFx0XHQoeTIgLSB5MSkgLyAvLyB5IHZlY3RvclxuXHRcdFx0XHRcdFx0KHgyIC0geDEpIC8vIHggdmVjdG9yXG5cdFx0XHRcdFx0XHQpICogMTgwIC8gbWF0aFBJKSArICdcIic7XG5cblx0XHRcdFx0XHRhZGRGaWxsTm9kZSgpO1xuXG5cdFx0XHRcdC8vIFJhZGlhbCAoY2lyY3VsYXIpIGdyYWRpZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgciA9IGdyYWRpZW50LnIsXG5cdFx0XHRcdFx0XHRzaXpleCA9IHIgKiAyLFxuXHRcdFx0XHRcdFx0c2l6ZXkgPSByICogMixcblx0XHRcdFx0XHRcdGN4ID0gZ3JhZGllbnQuY3gsXG5cdFx0XHRcdFx0XHRjeSA9IGdyYWRpZW50LmN5LFxuXHRcdFx0XHRcdFx0cmFkaWFsUmVmZXJlbmNlID0gZWxlbS5yYWRpYWxSZWZlcmVuY2UsXG5cdFx0XHRcdFx0XHRiQm94LFxuXHRcdFx0XHRcdFx0YXBwbHlSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJhZGlhbFJlZmVyZW5jZSkge1xuXHRcdFx0XHRcdFx0XHRcdGJCb3ggPSB3cmFwcGVyLmdldEJCb3goKTtcblx0XHRcdFx0XHRcdFx0XHRjeCArPSAocmFkaWFsUmVmZXJlbmNlWzBdIC0gYkJveC54KSAvIGJCb3gud2lkdGggLSAwLjU7XG5cdFx0XHRcdFx0XHRcdFx0Y3kgKz0gKHJhZGlhbFJlZmVyZW5jZVsxXSAtIGJCb3gueSkgLyBiQm94LmhlaWdodCAtIDAuNTtcblx0XHRcdFx0XHRcdFx0XHRzaXpleCAqPSByYWRpYWxSZWZlcmVuY2VbMl0gLyBiQm94LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdHNpemV5ICo9IHJhZGlhbFJlZmVyZW5jZVsyXSAvIGJCb3guaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZpbGxBdHRyID0gJ3NyYz1cIicgKyBkZWZhdWx0T3B0aW9ucy5nbG9iYWwuVk1MUmFkaWFsR3JhZGllbnRVUkwgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0J3NpemU9XCInICsgc2l6ZXggKyAnLCcgKyBzaXpleSArICdcIiAnICtcblx0XHRcdFx0XHRcdFx0XHQnb3JpZ2luPVwiMC41LDAuNVwiICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdwb3NpdGlvbj1cIicgKyBjeCArICcsJyArIGN5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdjb2xvcjI9XCInICsgY29sb3IyICsgJ1wiICc7XG5cblx0XHRcdFx0XHRcdFx0YWRkRmlsbE5vZGUoKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBBcHBseSByYWRpYWwgZ3JhZGllbnRcblx0XHRcdFx0XHRpZiAod3JhcHBlci5hZGRlZCkge1xuXHRcdFx0XHRcdFx0YXBwbHlSYWRpYWxHcmFkaWVudCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGtub3cgdGhlIGJvdW5kaW5nIGJveCB0byBnZXQgdGhlIHNpemUgYW5kIHBvc2l0aW9uIHJpZ2h0XG5cdFx0XHRcdFx0XHRhZGRFdmVudCh3cmFwcGVyLCAnYWRkJywgYXBwbHlSYWRpYWxHcmFkaWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVGhlIGZpbGwgZWxlbWVudCdzIGNvbG9yIGF0dHJpYnV0ZSBpcyBicm9rZW4gaW4gSUU4IHN0YW5kYXJkcyBtb2RlLCBzbyB3ZVxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gc2V0IHRoZSBwYXJlbnQgc2hhcGUncyBmaWxsY29sb3IgYXR0cmlidXRlIGluc3RlYWQuXG5cdFx0XHRcdFx0cmV0ID0gY29sb3IxO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEdyYWRpZW50cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgVk1MIHN0cm9rZSwgcmV0dXJuIHRoZSBmaXJzdCBjb2xvci4gIzcyMi5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9IHN0b3BDb2xvcjtcblx0XHRcdH1cblxuXHRcdC8vIGlmIHRoZSBjb2xvciBpcyBhbiByZ2JhIGNvbG9yLCBzcGxpdCBpdCBhbmQgYWRkIGEgZmlsbCBub2RlXG5cdFx0Ly8gdG8gaG9sZCB0aGUgb3BhY2l0eSBjb21wb25lbnRcblx0XHR9IGVsc2UgaWYgKHJlZ2V4UmdiYS50ZXN0KGNvbG9yKSAmJiBlbGVtLnRhZ05hbWUgIT09ICdJTUcnKSB7XG5cblx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3IoY29sb3IpO1xuXG5cdFx0XHRtYXJrdXAgPSBbJzwnLCBwcm9wLCAnIG9wYWNpdHk9XCInLCBjb2xvck9iamVjdC5nZXQoJ2EnKSwgJ1wiLz4nXTtcblx0XHRcdGNyZWF0ZUVsZW1lbnQodGhpcy5wcmVwVk1MKG1hcmt1cCksIG51bGwsIG51bGwsIGVsZW0pO1xuXG5cdFx0XHRyZXQgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHByb3BOb2RlcyA9IGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUocHJvcCk7IC8vICdzdHJva2UnIG9yICdmaWxsJyBub2RlXG5cdFx0XHRpZiAocHJvcE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRwcm9wTm9kZXNbMF0ub3BhY2l0eSA9IDE7XG5cdFx0XHRcdHByb3BOb2Rlc1swXS50eXBlID0gJ3NvbGlkJztcblx0XHRcdH1cblx0XHRcdHJldCA9IGNvbG9yO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRha2UgYSBWTUwgc3RyaW5nIGFuZCBwcmVwYXJlIGl0IGZvciBlaXRoZXIgSUU4IG9yIElFNi9JRTcuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hcmt1cCBBIHN0cmluZyBhcnJheSBvZiB0aGUgVk1MIG1hcmt1cCB0byBwcmVwYXJlXG5cdCAqL1xuXHRwcmVwVk1MOiBmdW5jdGlvbiAobWFya3VwKSB7XG5cdFx0dmFyIHZtbFN0eWxlID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOycsXG5cdFx0XHRpc0lFOCA9IHRoaXMuaXNJRTg7XG5cblx0XHRtYXJrdXAgPSBtYXJrdXAuam9pbignJyk7XG5cblx0XHRpZiAoaXNJRTgpIHsgLy8gYWRkIHhtbG5zIGFuZCBzdHlsZSBpbmxpbmVcblx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCcvPicsICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiIC8+Jyk7XG5cdFx0XHRpZiAobWFya3VwLmluZGV4T2YoJ3N0eWxlPVwiJykgPT09IC0xKSB7XG5cdFx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCcvPicsICcgc3R5bGU9XCInICsgdm1sU3R5bGUgKyAnXCIgLz4nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCdzdHlsZT1cIicsICdzdHlsZT1cIicgKyB2bWxTdHlsZSk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgeyAvLyBhZGQgbmFtZXNwYWNlXG5cdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnPCcsICc8aGN2OicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXJrdXA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSByb3RhdGVkIGFuZCBhbGlnbmVkIHRleHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKi9cblx0dGV4dDogU1ZHUmVuZGVyZXIucHJvdG90eXBlLmh0bWwsXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgcGF0aCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcblx0ICovXG5cdHBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGF0dHIgPSB7XG5cdFx0XHQvLyBzdWJwaXhlbCBwcmVjaXNpb24gZG93biB0byAwLjEgKHdpZHRoIGFuZCBoZWlnaHQgPSAxcHgpXG5cdFx0XHRjb29yZHNpemU6ICcxMCAxMCdcblx0XHR9O1xuXHRcdGlmIChpc0FycmF5KHBhdGgpKSB7XG5cdFx0XHRhdHRyLmQgPSBwYXRoO1xuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0ZXh0ZW5kKGF0dHIsIHBhdGgpO1xuXHRcdH1cblx0XHQvLyBjcmVhdGUgdGhlIHNoYXBlXG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudCgnc2hhcGUnKS5hdHRyKGF0dHIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIHJldHVybiBhIGNpcmNsZSBlbGVtZW50LiBJbiBWTUwgY2lyY2xlcyBhcmUgaW1wbGVtZW50ZWQgYXNcblx0ICogc2hhcGVzLCB3aGljaCBpcyBmYXN0ZXIgdGhhbiB2Om92YWxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJcblx0ICovXG5cdGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHIpIHtcblx0XHR2YXIgY2lyY2xlID0gdGhpcy5zeW1ib2woJ2NpcmNsZScpO1xuXHRcdGlmIChpc09iamVjdCh4KSkge1xuXHRcdFx0ciA9IHgucjtcblx0XHRcdHkgPSB4Lnk7XG5cdFx0XHR4ID0geC54O1xuXHRcdH1cblx0XHRjaXJjbGUuaXNDaXJjbGUgPSB0cnVlOyAvLyBDYXVzZXMgeCBhbmQgeSB0byBtZWFuIGNlbnRlciAoIzE2ODIpXG5cdFx0Y2lyY2xlLnIgPSByO1xuXHRcdHJldHVybiBjaXJjbGUuYXR0cih7IHg6IHgsIHk6IHkgfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGdyb3VwIHVzaW5nIGFuIG91dGVyIGRpdiBhbmQgYW4gaW5uZXIgdjpncm91cCB0byBhbGxvdyByb3RhdGluZ1xuXHQgKiBhbmQgZmxpcHBpbmcuIEEgc2ltcGxlIHY6Z3JvdXAgd291bGQgaGF2ZSBwcm9ibGVtcyB3aXRoIHBvc2l0aW9uaW5nXG5cdCAqIGNoaWxkIEhUTUwgZWxlbWVudHMgYW5kIENTUyBjbGlwLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXBcblx0ICovXG5cdGc6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIHdyYXBwZXIsXG5cdFx0XHRhdHRyaWJzO1xuXG5cdFx0Ly8gc2V0IHRoZSBjbGFzcyBuYW1lXG5cdFx0aWYgKG5hbWUpIHtcblx0XHRcdGF0dHJpYnMgPSB7ICdjbGFzc05hbWUnOiBQUkVGSVggKyBuYW1lLCAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH07XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIGRpdiB0byBob2xkIEhUTUwgYW5kIGNsaXBwaW5nXG5cdFx0d3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudChESVYpLmF0dHIoYXR0cmlicyk7XG5cblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogVk1MIG92ZXJyaWRlIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgSFRNTCBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRpbWFnZTogZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciBvYmogPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG5cdFx0XHQuYXR0cih7IHNyYzogc3JjIH0pO1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRvYmouYXR0cih7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBWTUwgdXNlcyBhIHNoYXBlIGZvciByZWN0IHRvIG92ZXJjb21lIGJ1Z3MgYW5kIHJvdGF0aW9uIHByb2JsZW1zXG5cdCAqL1xuXHRyZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgciwgc3Ryb2tlV2lkdGgpIHtcblxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5zeW1ib2woJ3JlY3QnKTtcblx0XHR3cmFwcGVyLnIgPSBpc09iamVjdCh4KSA/IHguciA6IHI7XG5cblx0XHQvL3JldHVybiB3cmFwcGVyLmF0dHIod3JhcHBlci5jcmlzcChzdHJva2VXaWR0aCwgeCwgeSwgbWF0aE1heCh3aWR0aCwgMCksIG1hdGhNYXgoaGVpZ2h0LCAwKSkpO1xuXHRcdHJldHVybiB3cmFwcGVyLmF0dHIoXG5cdFx0XHRcdGlzT2JqZWN0KHgpID9cblx0XHRcdFx0XHR4IDpcblx0XHRcdFx0XHQvLyBkbyBub3QgY3Jpc3BpZnkgd2hlbiBhbiBvYmplY3QgaXMgcGFzc2VkIGluIChhcyBpbiBjb2x1bW4gY2hhcnRzKVxuXHRcdFx0XHRcdHdyYXBwZXIuY3Jpc3Aoc3Ryb2tlV2lkdGgsIHgsIHksIG1hdGhNYXgod2lkdGgsIDApLCBtYXRoTWF4KGhlaWdodCwgMCkpXG5cdFx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbiB0aGUgVk1MIHJlbmRlcmVyLCBlYWNoIGNoaWxkIG9mIGFuIGludmVydGVkIGRpdiAoZ3JvdXApIGlzIGludmVydGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnROb2RlXG5cdCAqL1xuXHRpbnZlcnRDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5vZGUpIHtcblx0XHR2YXIgcGFyZW50U3R5bGUgPSBwYXJlbnROb2RlLnN0eWxlO1xuXHRcdGNzcyhlbGVtZW50LCB7XG5cdFx0XHRmbGlwOiAneCcsXG5cdFx0XHRsZWZ0OiBwSW50KHBhcmVudFN0eWxlLndpZHRoKSAtIDEsXG5cdFx0XHR0b3A6IHBJbnQocGFyZW50U3R5bGUuaGVpZ2h0KSAtIDEsXG5cdFx0XHRyb3RhdGlvbjogLTkwXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFN5bWJvbCBkZWZpbml0aW9ucyB0aGF0IG92ZXJyaWRlIHRoZSBwYXJlbnQgU1ZHIHJlbmRlcmVyJ3Mgc3ltYm9sc1xuXHQgKlxuXHQgKi9cblx0c3ltYm9sczoge1xuXHRcdC8vIFZNTCBzcGVjaWZpYyBhcmMgZnVuY3Rpb25cblx0XHRhcmM6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRlbmQgPSBvcHRpb25zLmVuZCxcblx0XHRcdFx0cmFkaXVzID0gb3B0aW9ucy5yIHx8IHcgfHwgaCxcblx0XHRcdFx0aW5uZXJSYWRpdXMgPSBvcHRpb25zLmlubmVyUixcblx0XHRcdFx0Y29zU3RhcnQgPSBtYXRoQ29zKHN0YXJ0KSxcblx0XHRcdFx0c2luU3RhcnQgPSBtYXRoU2luKHN0YXJ0KSxcblx0XHRcdFx0Y29zRW5kID0gbWF0aENvcyhlbmQpLFxuXHRcdFx0XHRzaW5FbmQgPSBtYXRoU2luKGVuZCksXG5cdFx0XHRcdHJldDtcblxuXHRcdFx0aWYgKGVuZCAtIHN0YXJ0ID09PSAwKSB7IC8vIG5vIGFuZ2xlLCBkb24ndCBzaG93IGl0LlxuXHRcdFx0XHRyZXR1cm4gWyd4J107XG5cdFx0XHR9XG5cblx0XHRcdHJldCA9IFtcblx0XHRcdFx0J3dhJywgLy8gY2xvY2t3aXNlIGFyYyB0b1xuXHRcdFx0XHR4IC0gcmFkaXVzLCAvLyBsZWZ0XG5cdFx0XHRcdHkgLSByYWRpdXMsIC8vIHRvcFxuXHRcdFx0XHR4ICsgcmFkaXVzLCAvLyByaWdodFxuXHRcdFx0XHR5ICsgcmFkaXVzLCAvLyBib3R0b21cblx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc1N0YXJ0LCAvLyBzdGFydCB4XG5cdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5TdGFydCwgLy8gc3RhcnQgeVxuXHRcdFx0XHR4ICsgcmFkaXVzICogY29zRW5kLCAvLyBlbmQgeFxuXHRcdFx0XHR5ICsgcmFkaXVzICogc2luRW5kICAvLyBlbmQgeVxuXHRcdFx0XTtcblxuXHRcdFx0aWYgKG9wdGlvbnMub3BlbiAmJiAhaW5uZXJSYWRpdXMpIHtcblx0XHRcdFx0cmV0LnB1c2goXG5cdFx0XHRcdFx0J2UnLFxuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0eCwvLyAtIGlubmVyUmFkaXVzLFxuXHRcdFx0XHRcdHkvLyAtIGlubmVyUmFkaXVzXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldC5wdXNoKFxuXHRcdFx0XHQnYXQnLCAvLyBhbnRpIGNsb2Nrd2lzZSBhcmMgdG9cblx0XHRcdFx0eCAtIGlubmVyUmFkaXVzLCAvLyBsZWZ0XG5cdFx0XHRcdHkgLSBpbm5lclJhZGl1cywgLy8gdG9wXG5cdFx0XHRcdHggKyBpbm5lclJhZGl1cywgLy8gcmlnaHRcblx0XHRcdFx0eSArIGlubmVyUmFkaXVzLCAvLyBib3R0b21cblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zRW5kLCAvLyBzdGFydCB4XG5cdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpbkVuZCwgLy8gc3RhcnQgeVxuXHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NTdGFydCwgLy8gZW5kIHhcblx0XHRcdFx0eSArIGlubmVyUmFkaXVzICogc2luU3RhcnQsIC8vIGVuZCB5XG5cdFx0XHRcdCd4JywgLy8gZmluaXNoIHBhdGhcblx0XHRcdFx0J2UnIC8vIGNsb3NlXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXQuaXNBcmMgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0sXG5cdFx0Ly8gQWRkIGNpcmNsZSBzeW1ib2wgcGF0aC4gVGhpcyBwZXJmb3JtcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHY6b3ZhbC5cblx0XHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCB3cmFwcGVyKSB7XG5cblx0XHRcdGlmICh3cmFwcGVyKSB7XG5cdFx0XHRcdHcgPSBoID0gMiAqIHdyYXBwZXIucjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VudGVyIGNvcnJlY3Rpb24sICMxNjgyXG5cdFx0XHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLmlzQ2lyY2xlKSB7XG5cdFx0XHRcdHggLT0gdyAvIDI7XG5cdFx0XHRcdHkgLT0gaCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiB0aGUgcGF0aFxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0J3dhJywgLy8gY2xvY2t3aXNlYXJjdG9cblx0XHRcdFx0eCwgLy8gbGVmdFxuXHRcdFx0XHR5LCAvLyB0b3Bcblx0XHRcdFx0eCArIHcsIC8vIHJpZ2h0XG5cdFx0XHRcdHkgKyBoLCAvLyBib3R0b21cblx0XHRcdFx0eCArIHcsIC8vIHN0YXJ0IHhcblx0XHRcdFx0eSArIGggLyAyLCAgICAgLy8gc3RhcnQgeVxuXHRcdFx0XHR4ICsgdywgLy8gZW5kIHhcblx0XHRcdFx0eSArIGggLyAyLCAgICAgLy8gZW5kIHlcblx0XHRcdFx0Ly8neCcsIC8vIGZpbmlzaCBwYXRoXG5cdFx0XHRcdCdlJyAvLyBjbG9zZVxuXHRcdFx0XTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEFkZCByZWN0YW5nbGUgc3ltYm9sIHBhdGggd2hpY2ggZWFzZXMgcm90YXRpb24gYW5kIG9taXRzIGFyY3NpemUgcHJvYmxlbXNcblx0XHQgKiBjb21wYXJlZCB0byB0aGUgYnVpbHQtaW4gVk1MIHJvdW5kcmVjdCBzaGFwZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgQm9yZGVyIHJhZGl1c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFdpZHRoIGFuZCBoZWlnaHRcblx0XHQgKi9cblxuXHRcdHJlY3Q6IGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblxuXHRcdFx0dmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoLFxuXHRcdFx0XHRib3R0b20gPSB0b3AgKyBoZWlnaHQsXG5cdFx0XHRcdHJldCxcblx0XHRcdFx0cjtcblxuXHRcdFx0Ly8gTm8gcmFkaXVzLCByZXR1cm4gdGhlIG1vcmUgbGlnaHR3ZWlnaHQgc3F1YXJlXG5cdFx0XHRpZiAoIWRlZmluZWQob3B0aW9ucykgfHwgIW9wdGlvbnMucikge1xuXHRcdFx0XHRyZXQgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9scy5zcXVhcmUuYXBwbHkoMCwgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gSGFzIHJhZGl1cyBhZGQgYXJjcyBmb3IgdGhlIGNvcm5lcnNcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ciA9IG1hdGhNaW4ob3B0aW9ucy5yLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0bGVmdCArIHIsIHRvcCxcblxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0cmlnaHQgLSByLCB0b3AsXG5cdFx0XHRcdFx0J3dhJyxcblx0XHRcdFx0XHRyaWdodCAtIDIgKiByLCB0b3AsXG5cdFx0XHRcdFx0cmlnaHQsIHRvcCArIDIgKiByLFxuXHRcdFx0XHRcdHJpZ2h0IC0gciwgdG9wLFxuXHRcdFx0XHRcdHJpZ2h0LCB0b3AgKyByLFxuXG5cdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRyaWdodCwgYm90dG9tIC0gcixcblx0XHRcdFx0XHQnd2EnLFxuXHRcdFx0XHRcdHJpZ2h0IC0gMiAqIHIsIGJvdHRvbSAtIDIgKiByLFxuXHRcdFx0XHRcdHJpZ2h0LCBib3R0b20sXG5cdFx0XHRcdFx0cmlnaHQsIGJvdHRvbSAtIHIsXG5cdFx0XHRcdFx0cmlnaHQgLSByLCBib3R0b20sXG5cblx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdGxlZnQgKyByLCBib3R0b20sXG5cdFx0XHRcdFx0J3dhJyxcblx0XHRcdFx0XHRsZWZ0LCBib3R0b20gLSAyICogcixcblx0XHRcdFx0XHRsZWZ0ICsgMiAqIHIsIGJvdHRvbSxcblx0XHRcdFx0XHRsZWZ0ICsgciwgYm90dG9tLFxuXHRcdFx0XHRcdGxlZnQsIGJvdHRvbSAtIHIsXG5cblx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdGxlZnQsIHRvcCArIHIsXG5cdFx0XHRcdFx0J3dhJyxcblx0XHRcdFx0XHRsZWZ0LCB0b3AsXG5cdFx0XHRcdFx0bGVmdCArIDIgKiByLCB0b3AgKyAyICogcixcblx0XHRcdFx0XHRsZWZ0LCB0b3AgKyByLFxuXHRcdFx0XHRcdGxlZnQgKyByLCB0b3AsXG5cblxuXHRcdFx0XHRcdCd4Jyxcblx0XHRcdFx0XHQnZSdcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9XG59O1xuSGlnaGNoYXJ0cy5WTUxSZW5kZXJlciA9IFZNTFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5WTUxSZW5kZXJlci5wcm90b3R5cGUgPSBtZXJnZShTVkdSZW5kZXJlci5wcm90b3R5cGUsIFZNTFJlbmRlcmVyRXh0ZW5zaW9uKTtcblxuXHQvLyBnZW5lcmFsIHJlbmRlcmVyXG5cdFJlbmRlcmVyID0gVk1MUmVuZGVyZXI7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEVORCBPRiBJTlRFUk5FVCBFWFBMT1JFUiA8PSA4IFNQRUNJRklDIENPREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFNUQVJUIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUuIFRISVMgQ0FOIEJFIFJFTU9WRUQgSUYgWU9VJ1JFIE5PVCAgICAgICpcbiAqIFRBUkdFVElORyBUSEFUIFNZU1RFTS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBDYW5WR1JlbmRlcmVyLFxuXHRDYW5WR0NvbnRyb2xsZXI7XG5cbmlmICh1c2VDYW5WRykge1xuXHQvKipcblx0ICogVGhlIENhblZHUmVuZGVyZXIgaXMgZW1wdHkgZnJvbSBzdGFydCB0byBrZWVwIHRoZSBzb3VyY2UgZm9vdHByaW50IHNtYWxsLlxuXHQgKiBXaGVuIHJlcXVlc3RlZCwgdGhlIENhblZHQ29udHJvbGxlciBkb3dubG9hZHMgdGhlIHJlc3Qgb2YgdGhlIHNvdXJjZSBwYWNrYWdlZFxuXHQgKiB0b2dldGhlciB3aXRoIHRoZSBjYW52ZyBsaWJyYXJ5LlxuXHQgKi9cblx0SGlnaGNoYXJ0cy5DYW5WR1JlbmRlcmVyID0gQ2FuVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBPdmVycmlkZSB0aGUgZ2xvYmFsIFNWRyBuYW1lc3BhY2UgdG8gZmFrZSBTVkcvSFRNTCB0aGF0IGFjY2VwdHMgQ1NTXG5cdFx0U1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydCB3aXRoIGFuIGVtcHR5IHN5bWJvbHMgb2JqZWN0LiBUaGlzIGlzIG5lZWRlZCB3aGVuIGV4cG9ydGluZyBpcyB1c2VkIChleHBvcnRpbmcuc3JjLmpzIHdpbGwgYWRkIGEgZmV3IHN5bWJvbHMpLCBidXQgXG5cdCAqIHRoZSBpbXBsZW1lbnRhdGlvbiBmcm9tIFN2Z1JlbmRlcmVyIHdpbGwgbm90IGJlIG1lcmdlZCBpbiB1bnRpbCBmaXJzdCByZW5kZXIuXG5cdCAqL1xuXHRDYW5WR1JlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzID0ge307XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgb24gZGVtYW5kIGRvd25sb2FkIG9mIGNhbnZnIHJlbmRlcmluZyBzdXBwb3J0LlxuXHQgKi9cblx0Q2FuVkdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBMaXN0IG9mIHJlbmRlcmVyaW5nIGNhbGxzXG5cdFx0dmFyIGRlZmVycmVkUmVuZGVyQ2FsbHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gZG93bmxvYWRlZCwgd2UgYXJlIHJlYWR5IHRvIGRyYXcgZGVmZXJyZWQgY2hhcnRzLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRyYXdEZWZlcnJlZCgpIHtcblx0XHRcdHZhciBjYWxsTGVuZ3RoID0gZGVmZXJyZWRSZW5kZXJDYWxscy5sZW5ndGgsXG5cdFx0XHRcdGNhbGxJbmRleDtcblxuXHRcdFx0Ly8gRHJhdyBhbGwgcGVuZGluZyByZW5kZXIgY2FsbHNcblx0XHRcdGZvciAoY2FsbEluZGV4ID0gMDsgY2FsbEluZGV4IDwgY2FsbExlbmd0aDsgY2FsbEluZGV4KyspIHtcblx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxsc1tjYWxsSW5kZXhdKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDbGVhciB0aGUgbGlzdFxuXHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxscyA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRwdXNoOiBmdW5jdGlvbiAoZnVuYywgc2NyaXB0TG9jYXRpb24pIHtcblx0XHRcdFx0Ly8gT25seSBnZXQgdGhlIHNjcmlwdCBvbmNlXG5cdFx0XHRcdGlmIChkZWZlcnJlZFJlbmRlckNhbGxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGdldFNjcmlwdChzY3JpcHRMb2NhdGlvbiwgZHJhd0RlZmVycmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBSZWdpc3RlciByZW5kZXIgY2FsbFxuXHRcdFx0XHRkZWZlcnJlZFJlbmRlckNhbGxzLnB1c2goZnVuYyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpKTtcblxuXHRSZW5kZXJlciA9IENhblZHUmVuZGVyZXI7XG59IC8vIGVuZCBDYW5WR1JlbmRlcmVyXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEVORCBPRiBBTkRST0lEIDwgMyBTUEVDSUZJQyBDT0RFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBUaGUgVGljayBjbGFzc1xuICovXG5mdW5jdGlvbiBUaWNrKGF4aXMsIHBvcywgdHlwZSwgbm9MYWJlbCkge1xuXHR0aGlzLmF4aXMgPSBheGlzO1xuXHR0aGlzLnBvcyA9IHBvcztcblx0dGhpcy50eXBlID0gdHlwZSB8fCAnJztcblx0dGhpcy5pc05ldyA9IHRydWU7XG5cblx0aWYgKCF0eXBlICYmICFub0xhYmVsKSB7XG5cdFx0dGhpcy5hZGRMYWJlbCgpO1xuXHR9XG59XG5cblRpY2sucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogV3JpdGUgdGhlIHRpY2sgbGFiZWxcblx0ICovXG5cdGFkZExhYmVsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0YXhpcyA9IHRpY2suYXhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0bmFtZXMgPSBheGlzLnNlcmllc1swXSAmJiBheGlzLnNlcmllc1swXS5uYW1lcyxcblx0XHRcdHBvcyA9IHRpY2sucG9zLFxuXHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRzdHIsXG5cdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0d2lkdGggPSAoaG9yaXogJiYgY2F0ZWdvcmllcyAmJlxuXHRcdFx0XHQhbGFiZWxPcHRpb25zLnN0ZXAgJiYgIWxhYmVsT3B0aW9ucy5zdGFnZ2VyTGluZXMgJiZcblx0XHRcdFx0IWxhYmVsT3B0aW9ucy5yb3RhdGlvbiAmJlxuXHRcdFx0XHRjaGFydC5wbG90V2lkdGggLyB0aWNrUG9zaXRpb25zLmxlbmd0aCkgfHxcblx0XHRcdFx0KCFob3JpeiAmJiAoY2hhcnQubWFyZ2luWzNdIHx8IGNoYXJ0LmNoYXJ0V2lkdGggKiAwLjMzKSksIC8vICMxNTgwLCAjMTkzMVxuXHRcdFx0aXNGaXJzdCA9IHBvcyA9PT0gdGlja1Bvc2l0aW9uc1swXSxcblx0XHRcdGlzTGFzdCA9IHBvcyA9PT0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0Y3NzLFxuXHRcdFx0YXR0cixcblx0XHRcdHZhbHVlID0gY2F0ZWdvcmllcyA/XG5cdFx0XHRcdHBpY2soY2F0ZWdvcmllc1twb3NdLCBuYW1lcyAmJiBuYW1lc1twb3NdLCBwb3MpIDogXG5cdFx0XHRcdHBvcyxcblx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdHRpY2tQb3NpdGlvbkluZm8gPSB0aWNrUG9zaXRpb25zLmluZm8sXG5cdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0O1xuXG5cdFx0Ly8gU2V0IHRoZSBkYXRldGltZSBsYWJlbCBmb3JtYXQuIElmIGEgaGlnaGVyIHJhbmsgaXMgc2V0IGZvciB0aGlzIHBvc2l0aW9uLCB1c2UgdGhhdC4gSWYgbm90LFxuXHRcdC8vIHVzZSB0aGUgZ2VuZXJhbCBmb3JtYXQuXG5cdFx0aWYgKGF4aXMuaXNEYXRldGltZUF4aXMgJiYgdGlja1Bvc2l0aW9uSW5mbykge1xuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHNbdGlja1Bvc2l0aW9uSW5mby5oaWdoZXJSYW5rc1twb3NdIHx8IHRpY2tQb3NpdGlvbkluZm8udW5pdE5hbWVdO1xuXHRcdH1cblxuXHRcdC8vIHNldCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3MgaW4gcmVuZGVyIG1ldGhvZFxuXHRcdHRpY2suaXNGaXJzdCA9IGlzRmlyc3Q7XG5cdFx0dGljay5pc0xhc3QgPSBpc0xhc3Q7XG5cblx0XHQvLyBnZXQgdGhlIHN0cmluZ1xuXHRcdHN0ciA9IGF4aXMubGFiZWxGb3JtYXR0ZXIuY2FsbCh7XG5cdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0aXNGaXJzdDogaXNGaXJzdCxcblx0XHRcdGlzTGFzdDogaXNMYXN0LFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdDogZGF0ZVRpbWVMYWJlbEZvcm1hdCxcblx0XHRcdHZhbHVlOiBheGlzLmlzTG9nID8gY29ycmVjdEZsb2F0KGxpbjJsb2codmFsdWUpKSA6IHZhbHVlXG5cdFx0fSk7XG5cblx0XHQvLyBwcmVwYXJlIENTU1xuXHRcdGNzcyA9IHdpZHRoICYmIHsgd2lkdGg6IG1hdGhNYXgoMSwgbWF0aFJvdW5kKHdpZHRoIC0gMiAqIChsYWJlbE9wdGlvbnMucGFkZGluZyB8fCAxMCkpKSArIFBYIH07XG5cdFx0Y3NzID0gZXh0ZW5kKGNzcywgbGFiZWxPcHRpb25zLnN0eWxlKTtcblxuXHRcdC8vIGZpcnN0IGNhbGxcblx0XHRpZiAoIWRlZmluZWQobGFiZWwpKSB7XG5cdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRhbGlnbjogYXhpcy5sYWJlbEFsaWduXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzTnVtYmVyKGxhYmVsT3B0aW9ucy5yb3RhdGlvbikpIHtcblx0XHRcdFx0YXR0ci5yb3RhdGlvbiA9IGxhYmVsT3B0aW9ucy5yb3RhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh3aWR0aCAmJiBsYWJlbE9wdGlvbnMuZWxsaXBzaXMpIHtcblx0XHRcdFx0YXR0ci5fY2xpcEhlaWdodCA9IGF4aXMubGVuIC8gdGlja1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdHRpY2subGFiZWwgPVxuXHRcdFx0XHRkZWZpbmVkKHN0cikgJiYgbGFiZWxPcHRpb25zLmVuYWJsZWQgP1xuXHRcdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRcdHN0cixcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0bGFiZWxPcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHQvLyB3aXRob3V0IHBvc2l0aW9uIGFic29sdXRlLCBJRSBleHBvcnQgc29tZXRpbWVzIGlzIHdyb25nXG5cdFx0XHRcdFx0XHQuY3NzKGNzcylcblx0XHRcdFx0XHRcdC5hZGQoYXhpcy5sYWJlbEdyb3VwKSA6XG5cdFx0XHRcdFx0bnVsbDtcblxuXHRcdC8vIHVwZGF0ZVxuXHRcdH0gZWxzZSBpZiAobGFiZWwpIHtcblx0XHRcdGxhYmVsLmF0dHIoe1xuXHRcdFx0XHRcdHRleHQ6IHN0clxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKGNzcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG9mZnNldCBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGxhYmVsXG5cdCAqL1xuXHRnZXRMYWJlbFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGFiZWwgPSB0aGlzLmxhYmVsLFxuXHRcdFx0YXhpcyA9IHRoaXMuYXhpcztcblx0XHRyZXR1cm4gbGFiZWwgP1xuXHRcdFx0KCh0aGlzLmxhYmVsQkJveCA9IGxhYmVsLmdldEJCb3goKSkpW2F4aXMuaG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCddIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpbmQgaG93IGZhciB0aGUgbGFiZWxzIGV4dGVuZCB0byB0aGUgcmlnaHQgYW5kIGxlZnQgb2YgdGhlIHRpY2sncyB4IHBvc2l0aW9uLiBVc2VkIGZvciBhbnRpLWNvbGxpc2lvblxuXHQgKiBkZXRlY3Rpb24gd2l0aCBvdmVyZmxvdyBsb2dpYy5cblx0ICovXG5cdGdldExhYmVsU2lkZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYkJveCA9IHRoaXMubGFiZWxCQm94LCAvLyBhc3N1bWUgZ2V0TGFiZWxTaXplIGhhcyBydW4gYXQgdGhpcyBwb2ludFxuXHRcdFx0YXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRsYWJlbE9wdGlvbnMgPSBvcHRpb25zLmxhYmVscyxcblx0XHRcdHdpZHRoID0gYkJveC53aWR0aCxcblx0XHRcdGxlZnRTaWRlID0gd2lkdGggKiB7IGxlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSB9W2F4aXMubGFiZWxBbGlnbl0gLSBsYWJlbE9wdGlvbnMueDtcblxuXHRcdHJldHVybiBbLWxlZnRTaWRlLCB3aWR0aCAtIGxlZnRTaWRlXTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIHRoZSBsYWJlbCBvdmVyZmxvdyBieSBhZGp1c3RpbmcgdGhlIGxhYmVscyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgZWRnZSwgb3Jcblx0ICogaGlkZSB0aGVtIGlmIHRoZXkgY29sbGlkZSBpbnRvIHRoZSBuZWlnaGJvdXIgbGFiZWwuXG5cdCAqL1xuXHRoYW5kbGVPdmVyZmxvdzogZnVuY3Rpb24gKGluZGV4LCB4eSkge1xuXHRcdHZhciBzaG93ID0gdHJ1ZSxcblx0XHRcdGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRpc0ZpcnN0ID0gdGhpcy5pc0ZpcnN0LFxuXHRcdFx0aXNMYXN0ID0gdGhpcy5pc0xhc3QsXG5cdFx0XHR4ID0geHkueCxcblx0XHRcdHJldmVyc2VkID0gYXhpcy5yZXZlcnNlZCxcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnM7XG5cblx0XHRpZiAoaXNGaXJzdCB8fCBpc0xhc3QpIHtcblxuXHRcdFx0dmFyIHNpZGVzID0gdGhpcy5nZXRMYWJlbFNpZGVzKCksXG5cdFx0XHRcdGxlZnRTaWRlID0gc2lkZXNbMF0sXG5cdFx0XHRcdHJpZ2h0U2lkZSA9IHNpZGVzWzFdLFxuXHRcdFx0XHRwbG90TGVmdCA9IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHRwbG90UmlnaHQgPSBwbG90TGVmdCArIGF4aXMubGVuLFxuXHRcdFx0XHRuZWlnaGJvdXIgPSBheGlzLnRpY2tzW3RpY2tQb3NpdGlvbnNbaW5kZXggKyAoaXNGaXJzdCA/IDEgOiAtMSldXSxcblx0XHRcdFx0bmVpZ2hib3VyRWRnZSA9IG5laWdoYm91ciAmJiBuZWlnaGJvdXIubGFiZWwueHkgJiYgbmVpZ2hib3VyLmxhYmVsLnh5LnggKyBuZWlnaGJvdXIuZ2V0TGFiZWxTaWRlcygpW2lzRmlyc3QgPyAwIDogMV07XG5cblx0XHRcdGlmICgoaXNGaXJzdCAmJiAhcmV2ZXJzZWQpIHx8IChpc0xhc3QgJiYgcmV2ZXJzZWQpKSB7XG5cdFx0XHRcdC8vIElzIHRoZSBsYWJlbCBzcGlsbGluZyBvdXQgdG8gdGhlIGxlZnQgb2YgdGhlIHBsb3QgYXJlYT9cblx0XHRcdFx0aWYgKHggKyBsZWZ0U2lkZSA8IHBsb3RMZWZ0KSB7XG5cblx0XHRcdFx0XHQvLyBBbGlnbiBpdCB0byBwbG90IGxlZnRcblx0XHRcdFx0XHR4ID0gcGxvdExlZnQgLSBsZWZ0U2lkZTtcblxuXHRcdFx0XHRcdC8vIEhpZGUgaXQgaWYgaXQgbm93IG92ZXJsYXBzIHRoZSBuZWlnaGJvdXIgbGFiZWxcblx0XHRcdFx0XHRpZiAobmVpZ2hib3VyICYmIHggKyByaWdodFNpZGUgPiBuZWlnaGJvdXJFZGdlKSB7XG5cdFx0XHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElzIHRoZSBsYWJlbCBzcGlsbGluZyBvdXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwbG90IGFyZWE/XG5cdFx0XHRcdGlmICh4ICsgcmlnaHRTaWRlID4gcGxvdFJpZ2h0KSB7XG5cblx0XHRcdFx0XHQvLyBBbGlnbiBpdCB0byBwbG90IHJpZ2h0XG5cdFx0XHRcdFx0eCA9IHBsb3RSaWdodCAtIHJpZ2h0U2lkZTtcblxuXHRcdFx0XHRcdC8vIEhpZGUgaXQgaWYgaXQgbm93IG92ZXJsYXBzIHRoZSBuZWlnaGJvdXIgbGFiZWxcblx0XHRcdFx0XHRpZiAobmVpZ2hib3VyICYmIHggKyBsZWZ0U2lkZSA8IG5laWdoYm91ckVkZ2UpIHtcblx0XHRcdFx0XHRcdHNob3cgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIG1vZGlmaWVkIHggcG9zaXRpb24gb2YgdGhlIGxhYmVsXG5cdFx0XHR4eS54ID0geDtcblx0XHR9XG5cdFx0cmV0dXJuIHNob3c7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgeCBhbmQgeSBwb3NpdGlvbiBmb3IgdGlja3MgYW5kIGxhYmVsc1xuXHQgKi9cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChob3JpeiwgcG9zLCB0aWNrbWFya09mZnNldCwgb2xkKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRjSGVpZ2h0ID0gKG9sZCAmJiBjaGFydC5vbGRDaGFydEhlaWdodCkgfHwgY2hhcnQuY2hhcnRIZWlnaHQ7XG5cdFx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IGhvcml6ID9cblx0XHRcdFx0YXhpcy50cmFuc2xhdGUocG9zICsgdGlja21hcmtPZmZzZXQsIG51bGwsIG51bGwsIG9sZCkgKyBheGlzLnRyYW5zQiA6XG5cdFx0XHRcdGF4aXMubGVmdCArIGF4aXMub2Zmc2V0ICsgKGF4aXMub3Bwb3NpdGUgPyAoKG9sZCAmJiBjaGFydC5vbGRDaGFydFdpZHRoKSB8fCBjaGFydC5jaGFydFdpZHRoKSAtIGF4aXMucmlnaHQgLSBheGlzLmxlZnQgOiAwKSxcblxuXHRcdFx0eTogaG9yaXogP1xuXHRcdFx0XHRjSGVpZ2h0IC0gYXhpcy5ib3R0b20gKyBheGlzLm9mZnNldCAtIChheGlzLm9wcG9zaXRlID8gYXhpcy5oZWlnaHQgOiAwKSA6XG5cdFx0XHRcdGNIZWlnaHQgLSBheGlzLnRyYW5zbGF0ZShwb3MgKyB0aWNrbWFya09mZnNldCwgbnVsbCwgbnVsbCwgb2xkKSAtIGF4aXMudHJhbnNCXG5cdFx0fTtcblx0XHRcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHgsIHkgcG9zaXRpb24gb2YgdGhlIHRpY2sgbGFiZWxcblx0ICovXG5cdGdldExhYmVsUG9zaXRpb246IGZ1bmN0aW9uICh4LCB5LCBsYWJlbCwgaG9yaXosIGxhYmVsT3B0aW9ucywgdGlja21hcmtPZmZzZXQsIGluZGV4LCBzdGVwKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHR0cmFuc0EgPSBheGlzLnRyYW5zQSxcblx0XHRcdHJldmVyc2VkID0gYXhpcy5yZXZlcnNlZCxcblx0XHRcdHN0YWdnZXJMaW5lcyA9IGF4aXMuc3RhZ2dlckxpbmVzLFxuXHRcdFx0YmFzZWxpbmUgPSBheGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGxhYmVsT3B0aW9ucy5zdHlsZS5mb250U2l6ZSkuYixcblx0XHRcdHJvdGF0aW9uID0gbGFiZWxPcHRpb25zLnJvdGF0aW9uO1xuXHRcdFx0XG5cdFx0eCA9IHggKyBsYWJlbE9wdGlvbnMueCAtICh0aWNrbWFya09mZnNldCAmJiBob3JpeiA/XG5cdFx0XHR0aWNrbWFya09mZnNldCAqIHRyYW5zQSAqIChyZXZlcnNlZCA/IC0xIDogMSkgOiAwKTtcblx0XHR5ID0geSArIGxhYmVsT3B0aW9ucy55IC0gKHRpY2ttYXJrT2Zmc2V0ICYmICFob3JpeiA/XG5cdFx0XHR0aWNrbWFya09mZnNldCAqIHRyYW5zQSAqIChyZXZlcnNlZCA/IDEgOiAtMSkgOiAwKTtcblxuXHRcdC8vIENvcnJlY3QgZm9yIHJvdGF0aW9uICgjMTc2NClcblx0XHRpZiAocm90YXRpb24gJiYgYXhpcy5zaWRlID09PSAyKSB7XG5cdFx0XHR5IC09IGJhc2VsaW5lIC0gYmFzZWxpbmUgKiBtYXRoQ29zKHJvdGF0aW9uICogZGVnMnJhZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFZlcnRpY2FsbHkgY2VudGVyZWRcblx0XHRpZiAoIWRlZmluZWQobGFiZWxPcHRpb25zLnkpICYmICFyb3RhdGlvbikgeyAvLyAjMTk1MVxuXHRcdFx0eSArPSBiYXNlbGluZSAtIGxhYmVsLmdldEJCb3goKS5oZWlnaHQgLyAyO1xuXHRcdH1cblx0XHRcblx0XHQvLyBDb3JyZWN0IGZvciBzdGFnZ2VyZWQgbGFiZWxzXG5cdFx0aWYgKHN0YWdnZXJMaW5lcykge1xuXHRcdFx0eSArPSAoaW5kZXggLyAoc3RlcCB8fCAxKSAlIHN0YWdnZXJMaW5lcykgKiAoYXhpcy5sYWJlbE9mZnNldCAvIHN0YWdnZXJMaW5lcyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH0sXG5cdFxuXHQvKipcblx0ICogRXh0ZW5kaWJsZSBtZXRob2QgdG8gcmV0dXJuIHRoZSBwYXRoIG9mIHRoZSBtYXJrZXJcblx0ICovXG5cdGdldE1hcmtQYXRoOiBmdW5jdGlvbiAoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoLCBob3JpeiwgcmVuZGVyZXIpIHtcblx0XHRyZXR1cm4gcmVuZGVyZXIuY3Jpc3BMaW5lKFtcblx0XHRcdFx0TSxcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdFx0TCxcblx0XHRcdFx0eCArIChob3JpeiA/IDAgOiAtdGlja0xlbmd0aCksXG5cdFx0XHRcdHkgKyAoaG9yaXogPyB0aWNrTGVuZ3RoIDogMClcblx0XHRcdF0sIHRpY2tXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFB1dCBldmVyeXRoaW5nIGluIHBsYWNlXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfVxuXHQgKiBAcGFyYW0gb2xkIHtCb29sZWFufSBVc2Ugb2xkIGNvb3JkaW5hdGVzIHRvIHByZXBhcmUgYW4gYW5pbWF0aW9uIGludG8gbmV3IHBvc2l0aW9uXG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uIChpbmRleCwgb2xkLCBvcGFjaXR5KSB7XG5cdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0YXhpcyA9IHRpY2suYXhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0aG9yaXogPSBheGlzLmhvcml6LFxuXHRcdFx0dHlwZSA9IHRpY2sudHlwZSxcblx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdHBvcyA9IHRpY2sucG9zLFxuXHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRncmlkTGluZSA9IHRpY2suZ3JpZExpbmUsXG5cdFx0XHRncmlkUHJlZml4ID0gdHlwZSA/IHR5cGUgKyAnR3JpZCcgOiAnZ3JpZCcsXG5cdFx0XHR0aWNrUHJlZml4ID0gdHlwZSA/IHR5cGUgKyAnVGljaycgOiAndGljaycsXG5cdFx0XHRncmlkTGluZVdpZHRoID0gb3B0aW9uc1tncmlkUHJlZml4ICsgJ0xpbmVXaWR0aCddLFxuXHRcdFx0Z3JpZExpbmVDb2xvciA9IG9wdGlvbnNbZ3JpZFByZWZpeCArICdMaW5lQ29sb3InXSxcblx0XHRcdGRhc2hTdHlsZSA9IG9wdGlvbnNbZ3JpZFByZWZpeCArICdMaW5lRGFzaFN0eWxlJ10sXG5cdFx0XHR0aWNrTGVuZ3RoID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ0xlbmd0aCddLFxuXHRcdFx0dGlja1dpZHRoID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ1dpZHRoJ10gfHwgMCxcblx0XHRcdHRpY2tDb2xvciA9IG9wdGlvbnNbdGlja1ByZWZpeCArICdDb2xvciddLFxuXHRcdFx0dGlja1Bvc2l0aW9uID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ1Bvc2l0aW9uJ10sXG5cdFx0XHRncmlkTGluZVBhdGgsXG5cdFx0XHRtYXJrID0gdGljay5tYXJrLFxuXHRcdFx0bWFya1BhdGgsXG5cdFx0XHRzdGVwID0gbGFiZWxPcHRpb25zLnN0ZXAsXG5cdFx0XHRhdHRyaWJzLFxuXHRcdFx0c2hvdyA9IHRydWUsXG5cdFx0XHR0aWNrbWFya09mZnNldCA9IGF4aXMudGlja21hcmtPZmZzZXQsXG5cdFx0XHR4eSA9IHRpY2suZ2V0UG9zaXRpb24oaG9yaXosIHBvcywgdGlja21hcmtPZmZzZXQsIG9sZCksXG5cdFx0XHR4ID0geHkueCxcblx0XHRcdHkgPSB4eS55LFxuXHRcdFx0cmV2ZXJzZUNyaXNwID0gKChob3JpeiAmJiB4ID09PSBheGlzLnBvcyArIGF4aXMubGVuKSB8fCAoIWhvcml6ICYmIHkgPT09IGF4aXMucG9zKSkgPyAtMSA6IDEsIC8vICMxNDgwLCAjMTY4N1xuXHRcdFx0c3RhZ2dlckxpbmVzID0gYXhpcy5zdGFnZ2VyTGluZXM7XG5cblx0XHR0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblx0XHRcblx0XHQvLyBjcmVhdGUgdGhlIGdyaWQgbGluZVxuXHRcdGlmIChncmlkTGluZVdpZHRoKSB7XG5cdFx0XHRncmlkTGluZVBhdGggPSBheGlzLmdldFBsb3RMaW5lUGF0aChwb3MgKyB0aWNrbWFya09mZnNldCwgZ3JpZExpbmVXaWR0aCAqIHJldmVyc2VDcmlzcCwgb2xkLCB0cnVlKTtcblxuXHRcdFx0aWYgKGdyaWRMaW5lID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRzdHJva2U6IGdyaWRMaW5lQ29sb3IsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGdyaWRMaW5lV2lkdGhcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gZGFzaFN0eWxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdGF0dHJpYnMuekluZGV4ID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2xkKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5vcGFjaXR5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWNrLmdyaWRMaW5lID0gZ3JpZExpbmUgPVxuXHRcdFx0XHRcdGdyaWRMaW5lV2lkdGggP1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIucGF0aChncmlkTGluZVBhdGgpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZChheGlzLmdyaWRHcm91cCkgOlxuXHRcdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHBhcmFtZXRlciAnb2xkJyBpcyBzZXQsIHRoZSBjdXJyZW50IGNhbGwgd2lsbCBiZSBmb2xsb3dlZFxuXHRcdFx0Ly8gYnkgYW5vdGhlciBjYWxsLCB0aGVyZWZvcmUgZG8gbm90IGRvIGFueSBhbmltYXRpb25zIHRoaXMgdGltZVxuXHRcdFx0aWYgKCFvbGQgJiYgZ3JpZExpbmUgJiYgZ3JpZExpbmVQYXRoKSB7XG5cdFx0XHRcdGdyaWRMaW5lW3RpY2suaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHtcblx0XHRcdFx0XHRkOiBncmlkTGluZVBhdGgsXG5cdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgdGhlIHRpY2sgbWFya1xuXHRcdGlmICh0aWNrV2lkdGggJiYgdGlja0xlbmd0aCkge1xuXG5cdFx0XHQvLyBuZWdhdGUgdGhlIGxlbmd0aFxuXHRcdFx0aWYgKHRpY2tQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcblx0XHRcdFx0dGlja0xlbmd0aCA9IC10aWNrTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGF4aXMub3Bwb3NpdGUpIHtcblx0XHRcdFx0dGlja0xlbmd0aCA9IC10aWNrTGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXJrUGF0aCA9IHRpY2suZ2V0TWFya1BhdGgoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoICogcmV2ZXJzZUNyaXNwLCBob3JpeiwgcmVuZGVyZXIpO1xuXG5cdFx0XHRpZiAobWFyaykgeyAvLyB1cGRhdGluZ1xuXHRcdFx0XHRtYXJrLmFuaW1hdGUoe1xuXHRcdFx0XHRcdGQ6IG1hcmtQYXRoLFxuXHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgeyAvLyBmaXJzdCB0aW1lXG5cdFx0XHRcdHRpY2subWFyayA9IHJlbmRlcmVyLnBhdGgoXG5cdFx0XHRcdFx0bWFya1BhdGhcblx0XHRcdFx0KS5hdHRyKHtcblx0XHRcdFx0XHRzdHJva2U6IHRpY2tDb2xvcixcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogdGlja1dpZHRoLFxuXHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0fSkuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGUgbGFiZWwgaXMgY3JlYXRlZCBvbiBpbml0IC0gbm93IG1vdmUgaXQgaW50byBwbGFjZVxuXHRcdGlmIChsYWJlbCAmJiAhaXNOYU4oeCkpIHtcblx0XHRcdGxhYmVsLnh5ID0geHkgPSB0aWNrLmdldExhYmVsUG9zaXRpb24oeCwgeSwgbGFiZWwsIGhvcml6LCBsYWJlbE9wdGlvbnMsIHRpY2ttYXJrT2Zmc2V0LCBpbmRleCwgc3RlcCk7XG5cblx0XHRcdC8vIEFwcGx5IHNob3cgZmlyc3QgYW5kIHNob3cgbGFzdC4gSWYgdGhlIHRpY2sgaXMgYm90aCBmaXJzdCBhbmQgbGFzdCwgaXQgaXMgXG5cdFx0XHQvLyBhIHNpbmdsZSBjZW50ZXJlZCB0aWNrLCBpbiB3aGljaCBjYXNlIHdlIHNob3cgdGhlIGxhYmVsIGFueXdheSAoIzIxMDApLlxuXHRcdFx0aWYgKCh0aWNrLmlzRmlyc3QgJiYgIXRpY2suaXNMYXN0ICYmICFwaWNrKG9wdGlvbnMuc2hvd0ZpcnN0TGFiZWwsIDEpKSB8fFxuXHRcdFx0XHRcdCh0aWNrLmlzTGFzdCAmJiAhdGljay5pc0ZpcnN0ICYmICFwaWNrKG9wdGlvbnMuc2hvd0xhc3RMYWJlbCwgMSkpKSB7XG5cdFx0XHRcdHNob3cgPSBmYWxzZTtcblxuXHRcdFx0Ly8gSGFuZGxlIGxhYmVsIG92ZXJmbG93IGFuZCBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHlcblx0XHRcdH0gZWxzZSBpZiAoIXN0YWdnZXJMaW5lcyAmJiBob3JpeiAmJiBsYWJlbE9wdGlvbnMub3ZlcmZsb3cgPT09ICdqdXN0aWZ5JyAmJiAhdGljay5oYW5kbGVPdmVyZmxvdyhpbmRleCwgeHkpKSB7XG5cdFx0XHRcdHNob3cgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgc3RlcFxuXHRcdFx0aWYgKHN0ZXAgJiYgaW5kZXggJSBzdGVwKSB7XG5cdFx0XHRcdC8vIHNob3cgdGhvc2UgaW5kaWNlcyBkaXZpZGFibGUgYnkgc3RlcFxuXHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3IHBvc2l0aW9uLCBhbmQgc2hvdyBvciBoaWRlXG5cdFx0XHRpZiAoc2hvdyAmJiAhaXNOYU4oeHkueSkpIHtcblx0XHRcdFx0eHkub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0XHRcdGxhYmVsW3RpY2suaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHh5KTtcblx0XHRcdFx0dGljay5pc05ldyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFiZWwuYXR0cigneScsIC05OTk5KTsgLy8gIzEzMzhcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3RydWN0b3IgZm9yIHRoZSB0aWNrIHByb3RvdHlwZVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogVGhlIG9iamVjdCB3cmFwcGVyIGZvciBwbG90IGxpbmVzIGFuZCBwbG90IGJhbmRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBQbG90TGluZU9yQmFuZChheGlzLCBvcHRpb25zKSB7XG5cdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0aWYgKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHR9XG59XG5cblBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZSA9IHtcblx0XG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIHBsb3QgbGluZSBvciBwbG90IGJhbmQuIElmIGl0IGlzIGFscmVhZHkgZXhpc3RpbmcsXG5cdCAqIG1vdmUgaXQuXG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGxvdExpbmUgPSB0aGlzLFxuXHRcdFx0YXhpcyA9IHBsb3RMaW5lLmF4aXMsXG5cdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRoYWxmUG9pbnRSYW5nZSA9IChheGlzLnBvaW50UmFuZ2UgfHwgMCkgLyAyLFxuXHRcdFx0b3B0aW9ucyA9IHBsb3RMaW5lLm9wdGlvbnMsXG5cdFx0XHRvcHRpb25zTGFiZWwgPSBvcHRpb25zLmxhYmVsLFxuXHRcdFx0bGFiZWwgPSBwbG90TGluZS5sYWJlbCxcblx0XHRcdHdpZHRoID0gb3B0aW9ucy53aWR0aCxcblx0XHRcdHRvID0gb3B0aW9ucy50byxcblx0XHRcdGZyb20gPSBvcHRpb25zLmZyb20sXG5cdFx0XHRpc0JhbmQgPSBkZWZpbmVkKGZyb20pICYmIGRlZmluZWQodG8pLFxuXHRcdFx0dmFsdWUgPSBvcHRpb25zLnZhbHVlLFxuXHRcdFx0ZGFzaFN0eWxlID0gb3B0aW9ucy5kYXNoU3R5bGUsXG5cdFx0XHRzdmdFbGVtID0gcGxvdExpbmUuc3ZnRWxlbSxcblx0XHRcdHBhdGggPSBbXSxcblx0XHRcdGFkZEV2ZW50LFxuXHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0eHMsXG5cdFx0XHR5cyxcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0Y29sb3IgPSBvcHRpb25zLmNvbG9yLFxuXHRcdFx0ekluZGV4ID0gb3B0aW9ucy56SW5kZXgsXG5cdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cyxcblx0XHRcdGF0dHJpYnMsXG5cdFx0XHRyZW5kZXJlciA9IGF4aXMuY2hhcnQucmVuZGVyZXI7XG5cblx0XHQvLyBsb2dhcml0aG1pYyBjb252ZXJzaW9uXG5cdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdGZyb20gPSBsb2cybGluKGZyb20pO1xuXHRcdFx0dG8gPSBsb2cybGluKHRvKTtcblx0XHRcdHZhbHVlID0gbG9nMmxpbih2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gcGxvdCBsaW5lXG5cdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRwYXRoID0gYXhpcy5nZXRQbG90TGluZVBhdGgodmFsdWUsIHdpZHRoKTtcblx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdHN0cm9rZTogY29sb3IsXG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB3aWR0aFxuXHRcdFx0fTtcblx0XHRcdGlmIChkYXNoU3R5bGUpIHtcblx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpc0JhbmQpIHsgLy8gcGxvdCBiYW5kXG5cdFx0XHRcblx0XHRcdC8vIGtlZXAgd2l0aGluIHBsb3QgYXJlYVxuXHRcdFx0ZnJvbSA9IG1hdGhNYXgoZnJvbSwgYXhpcy5taW4gLSBoYWxmUG9pbnRSYW5nZSk7XG5cdFx0XHR0byA9IG1hdGhNaW4odG8sIGF4aXMubWF4ICsgaGFsZlBvaW50UmFuZ2UpO1xuXHRcdFx0XG5cdFx0XHRwYXRoID0gYXhpcy5nZXRQbG90QmFuZFBhdGgoZnJvbSwgdG8sIG9wdGlvbnMpO1xuXHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0ZmlsbDogY29sb3Jcblx0XHRcdH07XG5cdFx0XHRpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuXHRcdFx0XHRhdHRyaWJzLnN0cm9rZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS13aWR0aCddID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyB6SW5kZXhcblx0XHRpZiAoZGVmaW5lZCh6SW5kZXgpKSB7XG5cdFx0XHRhdHRyaWJzLnpJbmRleCA9IHpJbmRleDtcblx0XHR9XG5cblx0XHQvLyBjb21tb24gZm9yIGxpbmVzIGFuZCBiYW5kc1xuXHRcdGlmIChzdmdFbGVtKSB7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRzdmdFbGVtLmFuaW1hdGUoe1xuXHRcdFx0XHRcdGQ6IHBhdGhcblx0XHRcdFx0fSwgbnVsbCwgc3ZnRWxlbS5vbkdldFBhdGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3ZnRWxlbS5oaWRlKCk7XG5cdFx0XHRcdHN2Z0VsZW0ub25HZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHN2Z0VsZW0uc2hvdygpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCkge1xuXHRcdFx0cGxvdExpbmUuc3ZnRWxlbSA9IHN2Z0VsZW0gPSByZW5kZXJlci5wYXRoKHBhdGgpXG5cdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZCgpO1xuXG5cdFx0XHQvLyBldmVudHNcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0YWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cdFx0XHRcdFx0c3ZnRWxlbS5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRldmVudHNbZXZlbnRUeXBlXS5hcHBseShwbG90TGluZSwgW2VdKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQoZXZlbnRUeXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZSBwbG90IGJhbmQvbGluZSBsYWJlbFxuXHRcdGlmIChvcHRpb25zTGFiZWwgJiYgZGVmaW5lZChvcHRpb25zTGFiZWwudGV4dCkgJiYgcGF0aCAmJiBwYXRoLmxlbmd0aCAmJiBheGlzLndpZHRoID4gMCAmJiBheGlzLmhlaWdodCA+IDApIHtcblx0XHRcdC8vIGFwcGx5IGRlZmF1bHRzXG5cdFx0XHRvcHRpb25zTGFiZWwgPSBtZXJnZSh7XG5cdFx0XHRcdGFsaWduOiBob3JpeiAmJiBpc0JhbmQgJiYgJ2NlbnRlcicsXG5cdFx0XHRcdHg6IGhvcml6ID8gIWlzQmFuZCAmJiA0IDogMTAsXG5cdFx0XHRcdHZlcnRpY2FsQWxpZ24gOiAhaG9yaXogJiYgaXNCYW5kICYmICdtaWRkbGUnLFxuXHRcdFx0XHR5OiBob3JpeiA/IGlzQmFuZCA/IDE2IDogMTAgOiBpc0JhbmQgPyA2IDogLTQsXG5cdFx0XHRcdHJvdGF0aW9uOiBob3JpeiAmJiAhaXNCYW5kICYmIDkwXG5cdFx0XHR9LCBvcHRpb25zTGFiZWwpO1xuXG5cdFx0XHQvLyBhZGQgdGhlIFNWRyBlbGVtZW50XG5cdFx0XHRpZiAoIWxhYmVsKSB7XG5cdFx0XHRcdHBsb3RMaW5lLmxhYmVsID0gbGFiZWwgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0b3B0aW9uc0xhYmVsLnRleHQsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdG9wdGlvbnNMYWJlbC51c2VIVE1MXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGFsaWduOiBvcHRpb25zTGFiZWwudGV4dEFsaWduIHx8IG9wdGlvbnNMYWJlbC5hbGlnbixcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBvcHRpb25zTGFiZWwucm90YXRpb24sXG5cdFx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyhvcHRpb25zTGFiZWwuc3R5bGUpXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBhbmQgYWxpZ24gdGhlIGxhYmVsXG5cdFx0XHR4cyA9IFtwYXRoWzFdLCBwYXRoWzRdLCBwaWNrKHBhdGhbNl0sIHBhdGhbMV0pXTtcblx0XHRcdHlzID0gW3BhdGhbMl0sIHBhdGhbNV0sIHBpY2socGF0aFs3XSwgcGF0aFsyXSldO1xuXHRcdFx0eCA9IGFycmF5TWluKHhzKTtcblx0XHRcdHkgPSBhcnJheU1pbih5cyk7XG5cblx0XHRcdGxhYmVsLmFsaWduKG9wdGlvbnNMYWJlbCwgZmFsc2UsIHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeSxcblx0XHRcdFx0d2lkdGg6IGFycmF5TWF4KHhzKSAtIHgsXG5cdFx0XHRcdGhlaWdodDogYXJyYXlNYXgoeXMpIC0geVxuXHRcdFx0fSk7XG5cdFx0XHRsYWJlbC5zaG93KCk7XG5cblx0XHR9IGVsc2UgaWYgKGxhYmVsKSB7IC8vIG1vdmUgb3V0IG9mIHNpZ2h0XG5cdFx0XHRsYWJlbC5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hhaW5hYmxlXG5cdFx0cmV0dXJuIHBsb3RMaW5lO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIHBsb3QgbGluZSBvciBiYW5kXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcmVtb3ZlIGl0IGZyb20gdGhlIGxvb2t1cFxuXHRcdGVyYXNlKHRoaXMuYXhpcy5wbG90TGluZXNBbmRCYW5kcywgdGhpcyk7XG5cdFx0XG5cdFx0ZGVsZXRlIHRoaXMuYXhpcztcblx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyh0aGlzKTtcblx0fVxufTtcbi8qKlxuICogVGhlIGNsYXNzIGZvciBzdGFjayBpdGVtc1xuICovXG5mdW5jdGlvbiBTdGFja0l0ZW0oYXhpcywgb3B0aW9ucywgaXNOZWdhdGl2ZSwgeCwgc3RhY2tPcHRpb24sIHN0YWNraW5nKSB7XG5cdFxuXHR2YXIgaW52ZXJ0ZWQgPSBheGlzLmNoYXJ0LmludmVydGVkO1xuXG5cdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0Ly8gVGVsbHMgaWYgdGhlIHN0YWNrIGlzIG5lZ2F0aXZlXG5cdHRoaXMuaXNOZWdhdGl2ZSA9IGlzTmVnYXRpdmU7XG5cblx0Ly8gU2F2ZSB0aGUgb3B0aW9ucyB0byBiZSBhYmxlIHRvIHN0eWxlIHRoZSBsYWJlbFxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdC8vIFNhdmUgdGhlIHggdmFsdWUgdG8gYmUgYWJsZSB0byBwb3NpdGlvbiB0aGUgbGFiZWwgbGF0ZXJcblx0dGhpcy54ID0geDtcblxuXHQvLyBJbml0aWFsaXplIHRvdGFsIHZhbHVlXG5cdHRoaXMudG90YWwgPSBudWxsO1xuXG5cdC8vIFRoaXMgd2lsbCBrZWVwIGVhY2ggcG9pbnRzJyBleHRyZW1lcyBzdG9yZWQgYnkgc2VyaWVzLmluZGV4XG5cdHRoaXMucG9pbnRzID0ge307XG5cblx0Ly8gU2F2ZSB0aGUgc3RhY2sgb3B0aW9uIG9uIHRoZSBzZXJpZXMgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCB3aGV0aGVyIHRvIHRyZWF0IGl0IGFzIHBlcmNlbnRcblx0dGhpcy5zdGFjayA9IHN0YWNrT3B0aW9uO1xuXHR0aGlzLnBlcmNlbnQgPSBzdGFja2luZyA9PT0gJ3BlcmNlbnQnO1xuXG5cdC8vIFRoZSBhbGlnbiBvcHRpb25zIGFuZCB0ZXh0IGFsaWduIHZhcmllcyBvbiB3aGV0aGVyIHRoZSBzdGFjayBpcyBuZWdhdGl2ZSBhbmRcblx0Ly8gaWYgdGhlIGNoYXJ0IGlzIGludmVydGVkIG9yIG5vdC5cblx0Ly8gRmlyc3QgdGVzdCB0aGUgdXNlciBzdXBwbGllZCB2YWx1ZSwgdGhlbiB1c2UgdGhlIGR5bmFtaWMuXG5cdHRoaXMuYWxpZ25PcHRpb25zID0ge1xuXHRcdGFsaWduOiBvcHRpb25zLmFsaWduIHx8IChpbnZlcnRlZCA/IChpc05lZ2F0aXZlID8gJ2xlZnQnIDogJ3JpZ2h0JykgOiAnY2VudGVyJyksXG5cdFx0dmVydGljYWxBbGlnbjogb3B0aW9ucy52ZXJ0aWNhbEFsaWduIHx8IChpbnZlcnRlZCA/ICdtaWRkbGUnIDogKGlzTmVnYXRpdmUgPyAnYm90dG9tJyA6ICd0b3AnKSksXG5cdFx0eTogcGljayhvcHRpb25zLnksIGludmVydGVkID8gNCA6IChpc05lZ2F0aXZlID8gMTQgOiAtNikpLFxuXHRcdHg6IHBpY2sob3B0aW9ucy54LCBpbnZlcnRlZCA/IChpc05lZ2F0aXZlID8gLTYgOiA2KSA6IDApXG5cdH07XG5cblx0dGhpcy50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbiB8fCAoaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/ICdyaWdodCcgOiAnbGVmdCcpIDogJ2NlbnRlcicpO1xufVxuXG5TdGFja0l0ZW0ucHJvdG90eXBlID0ge1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXModGhpcywgdGhpcy5heGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgc3RhY2sgdG90YWwgbGFiZWwgYW5kIGFkZHMgaXQgdG8gdGhlIHN0YWNrIGxhYmVsIGdyb3VwLlxuXHQgKi9cblx0cmVuZGVyOiBmdW5jdGlvbiAoZ3JvdXApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGZvcm1hdE9wdGlvbiA9IG9wdGlvbnMuZm9ybWF0LFxuXHRcdFx0c3RyID0gZm9ybWF0T3B0aW9uID9cblx0XHRcdFx0Zm9ybWF0KGZvcm1hdE9wdGlvbiwgdGhpcykgOiBcblx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIuY2FsbCh0aGlzKTsgIC8vIGZvcm1hdCB0aGUgdGV4dCBpbiB0aGUgbGFiZWxcblxuXHRcdC8vIENoYW5nZSB0aGUgdGV4dCB0byByZWZsZWN0IHRoZSBuZXcgdG90YWwgYW5kIHNldCB2aXNpYmlsaXR5IHRvIGhpZGRlbiBpbiBjYXNlIHRoZSBzZXJpZSBpcyBoaWRkZW5cblx0XHRpZiAodGhpcy5sYWJlbCkge1xuXHRcdFx0dGhpcy5sYWJlbC5hdHRyKHt0ZXh0OiBzdHIsIHZpc2liaWxpdHk6IEhJRERFTn0pO1xuXHRcdC8vIENyZWF0ZSBuZXcgbGFiZWxcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sYWJlbCA9XG5cdFx0XHRcdHRoaXMuYXhpcy5jaGFydC5yZW5kZXJlci50ZXh0KHN0ciwgMCwgMCwgb3B0aW9ucy51c2VIVE1MKVx0XHQvLyBkdW1teSBwb3NpdGlvbnMsIGFjdHVhbCBwb3NpdGlvbiB1cGRhdGVkIHdpdGggc2V0T2Zmc2V0IG1ldGhvZCBpbiBjb2x1bW5zZXJpZXNcblx0XHRcdFx0XHQuY3NzKG9wdGlvbnMuc3R5bGUpXHRcdFx0XHQvLyBhcHBseSBzdHlsZVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGFsaWduOiB0aGlzLnRleHRBbGlnbixcdFx0XHRcdC8vIGZpeCB0aGUgdGV4dC1hbmNob3Jcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFx0Ly8gcm90YXRpb25cblx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IEhJRERFTlx0XHRcdFx0XHQvLyBoaWRkZW4gdW50aWwgc2V0T2Zmc2V0IGlzIGNhbGxlZFxuXHRcdFx0XHRcdH0pXHRcdFx0XHRcblx0XHRcdFx0XHQuYWRkKGdyb3VwKTtcdFx0XHRcdFx0XHRcdC8vIGFkZCB0byB0aGUgbGFiZWxzLWdyb3VwXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBvZmZzZXQgdGhhdCB0aGUgc3RhY2sgaGFzIGZyb20gdGhlIHggdmFsdWUgYW5kIHJlcG9zaXRpb25zIHRoZSBsYWJlbC5cblx0ICovXG5cdHNldE9mZnNldDogZnVuY3Rpb24gKHhPZmZzZXQsIHhXaWR0aCkge1xuXHRcdHZhciBzdGFja0l0ZW0gPSB0aGlzLFxuXHRcdFx0YXhpcyA9IHN0YWNrSXRlbS5heGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdG5lZyA9IHRoaXMuaXNOZWdhdGl2ZSxcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgdHJlYXRtZW50IGlzIG5lZWRlZCBmb3IgbmVnYXRpdmUgc3RhY2tzXG5cdFx0XHR5ID0gYXhpcy50cmFuc2xhdGUodGhpcy5wZXJjZW50ID8gMTAwIDogdGhpcy50b3RhbCwgMCwgMCwgMCwgMSksIC8vIHN0YWNrIHZhbHVlIHRyYW5zbGF0ZWQgbWFwcGVkIHRvIGNoYXJ0IGNvb3JkaW5hdGVzXG5cdFx0XHR5WmVybyA9IGF4aXMudHJhbnNsYXRlKDApLFx0XHRcdFx0XHRcdC8vIHN0YWNrIG9yaWdpblxuXHRcdFx0aCA9IG1hdGhBYnMoeSAtIHlaZXJvKSxcdFx0XHRcdFx0XHRcdC8vIHN0YWNrIGhlaWdodFxuXHRcdFx0eCA9IGNoYXJ0LnhBeGlzWzBdLnRyYW5zbGF0ZSh0aGlzLngpICsgeE9mZnNldCxcdC8vIHN0YWNrIHggcG9zaXRpb25cblx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0c3RhY2tCb3ggPSB7XHQvLyB0aGlzIGlzIHRoZSBib3ggZm9yIHRoZSBjb21wbGV0ZSBzdGFja1xuXHRcdFx0XHR4OiBpbnZlcnRlZCA/IChuZWcgPyB5IDogeSAtIGgpIDogeCxcblx0XHRcdFx0eTogaW52ZXJ0ZWQgPyBwbG90SGVpZ2h0IC0geCAtIHhXaWR0aCA6IChuZWcgPyAocGxvdEhlaWdodCAtIHkgLSBoKSA6IHBsb3RIZWlnaHQgLSB5KSxcblx0XHRcdFx0d2lkdGg6IGludmVydGVkID8gaCA6IHhXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBpbnZlcnRlZCA/IHhXaWR0aCA6IGhcblx0XHRcdH0sXG5cdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsXG5cdFx0XHRhbGlnbkF0dHI7XG5cdFx0XG5cdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRsYWJlbC5hbGlnbih0aGlzLmFsaWduT3B0aW9ucywgbnVsbCwgc3RhY2tCb3gpO1x0Ly8gYWxpZ24gdGhlIGxhYmVsIHRvIHRoZSBib3hcblx0XHRcdFx0XG5cdFx0XHQvLyBTZXQgdmlzaWJpbGl0eSAoIzY3OClcblx0XHRcdGFsaWduQXR0ciA9IGxhYmVsLmFsaWduQXR0cjtcblx0XHRcdGxhYmVsLmF0dHIoeyBcblx0XHRcdFx0dmlzaWJpbGl0eTogdGhpcy5vcHRpb25zLmNyb3AgPT09IGZhbHNlIHx8IGNoYXJ0LmlzSW5zaWRlUGxvdChhbGlnbkF0dHIueCwgYWxpZ25BdHRyLnkpID8gXG5cdFx0XHRcdFx0KGhhc1NWRyA/ICdpbmhlcml0JyA6IFZJU0lCTEUpIDogXG5cdFx0XHRcdFx0SElEREVOXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBheGlzIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBBeGlzKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuQXhpcy5wcm90b3R5cGUgPSB7XG5cdFxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgWCBheGlzIC0gdGhlIFkgYXhpcyBoYXMgZXh0ZW5kZWQgZGVmYXVsdHMgXG5cdCAqL1xuXHRkZWZhdWx0T3B0aW9uczoge1xuXHRcdC8vIGFsbG93RGVjaW1hbHM6IG51bGwsXG5cdFx0Ly8gYWx0ZXJuYXRlR3JpZENvbG9yOiBudWxsLFxuXHRcdC8vIGNhdGVnb3JpZXM6IFtdLFxuXHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7XG5cdFx0XHRtaWxsaXNlY29uZDogJyVIOiVNOiVTLiVMJyxcblx0XHRcdHNlY29uZDogJyVIOiVNOiVTJyxcblx0XHRcdG1pbnV0ZTogJyVIOiVNJyxcblx0XHRcdGhvdXI6ICclSDolTScsXG5cdFx0XHRkYXk6ICclZS4gJWInLFxuXHRcdFx0d2VlazogJyVlLiAlYicsXG5cdFx0XHRtb250aDogJyViIFxcJyV5Jyxcblx0XHRcdHllYXI6ICclWSdcblx0XHR9LFxuXHRcdGVuZE9uVGljazogZmFsc2UsXG5cdFx0Z3JpZExpbmVDb2xvcjogJyNDMEMwQzAnLFxuXHRcdC8vIGdyaWRMaW5lRGFzaFN0eWxlOiAnc29saWQnLFxuXHRcdC8vIGdyaWRMaW5lV2lkdGg6IDAsXG5cdFx0Ly8gcmV2ZXJzZWQ6IGZhbHNlLFxuXHRcblx0XHRsYWJlbHM6IGRlZmF1bHRMYWJlbE9wdGlvbnMsXG5cdFx0XHQvLyB7IHN0ZXA6IG51bGwgfSxcblx0XHRsaW5lQ29sb3I6ICcjQzBEMEUwJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0Ly9saW5rZWRUbzogbnVsbCxcblx0XHQvL21heDogdW5kZWZpbmVkLFxuXHRcdC8vbWluOiB1bmRlZmluZWQsXG5cdFx0bWluUGFkZGluZzogMC4wMSxcblx0XHRtYXhQYWRkaW5nOiAwLjAxLFxuXHRcdC8vbWluUmFuZ2U6IG51bGwsXG5cdFx0bWlub3JHcmlkTGluZUNvbG9yOiAnI0UwRTBFMCcsXG5cdFx0Ly8gbWlub3JHcmlkTGluZURhc2hTdHlsZTogbnVsbCxcblx0XHRtaW5vckdyaWRMaW5lV2lkdGg6IDEsXG5cdFx0bWlub3JUaWNrQ29sb3I6ICcjQTBBMEEwJyxcblx0XHQvL21pbm9yVGlja0ludGVydmFsOiBudWxsLFxuXHRcdG1pbm9yVGlja0xlbmd0aDogMixcblx0XHRtaW5vclRpY2tQb3NpdGlvbjogJ291dHNpZGUnLCAvLyBpbnNpZGUgb3Igb3V0c2lkZVxuXHRcdC8vbWlub3JUaWNrV2lkdGg6IDAsXG5cdFx0Ly9vcHBvc2l0ZTogZmFsc2UsXG5cdFx0Ly9vZmZzZXQ6IDAsXG5cdFx0Ly9wbG90QmFuZHM6IFt7XG5cdFx0Ly9cdGV2ZW50czoge30sXG5cdFx0Ly9cdHpJbmRleDogMSxcblx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0Ly99XSxcblx0XHQvL3Bsb3RMaW5lczogW3tcblx0XHQvL1x0ZXZlbnRzOiB7fVxuXHRcdC8vICBkYXNoU3R5bGU6IHt9XG5cdFx0Ly9cdHpJbmRleDpcblx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0Ly99XSxcblx0XHQvL3JldmVyc2VkOiBmYWxzZSxcblx0XHQvLyBzaG93Rmlyc3RMYWJlbDogdHJ1ZSxcblx0XHQvLyBzaG93TGFzdExhYmVsOiB0cnVlLFxuXHRcdHN0YXJ0T2ZXZWVrOiAxLFxuXHRcdHN0YXJ0T25UaWNrOiBmYWxzZSxcblx0XHR0aWNrQ29sb3I6ICcjQzBEMEUwJyxcblx0XHQvL3RpY2tJbnRlcnZhbDogbnVsbCxcblx0XHR0aWNrTGVuZ3RoOiA1LFxuXHRcdHRpY2ttYXJrUGxhY2VtZW50OiAnYmV0d2VlbicsIC8vIG9uIG9yIGJldHdlZW5cblx0XHR0aWNrUGl4ZWxJbnRlcnZhbDogMTAwLFxuXHRcdHRpY2tQb3NpdGlvbjogJ291dHNpZGUnLFxuXHRcdHRpY2tXaWR0aDogMSxcblx0XHR0aXRsZToge1xuXHRcdFx0Ly90ZXh0OiBudWxsLFxuXHRcdFx0YWxpZ246ICdtaWRkbGUnLCAvLyBsb3csIG1pZGRsZSBvciBoaWdoXG5cdFx0XHQvL21hcmdpbjogMCBmb3IgaG9yaXpvbnRhbCwgMTAgZm9yIHZlcnRpY2FsIGF4ZXMsXG5cdFx0XHQvL3JvdGF0aW9uOiAwLFxuXHRcdFx0Ly9zaWRlOiAnb3V0c2lkZScsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyM0ZDc1OWUnLFxuXHRcdFx0XHQvL2ZvbnQ6IGRlZmF1bHRGb250LnJlcGxhY2UoJ25vcm1hbCcsICdib2xkJylcblx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnXG5cdFx0XHR9XG5cdFx0XHQvL3g6IDAsXG5cdFx0XHQvL3k6IDBcblx0XHR9LFxuXHRcdHR5cGU6ICdsaW5lYXInIC8vIGxpbmVhciwgbG9nYXJpdGhtaWMgb3IgZGF0ZXRpbWVcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBUaGlzIG9wdGlvbnMgc2V0IGV4dGVuZHMgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBZIGF4ZXNcblx0ICovXG5cdGRlZmF1bHRZQXhpc09wdGlvbnM6IHtcblx0XHRlbmRPblRpY2s6IHRydWUsXG5cdFx0Z3JpZExpbmVXaWR0aDogMSxcblx0XHR0aWNrUGl4ZWxJbnRlcnZhbDogNzIsXG5cdFx0c2hvd0xhc3RMYWJlbDogdHJ1ZSxcblx0XHRsYWJlbHM6IHtcblx0XHRcdHg6IC04LFxuXHRcdFx0eTogM1xuXHRcdH0sXG5cdFx0bGluZVdpZHRoOiAwLFxuXHRcdG1heFBhZGRpbmc6IDAuMDUsXG5cdFx0bWluUGFkZGluZzogMC4wNSxcblx0XHRzdGFydE9uVGljazogdHJ1ZSxcblx0XHR0aWNrV2lkdGg6IDAsXG5cdFx0dGl0bGU6IHtcblx0XHRcdHJvdGF0aW9uOiAyNzAsXG5cdFx0XHR0ZXh0OiAnVmFsdWVzJ1xuXHRcdH0sXG5cdFx0c3RhY2tMYWJlbHM6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0Ly9hbGlnbjogZHluYW1pYyxcblx0XHRcdC8veTogZHluYW1pYyxcblx0XHRcdC8veDogZHluYW1pYyxcblx0XHRcdC8vdmVydGljYWxBbGlnbjogZHluYW1pYyxcblx0XHRcdC8vdGV4dEFsaWduOiBkeW5hbWljLFxuXHRcdFx0Ly9yb3RhdGlvbjogMCxcblx0XHRcdGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbnVtYmVyRm9ybWF0KHRoaXMudG90YWwsIC0xKTtcblx0XHRcdH0sXG5cdFx0XHRzdHlsZTogZGVmYXVsdExhYmVsT3B0aW9ucy5zdHlsZVxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIGxlZnQgYXhlc1xuXHQgKi9cblx0ZGVmYXVsdExlZnRBeGlzT3B0aW9uczoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0eDogLTgsXG5cdFx0XHR5OiBudWxsXG5cdFx0fSxcblx0XHR0aXRsZToge1xuXHRcdFx0cm90YXRpb246IDI3MFxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIHJpZ2h0IGF4ZXNcblx0ICovXG5cdGRlZmF1bHRSaWdodEF4aXNPcHRpb25zOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHR4OiA4LFxuXHRcdFx0eTogbnVsbFxuXHRcdH0sXG5cdFx0dGl0bGU6IHtcblx0XHRcdHJvdGF0aW9uOiA5MFxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIGJvdHRvbSBheGVzXG5cdCAqL1xuXHRkZWZhdWx0Qm90dG9tQXhpc09wdGlvbnM6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiAxNFxuXHRcdFx0Ly8gb3ZlcmZsb3c6IHVuZGVmaW5lZCxcblx0XHRcdC8vIHN0YWdnZXJMaW5lczogbnVsbFxuXHRcdH0sXG5cdFx0dGl0bGU6IHtcblx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBsZWZ0IGF4ZXNcblx0ICovXG5cdGRlZmF1bHRUb3BBeGlzT3B0aW9uczoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0eDogMCxcblx0XHRcdHk6IC01XG5cdFx0XHQvLyBvdmVyZmxvdzogdW5kZWZpbmVkXG5cdFx0XHQvLyBzdGFnZ2VyTGluZXM6IG51bGxcblx0XHR9LFxuXHRcdHRpdGxlOiB7XG5cdFx0XHRyb3RhdGlvbjogMFxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBheGlzXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIHVzZXJPcHRpb25zKSB7XG5cdFx0XHRcblx0XHRcblx0XHR2YXIgaXNYQXhpcyA9IHVzZXJPcHRpb25zLmlzWCxcblx0XHRcdGF4aXMgPSB0aGlzO1xuXHRcblx0XHQvLyBGbGFnLCBpcyB0aGUgYXhpcyBob3Jpem9udGFsXG5cdFx0YXhpcy5ob3JpeiA9IGNoYXJ0LmludmVydGVkID8gIWlzWEF4aXMgOiBpc1hBeGlzO1xuXHRcdFxuXHRcdC8vIEZsYWcsIGlzWEF4aXNcblx0XHRheGlzLmlzWEF4aXMgPSBpc1hBeGlzO1xuXHRcdGF4aXMueE9yWSA9IGlzWEF4aXMgPyAneCcgOiAneSc7XG5cdFxuXHRcblx0XHRheGlzLm9wcG9zaXRlID0gdXNlck9wdGlvbnMub3Bwb3NpdGU7IC8vIG5lZWRlZCBpbiBzZXRPcHRpb25zXG5cdFx0YXhpcy5zaWRlID0gYXhpcy5ob3JpeiA/XG5cdFx0XHRcdChheGlzLm9wcG9zaXRlID8gMCA6IDIpIDogLy8gdG9wIDogYm90dG9tXG5cdFx0XHRcdChheGlzLm9wcG9zaXRlID8gMSA6IDMpOyAgLy8gcmlnaHQgOiBsZWZ0XG5cdFxuXHRcdGF4aXMuc2V0T3B0aW9ucyh1c2VyT3B0aW9ucyk7XG5cdFx0XG5cdFxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dHlwZSA9IG9wdGlvbnMudHlwZSxcblx0XHRcdGlzRGF0ZXRpbWVBeGlzID0gdHlwZSA9PT0gJ2RhdGV0aW1lJztcblx0XG5cdFx0YXhpcy5sYWJlbEZvcm1hdHRlciA9IG9wdGlvbnMubGFiZWxzLmZvcm1hdHRlciB8fCBheGlzLmRlZmF1bHRMYWJlbEZvcm1hdHRlcjsgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGR5bmFtaWMgZm9ybWF0XG5cdFxuXHRcblx0XHQvLyBGbGFnLCBzdGFnZ2VyIGxpbmVzIG9yIG5vdFxuXHRcdGF4aXMudXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucztcblx0XG5cdFx0Ly9heGlzLmF4aXNUaXRsZU1hcmdpbiA9IFVOREVGSU5FRCwvLyA9IG9wdGlvbnMudGl0bGUubWFyZ2luLFxuXHRcdGF4aXMubWluUGl4ZWxQYWRkaW5nID0gMDtcblx0XHQvL2F4aXMuaWdub3JlTWluUGFkZGluZyA9IFVOREVGSU5FRDsgLy8gY2FuIGJlIHNldCB0byB0cnVlIGJ5IGEgY29sdW1uIG9yIGJhciBzZXJpZXNcblx0XHQvL2F4aXMuaWdub3JlTWF4UGFkZGluZyA9IFVOREVGSU5FRDtcblx0XG5cdFx0YXhpcy5jaGFydCA9IGNoYXJ0O1xuXHRcdGF4aXMucmV2ZXJzZWQgPSBvcHRpb25zLnJldmVyc2VkO1xuXHRcdGF4aXMuem9vbUVuYWJsZWQgPSBvcHRpb25zLnpvb21FbmFibGVkICE9PSBmYWxzZTtcblx0XG5cdFx0Ly8gSW5pdGlhbCBjYXRlZ29yaWVzXG5cdFx0YXhpcy5jYXRlZ29yaWVzID0gb3B0aW9ucy5jYXRlZ29yaWVzIHx8IHR5cGUgPT09ICdjYXRlZ29yeSc7XG5cdFxuXHRcdC8vIEVsZW1lbnRzXG5cdFx0Ly9heGlzLmF4aXNHcm91cCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMuZ3JpZEdyb3VwID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5heGlzVGl0bGUgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLmF4aXNMaW5lID0gVU5ERUZJTkVEO1xuXHRcblx0XHQvLyBTaG9ydGhhbmQgdHlwZXNcblx0XHRheGlzLmlzTG9nID0gdHlwZSA9PT0gJ2xvZ2FyaXRobWljJztcblx0XHRheGlzLmlzRGF0ZXRpbWVBeGlzID0gaXNEYXRldGltZUF4aXM7XG5cdFxuXHRcdC8vIEZsYWcsIGlmIGF4aXMgaXMgbGlua2VkIHRvIGFub3RoZXIgYXhpc1xuXHRcdGF4aXMuaXNMaW5rZWQgPSBkZWZpbmVkKG9wdGlvbnMubGlua2VkVG8pO1xuXHRcdC8vIExpbmtlZCBheGlzLlxuXHRcdC8vYXhpcy5saW5rZWRQYXJlbnQgPSBVTkRFRklORUQ7XHRcblx0XHRcblx0XHQvLyBUaWNrIHBvc2l0aW9uc1xuXHRcdC8vYXhpcy50aWNrUG9zaXRpb25zID0gVU5ERUZJTkVEOyAvLyBhcnJheSBjb250YWluaW5nIHByZWRlZmluZWQgcG9zaXRpb25zXG5cdFx0Ly8gVGljayBpbnRlcnZhbHNcblx0XHQvL2F4aXMudGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5taW5vclRpY2tJbnRlcnZhbCA9IFVOREVGSU5FRDtcblx0XHRcblx0XHRheGlzLnRpY2ttYXJrT2Zmc2V0ID0gKGF4aXMuY2F0ZWdvcmllcyAmJiBvcHRpb25zLnRpY2ttYXJrUGxhY2VtZW50ID09PSAnYmV0d2VlbicpID8gMC41IDogMDtcblx0XG5cdFx0Ly8gTWFqb3IgdGlja3Ncblx0XHRheGlzLnRpY2tzID0ge307XG5cdFx0Ly8gTWlub3IgdGlja3Ncblx0XHRheGlzLm1pbm9yVGlja3MgPSB7fTtcblx0XHQvL2F4aXMudGlja0Ftb3VudCA9IFVOREVGSU5FRDtcblx0XG5cdFx0Ly8gTGlzdCBvZiBwbG90TGluZXMvQmFuZHNcblx0XHRheGlzLnBsb3RMaW5lc0FuZEJhbmRzID0gW107XG5cdFxuXHRcdC8vIEFsdGVybmF0ZSBiYW5kc1xuXHRcdGF4aXMuYWx0ZXJuYXRlQmFuZHMgPSB7fTtcblx0XG5cdFx0Ly8gQXhpcyBtZXRyaWNzXG5cdFx0Ly9heGlzLmxlZnQgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLnRvcCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMud2lkdGggPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLmhlaWdodCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMuYm90dG9tID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5yaWdodCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMudHJhbnNBID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy50cmFuc0IgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLm9sZFRyYW5zQSA9IFVOREVGSU5FRDtcblx0XHRheGlzLmxlbiA9IDA7XG5cdFx0Ly9heGlzLm9sZE1pbiA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMub2xkTWF4ID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRVc2VyTWluID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRVc2VyTWF4ID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRBeGlzTGVuZ3RoID0gVU5ERUZJTkVEO1xuXHRcdGF4aXMubWluUmFuZ2UgPSBheGlzLnVzZXJNaW5SYW5nZSA9IG9wdGlvbnMubWluUmFuZ2UgfHwgb3B0aW9ucy5tYXhab29tO1xuXHRcdGF4aXMucmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xuXHRcdGF4aXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcblx0XG5cdFxuXHRcdC8vIERpY3Rpb25hcnkgZm9yIHN0YWNrc1xuXHRcdGF4aXMuc3RhY2tzID0ge307XG5cdFx0YXhpcy5vbGRTdGFja3MgPSB7fTtcblxuXHRcdC8vIERpY3Rpb25hcnkgZm9yIHN0YWNrcyBtYXggdmFsdWVzXG5cdFx0YXhpcy5zdGFja0V4dHJlbWVzID0ge307XG5cblx0XHQvLyBNaW4gYW5kIG1heCBpbiB0aGUgZGF0YVxuXHRcdC8vYXhpcy5kYXRhTWluID0gVU5ERUZJTkVELFxuXHRcdC8vYXhpcy5kYXRhTWF4ID0gVU5ERUZJTkVELFxuXHRcblx0XHQvLyBUaGUgYXhpcyByYW5nZVxuXHRcdGF4aXMubWF4ID0gbnVsbDtcblx0XHRheGlzLm1pbiA9IG51bGw7XG5cdFxuXHRcdC8vIFVzZXIgc2V0IG1pbiBhbmQgbWF4XG5cdFx0Ly9heGlzLnVzZXJNaW4gPSBVTkRFRklORUQsXG5cdFx0Ly9heGlzLnVzZXJNYXggPSBVTkRFRklORUQsXG5cblx0XHQvLyBSdW4gQXhpc1xuXHRcdFxuXHRcdHZhciBldmVudFR5cGUsXG5cdFx0XHRldmVudHMgPSBheGlzLm9wdGlvbnMuZXZlbnRzO1xuXG5cdFx0Ly8gUmVnaXN0ZXJcblx0XHRpZiAoaW5BcnJheShheGlzLCBjaGFydC5heGVzKSA9PT0gLTEpIHsgLy8gZG9uJ3QgYWRkIGl0IGFnYWluIG9uIEF4aXMudXBkYXRlKClcblx0XHRcdGNoYXJ0LmF4ZXMucHVzaChheGlzKTtcblx0XHRcdGNoYXJ0W2lzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ10ucHVzaChheGlzKTtcblx0XHR9XG5cblx0XHRheGlzLnNlcmllcyA9IGF4aXMuc2VyaWVzIHx8IFtdOyAvLyBwb3B1bGF0ZWQgYnkgU2VyaWVzXG5cblx0XHQvLyBpbnZlcnRlZCBjaGFydHMgaGF2ZSByZXZlcnNlZCB4QXhlcyBhcyBkZWZhdWx0XG5cdFx0aWYgKGNoYXJ0LmludmVydGVkICYmIGlzWEF4aXMgJiYgYXhpcy5yZXZlcnNlZCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRheGlzLnJldmVyc2VkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRheGlzLnJlbW92ZVBsb3RCYW5kID0gYXhpcy5yZW1vdmVQbG90QmFuZE9yTGluZTtcblx0XHRheGlzLnJlbW92ZVBsb3RMaW5lID0gYXhpcy5yZW1vdmVQbG90QmFuZE9yTGluZTtcblxuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRhZGRFdmVudChheGlzLCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHR9XG5cblx0XHQvLyBleHRlbmQgbG9nYXJpdGhtaWMgYXhpc1xuXHRcdGlmIChheGlzLmlzTG9nKSB7XG5cdFx0XHRheGlzLnZhbDJsaW4gPSBsb2cybGluO1xuXHRcdFx0YXhpcy5saW4ydmFsID0gbGluMmxvZztcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0ICogTWVyZ2UgYW5kIHNldCBvcHRpb25zXG5cdCAqL1xuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAodXNlck9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBtZXJnZShcblx0XHRcdHRoaXMuZGVmYXVsdE9wdGlvbnMsXG5cdFx0XHR0aGlzLmlzWEF4aXMgPyB7fSA6IHRoaXMuZGVmYXVsdFlBeGlzT3B0aW9ucyxcblx0XHRcdFt0aGlzLmRlZmF1bHRUb3BBeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucyxcblx0XHRcdFx0dGhpcy5kZWZhdWx0Qm90dG9tQXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdExlZnRBeGlzT3B0aW9uc11bdGhpcy5zaWRlXSxcblx0XHRcdG1lcmdlKFxuXHRcdFx0XHRkZWZhdWx0T3B0aW9uc1t0aGlzLmlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ10sIC8vIGlmIHNldCBpbiBzZXRPcHRpb25zICgjMTA1Mylcblx0XHRcdFx0dXNlck9wdGlvbnNcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGF4aXMgd2l0aCBhIG5ldyBvcHRpb25zIHN0cnVjdHVyZVxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAobmV3T3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zW3RoaXMueE9yWSArICdBeGlzJ11bdGhpcy5vcHRpb25zLmluZGV4XSA9IG1lcmdlKHRoaXMudXNlck9wdGlvbnMsIG5ld09wdGlvbnMpO1xuXG5cdFx0dGhpcy5kZXN0cm95KHRydWUpO1xuXHRcdHRoaXMuX2FkZGVkUGxvdExCID0gdGhpcy51c2VyTWluID0gdGhpcy51c2VyTWF4ID0gVU5ERUZJTkVEOyAvLyAjMTYxMSwgIzIzMDZcblxuXHRcdHRoaXMuaW5pdChjaGFydCwgZXh0ZW5kKG5ld09wdGlvbnMsIHsgZXZlbnRzOiBVTkRFRklORUQgfSkpO1xuXG5cdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0fVxuXHR9LFx0XG5cdFxuXHQvKipcbiAgICAgKiBSZW1vdmUgdGhlIGF4aXMgZnJvbSB0aGUgY2hhcnRcbiAgICAgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGtleSA9IHRoaXMueE9yWSArICdBeGlzJzsgLy8geEF4aXMgb3IgeUF4aXNcblxuXHRcdC8vIFJlbW92ZSBhc3NvY2lhdGVkIHNlcmllc1xuXHRcdGVhY2godGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdHNlcmllcy5yZW1vdmUoZmFsc2UpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBheGlzXG5cdFx0ZXJhc2UoY2hhcnQuYXhlcywgdGhpcyk7XG5cdFx0ZXJhc2UoY2hhcnRba2V5XSwgdGhpcyk7XG5cdFx0Y2hhcnQub3B0aW9uc1trZXldLnNwbGljZSh0aGlzLm9wdGlvbnMuaW5kZXgsIDEpO1xuXHRcdGVhY2goY2hhcnRba2V5XSwgZnVuY3Rpb24gKGF4aXMsIGkpIHsgLy8gUmUtaW5kZXgsICMxNzA2XG5cdFx0XHRheGlzLm9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdH0pO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXG5cdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqIFxuXHQgKiBUaGUgZGVmYXVsdCBsYWJlbCBmb3JtYXR0ZXIuIFRoZSBjb250ZXh0IGlzIGEgc3BlY2lhbCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGFiZWwuXG5cdCAqL1xuXHRkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdGNhdGVnb3JpZXMgPSBheGlzLmNhdGVnb3JpZXMsIFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IHRoaXMuZGF0ZVRpbWVMYWJlbEZvcm1hdCxcblx0XHRcdG51bWVyaWNTeW1ib2xzID0gZGVmYXVsdE9wdGlvbnMubGFuZy5udW1lcmljU3ltYm9scyxcblx0XHRcdGkgPSBudW1lcmljU3ltYm9scyAmJiBudW1lcmljU3ltYm9scy5sZW5ndGgsXG5cdFx0XHRtdWx0aSxcblx0XHRcdHJldCxcblx0XHRcdGZvcm1hdE9wdGlvbiA9IGF4aXMub3B0aW9ucy5sYWJlbHMuZm9ybWF0LFxuXHRcdFx0XG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHNhbWUgc3ltYm9sIGlzIGFkZGVkIGZvciBhbGwgbGFiZWxzIG9uIGEgbGluZWFyIGF4aXNcblx0XHRcdG51bWVyaWNTeW1ib2xEZXRlY3RvciA9IGF4aXMuaXNMb2cgPyB2YWx1ZSA6IGF4aXMudGlja0ludGVydmFsO1xuXG5cdFx0aWYgKGZvcm1hdE9wdGlvbikge1xuXHRcdFx0cmV0ID0gZm9ybWF0KGZvcm1hdE9wdGlvbiwgdGhpcyk7XG5cdFx0XG5cdFx0fSBlbHNlIGlmIChjYXRlZ29yaWVzKSB7XG5cdFx0XHRyZXQgPSB2YWx1ZTtcblx0XHRcblx0XHR9IGVsc2UgaWYgKGRhdGVUaW1lTGFiZWxGb3JtYXQpIHsgLy8gZGF0ZXRpbWUgYXhpc1xuXHRcdFx0cmV0ID0gZGF0ZUZvcm1hdChkYXRlVGltZUxhYmVsRm9ybWF0LCB2YWx1ZSk7XG5cdFx0XG5cdFx0fSBlbHNlIGlmIChpICYmIG51bWVyaWNTeW1ib2xEZXRlY3RvciA+PSAxMDAwKSB7XG5cdFx0XHQvLyBEZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgYWRkIGEgbnVtZXJpYyBzeW1ib2wgbGlrZSBrICh0aG91c2FuZHMpIG9yIE0gKG1pbGxpb25zKS5cblx0XHRcdC8vIElmIHdlIGFyZSB0byBlbmFibGUgdGhpcyBpbiB0b29sdGlwIG9yIG90aGVyIHBsYWNlcyBhcyB3ZWxsLCB3ZSBjYW4gbW92ZSB0aGlzXG5cdFx0XHQvLyBsb2dpYyB0byB0aGUgbnVtYmVyRm9ybWF0dGVyIGFuZCBlbmFibGUgaXQgYnkgYSBwYXJhbWV0ZXIuXG5cdFx0XHR3aGlsZSAoaS0tICYmIHJldCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdG11bHRpID0gTWF0aC5wb3coMTAwMCwgaSArIDEpO1xuXHRcdFx0XHRpZiAobnVtZXJpY1N5bWJvbERldGVjdG9yID49IG11bHRpICYmIG51bWVyaWNTeW1ib2xzW2ldICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0ID0gbnVtYmVyRm9ybWF0KHZhbHVlIC8gbXVsdGksIC0xKSArIG51bWVyaWNTeW1ib2xzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChyZXQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0aWYgKHZhbHVlID49IDEwMDApIHsgLy8gYWRkIHRob3VzYW5kcyBzZXBhcmF0b3JzXG5cdFx0XHRcdHJldCA9IG51bWJlckZvcm1hdCh2YWx1ZSwgMCk7XG5cblx0XHRcdH0gZWxzZSB7IC8vIHNtYWxsIG51bWJlcnNcblx0XHRcdFx0cmV0ID0gbnVtYmVyRm9ybWF0KHZhbHVlLCAtMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBmb3IgdGhlIHNlcmllcyBvZiBlYWNoIGF4aXNcblx0ICovXG5cdGdldFNlcmllc0V4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0O1xuXG5cdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gZmFsc2U7XG5cblx0XHQvLyByZXNldCBkYXRhTWluIGFuZCBkYXRhTWF4IGluIGNhc2Ugd2UncmUgcmVkcmF3aW5nXG5cdFx0YXhpcy5kYXRhTWluID0gYXhpcy5kYXRhTWF4ID0gbnVsbDtcblxuXHRcdC8vIHJlc2V0IGNhY2hlZCBzdGFja2luZyBleHRyZW1lc1xuXHRcdGF4aXMuc3RhY2tFeHRyZW1lcyA9IHt9O1xuXG5cdFx0YXhpcy5idWlsZFN0YWNrcygpO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRoaXMgYXhpcycgc2VyaWVzXG5cdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXG5cdFx0XHRpZiAoc2VyaWVzLnZpc2libGUgfHwgIWNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cblx0XHRcdFx0dmFyIHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHR4RGF0YSxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0XHRzZXJpZXNEYXRhTWluLFxuXHRcdFx0XHRcdHNlcmllc0RhdGFNYXg7XG5cblx0XHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBWYWxpZGF0ZSB0aHJlc2hvbGQgaW4gbG9nYXJpdGhtaWMgYXhlc1xuXHRcdFx0XHRpZiAoYXhpcy5pc0xvZyAmJiB0aHJlc2hvbGQgPD0gMCkge1xuXHRcdFx0XHRcdHRocmVzaG9sZCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZGF0YU1pbiBhbmQgZGF0YU1heCBmb3IgWCBheGVzXG5cdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRpZiAoeERhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCB4RGF0YVswXSksIGFycmF5TWluKHhEYXRhKSk7XG5cdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSBtYXRoTWF4KHBpY2soYXhpcy5kYXRhTWF4LCB4RGF0YVswXSksIGFycmF5TWF4KHhEYXRhKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkYXRhTWluIGFuZCBkYXRhTWF4IGZvciBZIGF4ZXMsIGFzIHdlbGwgYXMgaGFuZGxlIHN0YWNraW5nIGFuZCBwcm9jZXNzZWQgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoaXMgcGFydGljdWxhciBzZXJpZXMgZXh0cmVtZXNcblx0XHRcdFx0XHRzZXJpZXMuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0XHRzZXJpZXNEYXRhTWF4ID0gc2VyaWVzLmRhdGFNYXg7XG5cdFx0XHRcdFx0c2VyaWVzRGF0YU1pbiA9IHNlcmllcy5kYXRhTWluO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBkYXRhTWluIGFuZCBkYXRhTWF4IHNvIGZhci4gSWYgcGVyY2VudGFnZSBpcyB1c2VkLCB0aGUgbWluIGFuZCBtYXggYXJlXG5cdFx0XHRcdFx0Ly8gYWx3YXlzIDAgYW5kIDEwMC4gSWYgc2VyaWVzRGF0YU1pbiBhbmQgc2VyaWVzRGF0YU1heCBpcyBudWxsLCB0aGVuIHNlcmllc1xuXHRcdFx0XHRcdC8vIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgeSBkYXRhLCB3ZSBjb250aW51ZSB3aXRoIG51bGxzXG5cdFx0XHRcdFx0aWYgKGRlZmluZWQoc2VyaWVzRGF0YU1pbikgJiYgZGVmaW5lZChzZXJpZXNEYXRhTWF4KSkge1xuXHRcdFx0XHRcdFx0YXhpcy5kYXRhTWluID0gbWF0aE1pbihwaWNrKGF4aXMuZGF0YU1pbiwgc2VyaWVzRGF0YU1pbiksIHNlcmllc0RhdGFNaW4pO1xuXHRcdFx0XHRcdFx0YXhpcy5kYXRhTWF4ID0gbWF0aE1heChwaWNrKGF4aXMuZGF0YU1heCwgc2VyaWVzRGF0YU1heCksIHNlcmllc0RhdGFNYXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkanVzdCB0byB0aHJlc2hvbGRcblx0XHRcdFx0XHRpZiAoZGVmaW5lZCh0aHJlc2hvbGQpKSB7XG5cdFx0XHRcdFx0XHRpZiAoYXhpcy5kYXRhTWluID49IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSB0aHJlc2hvbGQ7XG5cdFx0XHRcdFx0XHRcdGF4aXMuaWdub3JlTWluUGFkZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGF4aXMuZGF0YU1heCA8IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSB0aHJlc2hvbGQ7XG5cdFx0XHRcdFx0XHRcdGF4aXMuaWdub3JlTWF4UGFkZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRyYW5zbGF0ZSBmcm9tIGF4aXMgdmFsdWUgdG8gcGl4ZWwgcG9zaXRpb24gb24gdGhlIGNoYXJ0LCBvciBiYWNrXG5cdCAqXG5cdCAqL1xuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICh2YWwsIGJhY2t3YXJkcywgY3ZzQ29vcmQsIG9sZCwgaGFuZGxlTG9nLCBwb2ludFBsYWNlbWVudCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGF4aXNMZW5ndGggPSBheGlzLmxlbixcblx0XHRcdHNpZ24gPSAxLFxuXHRcdFx0Y3ZzT2Zmc2V0ID0gMCxcblx0XHRcdGxvY2FsQSA9IG9sZCA/IGF4aXMub2xkVHJhbnNBIDogYXhpcy50cmFuc0EsXG5cdFx0XHRsb2NhbE1pbiA9IG9sZCA/IGF4aXMub2xkTWluIDogYXhpcy5taW4sXG5cdFx0XHRyZXR1cm5WYWx1ZSxcblx0XHRcdG1pblBpeGVsUGFkZGluZyA9IGF4aXMubWluUGl4ZWxQYWRkaW5nLFxuXHRcdFx0cG9zdFRyYW5zbGF0ZSA9IChheGlzLm9wdGlvbnMub3JkaW5hbCB8fCAoYXhpcy5pc0xvZyAmJiBoYW5kbGVMb2cpKSAmJiBheGlzLmxpbjJ2YWw7XG5cblx0XHRpZiAoIWxvY2FsQSkge1xuXHRcdFx0bG9jYWxBID0gYXhpcy50cmFuc0E7XG5cdFx0fVxuXG5cdFx0Ly8gSW4gdmVydGljYWwgYXhlcywgdGhlIGNhbnZhcyBjb29yZGluYXRlcyBzdGFydCBmcm9tIDAgYXQgdGhlIHRvcCBsaWtlIGluIFxuXHRcdC8vIFNWRy4gXG5cdFx0aWYgKGN2c0Nvb3JkKSB7XG5cdFx0XHRzaWduICo9IC0xOyAvLyBjYW52YXMgY29vcmRpbmF0ZXMgaW52ZXJ0cyB0aGUgdmFsdWVcblx0XHRcdGN2c09mZnNldCA9IGF4aXNMZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIHJldmVyc2VkIGF4aXNcblx0XHRpZiAoYXhpcy5yZXZlcnNlZCkgeyBcblx0XHRcdHNpZ24gKj0gLTE7XG5cdFx0XHRjdnNPZmZzZXQgLT0gc2lnbiAqIGF4aXNMZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gRnJvbSBwaXhlbHMgdG8gdmFsdWVcblx0XHRpZiAoYmFja3dhcmRzKSB7IC8vIHJldmVyc2UgdHJhbnNsYXRpb25cblx0XHRcdFxuXHRcdFx0dmFsID0gdmFsICogc2lnbiArIGN2c09mZnNldDtcblx0XHRcdHZhbCAtPSBtaW5QaXhlbFBhZGRpbmc7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbCAvIGxvY2FsQSArIGxvY2FsTWluOyAvLyBmcm9tIGNoYXJ0IHBpeGVsIHRvIHZhbHVlXG5cdFx0XHRpZiAocG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IGF4aXMubGluMnZhbChyZXR1cm5WYWx1ZSk7XG5cdFx0XHR9XG5cblx0XHQvLyBGcm9tIHZhbHVlIHRvIHBpeGVsc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHR2YWwgPSBheGlzLnZhbDJsaW4odmFsKTtcblx0XHRcdH1cblx0XHRcdGlmIChwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nKSB7XG5cdFx0XHRcdHBvaW50UGxhY2VtZW50ID0gMC41O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuVmFsdWUgPSBzaWduICogKHZhbCAtIGxvY2FsTWluKSAqIGxvY2FsQSArIGN2c09mZnNldCArIChzaWduICogbWluUGl4ZWxQYWRkaW5nKSArXG5cdFx0XHRcdChpc051bWJlcihwb2ludFBsYWNlbWVudCkgPyBsb2NhbEEgKiBwb2ludFBsYWNlbWVudCAqIGF4aXMucG9pbnRSYW5nZSA6IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdG8gdHJhbnNsYXRlIGFuIGF4aXMgdmFsdWUgdG8gcGl4ZWwgcG9zaXRpb24uIFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBpbiB0ZXJtcyBvZiBheGlzIHVuaXRzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaW5hdGVzIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBjaGFydFxuXHQgKiAgICAgICAgb3IganVzdCB0aGUgYXhpcy9wYW5lIGl0c2VsZi5cblx0ICovXG5cdHRvUGl4ZWxzOiBmdW5jdGlvbiAodmFsdWUsIHBhbmVDb29yZGluYXRlcykge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSwgZmFsc2UsICF0aGlzLmhvcml6LCBudWxsLCB0cnVlKSArIChwYW5lQ29vcmRpbmF0ZXMgPyAwIDogdGhpcy5wb3MpO1xuXHR9LFxuXG5cdC8qXG5cdCAqIFV0aWxpdHkgbWV0aG9kIHRvIHRyYW5zbGF0ZSBhIHBpeGVsIHBvc2l0aW9uIGluIHRvIGFuIGF4aXMgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsIFRoZSBwaXhlbCB2YWx1ZSBjb29yZGluYXRlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaWFudGVzIFdoZXRoZXIgdGhlIGlucHV0IHBpeGVsIGlzIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBvciBqdXN0IHRoZVxuXHQgKiAgICAgICAgYXhpcy9wYW5lIGl0c2VsZi5cblx0ICovXG5cdHRvVmFsdWU6IGZ1bmN0aW9uIChwaXhlbCwgcGFuZUNvb3JkaW5hdGVzKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlKHBpeGVsIC0gKHBhbmVDb29yZGluYXRlcyA/IDAgOiB0aGlzLnBvcyksIHRydWUsICF0aGlzLmhvcml6LCBudWxsLCB0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBwYXRoIGZvciBhIHBsb3QgbGluZSB0aGF0IGdvZXMgZnJvbSB0aGUgZ2l2ZW4gdmFsdWUgb25cblx0ICogdGhpcyBheGlzLCBhY3Jvc3MgdGhlIHBsb3QgdG8gdGhlIG9wcG9zaXRlIHNpZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lV2lkdGggVXNlZCBmb3IgY2FsY3VsYXRpb24gY3Jpc3AgbGluZVxuXHQgKiBAcGFyYW0ge051bWJlcl0gb2xkIFVzZSBvbGQgY29vcmRpbmF0ZXMgKGZvciByZXNpemluZyBhbmQgcmVzY2FsaW5nKVxuXHQgKi9cblx0Z2V0UGxvdExpbmVQYXRoOiBmdW5jdGlvbiAodmFsdWUsIGxpbmVXaWR0aCwgb2xkLCBmb3JjZSkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdGF4aXNMZWZ0ID0gYXhpcy5sZWZ0LFxuXHRcdFx0YXhpc1RvcCA9IGF4aXMudG9wLFxuXHRcdFx0eDEsXG5cdFx0XHR5MSxcblx0XHRcdHgyLFxuXHRcdFx0eTIsXG5cdFx0XHR0cmFuc2xhdGVkVmFsdWUgPSBheGlzLnRyYW5zbGF0ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgb2xkKSxcblx0XHRcdGNIZWlnaHQgPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0KSB8fCBjaGFydC5jaGFydEhlaWdodCxcblx0XHRcdGNXaWR0aCA9IChvbGQgJiYgY2hhcnQub2xkQ2hhcnRXaWR0aCkgfHwgY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdHNraXAsXG5cdFx0XHR0cmFuc0IgPSBheGlzLnRyYW5zQjtcblxuXHRcdHgxID0geDIgPSBtYXRoUm91bmQodHJhbnNsYXRlZFZhbHVlICsgdHJhbnNCKTtcblx0XHR5MSA9IHkyID0gbWF0aFJvdW5kKGNIZWlnaHQgLSB0cmFuc2xhdGVkVmFsdWUgLSB0cmFuc0IpO1xuXG5cdFx0aWYgKGlzTmFOKHRyYW5zbGF0ZWRWYWx1ZSkpIHsgLy8gbm8gbWluIG9yIG1heFxuXHRcdFx0c2tpcCA9IHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKGF4aXMuaG9yaXopIHtcblx0XHRcdHkxID0gYXhpc1RvcDtcblx0XHRcdHkyID0gY0hlaWdodCAtIGF4aXMuYm90dG9tO1xuXHRcdFx0aWYgKHgxIDwgYXhpc0xlZnQgfHwgeDEgPiBheGlzTGVmdCArIGF4aXMud2lkdGgpIHtcblx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHgxID0gYXhpc0xlZnQ7XG5cdFx0XHR4MiA9IGNXaWR0aCAtIGF4aXMucmlnaHQ7XG5cblx0XHRcdGlmICh5MSA8IGF4aXNUb3AgfHwgeTEgPiBheGlzVG9wICsgYXhpcy5oZWlnaHQpIHtcblx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBza2lwICYmICFmb3JjZSA/XG5cdFx0XHRudWxsIDpcblx0XHRcdGNoYXJ0LnJlbmRlcmVyLmNyaXNwTGluZShbTSwgeDEsIHkxLCBMLCB4MiwgeTJdLCBsaW5lV2lkdGggfHwgMCk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBwYXRoIGZvciBhIHBsb3QgYmFuZFxuXHQgKi9cblx0Z2V0UGxvdEJhbmRQYXRoOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcblxuXHRcdHZhciB0b1BhdGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aCh0byksXG5cdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgoZnJvbSk7XG5cdFx0XHRcblx0XHRpZiAocGF0aCAmJiB0b1BhdGgpIHtcblx0XHRcdHBhdGgucHVzaChcblx0XHRcdFx0dG9QYXRoWzRdLFxuXHRcdFx0XHR0b1BhdGhbNV0sXG5cdFx0XHRcdHRvUGF0aFsxXSxcblx0XHRcdFx0dG9QYXRoWzJdXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7IC8vIG91dHNpZGUgdGhlIGF4aXMgYXJlYVxuXHRcdFx0cGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgb2YgYSBsaW5lYXIgYXhpcyB0byByb3VuZCB2YWx1ZXMgbGlrZSB3aG9sZSB0ZW5zIG9yIGV2ZXJ5IGZpdmUuXG5cdCAqL1xuXHRnZXRMaW5lYXJUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAodGlja0ludGVydmFsLCBtaW4sIG1heCkge1xuXHRcdHZhciBwb3MsXG5cdFx0XHRsYXN0UG9zLFxuXHRcdFx0cm91bmRlZE1pbiA9IGNvcnJlY3RGbG9hdChtYXRoRmxvb3IobWluIC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRyb3VuZGVkTWF4ID0gY29ycmVjdEZsb2F0KG1hdGhDZWlsKG1heCAvIHRpY2tJbnRlcnZhbCkgKiB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0dGlja1Bvc2l0aW9ucyA9IFtdO1xuXG5cdFx0Ly8gUG9wdWxhdGUgdGhlIGludGVybWVkaWF0ZSB2YWx1ZXNcblx0XHRwb3MgPSByb3VuZGVkTWluO1xuXHRcdHdoaWxlIChwb3MgPD0gcm91bmRlZE1heCkge1xuXG5cdFx0XHQvLyBQbGFjZSB0aGUgdGljayBvbiB0aGUgcm91bmRlZCB2YWx1ZVxuXHRcdFx0dGlja1Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cblx0XHRcdC8vIEFsd2F5cyBhZGQgdGhlIHJhdyB0aWNrSW50ZXJ2YWwsIG5vdCB0aGUgY29ycmVjdGVkIG9uZS5cblx0XHRcdHBvcyA9IGNvcnJlY3RGbG9hdChwb3MgKyB0aWNrSW50ZXJ2YWwpO1xuXG5cdFx0XHQvLyBJZiB0aGUgaW50ZXJ2YWwgaXMgbm90IGJpZyBlbm91Z2ggaW4gdGhlIGN1cnJlbnQgbWluIC0gbWF4IHJhbmdlIHRvIGFjdHVhbGx5IGluY3JlYXNlXG5cdFx0XHQvLyB0aGUgbG9vcCB2YXJpYWJsZSwgd2UgbmVlZCB0byBicmVhayBvdXQgdG8gcHJldmVudCBlbmRsZXNzIGxvb3AuIElzc3VlICM2MTlcblx0XHRcdGlmIChwb3MgPT09IGxhc3RQb3MpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlY29yZCB0aGUgbGFzdCB2YWx1ZVxuXHRcdFx0bGFzdFBvcyA9IHBvcztcblx0XHR9XG5cdFx0cmV0dXJuIHRpY2tQb3NpdGlvbnM7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiBhIGxvZ2FyaXRobWljIGF4aXNcblx0ICovXG5cdGdldExvZ1RpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uIChpbnRlcnZhbCwgbWluLCBtYXgsIG1pbm9yKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdGF4aXNMZW5ndGggPSBheGlzLmxlbixcblx0XHRcdC8vIFNpbmNlIHdlIHVzZSB0aGlzIG1ldGhvZCBmb3IgYm90aCBtYWpvciBhbmQgbWlub3IgdGlja3MsXG5cdFx0XHQvLyB1c2UgYSBsb2NhbCB2YXJpYWJsZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcblx0XHRcdHBvc2l0aW9ucyA9IFtdOyBcblx0XHRcblx0XHQvLyBSZXNldFxuXHRcdGlmICghbWlub3IpIHtcblx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmlyc3QgY2FzZTogQWxsIHRpY2tzIGZhbGwgb24gd2hvbGUgbG9nYXJpdGhtczogMSwgMTAsIDEwMCBldGMuXG5cdFx0aWYgKGludGVydmFsID49IDAuNSkge1xuXHRcdFx0aW50ZXJ2YWwgPSBtYXRoUm91bmQoaW50ZXJ2YWwpO1xuXHRcdFx0cG9zaXRpb25zID0gYXhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGludGVydmFsLCBtaW4sIG1heCk7XG5cdFx0XHRcblx0XHQvLyBTZWNvbmQgY2FzZTogV2UgbmVlZCBpbnRlcm1lZGlhcnkgdGlja3MuIEZvciBleGFtcGxlIFxuXHRcdC8vIDEsIDIsIDQsIDYsIDgsIDEwLCAyMCwgNDAgZXRjLiBcblx0XHR9IGVsc2UgaWYgKGludGVydmFsID49IDAuMDgpIHtcblx0XHRcdHZhciByb3VuZGVkTWluID0gbWF0aEZsb29yKG1pbiksXG5cdFx0XHRcdGludGVybWVkaWF0ZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0aixcblx0XHRcdFx0bGVuLFxuXHRcdFx0XHRwb3MsXG5cdFx0XHRcdGxhc3RQb3MsXG5cdFx0XHRcdGJyZWFrMjtcblx0XHRcdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPiAwLjMpIHtcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDRdO1xuXHRcdFx0fSBlbHNlIGlmIChpbnRlcnZhbCA+IDAuMTUpIHsgLy8gMC4yIGVxdWFscyBmaXZlIG1pbm9yIHRpY2tzIHBlciAxLCAxMCwgMTAwIGV0Y1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbMSwgMiwgNCwgNiwgOF07XG5cdFx0XHR9IGVsc2UgeyAvLyAwLjEgZXF1YWxzIHRlbiBtaW5vciB0aWNrcyBwZXIgMSwgMTAsIDEwMCBldGNcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKGkgPSByb3VuZGVkTWluOyBpIDwgbWF4ICsgMSAmJiAhYnJlYWsyOyBpKyspIHtcblx0XHRcdFx0bGVuID0gaW50ZXJtZWRpYXRlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGxlbiAmJiAhYnJlYWsyOyBqKyspIHtcblx0XHRcdFx0XHRwb3MgPSBsb2cybGluKGxpbjJsb2coaSkgKiBpbnRlcm1lZGlhdGVbal0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChwb3MgPiBtaW4gJiYgKCFtaW5vciB8fCBsYXN0UG9zIDw9IG1heCkpIHsgLy8gIzE2NzBcblx0XHRcdFx0XHRcdHBvc2l0aW9ucy5wdXNoKGxhc3RQb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobGFzdFBvcyA+IG1heCkge1xuXHRcdFx0XHRcdFx0YnJlYWsyID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0Ly8gVGhpcmQgY2FzZTogV2UgYXJlIHNvIGRlZXAgaW4gYmV0d2VlbiB3aG9sZSBsb2dhcml0aG1pYyB2YWx1ZXMgdGhhdFxuXHRcdC8vIHdlIG1pZ2h0IGFzIHdlbGwgaGFuZGxlIHRoZSB0aWNrIHBvc2l0aW9ucyBsaWtlIGEgbGluZWFyIGF4aXMuIEZvclxuXHRcdC8vIGV4YW1wbGUgMS4wMSwgMS4wMiwgMS4wMywgMS4wNC5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJlYWxNaW4gPSBsaW4ybG9nKG1pbiksXG5cdFx0XHRcdHJlYWxNYXggPSBsaW4ybG9nKG1heCksXG5cdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnNbbWlub3IgPyAnbWlub3JUaWNrSW50ZXJ2YWwnIDogJ3RpY2tJbnRlcnZhbCddLFxuXHRcdFx0XHRmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbiA9IHRpY2tJbnRlcnZhbE9wdGlvbiA9PT0gJ2F1dG8nID8gbnVsbCA6IHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLnRpY2tQaXhlbEludGVydmFsIC8gKG1pbm9yID8gNSA6IDEpLFxuXHRcdFx0XHR0b3RhbFBpeGVsTGVuZ3RoID0gbWlub3IgPyBheGlzTGVuZ3RoIC8gYXhpcy50aWNrUG9zaXRpb25zLmxlbmd0aCA6IGF4aXNMZW5ndGg7XG5cdFx0XHRcblx0XHRcdGludGVydmFsID0gcGljayhcblx0XHRcdFx0ZmlsdGVyZWRUaWNrSW50ZXJ2YWxPcHRpb24sXG5cdFx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsLFxuXHRcdFx0XHQocmVhbE1heCAtIHJlYWxNaW4pICogdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gLyAodG90YWxQaXhlbExlbmd0aCB8fCAxKVxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0aW50ZXJ2YWwgPSBub3JtYWxpemVUaWNrSW50ZXJ2YWwoXG5cdFx0XHRcdGludGVydmFsLCBcblx0XHRcdFx0bnVsbCwgXG5cdFx0XHRcdGdldE1hZ25pdHVkZShpbnRlcnZhbClcblx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdHBvc2l0aW9ucyA9IG1hcChheGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoXG5cdFx0XHRcdGludGVydmFsLCBcblx0XHRcdFx0cmVhbE1pbixcblx0XHRcdFx0cmVhbE1heFx0XG5cdFx0XHQpLCBsb2cybGluKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFtaW5vcikge1xuXHRcdFx0XHRheGlzLl9taW5vckF1dG9JbnRlcnZhbCA9IGludGVydmFsIC8gNTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2V0IHRoZSBheGlzLWxldmVsIHRpY2tJbnRlcnZhbCB2YXJpYWJsZSBcblx0XHRpZiAoIW1pbm9yKSB7XG5cdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9zaXRpb25zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG1pbm9yIHRpY2sgcG9zaXRpb25zLiBGb3IgbG9nYXJpdGhtaWMgYXhlcywgcmV1c2UgdGhlIHNhbWUgbG9naWNcblx0ICogYXMgZm9yIG1ham9yIHRpY2tzLlxuXHQgKi9cblx0Z2V0TWlub3JUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRtaW5vclRpY2tJbnRlcnZhbCA9IGF4aXMubWlub3JUaWNrSW50ZXJ2YWwsXG5cdFx0XHRtaW5vclRpY2tQb3NpdGlvbnMgPSBbXSxcblx0XHRcdHBvcyxcblx0XHRcdGksXG5cdFx0XHRsZW47XG5cdFx0XG5cdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdGxlbiA9IHRpY2tQb3NpdGlvbnMubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0YXhpcy5nZXRMb2dUaWNrUG9zaXRpb25zKG1pbm9yVGlja0ludGVydmFsLCB0aWNrUG9zaXRpb25zW2kgLSAxXSwgdGlja1Bvc2l0aW9uc1tpXSwgdHJ1ZSlcblx0XHRcdFx0KTtcdFxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoYXhpcy5pc0RhdGV0aW1lQXhpcyAmJiBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsID09PSAnYXV0bycpIHsgLy8gIzEzMTRcblx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdGdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHRub3JtYWxpemVUaW1lVGlja0ludGVydmFsKG1pbm9yVGlja0ludGVydmFsKSxcblx0XHRcdFx0XHRheGlzLm1pbixcblx0XHRcdFx0XHRheGlzLm1heCxcblx0XHRcdFx0XHRvcHRpb25zLnN0YXJ0T2ZXZWVrXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0XHRpZiAobWlub3JUaWNrUG9zaXRpb25zWzBdIDwgYXhpcy5taW4pIHtcblx0XHRcdFx0bWlub3JUaWNrUG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcdFx0XHRcblx0XHRcdGZvciAocG9zID0gYXhpcy5taW4gKyAodGlja1Bvc2l0aW9uc1swXSAtIGF4aXMubWluKSAlIG1pbm9yVGlja0ludGVydmFsOyBwb3MgPD0gYXhpcy5tYXg7IHBvcyArPSBtaW5vclRpY2tJbnRlcnZhbCkge1xuXHRcdFx0XHRtaW5vclRpY2tQb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWlub3JUaWNrUG9zaXRpb25zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGp1c3QgdGhlIG1pbiBhbmQgbWF4IGZvciB0aGUgbWluaW11bSByYW5nZS4gS2VlcCBpbiBtaW5kIHRoYXQgdGhlIHNlcmllcyBkYXRhIGlzIFxuXHQgKiBub3QgeWV0IHByb2Nlc3NlZCwgc28gd2UgZG9uJ3QgaGF2ZSBpbmZvcm1hdGlvbiBvbiBkYXRhIGNyb3BwaW5nIGFuZCBncm91cGluZywgb3IgXG5cdCAqIHVwZGF0ZWQgYXhpcy5wb2ludFJhbmdlIG9yIHNlcmllcy5wb2ludFJhbmdlLiBUaGUgZGF0YSBjYW4ndCBiZSBwcm9jZXNzZWQgdW50aWxcblx0ICogd2UgaGF2ZSBmaW5hbGx5IGVzdGFibGlzaGVkIG1pbiBhbmQgbWF4LlxuXHQgKi9cblx0YWRqdXN0Rm9yTWluUmFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0bWluID0gYXhpcy5taW4sXG5cdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdHpvb21PZmZzZXQsXG5cdFx0XHRzcGFjZUF2YWlsYWJsZSA9IGF4aXMuZGF0YU1heCAtIGF4aXMuZGF0YU1pbiA+PSBheGlzLm1pblJhbmdlLFxuXHRcdFx0Y2xvc2VzdERhdGFSYW5nZSxcblx0XHRcdGksXG5cdFx0XHRkaXN0YW5jZSxcblx0XHRcdHhEYXRhLFxuXHRcdFx0bG9vcExlbmd0aCxcblx0XHRcdG1pbkFyZ3MsXG5cdFx0XHRtYXhBcmdzO1xuXG5cdFx0Ly8gU2V0IHRoZSBhdXRvbWF0aWMgbWluaW11bSByYW5nZSBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCBkaXN0YW5jZVxuXHRcdGlmIChheGlzLmlzWEF4aXMgJiYgYXhpcy5taW5SYW5nZSA9PT0gVU5ERUZJTkVEICYmICFheGlzLmlzTG9nKSB7XG5cblx0XHRcdGlmIChkZWZpbmVkKG9wdGlvbnMubWluKSB8fCBkZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuXHRcdFx0XHRheGlzLm1pblJhbmdlID0gbnVsbDsgLy8gZG9uJ3QgZG8gdGhpcyBhZ2FpblxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiByYXcgZGF0YSBwb2ludHMsIGFzIG9wcG9zZWQgdG9cblx0XHRcdFx0Ly8gY2xvc2VzdFBvaW50UmFuZ2UgdGhhdCBhcHBsaWVzIHRvIHByb2Nlc3NlZCBwb2ludHMgKGNyb3BwZWQgYW5kIGdyb3VwZWQpXG5cdFx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRsb29wTGVuZ3RoID0gc2VyaWVzLnhJbmNyZW1lbnQgPyAxIDogeERhdGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRmb3IgKGkgPSBsb29wTGVuZ3RoOyBpID4gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHhEYXRhW2ldIC0geERhdGFbaSAtIDFdO1xuXHRcdFx0XHRcdFx0aWYgKGNsb3Nlc3REYXRhUmFuZ2UgPT09IFVOREVGSU5FRCB8fCBkaXN0YW5jZSA8IGNsb3Nlc3REYXRhUmFuZ2UpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2VzdERhdGFSYW5nZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBtYXRoTWluKGNsb3Nlc3REYXRhUmFuZ2UgKiA1LCBheGlzLmRhdGFNYXggLSBheGlzLmRhdGFNaW4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIG1pblJhbmdlIGlzIGV4Y2VlZGVkLCBhZGp1c3Rcblx0XHRpZiAobWF4IC0gbWluIDwgYXhpcy5taW5SYW5nZSkge1xuXHRcdFx0dmFyIG1pblJhbmdlID0gYXhpcy5taW5SYW5nZTtcblx0XHRcdHpvb21PZmZzZXQgPSAobWluUmFuZ2UgLSBtYXggKyBtaW4pIC8gMjtcblxuXHRcdFx0Ly8gaWYgbWluIGFuZCBtYXggb3B0aW9ucyBoYXZlIGJlZW4gc2V0LCBkb24ndCBnbyBiZXlvbmQgaXRcblx0XHRcdG1pbkFyZ3MgPSBbbWluIC0gem9vbU9mZnNldCwgcGljayhvcHRpb25zLm1pbiwgbWluIC0gem9vbU9mZnNldCldO1xuXHRcdFx0aWYgKHNwYWNlQXZhaWxhYmxlKSB7IC8vIGlmIHNwYWNlIGlzIGF2YWlsYWJsZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0bWluQXJnc1syXSA9IGF4aXMuZGF0YU1pbjtcblx0XHRcdH1cblx0XHRcdG1pbiA9IGFycmF5TWF4KG1pbkFyZ3MpO1xuXG5cdFx0XHRtYXhBcmdzID0gW21pbiArIG1pblJhbmdlLCBwaWNrKG9wdGlvbnMubWF4LCBtaW4gKyBtaW5SYW5nZSldO1xuXHRcdFx0aWYgKHNwYWNlQXZhaWxhYmxlKSB7IC8vIGlmIHNwYWNlIGlzIGF2YWlsYWJlLCBzdGF5IHdpdGhpbiB0aGUgZGF0YSByYW5nZVxuXHRcdFx0XHRtYXhBcmdzWzJdID0gYXhpcy5kYXRhTWF4O1xuXHRcdFx0fVxuXG5cdFx0XHRtYXggPSBhcnJheU1pbihtYXhBcmdzKTtcblxuXHRcdFx0Ly8gbm93IGlmIHRoZSBtYXggaXMgYWRqdXN0ZWQsIGFkanVzdCB0aGUgbWluIGJhY2tcblx0XHRcdGlmIChtYXggLSBtaW4gPCBtaW5SYW5nZSkge1xuXHRcdFx0XHRtaW5BcmdzWzBdID0gbWF4IC0gbWluUmFuZ2U7XG5cdFx0XHRcdG1pbkFyZ3NbMV0gPSBwaWNrKG9wdGlvbnMubWluLCBtYXggLSBtaW5SYW5nZSk7XG5cdFx0XHRcdG1pbiA9IGFycmF5TWF4KG1pbkFyZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBSZWNvcmQgbW9kaWZpZWQgZXh0cmVtZXNcblx0XHRheGlzLm1pbiA9IG1pbjtcblx0XHRheGlzLm1heCA9IG1heDtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRyYW5zbGF0aW9uIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzZXRBeGlzVHJhbnNsYXRpb246IGZ1bmN0aW9uIChzYXZlT2xkKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0cmFuZ2UgPSBheGlzLm1heCAtIGF4aXMubWluLFxuXHRcdFx0cG9pbnRSYW5nZSA9IDAsXG5cdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSxcblx0XHRcdG1pblBvaW50T2Zmc2V0ID0gMCxcblx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gMCxcblx0XHRcdGxpbmtlZFBhcmVudCA9IGF4aXMubGlua2VkUGFyZW50LFxuXHRcdFx0b3JkaW5hbENvcnJlY3Rpb24sXG5cdFx0XHR0cmFuc0EgPSBheGlzLnRyYW5zQTtcblxuXHRcdC8vIGFkanVzdCB0cmFuc2xhdGlvbiBmb3IgcGFkZGluZ1xuXHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdGlmIChsaW5rZWRQYXJlbnQpIHtcblx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSBsaW5rZWRQYXJlbnQubWluUG9pbnRPZmZzZXQ7XG5cdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gbGlua2VkUGFyZW50LnBvaW50UmFuZ2VQYWRkaW5nO1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHR2YXIgc2VyaWVzUG9pbnRSYW5nZSA9IHNlcmllcy5wb2ludFJhbmdlLFxuXHRcdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBzZXJpZXMub3B0aW9ucy5wb2ludFBsYWNlbWVudCxcblx0XHRcdFx0XHRcdHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlID0gc2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlO1xuXG5cdFx0XHRcdFx0aWYgKHNlcmllc1BvaW50UmFuZ2UgPiByYW5nZSkgeyAvLyAjMTQ0NlxuXHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRSYW5nZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvaW50UmFuZ2UgPSBtYXRoTWF4KHBvaW50UmFuZ2UsIHNlcmllc1BvaW50UmFuZ2UpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIG1pblBvaW50T2Zmc2V0IGlzIHRoZSB2YWx1ZSBwYWRkaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBheGlzIGluIG9yZGVyIHRvIG1ha2Vcblx0XHRcdFx0XHQvLyByb29tIGZvciBwb2ludHMgd2l0aCBhIHBvaW50UmFuZ2UsIHR5cGljYWxseSBjb2x1bW5zLiBXaGVuIHRoZSBwb2ludFBsYWNlbWVudCBvcHRpb25cblx0XHRcdFx0XHQvLyBpcyAnYmV0d2Vlbicgb3IgJ29uJywgdGhpcyBwYWRkaW5nIGRvZXMgbm90IGFwcGx5LlxuXHRcdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gbWF0aE1heChcblx0XHRcdFx0XHRcdG1pblBvaW50T2Zmc2V0LCBcblx0XHRcdFx0XHRcdGlzU3RyaW5nKHBvaW50UGxhY2VtZW50KSA/IDAgOiBzZXJpZXNQb2ludFJhbmdlIC8gMlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSB0b3RhbCBwYWRkaW5nIG5lZWRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBheGlzIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIFxuXHRcdFx0XHRcdC8vIHBvaW50UmFuZ2UuIElmIHRoZSBzZXJpZXMnIHBvaW50UGxhY2VtZW50IGlzICdvbicsIG5vIHBhZGRpbmcgaXMgYWRkZWQuXG5cdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcsXG5cdFx0XHRcdFx0XHRwb2ludFBsYWNlbWVudCA9PT0gJ29uJyA/IDAgOiBzZXJpZXNQb2ludFJhbmdlXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIFNldCB0aGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdFx0XHRpZiAoIXNlcmllcy5ub1NoYXJlZFRvb2x0aXAgJiYgZGVmaW5lZChzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZSkpIHtcblx0XHRcdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlID0gZGVmaW5lZChjbG9zZXN0UG9pbnRSYW5nZSkgP1xuXHRcdFx0XHRcdFx0XHRtYXRoTWluKGNsb3Nlc3RQb2ludFJhbmdlLCBzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZSkgOlxuXHRcdFx0XHRcdFx0XHRzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBSZWNvcmQgbWluUG9pbnRPZmZzZXQgYW5kIHBvaW50UmFuZ2VQYWRkaW5nXG5cdFx0XHRvcmRpbmFsQ29ycmVjdGlvbiA9IGF4aXMub3JkaW5hbFNsb3BlICYmIGNsb3Nlc3RQb2ludFJhbmdlID8gYXhpcy5vcmRpbmFsU2xvcGUgLyBjbG9zZXN0UG9pbnRSYW5nZSA6IDE7IC8vICM5ODgsICMxODUzXG5cdFx0XHRheGlzLm1pblBvaW50T2Zmc2V0ID0gbWluUG9pbnRPZmZzZXQgPSBtaW5Qb2ludE9mZnNldCAqIG9yZGluYWxDb3JyZWN0aW9uO1xuXHRcdFx0YXhpcy5wb2ludFJhbmdlUGFkZGluZyA9IHBvaW50UmFuZ2VQYWRkaW5nID0gcG9pbnRSYW5nZVBhZGRpbmcgKiBvcmRpbmFsQ29ycmVjdGlvbjtcblxuXHRcdFx0Ly8gcG9pbnRSYW5nZSBtZWFucyB0aGUgd2lkdGggcmVzZXJ2ZWQgZm9yIGVhY2ggcG9pbnQsIGxpa2UgaW4gYSBjb2x1bW4gY2hhcnRcblx0XHRcdGF4aXMucG9pbnRSYW5nZSA9IG1hdGhNaW4ocG9pbnRSYW5nZSwgcmFuZ2UpO1xuXG5cdFx0XHQvLyBjbG9zZXN0UG9pbnRSYW5nZSBtZWFucyB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cy4gSW4gY29sdW1uc1xuXHRcdFx0Ly8gaXQgaXMgbW9zdGx5IGVxdWFsIHRvIHBvaW50UmFuZ2UsIGJ1dCBpbiBsaW5lcyBwb2ludFJhbmdlIGlzIDAgd2hpbGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdC8vIGlzIHNvbWUgb3RoZXIgdmFsdWVcblx0XHRcdGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZTtcblx0XHR9XG5cblx0XHQvLyBTZWNvbmRhcnkgdmFsdWVzXG5cdFx0aWYgKHNhdmVPbGQpIHtcblx0XHRcdGF4aXMub2xkVHJhbnNBID0gdHJhbnNBO1xuXHRcdH1cblx0XHRheGlzLnRyYW5zbGF0aW9uU2xvcGUgPSBheGlzLnRyYW5zQSA9IHRyYW5zQSA9IGF4aXMubGVuIC8gKChyYW5nZSArIHBvaW50UmFuZ2VQYWRkaW5nKSB8fCAxKTtcblx0XHRheGlzLnRyYW5zQiA9IGF4aXMuaG9yaXogPyBheGlzLmxlZnQgOiBheGlzLmJvdHRvbTsgLy8gdHJhbnNsYXRpb24gYWRkZW5kXG5cdFx0YXhpcy5taW5QaXhlbFBhZGRpbmcgPSB0cmFuc0EgKiBtaW5Qb2ludE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byByb3VuZCB2YWx1ZXMgYW5kIG9wdGlvbmFsbHkgZXh0ZW5kIHRoZSBleHRyZW1lc1xuXHQgKiB0byB0aGUgbmVhcmVzdCB0aWNrXG5cdCAqL1xuXHRzZXRUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoc2Vjb25kUGFzcykge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2csXG5cdFx0XHRpc0RhdGV0aW1lQXhpcyA9IGF4aXMuaXNEYXRldGltZUF4aXMsXG5cdFx0XHRpc1hBeGlzID0gYXhpcy5pc1hBeGlzLFxuXHRcdFx0aXNMaW5rZWQgPSBheGlzLmlzTGlua2VkLFxuXHRcdFx0dGlja1Bvc2l0aW9uZXIgPSBheGlzLm9wdGlvbnMudGlja1Bvc2l0aW9uZXIsXG5cdFx0XHRtYXhQYWRkaW5nID0gb3B0aW9ucy5tYXhQYWRkaW5nLFxuXHRcdFx0bWluUGFkZGluZyA9IG9wdGlvbnMubWluUGFkZGluZyxcblx0XHRcdGxlbmd0aCxcblx0XHRcdGxpbmtlZFBhcmVudEV4dHJlbWVzLFxuXHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrSW50ZXJ2YWwsXG5cdFx0XHRtaW5UaWNrSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLm1pblRpY2tJbnRlcnZhbCxcblx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCxcblx0XHRcdHRpY2tQb3NpdGlvbnMsXG5cdFx0XHRrZWVwVHdvVGlja3NPbmx5LFxuXHRcdFx0Y2F0ZWdvcmllcyA9IGF4aXMuY2F0ZWdvcmllcztcblxuXHRcdC8vIGxpbmtlZCBheGlzIGdldHMgdGhlIGV4dHJlbWVzIGZyb20gdGhlIHBhcmVudCBheGlzXG5cdFx0aWYgKGlzTGlua2VkKSB7XG5cdFx0XHRheGlzLmxpbmtlZFBhcmVudCA9IGNoYXJ0W2lzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ11bb3B0aW9ucy5saW5rZWRUb107XG5cdFx0XHRsaW5rZWRQYXJlbnRFeHRyZW1lcyA9IGF4aXMubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCk7XG5cdFx0XHRheGlzLm1pbiA9IHBpY2sobGlua2VkUGFyZW50RXh0cmVtZXMubWluLCBsaW5rZWRQYXJlbnRFeHRyZW1lcy5kYXRhTWluKTtcblx0XHRcdGF4aXMubWF4ID0gcGljayhsaW5rZWRQYXJlbnRFeHRyZW1lcy5tYXgsIGxpbmtlZFBhcmVudEV4dHJlbWVzLmRhdGFNYXgpO1xuXHRcdFx0aWYgKG9wdGlvbnMudHlwZSAhPT0gYXhpcy5saW5rZWRQYXJlbnQub3B0aW9ucy50eXBlKSB7XG5cdFx0XHRcdGVycm9yKDExLCAxKTsgLy8gQ2FuJ3QgbGluayBheGVzIG9mIGRpZmZlcmVudCB0eXBlXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gaW5pdGlhbCBtaW4gYW5kIG1heCBmcm9tIHRoZSBleHRyZW1lIGRhdGEgdmFsdWVzXG5cdFx0XHRheGlzLm1pbiA9IHBpY2soYXhpcy51c2VyTWluLCBvcHRpb25zLm1pbiwgYXhpcy5kYXRhTWluKTtcblx0XHRcdGF4aXMubWF4ID0gcGljayhheGlzLnVzZXJNYXgsIG9wdGlvbnMubWF4LCBheGlzLmRhdGFNYXgpO1xuXHRcdH1cblxuXHRcdGlmIChpc0xvZykge1xuXHRcdFx0aWYgKCFzZWNvbmRQYXNzICYmIG1hdGhNaW4oYXhpcy5taW4sIHBpY2soYXhpcy5kYXRhTWluLCBheGlzLm1pbikpIDw9IDApIHsgLy8gIzk3OFxuXHRcdFx0XHRlcnJvcigxMCwgMSk7IC8vIENhbid0IHBsb3QgbmVnYXRpdmUgdmFsdWVzIG9uIGxvZyBheGlzXG5cdFx0XHR9XG5cdFx0XHRheGlzLm1pbiA9IGNvcnJlY3RGbG9hdChsb2cybGluKGF4aXMubWluKSk7IC8vIGNvcnJlY3RGbG9hdCBjdXJlcyAjOTM0XG5cdFx0XHRheGlzLm1heCA9IGNvcnJlY3RGbG9hdChsb2cybGluKGF4aXMubWF4KSk7XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIHpvb21lZCByYW5nZVxuXHRcdGlmIChheGlzLnJhbmdlKSB7XG5cdFx0XHRheGlzLnVzZXJNaW4gPSBheGlzLm1pbiA9IG1hdGhNYXgoYXhpcy5taW4sIGF4aXMubWF4IC0gYXhpcy5yYW5nZSk7IC8vICM2MThcblx0XHRcdGF4aXMudXNlck1heCA9IGF4aXMubWF4O1xuXHRcdFx0aWYgKHNlY29uZFBhc3MpIHtcblx0XHRcdFx0YXhpcy5yYW5nZSA9IG51bGw7ICAvLyBkb24ndCB1c2UgaXQgd2hlbiBydW5uaW5nIHNldEV4dHJlbWVzXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEhvb2sgZm9yIGFkanVzdGluZyB0aGlzLm1pbiBhbmQgdGhpcy5tYXguIFVzZWQgYnkgYnViYmxlIHNlcmllcy5cblx0XHRpZiAoYXhpcy5iZWZvcmVQYWRkaW5nKSB7XG5cdFx0XHRheGlzLmJlZm9yZVBhZGRpbmcoKTtcblx0XHR9XG5cblx0XHQvLyBhZGp1c3QgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlXG5cdFx0YXhpcy5hZGp1c3RGb3JNaW5SYW5nZSgpO1xuXHRcdFxuXHRcdC8vIFBhZCB0aGUgdmFsdWVzIHRvIGdldCBjbGVhciBvZiB0aGUgY2hhcnQncyBlZGdlcy4gVG8gYXZvaWQgdGlja0ludGVydmFsIHRha2luZyB0aGUgcGFkZGluZ1xuXHRcdC8vIGludG8gYWNjb3VudCwgd2UgZG8gdGhpcyBhZnRlciBjb21wdXRpbmcgdGljayBpbnRlcnZhbCAoIzEzMzcpLlxuXHRcdGlmICghY2F0ZWdvcmllcyAmJiAhYXhpcy51c2VQZXJjZW50YWdlICYmICFpc0xpbmtlZCAmJiBkZWZpbmVkKGF4aXMubWluKSAmJiBkZWZpbmVkKGF4aXMubWF4KSkge1xuXHRcdFx0bGVuZ3RoID0gYXhpcy5tYXggLSBheGlzLm1pbjtcblx0XHRcdGlmIChsZW5ndGgpIHtcblx0XHRcdFx0aWYgKCFkZWZpbmVkKG9wdGlvbnMubWluKSAmJiAhZGVmaW5lZChheGlzLnVzZXJNaW4pICYmIG1pblBhZGRpbmcgJiYgKGF4aXMuZGF0YU1pbiA8IDAgfHwgIWF4aXMuaWdub3JlTWluUGFkZGluZykpIHtcblx0XHRcdFx0XHRheGlzLm1pbiAtPSBsZW5ndGggKiBtaW5QYWRkaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZGVmaW5lZChvcHRpb25zLm1heCkgJiYgIWRlZmluZWQoYXhpcy51c2VyTWF4KSAgJiYgbWF4UGFkZGluZyAmJiAoYXhpcy5kYXRhTWF4ID4gMCB8fCAhYXhpcy5pZ25vcmVNYXhQYWRkaW5nKSkge1xuXHRcdFx0XHRcdGF4aXMubWF4ICs9IGxlbmd0aCAqIG1heFBhZGRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBnZXQgdGlja0ludGVydmFsXG5cdFx0aWYgKGF4aXMubWluID09PSBheGlzLm1heCB8fCBheGlzLm1pbiA9PT0gdW5kZWZpbmVkIHx8IGF4aXMubWF4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gMTtcblx0XHR9IGVsc2UgaWYgKGlzTGlua2VkICYmICF0aWNrSW50ZXJ2YWxPcHRpb24gJiZcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPT09IGF4aXMubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWwpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gYXhpcy5saW5rZWRQYXJlbnQudGlja0ludGVydmFsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IHBpY2soXG5cdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0Y2F0ZWdvcmllcyA/IC8vIGZvciBjYXRlZ29yaWVkIGF4aXMsIDEgaXMgZGVmYXVsdCwgZm9yIGxpbmVhciBheGlzIHVzZSB0aWNrUGl4XG5cdFx0XHRcdFx0MSA6XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbGV0IGl0IGJlIG1vcmUgdGhhbiB0aGUgZGF0YSByYW5nZVxuXHRcdFx0XHRcdChheGlzLm1heCAtIGF4aXMubWluKSAqIHRpY2tQaXhlbEludGVydmFsT3B0aW9uIC8gbWF0aE1heChheGlzLmxlbiwgdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24pXG5cdFx0XHQpO1xuXHRcdFx0Ly8gRm9yIHNxdWlzaGVkIGF4ZXMsIHNldCBvbmx5IHR3byB0aWNrc1xuXHRcdFx0aWYgKCFkZWZpbmVkKHRpY2tJbnRlcnZhbE9wdGlvbikgJiYgYXhpcy5sZW4gPCB0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiAmJiAhdGhpcy5pc1JhZGlhbCkge1xuXHRcdFx0XHRrZWVwVHdvVGlja3NPbmx5ID0gdHJ1ZTtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgLz0gNDsgLy8gdGljayBleHRyZW1lcyBjbG9zZXIgdG8gdGhlIHJlYWwgdmFsdWVzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHdlJ3JlIGZpbmlzaGVkIGRldGVjdGluZyBtaW4gYW5kIG1heCwgY3JvcCBhbmQgZ3JvdXAgc2VyaWVzIGRhdGEuIFRoaXNcblx0XHQvLyBpcyBpbiB0dXJuIG5lZWRlZCBpbiBvcmRlciB0byBmaW5kIHRpY2sgcG9zaXRpb25zIGluIG9yZGluYWwgYXhlcy4gXG5cdFx0aWYgKGlzWEF4aXMgJiYgIXNlY29uZFBhc3MpIHtcblx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLnByb2Nlc3NEYXRhKGF4aXMubWluICE9PSBheGlzLm9sZE1pbiB8fCBheGlzLm1heCAhPT0gYXhpcy5vbGRNYXgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHRoZSB0cmFuc2xhdGlvbiBmYWN0b3IgdXNlZCBpbiB0cmFuc2xhdGUgZnVuY3Rpb25cblx0XHRheGlzLnNldEF4aXNUcmFuc2xhdGlvbih0cnVlKTtcblxuXHRcdC8vIGhvb2sgZm9yIG9yZGluYWwgYXhlcyBhbmQgcmFkaWFsIGF4ZXNcblx0XHRpZiAoYXhpcy5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKSB7XG5cdFx0XHRheGlzLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gaG9vayBmb3IgZXh0ZW5zaW9ucywgdXNlZCBpbiBIaWdoc3RvY2sgb3JkaW5hbCBheGVzXG5cdFx0aWYgKGF4aXMucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gYXhpcy5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbChheGlzLnRpY2tJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0Ly8gSW4gY29sdW1uLWxpa2UgY2hhcnRzLCBkb24ndCBjcmFtcCBpbiBtb3JlIHRpY2tzIHRoYW4gdGhlcmUgYXJlIHBvaW50cyAoIzE5NDMpXG5cdFx0aWYgKGF4aXMucG9pbnRSYW5nZSkge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtYXRoTWF4KGF4aXMucG9pbnRSYW5nZSwgYXhpcy50aWNrSW50ZXJ2YWwpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBCZWZvcmUgbm9ybWFsaXppbmcgdGhlIHRpY2sgaW50ZXJ2YWwsIGhhbmRsZSBtaW5pbXVtIHRpY2sgaW50ZXJ2YWwuIFRoaXMgYXBwbGllcyBvbmx5IGlmIHRpY2tJbnRlcnZhbCBpcyBub3QgZGVmaW5lZC5cblx0XHRpZiAoIXRpY2tJbnRlcnZhbE9wdGlvbiAmJiBheGlzLnRpY2tJbnRlcnZhbCA8IG1pblRpY2tJbnRlcnZhbE9wdGlvbikge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtaW5UaWNrSW50ZXJ2YWxPcHRpb247XG5cdFx0fVxuXG5cdFx0Ly8gZm9yIGxpbmVhciBheGVzLCBnZXQgbWFnbml0dWRlIGFuZCBub3JtYWxpemUgdGhlIGludGVydmFsXG5cdFx0aWYgKCFpc0RhdGV0aW1lQXhpcyAmJiAhaXNMb2cpIHsgLy8gbGluZWFyXG5cdFx0XHRpZiAoIXRpY2tJbnRlcnZhbE9wdGlvbikge1xuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChheGlzLnRpY2tJbnRlcnZhbCwgbnVsbCwgZ2V0TWFnbml0dWRlKGF4aXMudGlja0ludGVydmFsKSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IG1pbm9yVGlja0ludGVydmFsXG5cdFx0YXhpcy5taW5vclRpY2tJbnRlcnZhbCA9IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWwgPT09ICdhdXRvJyAmJiBheGlzLnRpY2tJbnRlcnZhbCA/XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsIC8gNSA6IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWw7XG5cblx0XHQvLyBmaW5kIHRoZSB0aWNrIHBvc2l0aW9uc1xuXHRcdGF4aXMudGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbnMgPSBvcHRpb25zLnRpY2tQb3NpdGlvbnMgP1xuXHRcdFx0W10uY29uY2F0KG9wdGlvbnMudGlja1Bvc2l0aW9ucykgOiAvLyBXb3JrIG9uIGEgY29weSAoIzE1NjUpXG5cdFx0XHQodGlja1Bvc2l0aW9uZXIgJiYgdGlja1Bvc2l0aW9uZXIuYXBwbHkoYXhpcywgW2F4aXMubWluLCBheGlzLm1heF0pKTtcblx0XHRpZiAoIXRpY2tQb3NpdGlvbnMpIHtcblx0XHRcdFxuXHRcdFx0Ly8gVG9vIG1hbnkgdGlja3Ncblx0XHRcdGlmICghYXhpcy5vcmRpbmFsUG9zaXRpb25zICYmIChheGlzLm1heCAtIGF4aXMubWluKSAvIGF4aXMudGlja0ludGVydmFsID4gbWF0aE1heCgyICogYXhpcy5sZW4sIDIwMCkpIHtcblx0XHRcdFx0ZXJyb3IoMTksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaXNEYXRldGltZUF4aXMpIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IChheGlzLmdldE5vbkxpbmVhclRpbWVUaWNrcyB8fCBnZXRUaW1lVGlja3MpKFxuXHRcdFx0XHRcdG5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwoYXhpcy50aWNrSW50ZXJ2YWwsIG9wdGlvbnMudW5pdHMpLFxuXHRcdFx0XHRcdGF4aXMubWluLFxuXHRcdFx0XHRcdGF4aXMubWF4LFxuXHRcdFx0XHRcdG9wdGlvbnMuc3RhcnRPZldlZWssXG5cdFx0XHRcdFx0YXhpcy5vcmRpbmFsUG9zaXRpb25zLFxuXHRcdFx0XHRcdGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmIChpc0xvZykge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy5nZXRMb2dUaWNrUG9zaXRpb25zKGF4aXMudGlja0ludGVydmFsLCBheGlzLm1pbiwgYXhpcy5tYXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhheGlzLnRpY2tJbnRlcnZhbCwgYXhpcy5taW4sIGF4aXMubWF4KTtcblx0XHRcdH1cblx0XHRcdGlmIChrZWVwVHdvVGlja3NPbmx5KSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMuc3BsaWNlKDEsIHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMik7XG5cdFx0XHR9XG5cblx0XHRcdGF4aXMudGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbnM7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0xpbmtlZCkge1xuXG5cdFx0XHQvLyByZXNldCBtaW4vbWF4IG9yIHJlbW92ZSBleHRyZW1lcyBiYXNlZCBvbiBzdGFydC9lbmQgb24gdGlja1xuXHRcdFx0dmFyIHJvdW5kZWRNaW4gPSB0aWNrUG9zaXRpb25zWzBdLFxuXHRcdFx0XHRyb3VuZGVkTWF4ID0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRtaW5Qb2ludE9mZnNldCA9IGF4aXMubWluUG9pbnRPZmZzZXQgfHwgMCxcblx0XHRcdFx0c2luZ2xlUGFkO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5zdGFydE9uVGljaykge1xuXHRcdFx0XHRheGlzLm1pbiA9IHJvdW5kZWRNaW47XG5cdFx0XHR9IGVsc2UgaWYgKGF4aXMubWluIC0gbWluUG9pbnRPZmZzZXQgPiByb3VuZGVkTWluKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5kT25UaWNrKSB7XG5cdFx0XHRcdGF4aXMubWF4ID0gcm91bmRlZE1heDtcblx0XHRcdH0gZWxzZSBpZiAoYXhpcy5tYXggKyBtaW5Qb2ludE9mZnNldCA8IHJvdW5kZWRNYXgpIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludCwgb3IgYWxsIHBvaW50cyBoYXZlIHRoZSBzYW1lIHZhbHVlIG9uIHRoaXMgYXhpcywgdGhlbiBtaW5cblx0XHRcdC8vIGFuZCBtYXggYXJlIGVxdWFsIGFuZCB0aWNrUG9zaXRpb25zLmxlbmd0aCBpcyAxLiBJbiB0aGlzIGNhc2UsIGFkZCBzb21lIHBhZGRpbmdcblx0XHRcdC8vIGluIG9yZGVyIHRvIGNlbnRlciB0aGUgcG9pbnQsIGJ1dCBsZWF2ZSBpdCB3aXRoIG9uZSB0aWNrLiAjMTMzNy5cblx0XHRcdGlmICh0aWNrUG9zaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRzaW5nbGVQYWQgPSAwLjAwMTsgLy8gVGhlIGxvd2VzdCBwb3NzaWJsZSBudW1iZXIgdG8gYXZvaWQgZXh0cmEgcGFkZGluZyBvbiBjb2x1bW5zXG5cdFx0XHRcdGF4aXMubWluIC09IHNpbmdsZVBhZDtcblx0XHRcdFx0YXhpcy5tYXggKz0gc2luZ2xlUGFkO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heCB0aWNrcyBvZiBlaXRoZXIgdGhlIHggYW5kIHkgYXhpcyBjb2xsZWN0aW9uXG5cdCAqL1xuXHRzZXRNYXhUaWNrczogZnVuY3Rpb24gKCkge1xuXHRcdFxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRtYXhUaWNrcyA9IGNoYXJ0Lm1heFRpY2tzIHx8IHt9LFxuXHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdGtleSA9IHRoaXMuX21heFRpY2tzS2V5ID0gW3RoaXMueE9yWSwgdGhpcy5wb3MsIHRoaXMubGVuXS5qb2luKCctJyk7XG5cdFx0XG5cdFx0aWYgKCF0aGlzLmlzTGlua2VkICYmICF0aGlzLmlzRGF0ZXRpbWVBeGlzICYmIHRpY2tQb3NpdGlvbnMgJiYgdGlja1Bvc2l0aW9ucy5sZW5ndGggPiAobWF4VGlja3Nba2V5XSB8fCAwKSAmJiB0aGlzLm9wdGlvbnMuYWxpZ25UaWNrcyAhPT0gZmFsc2UpIHtcblx0XHRcdG1heFRpY2tzW2tleV0gPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHR9XG5cdFx0Y2hhcnQubWF4VGlja3MgPSBtYXhUaWNrcztcblx0fSxcblxuXHQvKipcblx0ICogV2hlbiB1c2luZyBtdWx0aXBsZSBheGVzLCBhZGp1c3QgdGhlIG51bWJlciBvZiB0aWNrcyB0byBtYXRjaCB0aGUgaGlnaGVzdFxuXHQgKiBudW1iZXIgb2YgdGlja3MgaW4gdGhhdCBncm91cFxuXHQgKi9cblx0YWRqdXN0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdGtleSA9IGF4aXMuX21heFRpY2tzS2V5LFxuXHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdG1heFRpY2tzID0gY2hhcnQubWF4VGlja3M7XG5cblx0XHRpZiAobWF4VGlja3MgJiYgbWF4VGlja3Nba2V5XSAmJiAhYXhpcy5pc0RhdGV0aW1lQXhpcyAmJiAhYXhpcy5jYXRlZ29yaWVzICYmICFheGlzLmlzTGlua2VkICYmIGF4aXMub3B0aW9ucy5hbGlnblRpY2tzICE9PSBmYWxzZSkgeyAvLyBvbmx5IGFwcGx5IHRvIGxpbmVhciBzY2FsZVxuXHRcdFx0dmFyIG9sZFRpY2tBbW91bnQgPSBheGlzLnRpY2tBbW91bnQsXG5cdFx0XHRcdGNhbGN1bGF0ZWRUaWNrQW1vdW50ID0gdGlja1Bvc2l0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdHRpY2tBbW91bnQ7XG5cblx0XHRcdC8vIHNldCB0aGUgYXhpcy1sZXZlbCB0aWNrQW1vdW50IHRvIHVzZSBiZWxvd1xuXHRcdFx0YXhpcy50aWNrQW1vdW50ID0gdGlja0Ftb3VudCA9IG1heFRpY2tzW2tleV07XG5cblx0XHRcdGlmIChjYWxjdWxhdGVkVGlja0Ftb3VudCA8IHRpY2tBbW91bnQpIHtcblx0XHRcdFx0d2hpbGUgKHRpY2tQb3NpdGlvbnMubGVuZ3RoIDwgdGlja0Ftb3VudCkge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaChjb3JyZWN0RmxvYXQoXG5cdFx0XHRcdFx0XHR0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV0gKyBheGlzLnRpY2tJbnRlcnZhbFxuXHRcdFx0XHRcdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF4aXMudHJhbnNBICo9IChjYWxjdWxhdGVkVGlja0Ftb3VudCAtIDEpIC8gKHRpY2tBbW91bnQgLSAxKTtcblx0XHRcdFx0YXhpcy5tYXggPSB0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV07XG5cblx0XHRcdH1cblx0XHRcdGlmIChkZWZpbmVkKG9sZFRpY2tBbW91bnQpICYmIHRpY2tBbW91bnQgIT09IG9sZFRpY2tBbW91bnQpIHtcblx0XHRcdFx0YXhpcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgc2NhbGUgYmFzZWQgb24gZGF0YSBtaW4gYW5kIG1heCwgdXNlciBzZXQgbWluIGFuZCBtYXggb3Igb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0c2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRzdGFja3MgPSBheGlzLnN0YWNrcyxcblx0XHRcdHR5cGUsXG5cdFx0XHRpLFxuXHRcdFx0aXNEaXJ0eURhdGEsXG5cdFx0XHRpc0RpcnR5QXhpc0xlbmd0aDtcblxuXHRcdGF4aXMub2xkTWluID0gYXhpcy5taW47XG5cdFx0YXhpcy5vbGRNYXggPSBheGlzLm1heDtcblx0XHRheGlzLm9sZEF4aXNMZW5ndGggPSBheGlzLmxlbjtcblxuXHRcdC8vIHNldCB0aGUgbmV3IGF4aXNMZW5ndGhcblx0XHRheGlzLnNldEF4aXNTaXplKCk7XG5cdFx0Ly9heGlzTGVuZ3RoID0gaG9yaXogPyBheGlzV2lkdGggOiBheGlzSGVpZ2h0O1xuXHRcdGlzRGlydHlBeGlzTGVuZ3RoID0gYXhpcy5sZW4gIT09IGF4aXMub2xkQXhpc0xlbmd0aDtcblxuXHRcdC8vIGlzIHRoZXJlIG5ldyBkYXRhP1xuXHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdGlmIChzZXJpZXMuaXNEaXJ0eURhdGEgfHwgc2VyaWVzLmlzRGlydHkgfHxcblx0XHRcdFx0XHRzZXJpZXMueEF4aXMuaXNEaXJ0eSkgeyAvLyB3aGVuIHggYXhpcyBpcyBkaXJ0eSwgd2UgbmVlZCBuZXcgZGF0YSBleHRyZW1lcyBmb3IgeSBhcyB3ZWxsXG5cdFx0XHRcdGlzRGlydHlEYXRhID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGRvIHdlIHJlYWxseSBuZWVkIHRvIGdvIHRocm91Z2ggYWxsIHRoaXM/XG5cdFx0aWYgKGlzRGlydHlBeGlzTGVuZ3RoIHx8IGlzRGlydHlEYXRhIHx8IGF4aXMuaXNMaW5rZWQgfHwgYXhpcy5mb3JjZVJlZHJhdyB8fFxuXHRcdFx0YXhpcy51c2VyTWluICE9PSBheGlzLm9sZFVzZXJNaW4gfHwgYXhpcy51c2VyTWF4ICE9PSBheGlzLm9sZFVzZXJNYXgpIHtcblx0XHRcdFxuXHRcdFx0Ly8gcmVzZXQgc3RhY2tzXG5cdFx0XHRpZiAoIWF4aXMuaXNYQXhpcykge1xuXHRcdFx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0YWNrc1t0eXBlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRheGlzLmZvcmNlUmVkcmF3ID0gZmFsc2U7XG5cblx0XHRcdC8vIGdldCBkYXRhIGV4dHJlbWVzIGlmIG5lZWRlZFxuXHRcdFx0YXhpcy5nZXRTZXJpZXNFeHRyZW1lcygpO1xuXG5cdFx0XHQvLyBnZXQgZml4ZWQgcG9zaXRpb25zIGJhc2VkIG9uIHRpY2tJbnRlcnZhbFxuXHRcdFx0YXhpcy5zZXRUaWNrUG9zaXRpb25zKCk7XG5cblx0XHRcdC8vIHJlY29yZCBvbGQgdmFsdWVzIHRvIGRlY2lkZSB3aGV0aGVyIGEgcmVzY2FsZSBpcyBuZWNlc3NhcnkgbGF0ZXIgb24gKCM1NDApXG5cdFx0XHRheGlzLm9sZFVzZXJNaW4gPSBheGlzLnVzZXJNaW47XG5cdFx0XHRheGlzLm9sZFVzZXJNYXggPSBheGlzLnVzZXJNYXg7XG5cblx0XHRcdC8vIE1hcmsgYXMgZGlydHkgaWYgaXQgaXMgbm90IGFscmVhZHkgc2V0IHRvIGRpcnR5IGFuZCBleHRyZW1lcyBoYXZlIGNoYW5nZWQuICM1OTUuXG5cdFx0XHRpZiAoIWF4aXMuaXNEaXJ0eSkge1xuXHRcdFx0XHRheGlzLmlzRGlydHkgPSBpc0RpcnR5QXhpc0xlbmd0aCB8fCBheGlzLm1pbiAhPT0gYXhpcy5vbGRNaW4gfHwgYXhpcy5tYXggIT09IGF4aXMub2xkTWF4O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWF4aXMuaXNYQXhpcykge1xuXHRcdFx0aWYgKGF4aXMub2xkU3RhY2tzKSB7XG5cdFx0XHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzID0gYXhpcy5vbGRTdGFja3M7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc2V0IHN0YWNrc1xuXHRcdFx0Zm9yICh0eXBlIGluIHN0YWNrcykge1xuXHRcdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cdFx0XHRcdFx0c3RhY2tzW3R5cGVdW2ldLmN1bSA9IHN0YWNrc1t0eXBlXVtpXS50b3RhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBTZXQgdGhlIG1heGltdW0gdGljayBhbW91bnRcblx0XHRheGlzLnNldE1heFRpY2tzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZXh0cmVtZXMgYW5kIG9wdGlvbmFsbHkgcmVkcmF3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNaW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG5ld01heFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhd1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHQgKiAgICBjb25maWd1cmF0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3VtZW50cyBcblx0ICpcblx0ICovXG5cdHNldEV4dHJlbWVzOiBmdW5jdGlvbiAobmV3TWluLCBuZXdNYXgsIHJlZHJhdywgYW5pbWF0aW9uLCBldmVudEFyZ3VtZW50cykge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydDtcblxuXHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG5cdFx0Ly8gRXh0ZW5kIHRoZSBhcmd1bWVudHMgd2l0aCBtaW4gYW5kIG1heFxuXHRcdGV2ZW50QXJndW1lbnRzID0gZXh0ZW5kKGV2ZW50QXJndW1lbnRzLCB7XG5cdFx0XHRtaW46IG5ld01pbixcblx0XHRcdG1heDogbmV3TWF4XG5cdFx0fSk7XG5cblx0XHQvLyBGaXJlIHRoZSBldmVudFxuXHRcdGZpcmVFdmVudChheGlzLCAnc2V0RXh0cmVtZXMnLCBldmVudEFyZ3VtZW50cywgZnVuY3Rpb24gKCkgeyAvLyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyXG5cblx0XHRcdGF4aXMudXNlck1pbiA9IG5ld01pbjtcblx0XHRcdGF4aXMudXNlck1heCA9IG5ld01heDtcblx0XHRcdGF4aXMuZXZlbnRBcmdzID0gZXZlbnRBcmd1bWVudHM7XG5cblx0XHRcdC8vIE1hcmsgZm9yIHJ1bm5pbmcgYWZ0ZXJTZXRFeHRyZW1lc1xuXHRcdFx0YXhpcy5pc0RpcnR5RXh0cmVtZXMgPSB0cnVlO1xuXG5cdFx0XHQvLyByZWRyYXdcblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciB6b29taW5nIGNoYXJ0LiBQdWxsZWQgb3V0IGluIGEgc2VwYXJhdGUgbWV0aG9kIHRvIGFsbG93IG92ZXJyaWRpbmdcblx0ICogaW4gc3RvY2sgY2hhcnRzLlxuXHQgKi9cblx0em9vbTogZnVuY3Rpb24gKG5ld01pbiwgbmV3TWF4KSB7XG5cblx0XHQvLyBQcmV2ZW50IHBpbmNoIHpvb21pbmcgb3V0IG9mIHJhbmdlLiBDaGVjayBmb3IgZGVmaW5lZCBpcyBmb3IgIzE5NDYuXG5cdFx0aWYgKCF0aGlzLmFsbG93Wm9vbU91dHNpZGUpIHtcblx0XHRcdGlmIChkZWZpbmVkKHRoaXMuZGF0YU1pbikgJiYgbmV3TWluIDw9IHRoaXMuZGF0YU1pbikge1xuXHRcdFx0XHRuZXdNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVmaW5lZCh0aGlzLmRhdGFNYXgpICYmIG5ld01heCA+PSB0aGlzLmRhdGFNYXgpIHtcblx0XHRcdFx0bmV3TWF4ID0gVU5ERUZJTkVEO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluIGZ1bGwgdmlldywgZGlzcGxheWluZyB0aGUgcmVzZXQgem9vbSBidXR0b24gaXMgbm90IHJlcXVpcmVkXG5cdFx0dGhpcy5kaXNwbGF5QnRuID0gbmV3TWluICE9PSBVTkRFRklORUQgfHwgbmV3TWF4ICE9PSBVTkRFRklORUQ7XG5cdFx0XG5cdFx0Ly8gRG8gaXRcblx0XHR0aGlzLnNldEV4dHJlbWVzKFxuXHRcdFx0bmV3TWluLFxuXHRcdFx0bmV3TWF4LFxuXHRcdFx0ZmFsc2UsIFxuXHRcdFx0VU5ERUZJTkVELCBcblx0XHRcdHsgdHJpZ2dlcjogJ3pvb20nIH1cblx0XHQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYXhpcyBtZXRyaWNzXG5cdCAqL1xuXHRzZXRBeGlzU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0b2Zmc2V0TGVmdCA9IG9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwLFxuXHRcdFx0b2Zmc2V0UmlnaHQgPSBvcHRpb25zLm9mZnNldFJpZ2h0IHx8IDAsXG5cdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHR3aWR0aCxcblx0XHRcdGhlaWdodCxcblx0XHRcdHRvcCxcblx0XHRcdGxlZnQ7XG5cblx0XHQvLyBFeHBvc2UgYmFzaWMgdmFsdWVzIHRvIHVzZSBpbiBTZXJpZXMgb2JqZWN0IGFuZCBuYXZpZ2F0b3Jcblx0XHR0aGlzLmxlZnQgPSBsZWZ0ID0gcGljayhvcHRpb25zLmxlZnQsIGNoYXJ0LnBsb3RMZWZ0ICsgb2Zmc2V0TGVmdCk7XG5cdFx0dGhpcy50b3AgPSB0b3AgPSBwaWNrKG9wdGlvbnMudG9wLCBjaGFydC5wbG90VG9wKTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGggPSBwaWNrKG9wdGlvbnMud2lkdGgsIGNoYXJ0LnBsb3RXaWR0aCAtIG9mZnNldExlZnQgKyBvZmZzZXRSaWdodCk7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgPSBwaWNrKG9wdGlvbnMuaGVpZ2h0LCBjaGFydC5wbG90SGVpZ2h0KTtcblx0XHR0aGlzLmJvdHRvbSA9IGNoYXJ0LmNoYXJ0SGVpZ2h0IC0gaGVpZ2h0IC0gdG9wO1xuXHRcdHRoaXMucmlnaHQgPSBjaGFydC5jaGFydFdpZHRoIC0gd2lkdGggLSBsZWZ0O1xuXG5cdFx0Ly8gRGlyZWN0aW9uIGFnbm9zdGljIHByb3BlcnRpZXNcblx0XHR0aGlzLmxlbiA9IG1hdGhNYXgoaG9yaXogPyB3aWR0aCA6IGhlaWdodCwgMCk7IC8vIG1hdGhNYXggZml4ZXMgIzkwNVxuXHRcdHRoaXMucG9zID0gaG9yaXogPyBsZWZ0IDogdG9wOyAvLyBkaXN0YW5jZSBmcm9tIFNWRyBvcmlnaW5cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBhY3R1YWwgYXhpcyBleHRyZW1lc1xuXHQgKi9cblx0Z2V0RXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2c7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiBpc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKGF4aXMubWluKSkgOiBheGlzLm1pbixcblx0XHRcdG1heDogaXNMb2cgPyBjb3JyZWN0RmxvYXQobGluMmxvZyhheGlzLm1heCkpIDogYXhpcy5tYXgsXG5cdFx0XHRkYXRhTWluOiBheGlzLmRhdGFNaW4sXG5cdFx0XHRkYXRhTWF4OiBheGlzLmRhdGFNYXgsXG5cdFx0XHR1c2VyTWluOiBheGlzLnVzZXJNaW4sXG5cdFx0XHR1c2VyTWF4OiBheGlzLnVzZXJNYXhcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHplcm8gcGxhbmUgZWl0aGVyIGJhc2VkIG9uIHplcm8gb3Igb24gdGhlIG1pbiBvciBtYXggdmFsdWUuXG5cdCAqIFVzZWQgaW4gYmFyIGFuZCBhcmVhIHBsb3RzXG5cdCAqL1xuXHRnZXRUaHJlc2hvbGQ6IGZ1bmN0aW9uICh0aHJlc2hvbGQpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2c7XG5cblx0XHR2YXIgcmVhbE1pbiA9IGlzTG9nID8gbGluMmxvZyhheGlzLm1pbikgOiBheGlzLm1pbixcblx0XHRcdHJlYWxNYXggPSBpc0xvZyA/IGxpbjJsb2coYXhpcy5tYXgpIDogYXhpcy5tYXg7XG5cdFx0XG5cdFx0aWYgKHJlYWxNaW4gPiB0aHJlc2hvbGQgfHwgdGhyZXNob2xkID09PSBudWxsKSB7XG5cdFx0XHR0aHJlc2hvbGQgPSByZWFsTWluO1xuXHRcdH0gZWxzZSBpZiAocmVhbE1heCA8IHRocmVzaG9sZCkge1xuXHRcdFx0dGhyZXNob2xkID0gcmVhbE1heDtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXhpcy50cmFuc2xhdGUodGhyZXNob2xkLCAwLCAxLCAwLCAxKTtcblx0fSxcblxuXHRhZGRQbG90QmFuZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR0aGlzLmFkZFBsb3RCYW5kT3JMaW5lKG9wdGlvbnMsICdwbG90QmFuZHMnKTtcblx0fSxcblx0XG5cdGFkZFBsb3RMaW5lOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHRoaXMuYWRkUGxvdEJhbmRPckxpbmUob3B0aW9ucywgJ3Bsb3RMaW5lcycpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYSBwbG90IGJhbmQgb3IgcGxvdCBsaW5lIGFmdGVyIHJlbmRlciB0aW1lXG5cdCAqXG5cdCAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFRoZSBwbG90QmFuZCBvciBwbG90TGluZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHQgKi9cblx0YWRkUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChvcHRpb25zLCBjb2xsKSB7XG5cdFx0dmFyIG9iaiA9IG5ldyBQbG90TGluZU9yQmFuZCh0aGlzLCBvcHRpb25zKS5yZW5kZXIoKSxcblx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucztcblxuXHRcdGlmIChvYmopIHsgLy8gIzIxODlcblx0XHRcdC8vIEFkZCBpdCB0byB0aGUgdXNlciBvcHRpb25zIGZvciBleHBvcnRpbmcgYW5kIEF4aXMudXBkYXRlXG5cdFx0XHRpZiAoY29sbCkge1xuXHRcdFx0XHR1c2VyT3B0aW9uc1tjb2xsXSA9IHVzZXJPcHRpb25zW2NvbGxdIHx8IFtdO1xuXHRcdFx0XHR1c2VyT3B0aW9uc1tjb2xsXS5wdXNoKG9wdGlvbnMpOyBcblx0XHRcdH1cblx0XHRcdHRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChvYmopOyBcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvKipcblx0ICogQ29tcHV0ZSBhdXRvIGFsaWdubWVudCBmb3IgdGhlIGF4aXMgbGFiZWwgYmFzZWQgb24gd2hpY2ggc2lkZSB0aGUgYXhpcyBpcyBvbiBcblx0ICogYW5kIHRoZSBnaXZlbiByb3RhdGlvbiBmb3IgdGhlIGxhYmVsXG5cdCAqL1xuXHRhdXRvTGFiZWxBbGlnbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG5cdFx0dmFyIHJldCwgXG5cdFx0XHRhbmdsZSA9IChwaWNrKHJvdGF0aW9uLCAwKSAtICh0aGlzLnNpZGUgKiA5MCkgKyA3MjApICUgMzYwO1xuXG5cdFx0aWYgKGFuZ2xlID4gMTUgJiYgYW5nbGUgPCAxNjUpIHtcblx0XHRcdHJldCA9ICdyaWdodCc7XG5cdFx0fSBlbHNlIGlmIChhbmdsZSA+IDE5NSAmJiBhbmdsZSA8IDM0NSkge1xuXHRcdFx0cmV0ID0gJ2xlZnQnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSAnY2VudGVyJztcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVyIHRoZSB0aWNrIGxhYmVscyB0byBhIHByZWxpbWluYXJ5IHBvc2l0aW9uIHRvIGdldCB0aGVpciBzaXplc1xuXHQgKi9cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0dGlja3MgPSBheGlzLnRpY2tzLFxuXHRcdFx0aG9yaXogPSBheGlzLmhvcml6LFxuXHRcdFx0c2lkZSA9IGF4aXMuc2lkZSxcblx0XHRcdGludmVydGVkU2lkZSA9IGNoYXJ0LmludmVydGVkID8gWzEsIDAsIDMsIDJdW3NpZGVdIDogc2lkZSxcblx0XHRcdGhhc0RhdGEsXG5cdFx0XHRzaG93QXhpcyxcblx0XHRcdHRpdGxlT2Zmc2V0ID0gMCxcblx0XHRcdHRpdGxlT2Zmc2V0T3B0aW9uLFxuXHRcdFx0dGl0bGVNYXJnaW4gPSAwLFxuXHRcdFx0YXhpc1RpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHRsYWJlbE9wdGlvbnMgPSBvcHRpb25zLmxhYmVscyxcblx0XHRcdGxhYmVsT2Zmc2V0ID0gMCwgLy8gcmVzZXRcblx0XHRcdGF4aXNPZmZzZXQgPSBjaGFydC5heGlzT2Zmc2V0LFxuXHRcdFx0Y2xpcE9mZnNldCA9IGNoYXJ0LmNsaXBPZmZzZXQsXG5cdFx0XHRkaXJlY3Rpb25GYWN0b3IgPSBbLTEsIDEsIDEsIC0xXVtzaWRlXSxcblx0XHRcdG4sXG5cdFx0XHRpLFxuXHRcdFx0YXV0b1N0YWdnZXJMaW5lcyA9IDEsXG5cdFx0XHRtYXhTdGFnZ2VyTGluZXMgPSBwaWNrKGxhYmVsT3B0aW9ucy5tYXhTdGFnZ2VyTGluZXMsIDUpLFxuXHRcdFx0c29ydGVkUG9zaXRpb25zLFxuXHRcdFx0bGFzdFJpZ2h0LFxuXHRcdFx0b3ZlcmxhcCxcblx0XHRcdHBvcyxcblx0XHRcdGJCb3gsXG5cdFx0XHR4LFxuXHRcdFx0dyxcblx0XHRcdGxpbmVObztcblx0XHRcdFxuXHRcdC8vIEZvciByZXVzZSBpbiBBeGlzLnJlbmRlclxuXHRcdGF4aXMuaGFzRGF0YSA9IGhhc0RhdGEgPSAoYXhpcy5oYXNWaXNpYmxlU2VyaWVzIHx8IChkZWZpbmVkKGF4aXMubWluKSAmJiBkZWZpbmVkKGF4aXMubWF4KSAmJiAhIXRpY2tQb3NpdGlvbnMpKTtcblx0XHRheGlzLnNob3dBeGlzID0gc2hvd0F4aXMgPSBoYXNEYXRhIHx8IHBpY2sob3B0aW9ucy5zaG93RW1wdHksIHRydWUpO1xuXG5cdFx0Ly8gU2V0L3Jlc2V0IHN0YWdnZXJMaW5lc1xuXHRcdGF4aXMuc3RhZ2dlckxpbmVzID0gYXhpcy5ob3JpeiAmJiBsYWJlbE9wdGlvbnMuc3RhZ2dlckxpbmVzO1xuXHRcdFxuXHRcdC8vIENyZWF0ZSB0aGUgYXhpc0dyb3VwIGFuZCBncmlkR3JvdXAgZWxlbWVudHMgb24gZmlyc3QgaXRlcmF0aW9uXG5cdFx0aWYgKCFheGlzLmF4aXNHcm91cCkge1xuXHRcdFx0YXhpcy5ncmlkR3JvdXAgPSByZW5kZXJlci5nKCdncmlkJylcblx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IG9wdGlvbnMuZ3JpZFpJbmRleCB8fCAxIH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHRcdGF4aXMuYXhpc0dyb3VwID0gcmVuZGVyZXIuZygnYXhpcycpXG5cdFx0XHRcdC5hdHRyKHsgekluZGV4OiBvcHRpb25zLnpJbmRleCB8fCAyIH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHRcdGF4aXMubGFiZWxHcm91cCA9IHJlbmRlcmVyLmcoJ2F4aXMtbGFiZWxzJylcblx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IGxhYmVsT3B0aW9ucy56SW5kZXggfHwgNyB9KVxuXHRcdFx0XHQuYWRkKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RhdGEgfHwgYXhpcy5pc0xpbmtlZCkge1xuXHRcdFx0XG5cdFx0XHQvLyBTZXQgdGhlIGV4cGxpY2l0IG9yIGF1dG9tYXRpYyBsYWJlbCBhbGlnbm1lbnRcblx0XHRcdGF4aXMubGFiZWxBbGlnbiA9IHBpY2sobGFiZWxPcHRpb25zLmFsaWduIHx8IGF4aXMuYXV0b0xhYmVsQWxpZ24obGFiZWxPcHRpb25zLnJvdGF0aW9uKSk7XG5cblx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRpZiAoIXRpY2tzW3Bvc10pIHtcblx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aWNrc1twb3NdLmFkZExhYmVsKCk7IC8vIHVwZGF0ZSBsYWJlbHMgZGVwZW5kaW5nIG9uIHRpY2sgaW50ZXJ2YWxcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEhhbmRsZSBhdXRvbWF0aWMgc3RhZ2dlciBsaW5lc1xuXHRcdFx0aWYgKGF4aXMuaG9yaXogJiYgIWF4aXMuc3RhZ2dlckxpbmVzICYmIG1heFN0YWdnZXJMaW5lcyAmJiAhbGFiZWxPcHRpb25zLnJvdGF0aW9uKSB7XG5cdFx0XHRcdHNvcnRlZFBvc2l0aW9ucyA9IGF4aXMucmV2ZXJzZWQgPyBbXS5jb25jYXQodGlja1Bvc2l0aW9ucykucmV2ZXJzZSgpIDogdGlja1Bvc2l0aW9ucztcblx0XHRcdFx0d2hpbGUgKGF1dG9TdGFnZ2VyTGluZXMgPCBtYXhTdGFnZ2VyTGluZXMpIHtcblx0XHRcdFx0XHRsYXN0UmlnaHQgPSBbXTtcblx0XHRcdFx0XHRvdmVybGFwID0gZmFsc2U7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNvcnRlZFBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cG9zID0gc29ydGVkUG9zaXRpb25zW2ldO1xuXHRcdFx0XHRcdFx0YkJveCA9IHRpY2tzW3Bvc10ubGFiZWwgJiYgdGlja3NbcG9zXS5sYWJlbC5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHR3ID0gYkJveCA/IGJCb3gud2lkdGggOiAwO1xuXHRcdFx0XHRcdFx0bGluZU5vID0gaSAlIGF1dG9TdGFnZ2VyTGluZXM7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICh3KSB7XG5cdFx0XHRcdFx0XHRcdHggPSBheGlzLnRyYW5zbGF0ZShwb3MpOyAvLyBkb24ndCBoYW5kbGUgbG9nXG5cdFx0XHRcdFx0XHRcdGlmIChsYXN0UmlnaHRbbGluZU5vXSAhPT0gVU5ERUZJTkVEICYmIHggPCBsYXN0UmlnaHRbbGluZU5vXSkge1xuXHRcdFx0XHRcdFx0XHRcdG92ZXJsYXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxhc3RSaWdodFtsaW5lTm9dID0geCArIHc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChvdmVybGFwKSB7XG5cdFx0XHRcdFx0XHRhdXRvU3RhZ2dlckxpbmVzKys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhdXRvU3RhZ2dlckxpbmVzID4gMSkge1xuXHRcdFx0XHRcdGF4aXMuc3RhZ2dlckxpbmVzID0gYXV0b1N0YWdnZXJMaW5lcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cblx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHQvLyBsZWZ0IHNpZGUgbXVzdCBiZSBhbGlnbjogcmlnaHQgYW5kIHJpZ2h0IHNpZGUgbXVzdCBoYXZlIGFsaWduOiBsZWZ0IGZvciBsYWJlbHNcblx0XHRcdFx0aWYgKHNpZGUgPT09IDAgfHwgc2lkZSA9PT0gMiB8fCB7IDE6ICdsZWZ0JywgMzogJ3JpZ2h0JyB9W3NpZGVdID09PSBheGlzLmxhYmVsQWxpZ24pIHtcblxuXHRcdFx0XHRcdC8vIGdldCB0aGUgaGlnaGVzdCBvZmZzZXRcblx0XHRcdFx0XHRsYWJlbE9mZnNldCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHR0aWNrc1twb3NdLmdldExhYmVsU2l6ZSgpLFxuXHRcdFx0XHRcdFx0bGFiZWxPZmZzZXRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdFx0aWYgKGF4aXMuc3RhZ2dlckxpbmVzKSB7XG5cdFx0XHRcdGxhYmVsT2Zmc2V0ICo9IGF4aXMuc3RhZ2dlckxpbmVzO1xuXHRcdFx0XHRheGlzLmxhYmVsT2Zmc2V0ID0gbGFiZWxPZmZzZXQ7XG5cdFx0XHR9XG5cdFx0XHRcblxuXHRcdH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSBkYXRhXG5cdFx0XHRmb3IgKG4gaW4gdGlja3MpIHtcblx0XHRcdFx0dGlja3Nbbl0uZGVzdHJveSgpO1xuXHRcdFx0XHRkZWxldGUgdGlja3Nbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXNUaXRsZU9wdGlvbnMgJiYgYXhpc1RpdGxlT3B0aW9ucy50ZXh0ICYmIGF4aXNUaXRsZU9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UpIHsgXG5cdFx0XHRpZiAoIWF4aXMuYXhpc1RpdGxlKSB7XG5cdFx0XHRcdGF4aXMuYXhpc1RpdGxlID0gcmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnRleHQsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHQpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHR6SW5kZXg6IDcsXG5cdFx0XHRcdFx0cm90YXRpb246IGF4aXNUaXRsZU9wdGlvbnMucm90YXRpb24gfHwgMCxcblx0XHRcdFx0XHRhbGlnbjpcblx0XHRcdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMudGV4dEFsaWduIHx8XG5cdFx0XHRcdFx0XHR7IGxvdzogJ2xlZnQnLCBtaWRkbGU6ICdjZW50ZXInLCBoaWdoOiAncmlnaHQnIH1bYXhpc1RpdGxlT3B0aW9ucy5hbGlnbl1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhheGlzVGl0bGVPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHQuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0YXhpcy5heGlzVGl0bGUuaXNOZXcgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvd0F4aXMpIHtcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSBheGlzLmF4aXNUaXRsZS5nZXRCQm94KClbaG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCddO1xuXHRcdFx0XHR0aXRsZU1hcmdpbiA9IHBpY2soYXhpc1RpdGxlT3B0aW9ucy5tYXJnaW4sIGhvcml6ID8gNSA6IDEwKTtcblx0XHRcdFx0dGl0bGVPZmZzZXRPcHRpb24gPSBheGlzVGl0bGVPcHRpb25zLm9mZnNldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGlkZSBvciBzaG93IHRoZSB0aXRsZSBkZXBlbmRpbmcgb24gd2hldGhlciBzaG93RW1wdHkgaXMgc2V0XG5cdFx0XHRheGlzLmF4aXNUaXRsZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gaGFuZGxlIGF1dG9tYXRpYyBvciB1c2VyIHNldCBvZmZzZXRcblx0XHRheGlzLm9mZnNldCA9IGRpcmVjdGlvbkZhY3RvciAqIHBpY2sob3B0aW9ucy5vZmZzZXQsIGF4aXNPZmZzZXRbc2lkZV0pO1xuXHRcdFxuXHRcdGF4aXMuYXhpc1RpdGxlTWFyZ2luID1cblx0XHRcdHBpY2sodGl0bGVPZmZzZXRPcHRpb24sXG5cdFx0XHRcdGxhYmVsT2Zmc2V0ICsgdGl0bGVNYXJnaW4gK1xuXHRcdFx0XHQoc2lkZSAhPT0gMiAmJiBsYWJlbE9mZnNldCAmJiBkaXJlY3Rpb25GYWN0b3IgKiBvcHRpb25zLmxhYmVsc1tob3JpeiA/ICd5JyA6ICd4J10pXG5cdFx0XHQpO1xuXG5cdFx0YXhpc09mZnNldFtzaWRlXSA9IG1hdGhNYXgoXG5cdFx0XHRheGlzT2Zmc2V0W3NpZGVdLFxuXHRcdFx0YXhpcy5heGlzVGl0bGVNYXJnaW4gKyB0aXRsZU9mZnNldCArIGRpcmVjdGlvbkZhY3RvciAqIGF4aXMub2Zmc2V0XG5cdFx0KTtcblx0XHRjbGlwT2Zmc2V0W2ludmVydGVkU2lkZV0gPSBtYXRoTWF4KGNsaXBPZmZzZXRbaW52ZXJ0ZWRTaWRlXSwgbWF0aEZsb29yKG9wdGlvbnMubGluZVdpZHRoIC8gMikgKiAyKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhdGggZm9yIHRoZSBheGlzIGxpbmVcblx0ICovXG5cdGdldExpbmVQYXRoOiBmdW5jdGlvbiAobGluZVdpZHRoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdG9wcG9zaXRlID0gdGhpcy5vcHBvc2l0ZSxcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0LFxuXHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0bGluZUxlZnQgPSB0aGlzLmxlZnQgKyAob3Bwb3NpdGUgPyB0aGlzLndpZHRoIDogMCkgKyBvZmZzZXQsXG5cdFx0XHRsaW5lVG9wID0gY2hhcnQuY2hhcnRIZWlnaHQgLSB0aGlzLmJvdHRvbSAtIChvcHBvc2l0ZSA/IHRoaXMuaGVpZ2h0IDogMCkgKyBvZmZzZXQ7XG5cdFx0XHRcblx0XHRpZiAob3Bwb3NpdGUpIHtcblx0XHRcdGxpbmVXaWR0aCAqPSAtMTsgLy8gY3Jpc3BpZnkgdGhlIG90aGVyIHdheSAtICMxNDgwLCAjMTY4N1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFydC5yZW5kZXJlci5jcmlzcExpbmUoW1xuXHRcdFx0XHRNLFxuXHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0dGhpcy5sZWZ0IDpcblx0XHRcdFx0XHRsaW5lTGVmdCxcblx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdGxpbmVUb3AgOlxuXHRcdFx0XHRcdHRoaXMudG9wLFxuXHRcdFx0XHRMLFxuXHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCAtIHRoaXMucmlnaHQgOlxuXHRcdFx0XHRcdGxpbmVMZWZ0LFxuXHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0bGluZVRvcCA6XG5cdFx0XHRcdFx0Y2hhcnQuY2hhcnRIZWlnaHQgLSB0aGlzLmJvdHRvbVxuXHRcdFx0XSwgbGluZVdpZHRoKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBQb3NpdGlvbiB0aGUgdGl0bGVcblx0ICovXG5cdGdldFRpdGxlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjb21wdXRlIGFuY2hvciBwb2ludHMgZm9yIGVhY2ggb2YgdGhlIHRpdGxlIGFsaWduIG9wdGlvbnNcblx0XHR2YXIgaG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0YXhpc0xlZnQgPSB0aGlzLmxlZnQsXG5cdFx0XHRheGlzVG9wID0gdGhpcy50b3AsXG5cdFx0XHRheGlzTGVuZ3RoID0gdGhpcy5sZW4sXG5cdFx0XHRheGlzVGl0bGVPcHRpb25zID0gdGhpcy5vcHRpb25zLnRpdGxlLFx0XHRcdFxuXHRcdFx0bWFyZ2luID0gaG9yaXogPyBheGlzTGVmdCA6IGF4aXNUb3AsXG5cdFx0XHRvcHBvc2l0ZSA9IHRoaXMub3Bwb3NpdGUsXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCxcblx0XHRcdGZvbnRTaXplID0gcEludChheGlzVGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplIHx8IDEyKSxcblx0XHRcdFxuXHRcdFx0Ly8gdGhlIHBvc2l0aW9uIGluIHRoZSBsZW5ndGggZGlyZWN0aW9uIG9mIHRoZSBheGlzXG5cdFx0XHRhbG9uZ0F4aXMgPSB7XG5cdFx0XHRcdGxvdzogbWFyZ2luICsgKGhvcml6ID8gMCA6IGF4aXNMZW5ndGgpLFxuXHRcdFx0XHRtaWRkbGU6IG1hcmdpbiArIGF4aXNMZW5ndGggLyAyLFxuXHRcdFx0XHRoaWdoOiBtYXJnaW4gKyAoaG9yaXogPyBheGlzTGVuZ3RoIDogMClcblx0XHRcdH1bYXhpc1RpdGxlT3B0aW9ucy5hbGlnbl0sXG5cdFxuXHRcdFx0Ly8gdGhlIHBvc2l0aW9uIGluIHRoZSBwZXJwZW5kaWN1bGFyIGRpcmVjdGlvbiBvZiB0aGUgYXhpc1xuXHRcdFx0b2ZmQXhpcyA9IChob3JpeiA/IGF4aXNUb3AgKyB0aGlzLmhlaWdodCA6IGF4aXNMZWZ0KSArXG5cdFx0XHRcdChob3JpeiA/IDEgOiAtMSkgKiAvLyBob3Jpem9udGFsIGF4aXMgcmV2ZXJzZXMgdGhlIG1hcmdpblxuXHRcdFx0XHQob3Bwb3NpdGUgPyAtMSA6IDEpICogLy8gc28gZG9lcyBvcHBvc2l0ZSBheGVzXG5cdFx0XHRcdHRoaXMuYXhpc1RpdGxlTWFyZ2luICtcblx0XHRcdFx0KHRoaXMuc2lkZSA9PT0gMiA/IGZvbnRTaXplIDogMCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogaG9yaXogP1xuXHRcdFx0XHRhbG9uZ0F4aXMgOlxuXHRcdFx0XHRvZmZBeGlzICsgKG9wcG9zaXRlID8gdGhpcy53aWR0aCA6IDApICsgb2Zmc2V0ICtcblx0XHRcdFx0XHQoYXhpc1RpdGxlT3B0aW9ucy54IHx8IDApLCAvLyB4XG5cdFx0XHR5OiBob3JpeiA/XG5cdFx0XHRcdG9mZkF4aXMgLSAob3Bwb3NpdGUgPyB0aGlzLmhlaWdodCA6IDApICsgb2Zmc2V0IDpcblx0XHRcdFx0YWxvbmdBeGlzICsgKGF4aXNUaXRsZU9wdGlvbnMueSB8fCAwKSAvLyB5XG5cdFx0fTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIGF4aXNcblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nLFxuXHRcdFx0aXNMaW5rZWQgPSBheGlzLmlzTGlua2VkLFxuXHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdGF4aXNUaXRsZSA9IGF4aXMuYXhpc1RpdGxlLFxuXHRcdFx0c3RhY2tzID0gYXhpcy5zdGFja3MsXG5cdFx0XHR0aWNrcyA9IGF4aXMudGlja3MsXG5cdFx0XHRtaW5vclRpY2tzID0gYXhpcy5taW5vclRpY2tzLFxuXHRcdFx0YWx0ZXJuYXRlQmFuZHMgPSBheGlzLmFsdGVybmF0ZUJhbmRzLFxuXHRcdFx0c3RhY2tMYWJlbE9wdGlvbnMgPSBvcHRpb25zLnN0YWNrTGFiZWxzLFxuXHRcdFx0YWx0ZXJuYXRlR3JpZENvbG9yID0gb3B0aW9ucy5hbHRlcm5hdGVHcmlkQ29sb3IsXG5cdFx0XHR0aWNrbWFya09mZnNldCA9IGF4aXMudGlja21hcmtPZmZzZXQsXG5cdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdGxpbmVQYXRoLFxuXHRcdFx0aGFzUmVuZGVyZWQgPSBjaGFydC5oYXNSZW5kZXJlZCxcblx0XHRcdHNsaWRlSW5UaWNrcyA9IGhhc1JlbmRlcmVkICYmIGRlZmluZWQoYXhpcy5vbGRNaW4pICYmICFpc05hTihheGlzLm9sZE1pbiksXG5cdFx0XHRoYXNEYXRhID0gYXhpcy5oYXNEYXRhLFxuXHRcdFx0c2hvd0F4aXMgPSBheGlzLnNob3dBeGlzLFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvO1xuXG5cdFx0Ly8gTWFyayBhbGwgZWxlbWVudHMgaW5BY3RpdmUgYmVmb3JlIHdlIGdvIG92ZXIgYW5kIG1hcmsgdGhlIGFjdGl2ZSBvbmVzXG5cdFx0ZWFjaChbdGlja3MsIG1pbm9yVGlja3MsIGFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdHZhciBwb3M7XG5cdFx0XHRmb3IgKHBvcyBpbiBjb2xsKSB7XG5cdFx0XHRcdGNvbGxbcG9zXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gSWYgdGhlIHNlcmllcyBoYXMgZGF0YSBkcmF3IHRoZSB0aWNrcy4gRWxzZSBvbmx5IHRoZSBsaW5lIGFuZCB0aXRsZVxuXHRcdGlmIChoYXNEYXRhIHx8IGlzTGlua2VkKSB7XG5cblx0XHRcdC8vIG1pbm9yIHRpY2tzXG5cdFx0XHRpZiAoYXhpcy5taW5vclRpY2tJbnRlcnZhbCAmJiAhYXhpcy5jYXRlZ29yaWVzKSB7XG5cdFx0XHRcdGVhY2goYXhpcy5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKSwgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRcdGlmICghbWlub3JUaWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10gPSBuZXcgVGljayhheGlzLCBwb3MsICdtaW5vcicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0aWYgKHNsaWRlSW5UaWNrcyAmJiBtaW5vclRpY2tzW3Bvc10uaXNOZXcpIHtcblx0XHRcdFx0XHRcdG1pbm9yVGlja3NbcG9zXS5yZW5kZXIobnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWlub3JUaWNrc1twb3NdLnJlbmRlcihudWxsLCBmYWxzZSwgMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWpvciB0aWNrcy4gUHVsbCBvdXQgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlbmRlciBpdCBsYXN0IHNvIHRoYXRcblx0XHRcdC8vIHdlIGNhbiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZWlnaGJvdXIgbGFiZWwuICM4MDguXG5cdFx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGgpIHsgLy8gIzEzMDBcblx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLnNsaWNlKDEpLmNvbmNhdChbdGlja1Bvc2l0aW9uc1swXV0pLCBmdW5jdGlvbiAocG9zLCBpKSB7XG5cdFxuXHRcdFx0XHRcdC8vIFJlb3JnYW5pemUgdGhlIGluZGljZXNcblx0XHRcdFx0XHRpID0gKGkgPT09IHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMSkgPyAwIDogaSArIDE7XG5cdFxuXHRcdFx0XHRcdC8vIGxpbmtlZCBheGVzIG5lZWQgYW4gZXh0cmEgY2hlY2sgdG8gZmluZCBvdXQgaWZcblx0XHRcdFx0XHRpZiAoIWlzTGlua2VkIHx8IChwb3MgPj0gYXhpcy5taW4gJiYgcG9zIDw9IGF4aXMubWF4KSkge1xuXHRcblx0XHRcdFx0XHRcdGlmICghdGlja3NbcG9zXSkge1xuXHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgbmV3IHRpY2tzIGluIG9sZCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0aWYgKHNsaWRlSW5UaWNrcyAmJiB0aWNrc1twb3NdLmlzTmV3KSB7XG5cdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGksIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGksIGZhbHNlLCAxKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gSW4gYSBjYXRlZ29yaXplZCBheGlzLCB0aGUgdGljayBtYXJrcyBhcmUgZGlzcGxheWVkIGJldHdlZW4gbGFiZWxzLiBTb1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGFkZCBhIHRpY2sgbWFyayBhbmQgZ3JpZCBsaW5lIGF0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIFggYXhpcy5cblx0XHRcdFx0aWYgKHRpY2ttYXJrT2Zmc2V0ICYmIGF4aXMubWluID09PSAwKSB7XG5cdFx0XHRcdFx0aWYgKCF0aWNrc1stMV0pIHtcblx0XHRcdFx0XHRcdHRpY2tzWy0xXSA9IG5ldyBUaWNrKGF4aXMsIC0xLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGlja3NbLTFdLnJlbmRlcigtMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFsdGVybmF0ZSBncmlkIGNvbG9yXG5cdFx0XHRpZiAoYWx0ZXJuYXRlR3JpZENvbG9yKSB7XG5cdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcywgaSkge1xuXHRcdFx0XHRcdGlmIChpICUgMiA9PT0gMCAmJiBwb3MgPCBheGlzLm1heCkge1xuXHRcdFx0XHRcdFx0aWYgKCFhbHRlcm5hdGVCYW5kc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10gPSBuZXcgUGxvdExpbmVPckJhbmQoYXhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcm9tID0gcG9zICsgdGlja21hcmtPZmZzZXQ7IC8vICM5NDlcblx0XHRcdFx0XHRcdHRvID0gdGlja1Bvc2l0aW9uc1tpICsgMV0gIT09IFVOREVGSU5FRCA/IHRpY2tQb3NpdGlvbnNbaSArIDFdICsgdGlja21hcmtPZmZzZXQgOiBheGlzLm1heDtcblx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10ub3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0ZnJvbTogaXNMb2cgPyBsaW4ybG9nKGZyb20pIDogZnJvbSxcblx0XHRcdFx0XHRcdFx0dG86IGlzTG9nID8gbGluMmxvZyh0bykgOiB0byxcblx0XHRcdFx0XHRcdFx0Y29sb3I6IGFsdGVybmF0ZUdyaWRDb2xvclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10ucmVuZGVyKCk7XG5cdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLmlzQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXN0b20gcGxvdCBsaW5lcyBhbmQgYmFuZHNcblx0XHRcdGlmICghYXhpcy5fYWRkZWRQbG90TEIpIHsgLy8gb25seSBmaXJzdCB0aW1lXG5cdFx0XHRcdGVhY2goKG9wdGlvbnMucGxvdExpbmVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5wbG90QmFuZHMgfHwgW10pLCBmdW5jdGlvbiAocGxvdExpbmVPcHRpb25zKSB7XG5cdFx0XHRcdFx0YXhpcy5hZGRQbG90QmFuZE9yTGluZShwbG90TGluZU9wdGlvbnMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YXhpcy5fYWRkZWRQbG90TEIgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0fSAvLyBlbmQgaWYgaGFzRGF0YVxuXG5cdFx0Ly8gUmVtb3ZlIGluYWN0aXZlIHRpY2tzXG5cdFx0ZWFjaChbdGlja3MsIG1pbm9yVGlja3MsIGFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdHZhciBwb3MsIFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRmb3JEZXN0cnVjdGlvbiA9IFtdLFxuXHRcdFx0XHRkZWxheSA9IGdsb2JhbEFuaW1hdGlvbiA/IGdsb2JhbEFuaW1hdGlvbi5kdXJhdGlvbiB8fCA1MDAgOiAwLFxuXHRcdFx0XHRkZXN0cm95SW5hY3RpdmVJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpID0gZm9yRGVzdHJ1Y3Rpb24ubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdC8vIFdoZW4gcmVzaXppbmcgcmFwaWRseSwgdGhlIHNhbWUgaXRlbXMgbWF5IGJlIGRlc3Ryb3llZCBpbiBkaWZmZXJlbnQgdGltZW91dHMsXG5cdFx0XHRcdFx0XHQvLyBvciB0aGUgbWF5IGJlIHJlYWN0aXZhdGVkXG5cdFx0XHRcdFx0XHRpZiAoY29sbFtmb3JEZXN0cnVjdGlvbltpXV0gJiYgIWNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0fTtcblxuXHRcdFx0Zm9yIChwb3MgaW4gY29sbCkge1xuXG5cdFx0XHRcdGlmICghY29sbFtwb3NdLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0Ly8gUmVuZGVyIHRvIHplcm8gb3BhY2l0eVxuXHRcdFx0XHRcdGNvbGxbcG9zXS5yZW5kZXIocG9zLCBmYWxzZSwgMCk7XG5cdFx0XHRcdFx0Y29sbFtwb3NdLmlzQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24ucHVzaChwb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gdGhlIG9iamVjdHMgYXJlIGZpbmlzaGVkIGZhZGluZyBvdXQsIGRlc3Ryb3kgdGhlbVxuXHRcdFx0aWYgKGNvbGwgPT09IGFsdGVybmF0ZUJhbmRzIHx8ICFjaGFydC5oYXNSZW5kZXJlZCB8fCAhZGVsYXkpIHtcblx0XHRcdFx0ZGVzdHJveUluYWN0aXZlSXRlbXMoKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVsYXkpIHtcblx0XHRcdFx0c2V0VGltZW91dChkZXN0cm95SW5hY3RpdmVJdGVtcywgZGVsYXkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gU3RhdGljIGl0ZW1zLiBBcyB0aGUgYXhpcyBncm91cCBpcyBjbGVhcmVkIG9uIHN1YnNlcXVlbnQgY2FsbHNcblx0XHQvLyB0byByZW5kZXIsIHRoZXNlIGl0ZW1zIGFyZSBhZGRlZCBvdXRzaWRlIHRoZSBncm91cC5cblx0XHQvLyBheGlzIGxpbmVcblx0XHRpZiAobGluZVdpZHRoKSB7XG5cdFx0XHRsaW5lUGF0aCA9IGF4aXMuZ2V0TGluZVBhdGgobGluZVdpZHRoKTtcblx0XHRcdGlmICghYXhpcy5heGlzTGluZSkge1xuXHRcdFx0XHRheGlzLmF4aXNMaW5lID0gcmVuZGVyZXIucGF0aChsaW5lUGF0aClcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMubGluZUNvbG9yLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRcdHpJbmRleDogN1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChheGlzLmF4aXNHcm91cCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRheGlzLmF4aXNMaW5lLmFuaW1hdGUoeyBkOiBsaW5lUGF0aCB9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvdyBvciBoaWRlIHRoZSBsaW5lIGRlcGVuZGluZyBvbiBvcHRpb25zLnNob3dFbXB0eVxuXHRcdFx0YXhpcy5heGlzTGluZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHR9XG5cblx0XHRpZiAoYXhpc1RpdGxlICYmIHNob3dBeGlzKSB7XG5cdFx0XHRcblx0XHRcdGF4aXNUaXRsZVtheGlzVGl0bGUuaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRheGlzLmdldFRpdGxlUG9zaXRpb24oKVxuXHRcdFx0KTtcblx0XHRcdGF4aXNUaXRsZS5pc05ldyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFN0YWNrZWQgdG90YWxzOlxuXHRcdGlmIChzdGFja0xhYmVsT3B0aW9ucyAmJiBzdGFja0xhYmVsT3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHR2YXIgc3RhY2tLZXksIG9uZVN0YWNrLCBzdGFja0NhdGVnb3J5LFxuXHRcdFx0XHRzdGFja1RvdGFsR3JvdXAgPSBheGlzLnN0YWNrVG90YWxHcm91cDtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgc2VwYXJhdGUgZ3JvdXAgZm9yIHRoZSBzdGFjayB0b3RhbCBsYWJlbHNcblx0XHRcdGlmICghc3RhY2tUb3RhbEdyb3VwKSB7XG5cdFx0XHRcdGF4aXMuc3RhY2tUb3RhbEdyb3VwID0gc3RhY2tUb3RhbEdyb3VwID1cblx0XHRcdFx0XHRyZW5kZXJlci5nKCdzdGFjay1sYWJlbHMnKVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiBWSVNJQkxFLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDZcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBsb3RMZWZ0L1RvcCB3aWxsIGNoYW5nZSB3aGVuIHkgYXhpcyBnZXRzIHdpZGVyIHNvIHdlIG5lZWQgdG8gdHJhbnNsYXRlIHRoZVxuXHRcdFx0Ly8gc3RhY2tUb3RhbEdyb3VwIGF0IGV2ZXJ5IHJlbmRlciBjYWxsLiBTZWUgYnVnICM1MDYgYW5kICM1MTZcblx0XHRcdHN0YWNrVG90YWxHcm91cC50cmFuc2xhdGUoY2hhcnQucGxvdExlZnQsIGNoYXJ0LnBsb3RUb3ApO1xuXG5cdFx0XHQvLyBSZW5kZXIgZWFjaCBzdGFjayB0b3RhbFxuXHRcdFx0Zm9yIChzdGFja0tleSBpbiBzdGFja3MpIHtcblx0XHRcdFx0b25lU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldO1xuXHRcdFx0XHRmb3IgKHN0YWNrQ2F0ZWdvcnkgaW4gb25lU3RhY2spIHtcblx0XHRcdFx0XHRvbmVTdGFja1tzdGFja0NhdGVnb3J5XS5yZW5kZXIoc3RhY2tUb3RhbEdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBFbmQgc3RhY2tlZCB0b3RhbHNcblxuXHRcdGF4aXMuaXNEaXJ0eSA9IGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBwbG90IGJhbmQgb3IgcGxvdCBsaW5lIGZyb20gdGhlIGNoYXJ0IGJ5IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpZFxuXHQgKi9cblx0cmVtb3ZlUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBwbG90TGluZXNBbmRCYW5kcyA9IHRoaXMucGxvdExpbmVzQW5kQmFuZHMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dXNlck9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAocGxvdExpbmVzQW5kQmFuZHNbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzW2ldLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWFjaChbb3B0aW9ucy5wbG90TGluZXMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RMaW5lcyB8fCBbXSwgb3B0aW9ucy5wbG90QmFuZHMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RCYW5kcyB8fCBbXV0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdGkgPSBhcnIubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAoYXJyW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdGVyYXNlKGFyciwgYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgYXhpcyB0aXRsZSBieSBvcHRpb25zXG5cdCAqL1xuXHRzZXRUaXRsZTogZnVuY3Rpb24gKG5ld1RpdGxlT3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0dGhpcy51cGRhdGUoeyB0aXRsZTogbmV3VGl0bGVPcHRpb25zIH0sIHJlZHJhdyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgYXhpcyB0byByZWZsZWN0IGNoYW5nZXMgaW4gdGhlIGRhdGEgb3IgYXhpcyBleHRyZW1lc1xuXHQgKi9cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXI7XG5cblx0XHQvLyBoaWRlIHRvb2x0aXAgYW5kIGhvdmVyIHN0YXRlc1xuXHRcdGlmIChwb2ludGVyLnJlc2V0KSB7XG5cdFx0XHRwb2ludGVyLnJlc2V0KHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIHJlbmRlciB0aGUgYXhpc1xuXHRcdGF4aXMucmVuZGVyKCk7XG5cblx0XHQvLyBtb3ZlIHBsb3QgbGluZXMgYW5kIGJhbmRzXG5cdFx0ZWFjaChheGlzLnBsb3RMaW5lc0FuZEJhbmRzLCBmdW5jdGlvbiAocGxvdExpbmUpIHtcblx0XHRcdHBsb3RMaW5lLnJlbmRlcigpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gbWFyayBhc3NvY2lhdGVkIHNlcmllcyBhcyBkaXJ0eSBhbmQgcmVhZHkgZm9yIHJlZHJhd1xuXHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHR9KTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZCB0aGUgc3RhY2tzIGZyb20gdG9wIGRvd25cblx0ICovXG5cdGJ1aWxkU3RhY2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0aSA9IHNlcmllcy5sZW5ndGg7XG5cdFx0aWYgKCF0aGlzLmlzWEF4aXMpIHtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2VyaWVzW2ldLnNldFN0YWNrZWRQb2ludHMoKTtcblx0XHRcdH1cblx0XHRcdC8vIExvb3AgdXAgYWdhaW4gdG8gY29tcHV0ZSBwZXJjZW50IHN0YWNrXG5cdFx0XHRpZiAodGhpcy51c2VQZXJjZW50YWdlKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzZXJpZXNbaV0uc2V0UGVyY2VudFN0YWNrcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgbmV3IGF4aXMgY2F0ZWdvcmllcyBhbmQgb3B0aW9uYWxseSByZWRyYXdcblx0ICogQHBhcmFtIHtBcnJheX0gY2F0ZWdvcmllc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhd1xuXHQgKi9cblx0c2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKGNhdGVnb3JpZXMsIHJlZHJhdykge1xuXHRcdHRoaXMudXBkYXRlKHsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9LCByZWRyYXcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyBhbiBBeGlzIGluc3RhbmNlLlxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKGtlZXBFdmVudHMpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRzdGFja3MgPSBheGlzLnN0YWNrcyxcblx0XHRcdHN0YWNrS2V5LFxuXHRcdFx0cGxvdExpbmVzQW5kQmFuZHMgPSBheGlzLnBsb3RMaW5lc0FuZEJhbmRzLFxuXHRcdFx0aTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgZXZlbnRzXG5cdFx0aWYgKCFrZWVwRXZlbnRzKSB7XG5cdFx0XHRyZW1vdmVFdmVudChheGlzKTtcblx0XHR9XG5cblx0XHQvLyBEZXN0cm95IGVhY2ggc3RhY2sgdG90YWxcblx0XHRmb3IgKHN0YWNrS2V5IGluIHN0YWNrcykge1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXMoc3RhY2tzW3N0YWNrS2V5XSk7XG5cblx0XHRcdHN0YWNrc1tzdGFja0tleV0gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIERlc3Ryb3kgY29sbGVjdGlvbnNcblx0XHRlYWNoKFtheGlzLnRpY2tzLCBheGlzLm1pbm9yVGlja3MsIGF4aXMuYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXMoY29sbCk7XG5cdFx0fSk7XG5cdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7IC8vICMxOTc1XG5cdFx0XHRwbG90TGluZXNBbmRCYW5kc1tpXS5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVzdHJveSBsb2NhbCB2YXJpYWJsZXNcblx0XHRlYWNoKFsnc3RhY2tUb3RhbEdyb3VwJywgJ2F4aXNMaW5lJywgJ2F4aXNHcm91cCcsICdncmlkR3JvdXAnLCAnbGFiZWxHcm91cCcsICdheGlzVGl0bGUnXSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdGlmIChheGlzW3Byb3BdKSB7XG5cdFx0XHRcdGF4aXNbcHJvcF0gPSBheGlzW3Byb3BdLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdFxufTsgLy8gZW5kIEF4aXNcblxuLyoqXG4gKiBUaGUgdG9vbHRpcCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgY2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRvb2x0aXAgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBUb29sdGlwKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuVG9vbHRpcC5wcm90b3R5cGUgPSB7XG5cblx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cblx0XHR2YXIgYm9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0c3R5bGUgPSBvcHRpb25zLnN0eWxlLFxuXHRcdFx0cGFkZGluZyA9IHBJbnQoc3R5bGUucGFkZGluZyk7XG5cblx0XHQvLyBTYXZlIHRoZSBjaGFydCBhbmQgb3B0aW9uc1xuXHRcdHRoaXMuY2hhcnQgPSBjaGFydDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0Ly8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBzZXJpZXNcblx0XHQvL3RoaXMuY3VycmVudFNlcmllcyA9IFVOREVGSU5FRDtcblxuXHRcdC8vIExpc3Qgb2YgY3Jvc3NoYWlyc1xuXHRcdHRoaXMuY3Jvc3NoYWlycyA9IFtdO1xuXG5cdFx0Ly8gQ3VycmVudCB2YWx1ZXMgb2YgeCBhbmQgeSB3aGVuIGFuaW1hdGluZ1xuXHRcdHRoaXMubm93ID0geyB4OiAwLCB5OiAwIH07XG5cblx0XHQvLyBUaGUgdG9vbHRpcCBpcyBpbml0aWFsbHkgaGlkZGVuXG5cdFx0dGhpcy5pc0hpZGRlbiA9IHRydWU7XG5cblxuXHRcdC8vIGNyZWF0ZSB0aGUgbGFiZWxcblx0XHR0aGlzLmxhYmVsID0gY2hhcnQucmVuZGVyZXIubGFiZWwoJycsIDAsIDAsIG9wdGlvbnMuc2hhcGUsIG51bGwsIG51bGwsIG9wdGlvbnMudXNlSFRNTCwgbnVsbCwgJ3Rvb2x0aXAnKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRwYWRkaW5nOiBwYWRkaW5nLFxuXHRcdFx0XHRmaWxsOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGJvcmRlcldpZHRoLFxuXHRcdFx0XHRyOiBvcHRpb25zLmJvcmRlclJhZGl1cyxcblx0XHRcdFx0ekluZGV4OiA4XG5cdFx0XHR9KVxuXHRcdFx0LmNzcyhzdHlsZSlcblx0XHRcdC5jc3MoeyBwYWRkaW5nOiAwIH0pIC8vIFJlbW92ZSBpdCBmcm9tIFZNTCwgdGhlIHBhZGRpbmcgaXMgYXBwbGllZCBhcyBhbiBhdHRyaWJ1dGUgaW5zdGVhZCAoIzExMTcpXG5cdFx0XHQuYWRkKClcblx0XHRcdC5hdHRyKHsgeTogLTk5OSB9KTsgLy8gIzIzMDFcblxuXHRcdC8vIFdoZW4gdXNpbmcgY2FuVkcgdGhlIHNoYWRvdyBzaG93cyB1cCBhcyBhIGdyYXkgY2lyY2xlXG5cdFx0Ly8gZXZlbiBpZiB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0aWYgKCF1c2VDYW5WRykge1xuXHRcdFx0dGhpcy5sYWJlbC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdH1cblxuXHRcdC8vIFB1YmxpYyBwcm9wZXJ0eSBmb3IgZ2V0dGluZyB0aGUgc2hhcmVkIHN0YXRlLlxuXHRcdHRoaXMuc2hhcmVkID0gb3B0aW9ucy5zaGFyZWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdGhlIHRvb2x0aXAgYW5kIGl0cyBlbGVtZW50cy5cblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRlYWNoKHRoaXMuY3Jvc3NoYWlycywgZnVuY3Rpb24gKGNyb3NzaGFpcikge1xuXHRcdFx0aWYgKGNyb3NzaGFpcikge1xuXHRcdFx0XHRjcm9zc2hhaXIuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRGVzdHJveSBhbmQgY2xlYXIgbG9jYWwgdmFyaWFibGVzXG5cdFx0aWYgKHRoaXMubGFiZWwpIHtcblx0XHRcdHRoaXMubGFiZWwgPSB0aGlzLmxhYmVsLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcblx0XHRjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBzb2Z0IG1vdmVtZW50IGZvciB0aGUgdG9vbHRpcFxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0bW92ZTogZnVuY3Rpb24gKHgsIHksIGFuY2hvclgsIGFuY2hvclkpIHtcblx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRub3cgPSB0b29sdGlwLm5vdyxcblx0XHRcdGFuaW1hdGUgPSB0b29sdGlwLm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSAmJiAhdG9vbHRpcC5pc0hpZGRlbjtcblxuXHRcdC8vIGdldCBpbnRlcm1lZGlhdGUgdmFsdWVzIGZvciBhbmltYXRpb25cblx0XHRleHRlbmQobm93LCB7XG5cdFx0XHR4OiBhbmltYXRlID8gKDIgKiBub3cueCArIHgpIC8gMyA6IHgsXG5cdFx0XHR5OiBhbmltYXRlID8gKG5vdy55ICsgeSkgLyAyIDogeSxcblx0XHRcdGFuY2hvclg6IGFuaW1hdGUgPyAoMiAqIG5vdy5hbmNob3JYICsgYW5jaG9yWCkgLyAzIDogYW5jaG9yWCxcblx0XHRcdGFuY2hvclk6IGFuaW1hdGUgPyAobm93LmFuY2hvclkgKyBhbmNob3JZKSAvIDIgOiBhbmNob3JZXG5cdFx0fSk7XG5cblx0XHQvLyBtb3ZlIHRvIHRoZSBpbnRlcm1lZGlhdGUgdmFsdWVcblx0XHR0b29sdGlwLmxhYmVsLmF0dHIobm93KTtcblxuXHRcdFxuXHRcdC8vIHJ1biBvbiBuZXh0IHRpY2sgb2YgdGhlIG1vdXNlIHRyYWNrZXJcblx0XHRpZiAoYW5pbWF0ZSAmJiAobWF0aEFicyh4IC0gbm93LngpID4gMSB8fCBtYXRoQWJzKHkgLSBub3cueSkgPiAxKSkge1xuXHRcdFxuXHRcdFx0Ly8gbmV2ZXIgYWxsb3cgdHdvIHRpbWVvdXRzXG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG5cdFx0XHRcblx0XHRcdC8vIHNldCB0aGUgZml4ZWQgaW50ZXJ2YWwgdGlja2luZyBmb3IgdGhlIHNtb290aCB0b29sdGlwXG5cdFx0XHR0aGlzLnRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFRoZSBpbnRlcnZhbCBmdW5jdGlvbiBtYXkgc3RpbGwgYmUgcnVubmluZyBkdXJpbmcgZGVzdHJveSwgc28gY2hlY2sgdGhhdCB0aGUgY2hhcnQgaXMgcmVhbGx5IHRoZXJlIGJlZm9yZSBjYWxsaW5nLlxuXHRcdFx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0XHRcdHRvb2x0aXAubW92ZSh4LCB5LCBhbmNob3JYLCBhbmNob3JZKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMzIpO1xuXHRcdFx0XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRoZSB0b29sdGlwXG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRvb2x0aXAgPSB0aGlzLFxuXHRcdFx0aG92ZXJQb2ludHM7XG5cdFx0XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTsgLy8gZGlzYWxsb3cgZHVwbGljYXRlIHRpbWVycyAoIzE3MjgsICMxNzY2KVxuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0aG92ZXJQb2ludHMgPSB0aGlzLmNoYXJ0LmhvdmVyUG9pbnRzO1xuXG5cdFx0XHR0aGlzLmhpZGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0b29sdGlwLmxhYmVsLmZhZGVPdXQoKTtcblx0XHRcdFx0dG9vbHRpcC5pc0hpZGRlbiA9IHRydWU7XG5cdFx0XHR9LCBwaWNrKHRoaXMub3B0aW9ucy5oaWRlRGVsYXksIDUwMCkpO1xuXG5cdFx0XHQvLyBoaWRlIHByZXZpb3VzIGhvdmVyUG9pbnRzIGFuZCBzZXQgbmV3XG5cdFx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdFx0ZWFjaChob3ZlclBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0cG9pbnQuc2V0U3RhdGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2hhcnQuaG92ZXJQb2ludHMgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgY3Jvc3NoYWlyc1xuXHQgKi9cblx0aGlkZUNyb3NzaGFpcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRlYWNoKHRoaXMuY3Jvc3NoYWlycywgZnVuY3Rpb24gKGNyb3NzaGFpcikge1xuXHRcdFx0aWYgKGNyb3NzaGFpcikge1xuXHRcdFx0XHRjcm9zc2hhaXIuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRcblx0LyoqIFxuXHQgKiBFeHRlbmRhYmxlIG1ldGhvZCB0byBnZXQgdGhlIGFuY2hvciBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxuXHQgKiBmcm9tIGEgcG9pbnQgb3Igc2V0IG9mIHBvaW50c1xuXHQgKi9cblx0Z2V0QW5jaG9yOiBmdW5jdGlvbiAocG9pbnRzLCBtb3VzZUV2ZW50KSB7XG5cdFx0dmFyIHJldCxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcCxcblx0XHRcdHBsb3RYID0gMCxcblx0XHRcdHBsb3RZID0gMCxcblx0XHRcdHlBeGlzO1xuXHRcdFxuXHRcdHBvaW50cyA9IHNwbGF0KHBvaW50cyk7XG5cdFx0XG5cdFx0Ly8gUGllIHVzZXMgYSBzcGVjaWFsIHRvb2x0aXBQb3Ncblx0XHRyZXQgPSBwb2ludHNbMF0udG9vbHRpcFBvcztcblx0XHRcblx0XHQvLyBXaGVuIHRvb2x0aXAgZm9sbG93cyBtb3VzZSwgcmVsYXRlIHRoZSBwb3NpdGlvbiB0byB0aGUgbW91c2Vcblx0XHRpZiAodGhpcy5mb2xsb3dQb2ludGVyICYmIG1vdXNlRXZlbnQpIHtcblx0XHRcdGlmIChtb3VzZUV2ZW50LmNoYXJ0WCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdG1vdXNlRXZlbnQgPSBjaGFydC5wb2ludGVyLm5vcm1hbGl6ZShtb3VzZUV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldCA9IFtcblx0XHRcdFx0bW91c2VFdmVudC5jaGFydFggLSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wXG5cdFx0XHRdO1xuXHRcdH1cblx0XHQvLyBXaGVuIHNoYXJlZCwgdXNlIHRoZSBhdmVyYWdlIHBvc2l0aW9uXG5cdFx0aWYgKCFyZXQpIHtcblx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0eUF4aXMgPSBwb2ludC5zZXJpZXMueUF4aXM7XG5cdFx0XHRcdHBsb3RYICs9IHBvaW50LnBsb3RYO1xuXHRcdFx0XHRwbG90WSArPSAocG9pbnQucGxvdExvdyA/IChwb2ludC5wbG90TG93ICsgcG9pbnQucGxvdEhpZ2gpIC8gMiA6IHBvaW50LnBsb3RZKSArXG5cdFx0XHRcdFx0KCFpbnZlcnRlZCAmJiB5QXhpcyA/IHlBeGlzLnRvcCAtIHBsb3RUb3AgOiAwKTsgLy8gIzExNTFcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwbG90WCAvPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0cGxvdFkgLz0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LnBsb3RXaWR0aCAtIHBsb3RZIDogcGxvdFgsXG5cdFx0XHRcdHRoaXMuc2hhcmVkICYmICFpbnZlcnRlZCAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiBtb3VzZUV2ZW50ID8gXG5cdFx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wIDogLy8gcGxhY2Ugc2hhcmVkIHRvb2x0aXAgbmV4dCB0byB0aGUgbW91c2UgKCM0MjQpXG5cdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5wbG90SGVpZ2h0IC0gcGxvdFggOiBwbG90WVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwKHJldCwgbWF0aFJvdW5kKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBQbGFjZSB0aGUgdG9vbHRpcCBpbiBhIGNoYXJ0IHdpdGhvdXQgc3BpbGxpbmcgb3ZlclxuXHQgKiBhbmQgbm90IGNvdmVyaW5nIHRoZSBwb2ludCBpdCBzZWxmLlxuXHQgKi9cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChib3hXaWR0aCwgYm94SGVpZ2h0LCBwb2ludCkge1xuXHRcdFxuXHRcdC8vIFNldCB1cCB0aGUgdmFyaWFibGVzXG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcCxcblx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0ZGlzdGFuY2UgPSBwaWNrKHRoaXMub3B0aW9ucy5kaXN0YW5jZSwgMTIpLFxuXHRcdFx0cG9pbnRYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRwb2ludFkgPSBwb2ludC5wbG90WSxcblx0XHRcdHggPSBwb2ludFggKyBwbG90TGVmdCArIChjaGFydC5pbnZlcnRlZCA/IGRpc3RhbmNlIDogLWJveFdpZHRoIC0gZGlzdGFuY2UpLFxuXHRcdFx0eSA9IHBvaW50WSAtIGJveEhlaWdodCArIHBsb3RUb3AgKyAxNSwgLy8gMTUgbWVhbnMgdGhlIHBvaW50IGlzIDE1IHBpeGVscyB1cCBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHRvb2x0aXBcblx0XHRcdGFsaWduZWRSaWdodDtcblx0XG5cdFx0Ly8gSXQgaXMgdG9vIGZhciB0byB0aGUgbGVmdCwgYWRqdXN0IGl0XG5cdFx0aWYgKHggPCA3KSB7XG5cdFx0XHR4ID0gcGxvdExlZnQgKyBtYXRoTWF4KHBvaW50WCwgMCkgKyBkaXN0YW5jZTtcblx0XHR9XG5cdFxuXHRcdC8vIFRlc3QgdG8gc2VlIGlmIHRoZSB0b29sdGlwIGlzIHRvbyBmYXIgdG8gdGhlIHJpZ2h0LFxuXHRcdC8vIGlmIGl0IGlzLCBtb3ZlIGl0IGJhY2sgdG8gYmUgaW5zaWRlIGFuZCB0aGVuIHVwIHRvIG5vdCBjb3ZlciB0aGUgcG9pbnQuXG5cdFx0aWYgKCh4ICsgYm94V2lkdGgpID4gKHBsb3RMZWZ0ICsgcGxvdFdpZHRoKSkge1xuXHRcdFx0eCAtPSAoeCArIGJveFdpZHRoKSAtIChwbG90TGVmdCArIHBsb3RXaWR0aCk7XG5cdFx0XHR5ID0gcG9pbnRZIC0gYm94SGVpZ2h0ICsgcGxvdFRvcCAtIGRpc3RhbmNlO1xuXHRcdFx0YWxpZ25lZFJpZ2h0ID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIGl0IGlzIG5vdyBhYm92ZSB0aGUgcGxvdCBhcmVhLCBhbGlnbiBpdCB0byB0aGUgdG9wIG9mIHRoZSBwbG90IGFyZWFcblx0XHRpZiAoeSA8IHBsb3RUb3AgKyA1KSB7XG5cdFx0XHR5ID0gcGxvdFRvcCArIDU7XG5cdFxuXHRcdFx0Ly8gSWYgdGhlIHRvb2x0aXAgaXMgc3RpbGwgY292ZXJpbmcgdGhlIHBvaW50LCBtb3ZlIGl0IGJlbG93IGluc3RlYWRcblx0XHRcdGlmIChhbGlnbmVkUmlnaHQgJiYgcG9pbnRZID49IHkgJiYgcG9pbnRZIDw9ICh5ICsgYm94SGVpZ2h0KSkge1xuXHRcdFx0XHR5ID0gcG9pbnRZICsgcGxvdFRvcCArIGRpc3RhbmNlOyAvLyBiZWxvd1xuXHRcdFx0fVxuXHRcdH0gXG5cdFxuXHRcdC8vIE5vdyBpZiB0aGUgdG9vbHRpcCBpcyBiZWxvdyB0aGUgY2hhcnQsIG1vdmUgaXQgdXAuIEl0J3MgYmV0dGVyIHRvIGNvdmVyIHRoZVxuXHRcdC8vIHBvaW50IHRoYW4gdG8gZGlzYXBwZWFyIG91dHNpZGUgdGhlIGNoYXJ0LiAjODM0LlxuXHRcdGlmICh5ICsgYm94SGVpZ2h0ID4gcGxvdFRvcCArIHBsb3RIZWlnaHQpIHtcblx0XHRcdHkgPSBtYXRoTWF4KHBsb3RUb3AsIHBsb3RUb3AgKyBwbG90SGVpZ2h0IC0gYm94SGVpZ2h0IC0gZGlzdGFuY2UpOyAvLyBiZWxvd1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcblx0fSxcblxuXHQvKipcblx0ICogSW4gY2FzZSBubyB1c2VyIGRlZmluZWQgZm9ybWF0dGVyIGlzIGdpdmVuLCB0aGlzIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHRoZSBjb250ZXh0XG5cdCAqIGhlcmUgaXMgYW4gb2JqZWN0IGhvbGRpbmcgcG9pbnQsIHNlcmllcywgeCwgeSBldGMuXG5cdCAqL1xuXHRkZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMucG9pbnRzIHx8IHNwbGF0KHRoaXMpLFxuXHRcdFx0c2VyaWVzID0gaXRlbXNbMF0uc2VyaWVzLFxuXHRcdFx0cztcblxuXHRcdC8vIGJ1aWxkIHRoZSBoZWFkZXJcblx0XHRzID0gW3Nlcmllcy50b29sdGlwSGVhZGVyRm9ybWF0dGVyKGl0ZW1zWzBdKV07XG5cblx0XHQvLyBidWlsZCB0aGUgdmFsdWVzXG5cdFx0ZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHNlcmllcyA9IGl0ZW0uc2VyaWVzO1xuXHRcdFx0cy5wdXNoKChzZXJpZXMudG9vbHRpcEZvcm1hdHRlciAmJiBzZXJpZXMudG9vbHRpcEZvcm1hdHRlcihpdGVtKSkgfHxcblx0XHRcdFx0aXRlbS5wb2ludC50b29sdGlwRm9ybWF0dGVyKHNlcmllcy50b29sdGlwT3B0aW9ucy5wb2ludEZvcm1hdCkpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZm9vdGVyXG5cdFx0cy5wdXNoKHRvb2x0aXAub3B0aW9ucy5mb290ZXJGb3JtYXQgfHwgJycpO1xuXG5cdFx0cmV0dXJuIHMuam9pbignJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZnJlc2ggdGhlIHRvb2x0aXAncyB0ZXh0IGFuZCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG5cdCAqL1xuXHRyZWZyZXNoOiBmdW5jdGlvbiAocG9pbnQsIG1vdXNlRXZlbnQpIHtcblx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHRvb2x0aXAuY2hhcnQsXG5cdFx0XHRsYWJlbCA9IHRvb2x0aXAubGFiZWwsXG5cdFx0XHRvcHRpb25zID0gdG9vbHRpcC5vcHRpb25zLFxuXHRcdFx0eCxcblx0XHRcdHksXG5cdFx0XHRhbmNob3IsXG5cdFx0XHR0ZXh0Q29uZmlnID0ge30sXG5cdFx0XHR0ZXh0LFxuXHRcdFx0cG9pbnRDb25maWcgPSBbXSxcblx0XHRcdGZvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IHRvb2x0aXAuZGVmYXVsdEZvcm1hdHRlcixcblx0XHRcdGhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludHMsXG5cdFx0XHRib3JkZXJDb2xvcixcblx0XHRcdGNyb3NzaGFpcnNPcHRpb25zID0gb3B0aW9ucy5jcm9zc2hhaXJzLFxuXHRcdFx0c2hhcmVkID0gdG9vbHRpcC5zaGFyZWQsXG5cdFx0XHRjdXJyZW50U2VyaWVzO1xuXHRcdFx0XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcblx0XHRcblx0XHQvLyBnZXQgdGhlIHJlZmVyZW5jZSBwb2ludCBjb29yZGluYXRlcyAocGllIGNoYXJ0cyB1c2UgdG9vbHRpcFBvcylcblx0XHR0b29sdGlwLmZvbGxvd1BvaW50ZXIgPSBzcGxhdChwb2ludClbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG5cdFx0YW5jaG9yID0gdG9vbHRpcC5nZXRBbmNob3IocG9pbnQsIG1vdXNlRXZlbnQpO1xuXHRcdHggPSBhbmNob3JbMF07XG5cdFx0eSA9IGFuY2hvclsxXTtcblxuXHRcdC8vIHNoYXJlZCB0b29sdGlwLCBhcnJheSBpcyBzZW50IG92ZXJcblx0XHRpZiAoc2hhcmVkICYmICEocG9pbnQuc2VyaWVzICYmIHBvaW50LnNlcmllcy5ub1NoYXJlZFRvb2x0aXApKSB7XG5cdFx0XHRcblx0XHRcdC8vIGhpZGUgcHJldmlvdXMgaG92ZXJQb2ludHMgYW5kIHNldCBuZXdcblx0XHRcdFxuXHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBwb2ludDtcblx0XHRcdGlmIChob3ZlclBvaW50cykge1xuXHRcdFx0XHRlYWNoKGhvdmVyUG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0ZWFjaChwb2ludCwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0aXRlbS5zZXRTdGF0ZShIT1ZFUl9TVEFURSk7XG5cblx0XHRcdFx0cG9pbnRDb25maWcucHVzaChpdGVtLmdldExhYmVsQ29uZmlnKCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRleHRDb25maWcgPSB7XG5cdFx0XHRcdHg6IHBvaW50WzBdLmNhdGVnb3J5LFxuXHRcdFx0XHR5OiBwb2ludFswXS55XG5cdFx0XHR9O1xuXHRcdFx0dGV4dENvbmZpZy5wb2ludHMgPSBwb2ludENvbmZpZztcblx0XHRcdHBvaW50ID0gcG9pbnRbMF07XG5cblx0XHQvLyBzaW5nbGUgcG9pbnQgdG9vbHRpcFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXh0Q29uZmlnID0gcG9pbnQuZ2V0TGFiZWxDb25maWcoKTtcblx0XHR9XG5cdFx0dGV4dCA9IGZvcm1hdHRlci5jYWxsKHRleHRDb25maWcsIHRvb2x0aXApO1xuXG5cdFx0Ly8gcmVnaXN0ZXIgdGhlIGN1cnJlbnQgc2VyaWVzXG5cdFx0Y3VycmVudFNlcmllcyA9IHBvaW50LnNlcmllcztcblxuXHRcdC8vIHVwZGF0ZSB0aGUgaW5uZXIgSFRNTFxuXHRcdGlmICh0ZXh0ID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gc2hvdyBpdFxuXHRcdFx0aWYgKHRvb2x0aXAuaXNIaWRkZW4pIHtcblx0XHRcdFx0c3RvcChsYWJlbCk7XG5cdFx0XHRcdGxhYmVsLmF0dHIoJ29wYWNpdHknLCAxKS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSB0ZXh0XG5cdFx0XHRsYWJlbC5hdHRyKHtcblx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNldCB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBib3hcblx0XHRcdGJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvciB8fCBwb2ludC5jb2xvciB8fCBjdXJyZW50U2VyaWVzLmNvbG9yIHx8ICcjNjA2MDYwJztcblx0XHRcdGxhYmVsLmF0dHIoe1xuXHRcdFx0XHRzdHJva2U6IGJvcmRlckNvbG9yXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IHBsb3RYOiB4LCBwbG90WTogeSB9KTtcblx0XHRcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBjcm9zc2hhaXJzXG5cdFx0aWYgKGNyb3NzaGFpcnNPcHRpb25zKSB7XG5cdFx0XHRjcm9zc2hhaXJzT3B0aW9ucyA9IHNwbGF0KGNyb3NzaGFpcnNPcHRpb25zKTsgLy8gW3gsIHldXG5cblx0XHRcdHZhciBwYXRoLFxuXHRcdFx0XHRpID0gY3Jvc3NoYWlyc09wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRhdHRyaWJzLFxuXHRcdFx0XHRheGlzLFxuXHRcdFx0XHR2YWwsXG5cdFx0XHRcdHNlcmllcztcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXM7XG5cdFx0XHRcdGF4aXMgPSBzZXJpZXNbaSA/ICd5QXhpcycgOiAneEF4aXMnXTtcblx0XHRcdFx0aWYgKGNyb3NzaGFpcnNPcHRpb25zW2ldICYmIGF4aXMpIHtcblx0XHRcdFx0XHR2YWwgPSBpID8gcGljayhwb2ludC5zdGFja1ksIHBvaW50LnkpIDogcG9pbnQueDsgLy8gIzgxNFxuXHRcdFx0XHRcdGlmIChheGlzLmlzTG9nKSB7IC8vICMxNjcxXG5cdFx0XHRcdFx0XHR2YWwgPSBsb2cybGluKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpID09PSAxICYmIHNlcmllcy5tb2RpZnlWYWx1ZSkgeyAvLyAjMTIwNSwgIzIzMTZcblx0XHRcdFx0XHRcdHZhbCA9IHNlcmllcy5tb2RpZnlWYWx1ZSh2YWwpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBhdGggPSBheGlzLmdldFBsb3RMaW5lUGF0aChcblx0XHRcdFx0XHRcdHZhbCxcblx0XHRcdFx0XHRcdDFcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKHRvb2x0aXAuY3Jvc3NoYWlyc1tpXSkge1xuXHRcdFx0XHRcdFx0dG9vbHRpcC5jcm9zc2hhaXJzW2ldLmF0dHIoeyBkOiBwYXRoLCB2aXNpYmlsaXR5OiBWSVNJQkxFIH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogY3Jvc3NoYWlyc09wdGlvbnNbaV0ud2lkdGggfHwgMSxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBjcm9zc2hhaXJzT3B0aW9uc1tpXS5jb2xvciB8fCAnI0MwQzBDMCcsXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogY3Jvc3NoYWlyc09wdGlvbnNbaV0uekluZGV4IHx8IDJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoY3Jvc3NoYWlyc09wdGlvbnNbaV0uZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gY3Jvc3NoYWlyc09wdGlvbnNbaV0uZGFzaFN0eWxlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG9vbHRpcC5jcm9zc2hhaXJzW2ldID0gY2hhcnQucmVuZGVyZXIucGF0aChwYXRoKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKVxuXHRcdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZpcmVFdmVudChjaGFydCwgJ3Rvb2x0aXBSZWZyZXNoJywge1xuXHRcdFx0XHR0ZXh0OiB0ZXh0LFxuXHRcdFx0XHR4OiB4ICsgY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdHk6IHkgKyBjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogYm9yZGVyQ29sb3Jcblx0XHRcdH0pO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEZpbmQgdGhlIG5ldyBwb3NpdGlvbiBhbmQgcGVyZm9ybSB0aGUgbW92ZVxuXHQgKi9cblx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsIFxuXHRcdFx0cG9zID0gKHRoaXMub3B0aW9ucy5wb3NpdGlvbmVyIHx8IHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwoXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdGxhYmVsLndpZHRoLFxuXHRcdFx0XHRsYWJlbC5oZWlnaHQsXG5cdFx0XHRcdHBvaW50XG5cdFx0XHQpO1xuXG5cdFx0Ly8gZG8gdGhlIG1vdmVcblx0XHR0aGlzLm1vdmUoXG5cdFx0XHRtYXRoUm91bmQocG9zLngpLCBcblx0XHRcdG1hdGhSb3VuZChwb3MueSksIFxuXHRcdFx0cG9pbnQucGxvdFggKyBjaGFydC5wbG90TGVmdCwgXG5cdFx0XHRwb2ludC5wbG90WSArIGNoYXJ0LnBsb3RUb3Bcblx0XHQpO1xuXHR9XG59O1xuLyoqXG4gKiBUaGUgbW91c2UgdHJhY2tlciBvYmplY3QuIEFsbCBtZXRob2RzIHN0YXJ0aW5nIHdpdGggXCJvblwiIGFyZSBwcmltYXJ5IERPTSBldmVudCBoYW5kbGVycy4gXG4gKiBTdWJzZXF1ZW50IG1ldGhvZHMgc2hvdWxkIGJlIG5hbWVkIGRpZmZlcmVudGx5IGZyb20gd2hhdCB0aGV5IGFyZSBkb2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgQ2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSByb290IG9wdGlvbnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIFBvaW50ZXIoY2hhcnQsIG9wdGlvbnMpIHtcblx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcbn1cblxuUG9pbnRlci5wcm90b3R5cGUgPSB7XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIFBvaW50ZXJcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFxuXHRcdHZhciBjaGFydE9wdGlvbnMgPSBvcHRpb25zLmNoYXJ0LFxuXHRcdFx0Y2hhcnRFdmVudHMgPSBjaGFydE9wdGlvbnMuZXZlbnRzLFxuXHRcdFx0em9vbVR5cGUgPSB1c2VDYW5WRyA/ICcnIDogY2hhcnRPcHRpb25zLnpvb21UeXBlLFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdHpvb21YLFxuXHRcdFx0em9vbVk7XG5cblx0XHQvLyBTdG9yZSByZWZlcmVuY2VzXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XG5cdFx0Ly8gWm9vbSBzdGF0dXNcblx0XHR0aGlzLnpvb21YID0gem9vbVggPSAveC8udGVzdCh6b29tVHlwZSk7XG5cdFx0dGhpcy56b29tWSA9IHpvb21ZID0gL3kvLnRlc3Qoem9vbVR5cGUpO1xuXHRcdHRoaXMuem9vbUhvciA9ICh6b29tWCAmJiAhaW52ZXJ0ZWQpIHx8ICh6b29tWSAmJiBpbnZlcnRlZCk7XG5cdFx0dGhpcy56b29tVmVydCA9ICh6b29tWSAmJiAhaW52ZXJ0ZWQpIHx8ICh6b29tWCAmJiBpbnZlcnRlZCk7XG5cblx0XHQvLyBEbyB3ZSBuZWVkIHRvIGhhbmRsZSBjbGljayBvbiBhIHRvdWNoIGRldmljZT9cblx0XHR0aGlzLnJ1bkNoYXJ0Q2xpY2sgPSBjaGFydEV2ZW50cyAmJiAhIWNoYXJ0RXZlbnRzLmNsaWNrO1xuXG5cdFx0dGhpcy5waW5jaERvd24gPSBbXTtcblx0XHR0aGlzLmxhc3RWYWxpZFRvdWNoID0ge307XG5cblx0XHRpZiAob3B0aW9ucy50b29sdGlwLmVuYWJsZWQpIHtcblx0XHRcdGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcChjaGFydCwgb3B0aW9ucy50b29sdGlwKTtcblx0XHR9XG5cblx0XHR0aGlzLnNldERPTUV2ZW50cygpO1xuXHR9LCBcblxuXHQvKipcblx0ICogQWRkIGNyb3NzYnJvd3NlciBzdXBwb3J0IGZvciBjaGFydFggYW5kIGNoYXJ0WVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0IGluIHN0YW5kYXJkIGJyb3dzZXJzXG5cdCAqL1xuXHRub3JtYWxpemU6IGZ1bmN0aW9uIChlLCBjaGFydFBvc2l0aW9uKSB7XG5cdFx0dmFyIGNoYXJ0WCxcblx0XHRcdGNoYXJ0WSxcblx0XHRcdGVQb3M7XG5cblx0XHQvLyBjb21tb24gSUUgbm9ybWFsaXppbmdcblx0XHRlID0gZSB8fCB3aW4uZXZlbnQ7XG5cdFx0aWYgKCFlLnRhcmdldCkge1xuXHRcdFx0ZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gRnJhbWV3b3JrIHNwZWNpZmljIG5vcm1hbGl6aW5nICgjMTE2NSlcblx0XHRlID0gd2FzaE1vdXNlRXZlbnQoZSk7XG5cdFx0XG5cdFx0Ly8gaU9TXG5cdFx0ZVBvcyA9IGUudG91Y2hlcyA/IGUudG91Y2hlcy5pdGVtKDApIDogZTtcblxuXHRcdC8vIEdldCBtb3VzZSBwb3NpdGlvblxuXHRcdGlmICghY2hhcnRQb3NpdGlvbikge1xuXHRcdFx0dGhpcy5jaGFydFBvc2l0aW9uID0gY2hhcnRQb3NpdGlvbiA9IG9mZnNldCh0aGlzLmNoYXJ0LmNvbnRhaW5lcik7XG5cdFx0fVxuXG5cdFx0Ly8gY2hhcnRYIGFuZCBjaGFydFlcblx0XHRpZiAoZVBvcy5wYWdlWCA9PT0gVU5ERUZJTkVEKSB7IC8vIElFIDwgOS4gIzg4Ni5cblx0XHRcdGNoYXJ0WCA9IG1hdGhNYXgoZS54LCBlLmNsaWVudFggLSBjaGFydFBvc2l0aW9uLmxlZnQpOyAvLyAjMjAwNSwgIzIxMjk6IHRoZSBzZWNvbmQgY2FzZSBpcyBcblx0XHRcdFx0Ly8gZm9yIElFMTAgcXVpcmtzIG1vZGUgd2l0aGluIGZyYW1lc2V0c1xuXHRcdFx0Y2hhcnRZID0gZS55O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGFydFggPSBlUG9zLnBhZ2VYIC0gY2hhcnRQb3NpdGlvbi5sZWZ0O1xuXHRcdFx0Y2hhcnRZID0gZVBvcy5wYWdlWSAtIGNoYXJ0UG9zaXRpb24udG9wO1xuXHRcdH1cblxuXHRcdHJldHVybiBleHRlbmQoZSwge1xuXHRcdFx0Y2hhcnRYOiBtYXRoUm91bmQoY2hhcnRYKSxcblx0XHRcdGNoYXJ0WTogbWF0aFJvdW5kKGNoYXJ0WSlcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBjbGljayBwb3NpdGlvbiBpbiB0ZXJtcyBvZiBheGlzIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgQSBwb2ludGVyIGV2ZW50XG5cdCAqL1xuXHRnZXRDb29yZGluYXRlczogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgY29vcmRpbmF0ZXMgPSB7XG5cdFx0XHRcdHhBeGlzOiBbXSxcblx0XHRcdFx0eUF4aXM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0ZWFjaCh0aGlzLmNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRjb29yZGluYXRlc1theGlzLmlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ10ucHVzaCh7XG5cdFx0XHRcdGF4aXM6IGF4aXMsXG5cdFx0XHRcdHZhbHVlOiBheGlzLnRvVmFsdWUoZVtheGlzLmhvcml6ID8gJ2NoYXJ0WCcgOiAnY2hhcnRZJ10pXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gY29vcmRpbmF0ZXM7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBpbmRleCBpbiB0aGUgdG9vbHRpcFBvaW50cyBhcnJheSwgY29ycmVzcG9uZGluZyB0byBwaXhlbCBwb3NpdGlvbiBpbiBcblx0ICogdGhlIHBsb3QgYXJlYS5cblx0ICovXG5cdGdldEluZGV4OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0cmV0dXJuIGNoYXJ0LmludmVydGVkID8gXG5cdFx0XHRjaGFydC5wbG90SGVpZ2h0ICsgY2hhcnQucGxvdFRvcCAtIGUuY2hhcnRZIDogXG5cdFx0XHRlLmNoYXJ0WCAtIGNoYXJ0LnBsb3RMZWZ0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBXaXRoIGxpbmUgdHlwZSBjaGFydHMgd2l0aCBhIHNpbmdsZSB0cmFja2VyLCBnZXQgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIG1vdXNlLlxuXHQgKiBSdW4gUG9pbnQub25Nb3VzZU92ZXIgYW5kIGRpc3BsYXkgdG9vbHRpcCBmb3IgdGhlIHBvaW50IG9yIHBvaW50cy5cblx0ICovXG5cdHJ1blBvaW50QWN0aW9uczogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHBvaW50ZXIuY2hhcnQsXG5cdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdHBvaW50LFxuXHRcdFx0cG9pbnRzLFxuXHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQsXG5cdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0aSxcblx0XHRcdGosXG5cdFx0XHRkaXN0YW5jZSA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRpbmRleCA9IHBvaW50ZXIuZ2V0SW5kZXgoZSksXG5cdFx0XHRhbmNob3I7XG5cblx0XHQvLyBzaGFyZWQgdG9vbHRpcFxuXHRcdGlmICh0b29sdGlwICYmIHBvaW50ZXIub3B0aW9ucy50b29sdGlwLnNoYXJlZCAmJiAhKGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdHBvaW50cyA9IFtdO1xuXG5cdFx0XHQvLyBsb29wIG92ZXIgYWxsIHNlcmllcyBhbmQgZmluZCB0aGUgb25lcyB3aXRoIHBvaW50cyBjbG9zZXN0IHRvIHRoZSBtb3VzZVxuXHRcdFx0aSA9IHNlcmllcy5sZW5ndGg7XG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG5cdFx0XHRcdGlmIChzZXJpZXNbal0udmlzaWJsZSAmJlxuXHRcdFx0XHRcdFx0c2VyaWVzW2pdLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyAhPT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdCFzZXJpZXNbal0ubm9TaGFyZWRUb29sdGlwICYmIHNlcmllc1tqXS50b29sdGlwUG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHBvaW50ID0gc2VyaWVzW2pdLnRvb2x0aXBQb2ludHNbaW5kZXhdO1xuXHRcdFx0XHRcdGlmIChwb2ludCAmJiBwb2ludC5zZXJpZXMpIHsgLy8gbm90IGEgZHVtbXkgcG9pbnQsICMxNTQ0XG5cdFx0XHRcdFx0XHRwb2ludC5fZGlzdCA9IG1hdGhBYnMoaW5kZXggLSBwb2ludC5jbGllbnRYKTtcblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gbWF0aE1pbihkaXN0YW5jZSwgcG9pbnQuX2Rpc3QpO1xuXHRcdFx0XHRcdFx0cG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVtb3ZlIGZ1cnRoZXN0IHBvaW50c1xuXHRcdFx0aSA9IHBvaW50cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChwb2ludHNbaV0uX2Rpc3QgPiBkaXN0YW5jZSkge1xuXHRcdFx0XHRcdHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHJlZnJlc2ggdGhlIHRvb2x0aXAgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAocG9pbnRzLmxlbmd0aCAmJiAocG9pbnRzWzBdLmNsaWVudFggIT09IHBvaW50ZXIuaG92ZXJYKSkge1xuXHRcdFx0XHR0b29sdGlwLnJlZnJlc2gocG9pbnRzLCBlKTtcblx0XHRcdFx0cG9pbnRlci5ob3ZlclggPSBwb2ludHNbMF0uY2xpZW50WDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzZXBhcmF0ZSB0b29sdGlwIGFuZCBnZW5lcmFsIG1vdXNlIGV2ZW50c1xuXHRcdGlmIChob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcy50cmFja2VyKSB7IC8vIG9ubHkgdXNlIGZvciBsaW5lLXR5cGUgc2VyaWVzIHdpdGggY29tbW9uIHRyYWNrZXJcblxuXHRcdFx0Ly8gZ2V0IHRoZSBwb2ludFxuXHRcdFx0cG9pbnQgPSBob3ZlclNlcmllcy50b29sdGlwUG9pbnRzW2luZGV4XTtcblxuXHRcdFx0Ly8gYSBuZXcgcG9pbnQgaXMgaG92ZXJlZCwgcmVmcmVzaCB0aGUgdG9vbHRpcFxuXHRcdFx0aWYgKHBvaW50ICYmIHBvaW50ICE9PSBob3ZlclBvaW50KSB7XG5cblx0XHRcdFx0Ly8gdHJpZ2dlciB0aGUgZXZlbnRzXG5cdFx0XHRcdHBvaW50Lm9uTW91c2VPdmVyKGUpO1xuXG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9IGVsc2UgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5mb2xsb3dQb2ludGVyICYmICF0b29sdGlwLmlzSGlkZGVuKSB7XG5cdFx0XHRhbmNob3IgPSB0b29sdGlwLmdldEFuY2hvcihbe31dLCBlKTtcblx0XHRcdHRvb2x0aXAudXBkYXRlUG9zaXRpb24oeyBwbG90WDogYW5jaG9yWzBdLCBwbG90WTogYW5jaG9yWzFdIH0pO1xuXHRcdH1cblx0fSxcblxuXG5cblx0LyoqXG5cdCAqIFJlc2V0IHRoZSB0cmFja2luZyBieSBoaWRpbmcgdGhlIHRvb2x0aXAsIHRoZSBob3ZlciBzZXJpZXMgc3RhdGUgYW5kIHRoZSBob3ZlciBwb2ludFxuXHQgKiBcblx0ICogQHBhcmFtIGFsbG93TW92ZSB7Qm9vbGVhbn0gSW5zdGVhZCBvZiBkZXN0cm95aW5nIHRoZSB0b29sdGlwIGFsdG9nZXRoZXIsIGFsbG93IG1vdmluZyBpdCBpZiBwb3NzaWJsZVxuXHQgKi9cblx0cmVzZXQ6IGZ1bmN0aW9uIChhbGxvd01vdmUpIHtcblx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHBvaW50ZXIuY2hhcnQsXG5cdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQsXG5cdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdHRvb2x0aXBQb2ludHMgPSB0b29sdGlwICYmIHRvb2x0aXAuc2hhcmVkID8gY2hhcnQuaG92ZXJQb2ludHMgOiBob3ZlclBvaW50O1xuXHRcdFx0XG5cdFx0Ly8gTmFycm93IGluIGFsbG93TW92ZVxuXHRcdGFsbG93TW92ZSA9IGFsbG93TW92ZSAmJiB0b29sdGlwICYmIHRvb2x0aXBQb2ludHM7XG5cdFx0XHRcblx0XHQvLyBDaGVjayBpZiB0aGUgcG9pbnRzIGhhdmUgbW92ZWQgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCAjMTAwM1xuXHRcdGlmIChhbGxvd01vdmUgJiYgc3BsYXQodG9vbHRpcFBvaW50cylbMF0ucGxvdFggPT09IFVOREVGSU5FRCkge1xuXHRcdFx0YWxsb3dNb3ZlID0gZmFsc2U7XG5cdFx0fVx0XG5cblx0XHQvLyBKdXN0IG1vdmUgdGhlIHRvb2x0aXAsICMzNDlcblx0XHRpZiAoYWxsb3dNb3ZlKSB7XG5cdFx0XHR0b29sdGlwLnJlZnJlc2godG9vbHRpcFBvaW50cyk7XG5cblx0XHQvLyBGdWxsIHJlc2V0XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKGhvdmVyUG9pbnQpIHtcblx0XHRcdFx0aG92ZXJQb2ludC5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChob3ZlclNlcmllcykge1xuXHRcdFx0XHRob3ZlclNlcmllcy5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRcdHRvb2x0aXAuaGlkZSgpO1xuXHRcdFx0XHR0b29sdGlwLmhpZGVDcm9zc2hhaXJzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50ZXIuaG92ZXJYID0gbnVsbDtcblxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2NhbGUgc2VyaWVzIGdyb3VwcyB0byBhIGNlcnRhaW4gc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG5cdCAqL1xuXHRzY2FsZUdyb3VwczogZnVuY3Rpb24gKGF0dHJpYnMsIGNsaXApIHtcblxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRzZXJpZXNBdHRyaWJzO1xuXG5cdFx0Ly8gU2NhbGUgZWFjaCBzZXJpZXNcblx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0c2VyaWVzQXR0cmlicyA9IGF0dHJpYnMgfHwgc2VyaWVzLmdldFBsb3RCb3goKTsgLy8gIzE3MDFcblx0XHRcdGlmIChzZXJpZXMueEF4aXMgJiYgc2VyaWVzLnhBeGlzLnpvb21FbmFibGVkKSB7XG5cdFx0XHRcdHNlcmllcy5ncm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRpZiAoc2VyaWVzLm1hcmtlckdyb3VwKSB7XG5cdFx0XHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwLmF0dHIoc2VyaWVzQXR0cmlicyk7XG5cdFx0XHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwLmNsaXAoY2xpcCA/IGNoYXJ0LmNsaXBSZWN0IDogbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlcmllcy5kYXRhTGFiZWxzR3JvdXApIHtcblx0XHRcdFx0XHRzZXJpZXMuZGF0YUxhYmVsc0dyb3VwLmF0dHIoc2VyaWVzQXR0cmlicyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHQvLyBDbGlwXG5cdFx0Y2hhcnQuY2xpcFJlY3QuYXR0cihjbGlwIHx8IGNoYXJ0LmNsaXBCb3gpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSdW4gdHJhbnNsYXRpb24gb3BlcmF0aW9ucyBmb3IgZWFjaCBkaXJlY3Rpb24gKGhvcml6b250YWwgYW5kIHZlcnRpY2FsKSBpbmRlcGVuZGVudGx5XG5cdCAqL1xuXHRwaW5jaFRyYW5zbGF0ZURpcmVjdGlvbjogZnVuY3Rpb24gKGhvcml6LCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHR4eSA9IGhvcml6ID8gJ3gnIDogJ3knLFxuXHRcdFx0WFkgPSBob3JpeiA/ICdYJyA6ICdZJyxcblx0XHRcdHNDaGFydFhZID0gJ2NoYXJ0JyArIFhZLFxuXHRcdFx0d2ggPSBob3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0Jyxcblx0XHRcdHBsb3RMZWZ0VG9wID0gY2hhcnRbJ3Bsb3QnICsgKGhvcml6ID8gJ0xlZnQnIDogJ1RvcCcpXSxcblx0XHRcdHNlbGVjdGlvbldILFxuXHRcdFx0c2VsZWN0aW9uWFksXG5cdFx0XHRjbGlwWFksXG5cdFx0XHRzY2FsZSA9IDEsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0Ym91bmRzID0gY2hhcnQuYm91bmRzW2hvcml6ID8gJ2gnIDogJ3YnXSxcblx0XHRcdHNpbmdsZVRvdWNoID0gcGluY2hEb3duLmxlbmd0aCA9PT0gMSxcblx0XHRcdHRvdWNoMFN0YXJ0ID0gcGluY2hEb3duWzBdW3NDaGFydFhZXSxcblx0XHRcdHRvdWNoME5vdyA9IHRvdWNoZXNbMF1bc0NoYXJ0WFldLFxuXHRcdFx0dG91Y2gxU3RhcnQgPSAhc2luZ2xlVG91Y2ggJiYgcGluY2hEb3duWzFdW3NDaGFydFhZXSxcblx0XHRcdHRvdWNoMU5vdyA9ICFzaW5nbGVUb3VjaCAmJiB0b3VjaGVzWzFdW3NDaGFydFhZXSxcblx0XHRcdG91dE9mQm91bmRzLFxuXHRcdFx0dHJhbnNmb3JtU2NhbGUsXG5cdFx0XHRzY2FsZUtleSxcblx0XHRcdHNldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIXNpbmdsZVRvdWNoICYmIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCkgPiAyMCkgeyAvLyBEb24ndCB6b29tIGlmIGZpbmdlcnMgYXJlIHRvbyBjbG9zZSBvbiB0aGlzIGF4aXNcblx0XHRcdFx0XHRzY2FsZSA9IG1hdGhBYnModG91Y2gwTm93IC0gdG91Y2gxTm93KSAvIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCk7XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y2xpcFhZID0gKChwbG90TGVmdFRvcCAtIHRvdWNoME5vdykgLyBzY2FsZSkgKyB0b3VjaDBTdGFydDtcblx0XHRcdFx0c2VsZWN0aW9uV0ggPSBjaGFydFsncGxvdCcgKyAoaG9yaXogPyAnV2lkdGgnIDogJ0hlaWdodCcpXSAvIHNjYWxlO1xuXHRcdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgc2NhbGUsIGZpcnN0IHBhc3Ncblx0XHRzZXRTY2FsZSgpO1xuXG5cdFx0c2VsZWN0aW9uWFkgPSBjbGlwWFk7IC8vIHRoZSBjbGlwIHBvc2l0aW9uICh4IG9yIHkpIGlzIGFsdGVyZWQgaWYgb3V0IG9mIGJvdW5kcywgdGhlIHNlbGVjdGlvbiBwb3NpdGlvbiBpcyBub3RcblxuXHRcdC8vIE91dCBvZiBib3VuZHNcblx0XHRpZiAoc2VsZWN0aW9uWFkgPCBib3VuZHMubWluKSB7XG5cdFx0XHRzZWxlY3Rpb25YWSA9IGJvdW5kcy5taW47XG5cdFx0XHRvdXRPZkJvdW5kcyA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChzZWxlY3Rpb25YWSArIHNlbGVjdGlvbldIID4gYm91bmRzLm1heCkge1xuXHRcdFx0c2VsZWN0aW9uWFkgPSBib3VuZHMubWF4IC0gc2VsZWN0aW9uV0g7XG5cdFx0XHRvdXRPZkJvdW5kcyA9IHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElzIHRoZSBjaGFydCBkcmFnZ2VkIG9mZiBpdHMgYm91bmRzLCBkZXRlcm1pbmVkIGJ5IGRhdGFNaW4gYW5kIGRhdGFNYXg/XG5cdFx0aWYgKG91dE9mQm91bmRzKSB7XG5cblx0XHRcdC8vIE1vZGlmeSB0aGUgdG91Y2hOb3cgcG9zaXRpb24gaW4gb3JkZXIgdG8gY3JlYXRlIGFuIGVsYXN0aWMgZHJhZyBtb3ZlbWVudC4gVGhpcyBpbmRpY2F0ZXNcblx0XHRcdC8vIHRvIHRoZSB1c2VyIHRoYXQgdGhlIGNoYXJ0IGlzIHJlc3BvbnNpdmUgYnV0IGNhbid0IGJlIGRyYWdnZWQgZnVydGhlci5cblx0XHRcdHRvdWNoME5vdyAtPSAwLjggKiAodG91Y2gwTm93IC0gbGFzdFZhbGlkVG91Y2hbeHldWzBdKTtcblx0XHRcdGlmICghc2luZ2xlVG91Y2gpIHtcblx0XHRcdFx0dG91Y2gxTm93IC09IDAuOCAqICh0b3VjaDFOb3cgLSBsYXN0VmFsaWRUb3VjaFt4eV1bMV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIHNjYWxlLCBzZWNvbmQgcGFzcyB0byBhZGFwdCB0byB0aGUgbW9kaWZpZWQgdG91Y2hOb3cgcG9zaXRpb25zXG5cdFx0XHRzZXRTY2FsZSgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxhc3RWYWxpZFRvdWNoW3h5XSA9IFt0b3VjaDBOb3csIHRvdWNoMU5vd107XG5cdFx0fVxuXG5cdFx0XG5cdFx0Ly8gU2V0IGdlb21ldHJ5IGZvciBjbGlwcGluZywgc2VsZWN0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvblxuXHRcdGlmICghaW52ZXJ0ZWQpIHsgLy8gVE9ETzogaW1wbGVtZW50IGNsaXBwaW5nIGZvciBpbnZlcnRlZCBjaGFydHNcblx0XHRcdGNsaXBbeHldID0gY2xpcFhZIC0gcGxvdExlZnRUb3A7XG5cdFx0XHRjbGlwW3doXSA9IHNlbGVjdGlvbldIO1xuXHRcdH1cblx0XHRzY2FsZUtleSA9IGludmVydGVkID8gKGhvcml6ID8gJ3NjYWxlWScgOiAnc2NhbGVYJykgOiAnc2NhbGUnICsgWFk7XG5cdFx0dHJhbnNmb3JtU2NhbGUgPSBpbnZlcnRlZCA/IDEgLyBzY2FsZSA6IHNjYWxlO1xuXG5cdFx0c2VsZWN0aW9uTWFya2VyW3doXSA9IHNlbGVjdGlvbldIO1xuXHRcdHNlbGVjdGlvbk1hcmtlclt4eV0gPSBzZWxlY3Rpb25YWTtcblx0XHR0cmFuc2Zvcm1bc2NhbGVLZXldID0gc2NhbGU7XG5cdFx0dHJhbnNmb3JtWyd0cmFuc2xhdGUnICsgWFldID0gKHRyYW5zZm9ybVNjYWxlICogcGxvdExlZnRUb3ApICsgKHRvdWNoME5vdyAtICh0cmFuc2Zvcm1TY2FsZSAqIHRvdWNoMFN0YXJ0KSk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogSGFuZGxlIHRvdWNoIGV2ZW50cyB3aXRoIHR3byB0b3VjaGVzXG5cdCAqL1xuXHRwaW5jaDogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VsZi5jaGFydCxcblx0XHRcdHBpbmNoRG93biA9IHNlbGYucGluY2hEb3duLFxuXHRcdFx0Zm9sbG93VG91Y2hNb3ZlID0gY2hhcnQudG9vbHRpcCAmJiBjaGFydC50b29sdGlwLm9wdGlvbnMuZm9sbG93VG91Y2hNb3ZlLFxuXHRcdFx0dG91Y2hlcyA9IGUudG91Y2hlcyxcblx0XHRcdHRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aCxcblx0XHRcdGxhc3RWYWxpZFRvdWNoID0gc2VsZi5sYXN0VmFsaWRUb3VjaCxcblx0XHRcdHpvb21Ib3IgPSBzZWxmLnpvb21Ib3IgfHwgc2VsZi5waW5jaEhvcixcblx0XHRcdHpvb21WZXJ0ID0gc2VsZi56b29tVmVydCB8fCBzZWxmLnBpbmNoVmVydCxcblx0XHRcdGhhc1pvb20gPSB6b29tSG9yIHx8IHpvb21WZXJ0LFxuXHRcdFx0c2VsZWN0aW9uTWFya2VyID0gc2VsZi5zZWxlY3Rpb25NYXJrZXIsXG5cdFx0XHR0cmFuc2Zvcm0gPSB7fSxcblx0XHRcdGZpcmVDbGlja0V2ZW50ID0gdG91Y2hlc0xlbmd0aCA9PT0gMSAmJiAoKHNlbGYuaW5DbGFzcyhlLnRhcmdldCwgUFJFRklYICsgJ3RyYWNrZXInKSAmJiBcblx0XHRcdFx0Y2hhcnQucnVuVHJhY2tlckNsaWNrKSB8fCBjaGFydC5ydW5DaGFydENsaWNrKSxcblx0XHRcdGNsaXAgPSB7fTtcblxuXHRcdC8vIE9uIHRvdWNoIGRldmljZXMsIG9ubHkgcHJvY2VlZCB0byB0cmlnZ2VyIGNsaWNrIGlmIGEgaGFuZGxlciBpcyBkZWZpbmVkXG5cdFx0aWYgKChoYXNab29tIHx8IGZvbGxvd1RvdWNoTW92ZSkgJiYgIWZpcmVDbGlja0V2ZW50KSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIE5vcm1hbGl6ZSBlYWNoIHRvdWNoXG5cdFx0bWFwKHRvdWNoZXMsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5ub3JtYWxpemUoZSk7XG5cdFx0fSk7XG5cdFx0XHRcblx0XHQvLyBSZWdpc3RlciB0aGUgdG91Y2ggc3RhcnQgcG9zaXRpb25cblx0XHRpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdGVhY2godG91Y2hlcywgZnVuY3Rpb24gKGUsIGkpIHtcblx0XHRcdFx0cGluY2hEb3duW2ldID0geyBjaGFydFg6IGUuY2hhcnRYLCBjaGFydFk6IGUuY2hhcnRZIH07XG5cdFx0XHR9KTtcblx0XHRcdGxhc3RWYWxpZFRvdWNoLnggPSBbcGluY2hEb3duWzBdLmNoYXJ0WCwgcGluY2hEb3duWzFdICYmIHBpbmNoRG93blsxXS5jaGFydFhdO1xuXHRcdFx0bGFzdFZhbGlkVG91Y2gueSA9IFtwaW5jaERvd25bMF0uY2hhcnRZLCBwaW5jaERvd25bMV0gJiYgcGluY2hEb3duWzFdLmNoYXJ0WV07XG5cblx0XHRcdC8vIElkZW50aWZ5IHRoZSBkYXRhIGJvdW5kcyBpbiBwaXhlbHNcblx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMuem9vbUVuYWJsZWQpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2hhcnQuYm91bmRzW2F4aXMuaG9yaXogPyAnaCcgOiAndiddLFxuXHRcdFx0XHRcdFx0bWluUGl4ZWxQYWRkaW5nID0gYXhpcy5taW5QaXhlbFBhZGRpbmcsXG5cdFx0XHRcdFx0XHRtaW4gPSBheGlzLnRvUGl4ZWxzKGF4aXMuZGF0YU1pbiksXG5cdFx0XHRcdFx0XHRtYXggPSBheGlzLnRvUGl4ZWxzKGF4aXMuZGF0YU1heCksXG5cdFx0XHRcdFx0XHRhYnNNaW4gPSBtYXRoTWluKG1pbiwgbWF4KSxcblx0XHRcdFx0XHRcdGFic01heCA9IG1hdGhNYXgobWluLCBtYXgpO1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGJvdW5kcyBmb3IgdXNlIGluIHRoZSB0b3VjaG1vdmUgaGFuZGxlclxuXHRcdFx0XHRcdGJvdW5kcy5taW4gPSBtYXRoTWluKGF4aXMucG9zLCBhYnNNaW4gLSBtaW5QaXhlbFBhZGRpbmcpO1xuXHRcdFx0XHRcdGJvdW5kcy5tYXggPSBtYXRoTWF4KGF4aXMucG9zICsgYXhpcy5sZW4sIGFic01heCArIG1pblBpeGVsUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFxuXHRcdC8vIEV2ZW50IHR5cGUgaXMgdG91Y2htb3ZlLCBoYW5kbGUgcGFubmluZyBhbmQgcGluY2hpbmdcblx0XHR9IGVsc2UgaWYgKHBpbmNoRG93bi5sZW5ndGgpIHsgLy8gY2FuIGJlIDAgd2hlbiByZWxlYXNpbmcsIGlmIHRvdWNoZW5kIGZpcmVzIGZpcnN0XG5cdFx0XHRcblxuXHRcdFx0Ly8gU2V0IHRoZSBtYXJrZXJcblx0XHRcdGlmICghc2VsZWN0aW9uTWFya2VyKSB7XG5cdFx0XHRcdHNlbGYuc2VsZWN0aW9uTWFya2VyID0gc2VsZWN0aW9uTWFya2VyID0gZXh0ZW5kKHtcblx0XHRcdFx0XHRkZXN0cm95OiBub29wXG5cdFx0XHRcdH0sIGNoYXJ0LnBsb3RCb3gpO1xuXHRcdFx0fVxuXG5cdFx0XHRcblxuXHRcdFx0aWYgKHpvb21Ib3IpIHtcblx0XHRcdFx0c2VsZi5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbih0cnVlLCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoem9vbVZlcnQpIHtcblx0XHRcdFx0c2VsZi5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbihmYWxzZSwgcGluY2hEb3duLCB0b3VjaGVzLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1hcmtlciwgY2xpcCwgbGFzdFZhbGlkVG91Y2gpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLmhhc1BpbmNoZWQgPSBoYXNab29tO1xuXG5cdFx0XHQvLyBTY2FsZSBhbmQgdHJhbnNsYXRlIHRoZSBncm91cHMgdG8gcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2sgZHVyaW5nIHBpbmNoaW5nXG5cdFx0XHRzZWxmLnNjYWxlR3JvdXBzKHRyYW5zZm9ybSwgY2xpcCk7XG5cdFx0XHRcblx0XHRcdC8vIE9wdGlvbmFsbHkgbW92ZSB0aGUgdG9vbHRpcCBvbiB0b3VjaG1vdmVcblx0XHRcdGlmICghaGFzWm9vbSAmJiBmb2xsb3dUb3VjaE1vdmUgJiYgdG91Y2hlc0xlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhzZWxmLm5vcm1hbGl6ZShlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTdGFydCBhIGRyYWcgb3BlcmF0aW9uXG5cdCAqL1xuXHRkcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdC8vIFJlY29yZCB0aGUgc3RhcnQgcG9zaXRpb25cblx0XHRjaGFydC5tb3VzZUlzRG93biA9IGUudHlwZTtcblx0XHRjaGFydC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdGNoYXJ0Lm1vdXNlRG93blggPSB0aGlzLm1vdXNlRG93blggPSBlLmNoYXJ0WDtcblx0XHRjaGFydC5tb3VzZURvd25ZID0gdGhpcy5tb3VzZURvd25ZID0gZS5jaGFydFk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gYSBkcmFnIG9wZXJhdGlvbiBpbiByZXNwb25zZSB0byBhIG1vdXNlbW92ZSBldmVudCB3aGlsZSB0aGUgbW91c2UgaXMgZG93blxuXHQgKi9cblx0ZHJhZzogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0Y2hhcnRYID0gZS5jaGFydFgsXG5cdFx0XHRjaGFydFkgPSBlLmNoYXJ0WSxcblx0XHRcdHpvb21Ib3IgPSB0aGlzLnpvb21Ib3IsXG5cdFx0XHR6b29tVmVydCA9IHRoaXMuem9vbVZlcnQsXG5cdFx0XHRwbG90TGVmdCA9IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRwbG90V2lkdGggPSBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCxcblx0XHRcdGNsaWNrZWRJbnNpZGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0bW91c2VEb3duWCA9IHRoaXMubW91c2VEb3duWCxcblx0XHRcdG1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blk7XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhZGp1c3QgdG8gY29vb3JkaW5hdGVzXG5cdFx0Ly8gaW5zaWRlIHRvIHByZXZlbnQgdGhlIHNlbGVjdGlvbiBtYXJrZXIgZnJvbSBnb2luZyBvdXRzaWRlXG5cdFx0aWYgKGNoYXJ0WCA8IHBsb3RMZWZ0KSB7XG5cdFx0XHRjaGFydFggPSBwbG90TGVmdDtcblx0XHR9IGVsc2UgaWYgKGNoYXJ0WCA+IHBsb3RMZWZ0ICsgcGxvdFdpZHRoKSB7XG5cdFx0XHRjaGFydFggPSBwbG90TGVmdCArIHBsb3RXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAoY2hhcnRZIDwgcGxvdFRvcCkge1xuXHRcdFx0Y2hhcnRZID0gcGxvdFRvcDtcblx0XHR9IGVsc2UgaWYgKGNoYXJ0WSA+IHBsb3RUb3AgKyBwbG90SGVpZ2h0KSB7XG5cdFx0XHRjaGFydFkgPSBwbG90VG9wICsgcGxvdEhlaWdodDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBoYXMgbW92ZWQgbW9yZSB0aGFuIDEwcHhcblx0XHR0aGlzLmhhc0RyYWdnZWQgPSBNYXRoLnNxcnQoXG5cdFx0XHRNYXRoLnBvdyhtb3VzZURvd25YIC0gY2hhcnRYLCAyKSArXG5cdFx0XHRNYXRoLnBvdyhtb3VzZURvd25ZIC0gY2hhcnRZLCAyKVxuXHRcdCk7XG5cdFx0aWYgKHRoaXMuaGFzRHJhZ2dlZCA+IDEwKSB7XG5cdFx0XHRjbGlja2VkSW5zaWRlID0gY2hhcnQuaXNJbnNpZGVQbG90KG1vdXNlRG93blggLSBwbG90TGVmdCwgbW91c2VEb3duWSAtIHBsb3RUb3ApO1xuXG5cdFx0XHQvLyBtYWtlIGEgc2VsZWN0aW9uXG5cdFx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzICYmICh0aGlzLnpvb21YIHx8IHRoaXMuem9vbVkpICYmIGNsaWNrZWRJbnNpZGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyID0gY2hhcnQucmVuZGVyZXIucmVjdChcblx0XHRcdFx0XHRcdHBsb3RMZWZ0LFxuXHRcdFx0XHRcdFx0cGxvdFRvcCxcblx0XHRcdFx0XHRcdHpvb21Ib3IgPyAxIDogcGxvdFdpZHRoLFxuXHRcdFx0XHRcdFx0em9vbVZlcnQgPyAxIDogcGxvdEhlaWdodCxcblx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ZmlsbDogY2hhcnRPcHRpb25zLnNlbGVjdGlvbk1hcmtlckZpbGwgfHwgJ3JnYmEoNjksMTE0LDE2NywwLjI1KScsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gbWFya2VyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgem9vbUhvcikge1xuXHRcdFx0XHRzaXplID0gY2hhcnRYIC0gbW91c2VEb3duWDtcblx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIuYXR0cih7XG5cdFx0XHRcdFx0d2lkdGg6IG1hdGhBYnMoc2l6ZSksXG5cdFx0XHRcdFx0eDogKHNpemUgPiAwID8gMCA6IHNpemUpICsgbW91c2VEb3duWFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIGFkanVzdCB0aGUgaGVpZ2h0IG9mIHRoZSBzZWxlY3Rpb24gbWFya2VyXG5cdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgem9vbVZlcnQpIHtcblx0XHRcdFx0c2l6ZSA9IGNoYXJ0WSAtIG1vdXNlRG93blk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyLmF0dHIoe1xuXHRcdFx0XHRcdGhlaWdodDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHR5OiAoc2l6ZSA+IDAgPyAwIDogc2l6ZSkgKyBtb3VzZURvd25ZXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYW5uaW5nXG5cdFx0XHRpZiAoY2xpY2tlZEluc2lkZSAmJiAhdGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgY2hhcnRPcHRpb25zLnBhbm5pbmcpIHtcblx0XHRcdFx0Y2hhcnQucGFuKGUsIGNoYXJ0T3B0aW9ucy5wYW5uaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIE9uIG1vdXNlIHVwIG9yIHRvdWNoIGVuZCBhY3Jvc3MgdGhlIGVudGlyZSBkb2N1bWVudCwgZHJvcCB0aGUgc2VsZWN0aW9uLlxuXHQgKi9cblx0ZHJvcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0aGFzUGluY2hlZCA9IHRoaXMuaGFzUGluY2hlZDtcblxuXHRcdGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0dmFyIHNlbGVjdGlvbkRhdGEgPSB7XG5cdFx0XHRcdFx0eEF4aXM6IFtdLFxuXHRcdFx0XHRcdHlBeGlzOiBbXSxcblx0XHRcdFx0XHRvcmlnaW5hbEV2ZW50OiBlLm9yaWdpbmFsRXZlbnQgfHwgZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3Rpb25Cb3ggPSB0aGlzLnNlbGVjdGlvbk1hcmtlcixcblx0XHRcdFx0c2VsZWN0aW9uTGVmdCA9IHNlbGVjdGlvbkJveC54LFxuXHRcdFx0XHRzZWxlY3Rpb25Ub3AgPSBzZWxlY3Rpb25Cb3gueSxcblx0XHRcdFx0cnVuWm9vbTtcblx0XHRcdC8vIGEgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGVcblx0XHRcdGlmICh0aGlzLmhhc0RyYWdnZWQgfHwgaGFzUGluY2hlZCkge1xuXG5cdFx0XHRcdC8vIHJlY29yZCBlYWNoIGF4aXMnIG1pbiBhbmQgbWF4XG5cdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRpZiAoYXhpcy56b29tRW5hYmxlZCkge1xuXHRcdFx0XHRcdFx0dmFyIGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uTWluID0gYXhpcy50b1ZhbHVlKChob3JpeiA/IHNlbGVjdGlvbkxlZnQgOiBzZWxlY3Rpb25Ub3ApKSxcblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uTWF4ID0gYXhpcy50b1ZhbHVlKChob3JpeiA/IHNlbGVjdGlvbkxlZnQgKyBzZWxlY3Rpb25Cb3gud2lkdGggOiBzZWxlY3Rpb25Ub3AgKyBzZWxlY3Rpb25Cb3guaGVpZ2h0KSk7XG5cblx0XHRcdFx0XHRcdGlmICghaXNOYU4oc2VsZWN0aW9uTWluKSAmJiAhaXNOYU4oc2VsZWN0aW9uTWF4KSkgeyAvLyAjODU5XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGFbYXhpcy54T3JZICsgJ0F4aXMnXS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0XHRcdFx0XHRcdG1pbjogbWF0aE1pbihzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCksIC8vIGZvciByZXZlcnNlZCBheGVzLFxuXHRcdFx0XHRcdFx0XHRcdG1heDogbWF0aE1heChzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heClcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJ1blpvb20gPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChydW5ab29tKSB7XG5cdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnc2VsZWN0aW9uJywgc2VsZWN0aW9uRGF0YSwgZnVuY3Rpb24gKGFyZ3MpIHsgXG5cdFx0XHRcdFx0XHRjaGFydC56b29tKGV4dGVuZChhcmdzLCBoYXNQaW5jaGVkID8geyBhbmltYXRpb246IGZhbHNlIH0gOiBudWxsKSk7IFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIuZGVzdHJveSgpO1xuXG5cdFx0XHQvLyBSZXNldCBzY2FsaW5nIHByZXZpZXdcblx0XHRcdGlmIChoYXNQaW5jaGVkKSB7XG5cdFx0XHRcdHRoaXMuc2NhbGVHcm91cHMoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXNldCBhbGxcblx0XHRpZiAoY2hhcnQpIHsgLy8gaXQgbWF5IGJlIGRlc3Ryb3llZCBvbiBtb3VzZSB1cCAtICM4Nzdcblx0XHRcdGNzcyhjaGFydC5jb250YWluZXIsIHsgY3Vyc29yOiBjaGFydC5fY3Vyc29yIH0pO1xuXHRcdFx0Y2hhcnQuY2FuY2VsQ2xpY2sgPSB0aGlzLmhhc0RyYWdnZWQgPiAxMDsgLy8gIzM3MFxuXHRcdFx0Y2hhcnQubW91c2VJc0Rvd24gPSB0aGlzLmhhc0RyYWdnZWQgPSB0aGlzLmhhc1BpbmNoZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucGluY2hEb3duID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdG9uQ29udGFpbmVyTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1xuXG5cdFx0Ly8gaXNzdWUgIzI5NSwgZHJhZ2dpbmcgbm90IGFsd2F5cyB3b3JraW5nIGluIEZpcmVmb3hcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmRyYWdTdGFydChlKTtcblx0fSxcblxuXHRcblxuXHRvbkRvY3VtZW50TW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLmRyb3AoZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNwZWNpYWwgaGFuZGxlciBmb3IgbW91c2UgbW92ZSB0aGF0IHdpbGwgaGlkZSB0aGUgdG9vbHRpcCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIHBsb3RhcmVhLlxuXHQgKiBJc3N1ZSAjMTQ5IHdvcmthcm91bmQuIFRoZSBtb3VzZWxlYXZlIGV2ZW50IGRvZXMgbm90IGFsd2F5cyBmaXJlLiBcblx0ICovXG5cdG9uRG9jdW1lbnRNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGNoYXJ0UG9zaXRpb24gPSB0aGlzLmNoYXJ0UG9zaXRpb24sXG5cdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzO1xuXG5cdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUsIGNoYXJ0UG9zaXRpb24pO1xuXG5cdFx0Ly8gSWYgd2UncmUgb3V0c2lkZSwgaGlkZSB0aGUgdG9vbHRpcFxuXHRcdGlmIChjaGFydFBvc2l0aW9uICYmIGhvdmVyU2VyaWVzICYmICF0aGlzLmluQ2xhc3MoZS50YXJnZXQsICdoaWdoY2hhcnRzLXRyYWNrZXInKSAmJlxuXHRcdFx0XHQhY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFdoZW4gbW91c2UgbGVhdmVzIHRoZSBjb250YWluZXIsIGhpZGUgdGhlIHRvb2x0aXAuXG5cdCAqL1xuXHRvbkNvbnRhaW5lck1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0dGhpcy5jaGFydFBvc2l0aW9uID0gbnVsbDsgLy8gYWxzbyByZXNldCB0aGUgY2hhcnQgcG9zaXRpb24sIHVzZWQgaW4gIzE0OSBmaXhcblx0fSxcblxuXHQvLyBUaGUgbW91c2Vtb3ZlLCB0b3VjaG1vdmUgYW5kIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlclxuXHRvbkNvbnRhaW5lck1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHQvLyBub3JtYWxpemVcblx0XHRlID0gdGhpcy5ub3JtYWxpemUoZSk7XG5cblx0XHQvLyAjMjk1XG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChjaGFydC5tb3VzZUlzRG93biA9PT0gJ21vdXNlZG93bicpIHtcblx0XHRcdHRoaXMuZHJhZyhlKTtcblx0XHR9IFxuXHRcdFxuXHRcdC8vIFNob3cgdGhlIHRvb2x0aXAgYW5kIHJ1biBtb3VzZSBvdmVyIGV2ZW50cyAoIzk3Nylcblx0XHRpZiAoKHRoaXMuaW5DbGFzcyhlLnRhcmdldCwgJ2hpZ2hjaGFydHMtdHJhY2tlcicpIHx8IFxuXHRcdFx0XHRjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgdG8gZGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCBoYXMsIG9yIGhhcyBhIHBhcmVudCB3aXRoLCBhIHNwZWNpZmljXG5cdCAqIGNsYXNzIG5hbWUuIFVzZWQgb24gZGV0ZWN0aW9uIG9mIHRyYWNrZXIgb2JqZWN0cyBhbmQgb24gZGVjaWRpbmcgd2hldGhlclxuXHQgKiBob3ZlcmluZyB0aGUgdG9vbHRpcCBzaG91bGQgY2F1c2UgdGhlIGFjdGl2ZSBzZXJpZXMgdG8gbW91c2Ugb3V0LlxuXHQgKi9cblx0aW5DbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBlbGVtQ2xhc3NOYW1lO1xuXHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRlbGVtQ2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKTtcblx0XHRcdGlmIChlbGVtQ2xhc3NOYW1lKSB7XG5cdFx0XHRcdGlmIChlbGVtQ2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtQ2xhc3NOYW1lLmluZGV4T2YoUFJFRklYICsgJ2NvbnRhaW5lcicpICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHR9XHRcdFxuXHR9LFxuXG5cdG9uVHJhY2tlck1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzO1xuXHRcdGlmIChzZXJpZXMgJiYgIXNlcmllcy5vcHRpb25zLnN0aWNreVRyYWNraW5nICYmICF0aGlzLmluQ2xhc3MoZS50b0VsZW1lbnQgfHwgZS5yZWxhdGVkVGFyZ2V0LCBQUkVGSVggKyAndG9vbHRpcCcpKSB7XG5cdFx0XHRzZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdH1cblx0fSxcblxuXHRvbkNvbnRhaW5lckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludCwgXG5cdFx0XHRwbG90TGVmdCA9IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0Y2hhcnRQb3NpdGlvbixcblx0XHRcdHBsb3RYLFxuXHRcdFx0cGxvdFk7XG5cdFx0XG5cdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1xuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTsgLy8gSUUgc3BlY2lmaWNcblxuXHRcdGlmICghY2hhcnQuY2FuY2VsQ2xpY2spIHtcblx0XHRcdFxuXHRcdFx0Ly8gT24gdHJhY2tlciBjbGljaywgZmlyZSB0aGUgc2VyaWVzIGFuZCBwb2ludCBldmVudHMuICM3ODMsICMxNTgzXG5cdFx0XHRpZiAoaG92ZXJQb2ludCAmJiB0aGlzLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykpIHtcblx0XHRcdFx0Y2hhcnRQb3NpdGlvbiA9IHRoaXMuY2hhcnRQb3NpdGlvbjtcblx0XHRcdFx0cGxvdFggPSBob3ZlclBvaW50LnBsb3RYO1xuXHRcdFx0XHRwbG90WSA9IGhvdmVyUG9pbnQucGxvdFk7XG5cblx0XHRcdFx0Ly8gYWRkIHBhZ2UgcG9zaXRpb24gaW5mb1xuXHRcdFx0XHRleHRlbmQoaG92ZXJQb2ludCwge1xuXHRcdFx0XHRcdHBhZ2VYOiBjaGFydFBvc2l0aW9uLmxlZnQgKyBwbG90TGVmdCArXG5cdFx0XHRcdFx0XHQoaW52ZXJ0ZWQgPyBjaGFydC5wbG90V2lkdGggLSBwbG90WSA6IHBsb3RYKSxcblx0XHRcdFx0XHRwYWdlWTogY2hhcnRQb3NpdGlvbi50b3AgKyBwbG90VG9wICtcblx0XHRcdFx0XHRcdChpbnZlcnRlZCA/IGNoYXJ0LnBsb3RIZWlnaHQgLSBwbG90WCA6IHBsb3RZKVxuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0XHQvLyB0aGUgc2VyaWVzIGNsaWNrIGV2ZW50XG5cdFx0XHRcdGZpcmVFdmVudChob3ZlclBvaW50LnNlcmllcywgJ2NsaWNrJywgZXh0ZW5kKGUsIHtcblx0XHRcdFx0XHRwb2ludDogaG92ZXJQb2ludFxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Ly8gdGhlIHBvaW50IGNsaWNrIGV2ZW50XG5cdFx0XHRcdGlmIChjaGFydC5ob3ZlclBvaW50KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgKCMxODQ0KVxuXHRcdFx0XHRcdGhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoJ2NsaWNrJywgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiBjbGlja2luZyBvdXRzaWRlIGEgdHJhY2tlciwgZmlyZSBhIGNoYXJ0IGV2ZW50XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRlbmQoZSwgdGhpcy5nZXRDb29yZGluYXRlcyhlKSk7XG5cblx0XHRcdFx0Ly8gZmlyZSBhIGNsaWNrIGV2ZW50IGluIHRoZSBjaGFydFxuXHRcdFx0XHRpZiAoY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gcGxvdExlZnQsIGUuY2hhcnRZIC0gcGxvdFRvcCkpIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdjbGljaycsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdH1cblx0fSxcblxuXHRvbkNvbnRhaW5lclRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG5cblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdFx0aWYgKGNoYXJ0LmlzSW5zaWRlUGxvdChlLmNoYXJ0WCAtIGNoYXJ0LnBsb3RMZWZ0LCBlLmNoYXJ0WSAtIGNoYXJ0LnBsb3RUb3ApKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCB0aGUgY2xpY2sgcHNldWRvIGV2ZW50IGZyb20gZmlyaW5nIHVubGVzcyBpdCBpcyBzZXQgaW4gdGhlIG9wdGlvbnNcblx0XHRcdFx0LyppZiAoIWNoYXJ0LnJ1bkNoYXJ0Q2xpY2spIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0qL1xuXHRcdFx0XG5cdFx0XHRcdC8vIFJ1biBtb3VzZSBldmVudHMgYW5kIGRpc3BsYXkgdG9vbHRpcCBldGNcblx0XHRcdFx0dGhpcy5ydW5Qb2ludEFjdGlvbnMoZSk7XG5cblx0XHRcdFx0dGhpcy5waW5jaChlKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGlkZSB0aGUgdG9vbHRpcCBvbiB0b3VjaGluZyBvdXRzaWRlIHRoZSBwbG90IGFyZWEgKCMxMjAzKVxuXHRcdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcblx0XHRcdHRoaXMucGluY2goZSk7XG5cdFx0fVx0XHRcblx0fSxcblxuXHRvbkNvbnRhaW5lclRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSB8fCBlLnRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHR0aGlzLnBpbmNoKGUpO1xuXHRcdH1cblx0fSxcblxuXHRvbkRvY3VtZW50VG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5kcm9wKGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIEpTIERPTSBldmVudHMgb24gdGhlIGNvbnRhaW5lciBhbmQgZG9jdW1lbnQuIFRoaXMgbWV0aG9kIHNob3VsZCBjb250YWluXG5cdCAqIGEgb25lLXRvLW9uZSBhc3NpZ25tZW50IGJldHdlZW4gbWV0aG9kcyBhbmQgdGhlaXIgaGFuZGxlcnMuIEFueSBhZHZhbmNlZCBsb2dpYyBzaG91bGRcblx0ICogYmUgbW92ZWQgdG8gdGhlIGhhbmRsZXIgcmVmbGVjdGluZyB0aGUgZXZlbnQncyBuYW1lLlxuXHQgKi9cblx0c2V0RE9NRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRjb250YWluZXIgPSBwb2ludGVyLmNoYXJ0LmNvbnRhaW5lcixcblx0XHRcdGV2ZW50cztcblxuXHRcdHRoaXMuX2V2ZW50cyA9IGV2ZW50cyA9IFtcblx0XHRcdFtjb250YWluZXIsICdvbm1vdXNlZG93bicsICdvbkNvbnRhaW5lck1vdXNlRG93biddLFxuXHRcdFx0W2NvbnRhaW5lciwgJ29ubW91c2Vtb3ZlJywgJ29uQ29udGFpbmVyTW91c2VNb3ZlJ10sXG5cdFx0XHRbY29udGFpbmVyLCAnb25jbGljaycsICdvbkNvbnRhaW5lckNsaWNrJ10sXG5cdFx0XHRbY29udGFpbmVyLCAnbW91c2VsZWF2ZScsICdvbkNvbnRhaW5lck1vdXNlTGVhdmUnXSxcblx0XHRcdFtkb2MsICdtb3VzZW1vdmUnLCAnb25Eb2N1bWVudE1vdXNlTW92ZSddLFxuXHRcdFx0W2RvYywgJ21vdXNldXAnLCAnb25Eb2N1bWVudE1vdXNlVXAnXVxuXHRcdF07XG5cblx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdGV2ZW50cy5wdXNoKFxuXHRcdFx0XHRbY29udGFpbmVyLCAnb250b3VjaHN0YXJ0JywgJ29uQ29udGFpbmVyVG91Y2hTdGFydCddLFxuXHRcdFx0XHRbY29udGFpbmVyLCAnb250b3VjaG1vdmUnLCAnb25Db250YWluZXJUb3VjaE1vdmUnXSxcblx0XHRcdFx0W2RvYywgJ3RvdWNoZW5kJywgJ29uRG9jdW1lbnRUb3VjaEVuZCddXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnRDb25maWcpIHtcblxuXHRcdFx0Ly8gRmlyc3QsIGNyZWF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpbiB0dXJuIGNhbGxzIHRoZSBtZXRob2Qgb24gUG9pbnRlclxuXHRcdFx0cG9pbnRlclsnXycgKyBldmVudENvbmZpZ1syXV0gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyW2V2ZW50Q29uZmlnWzJdXShlKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIE5vdyBhdHRhY2ggdGhlIGZ1bmN0aW9uLCBlaXRoZXIgYXMgYSBkaXJlY3QgcHJvcGVydHkgb3IgdGhyb3VnaCBhZGRFdmVudFxuXHRcdFx0aWYgKGV2ZW50Q29uZmlnWzFdLmluZGV4T2YoJ29uJykgPT09IDApIHtcblx0XHRcdFx0ZXZlbnRDb25maWdbMF1bZXZlbnRDb25maWdbMV1dID0gcG9pbnRlclsnXycgKyBldmVudENvbmZpZ1syXV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRFdmVudChldmVudENvbmZpZ1swXSwgZXZlbnRDb25maWdbMV0sIHBvaW50ZXJbJ18nICsgZXZlbnRDb25maWdbMl1dKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgUG9pbnRlciBvYmplY3QgYW5kIGRpc2Nvbm5lY3RzIERPTSBldmVudHMuXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50ZXIgPSB0aGlzO1xuXG5cdFx0Ly8gUmVsZWFzZSBhbGwgRE9NIGV2ZW50c1xuXHRcdGVhY2gocG9pbnRlci5fZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnRDb25maWcpIHtcdFxuXHRcdFx0aWYgKGV2ZW50Q29uZmlnWzFdLmluZGV4T2YoJ29uJykgPT09IDApIHtcblx0XHRcdFx0ZXZlbnRDb25maWdbMF1bZXZlbnRDb25maWdbMV1dID0gbnVsbDsgLy8gZGVsZXRlIGJyZWFrcyBvbGRJRVxuXHRcdFx0fSBlbHNlIHtcdFx0XG5cdFx0XHRcdHJlbW92ZUV2ZW50KGV2ZW50Q29uZmlnWzBdLCBldmVudENvbmZpZ1sxXSwgcG9pbnRlclsnXycgKyBldmVudENvbmZpZ1syXV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGRlbGV0ZSBwb2ludGVyLl9ldmVudHM7XG5cblx0XHQvLyBtZW1vcnkgYW5kIENQVSBsZWFrXG5cdFx0Y2xlYXJJbnRlcnZhbChwb2ludGVyLnRvb2x0aXBUaW1lb3V0KTtcblx0fVxufTtcbi8qKlxuICogVGhlIG92ZXJ2aWV3IG9mIHRoZSBjaGFydCdzIHNlcmllc1xuICovXG5mdW5jdGlvbiBMZWdlbmQoY2hhcnQsIG9wdGlvbnMpIHtcblx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcbn1cblxuTGVnZW5kLnByb3RvdHlwZSA9IHtcblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFxuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0aXRlbVN0eWxlID0gb3B0aW9ucy5pdGVtU3R5bGUsXG5cdFx0XHRwYWRkaW5nID0gcGljayhvcHRpb25zLnBhZGRpbmcsIDgpLFxuXHRcdFx0aXRlbU1hcmdpblRvcCA9IG9wdGlvbnMuaXRlbU1hcmdpblRvcCB8fCAwO1xuXHRcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0aWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGxlZ2VuZC5iYXNlbGluZSA9IHBJbnQoaXRlbVN0eWxlLmZvbnRTaXplKSArIDMgKyBpdGVtTWFyZ2luVG9wOyAvLyB1c2VkIGluIFNlcmllcyBwcm90b3R5cGVcblx0XHRsZWdlbmQuaXRlbVN0eWxlID0gaXRlbVN0eWxlO1xuXHRcdGxlZ2VuZC5pdGVtSGlkZGVuU3R5bGUgPSBtZXJnZShpdGVtU3R5bGUsIG9wdGlvbnMuaXRlbUhpZGRlblN0eWxlKTtcblx0XHRsZWdlbmQuaXRlbU1hcmdpblRvcCA9IGl0ZW1NYXJnaW5Ub3A7XG5cdFx0bGVnZW5kLnBhZGRpbmcgPSBwYWRkaW5nO1xuXHRcdGxlZ2VuZC5pbml0aWFsSXRlbVggPSBwYWRkaW5nO1xuXHRcdGxlZ2VuZC5pbml0aWFsSXRlbVkgPSBwYWRkaW5nIC0gNTsgLy8gNSBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBhYm92ZSB0aGUgdGV4dFxuXHRcdGxlZ2VuZC5tYXhJdGVtV2lkdGggPSAwO1xuXHRcdGxlZ2VuZC5jaGFydCA9IGNoYXJ0O1xuXHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gMDtcblx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSAwO1xuXG5cdFx0Ly8gUmVuZGVyIGl0XG5cdFx0bGVnZW5kLnJlbmRlcigpO1xuXG5cdFx0Ly8gbW92ZSBjaGVja2JveGVzXG5cdFx0YWRkRXZlbnQobGVnZW5kLmNoYXJ0LCAnZW5kUmVzaXplJywgZnVuY3Rpb24gKCkgeyBcblx0XHRcdGxlZ2VuZC5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcblx0XHR9KTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNvbG9ycyBmb3IgdGhlIGxlZ2VuZCBpdGVtXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgU2VyaWVzIG9yIFBvaW50IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2aXNpYmxlIERpbW1lZCBvciBjb2xvcmVkXG5cdCAqL1xuXHRjb2xvcml6ZUl0ZW06IGZ1bmN0aW9uIChpdGVtLCB2aXNpYmxlKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRsZWdlbmRJdGVtID0gaXRlbS5sZWdlbmRJdGVtLFxuXHRcdFx0bGVnZW5kTGluZSA9IGl0ZW0ubGVnZW5kTGluZSxcblx0XHRcdGxlZ2VuZFN5bWJvbCA9IGl0ZW0ubGVnZW5kU3ltYm9sLFxuXHRcdFx0aGlkZGVuQ29sb3IgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLmNvbG9yLFxuXHRcdFx0dGV4dENvbG9yID0gdmlzaWJsZSA/IG9wdGlvbnMuaXRlbVN0eWxlLmNvbG9yIDogaGlkZGVuQ29sb3IsXG5cdFx0XHRzeW1ib2xDb2xvciA9IHZpc2libGUgPyBpdGVtLmNvbG9yIDogaGlkZGVuQ29sb3IsXG5cdFx0XHRtYXJrZXJPcHRpb25zID0gaXRlbS5vcHRpb25zICYmIGl0ZW0ub3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRzeW1ib2xBdHRyID0ge1xuXHRcdFx0XHRzdHJva2U6IHN5bWJvbENvbG9yLFxuXHRcdFx0XHRmaWxsOiBzeW1ib2xDb2xvclxuXHRcdFx0fSxcblx0XHRcdGtleSxcblx0XHRcdHZhbDtcblx0XHRcblx0XHRpZiAobGVnZW5kSXRlbSkge1xuXHRcdFx0bGVnZW5kSXRlbS5jc3MoeyBmaWxsOiB0ZXh0Q29sb3IsIGNvbG9yOiB0ZXh0Q29sb3IgfSk7IC8vIGNvbG9yIGZvciAjMTU1Mywgb2xkSUVcblx0XHR9XG5cdFx0aWYgKGxlZ2VuZExpbmUpIHtcblx0XHRcdGxlZ2VuZExpbmUuYXR0cih7IHN0cm9rZTogc3ltYm9sQ29sb3IgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChsZWdlbmRTeW1ib2wpIHtcblx0XHRcdFxuXHRcdFx0Ly8gQXBwbHkgbWFya2VyIG9wdGlvbnNcblx0XHRcdGlmIChtYXJrZXJPcHRpb25zICYmIGxlZ2VuZFN5bWJvbC5pc01hcmtlcikgeyAvLyAjNTg1XG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBpdGVtLmNvbnZlcnRBdHRyaWJzKG1hcmtlck9wdGlvbnMpO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBtYXJrZXJPcHRpb25zKSB7XG5cdFx0XHRcdFx0dmFsID0gbWFya2VyT3B0aW9uc1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWwgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0c3ltYm9sQXR0cltrZXldID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZWdlbmRTeW1ib2wuYXR0cihzeW1ib2xBdHRyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvc2l0aW9uIHRoZSBsZWdlbmQgaXRlbVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIFNlcmllcyBvciBQb2ludCBpbnN0YW5jZVxuXHQgKi9cblx0cG9zaXRpb25JdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0c3ltYm9sUGFkZGluZyA9IG9wdGlvbnMuc3ltYm9sUGFkZGluZyxcblx0XHRcdGx0ciA9ICFvcHRpb25zLnJ0bCxcblx0XHRcdGxlZ2VuZEl0ZW1Qb3MgPSBpdGVtLl9sZWdlbmRJdGVtUG9zLFxuXHRcdFx0aXRlbVggPSBsZWdlbmRJdGVtUG9zWzBdLFxuXHRcdFx0aXRlbVkgPSBsZWdlbmRJdGVtUG9zWzFdLFxuXHRcdFx0Y2hlY2tib3ggPSBpdGVtLmNoZWNrYm94O1xuXG5cdFx0aWYgKGl0ZW0ubGVnZW5kR3JvdXApIHtcblx0XHRcdGl0ZW0ubGVnZW5kR3JvdXAudHJhbnNsYXRlKFxuXHRcdFx0XHRsdHIgPyBpdGVtWCA6IGxlZ2VuZC5sZWdlbmRXaWR0aCAtIGl0ZW1YIC0gMiAqIHN5bWJvbFBhZGRpbmcgLSA0LFxuXHRcdFx0XHRpdGVtWVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tib3gpIHtcblx0XHRcdGNoZWNrYm94LnggPSBpdGVtWDtcblx0XHRcdGNoZWNrYm94LnkgPSBpdGVtWTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgYSBzaW5nbGUgbGVnZW5kIGl0ZW1cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHNlcmllcyBvciBwb2ludFxuXHQgKi9cblx0ZGVzdHJveUl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGNoZWNrYm94ID0gaXRlbS5jaGVja2JveDtcblxuXHRcdC8vIGRlc3Ryb3kgU1ZHIGVsZW1lbnRzXG5cdFx0ZWFjaChbJ2xlZ2VuZEl0ZW0nLCAnbGVnZW5kTGluZScsICdsZWdlbmRTeW1ib2wnLCAnbGVnZW5kR3JvdXAnXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKGl0ZW1ba2V5XSkge1xuXHRcdFx0XHRpdGVtW2tleV0gPSBpdGVtW2tleV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRkaXNjYXJkRWxlbWVudChpdGVtLmNoZWNrYm94KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBsZWdlbmQuXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRsZWdlbmRHcm91cCA9IGxlZ2VuZC5ncm91cCxcblx0XHRcdGJveCA9IGxlZ2VuZC5ib3g7XG5cblx0XHRpZiAoYm94KSB7XG5cdFx0XHRsZWdlbmQuYm94ID0gYm94LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHRpZiAobGVnZW5kR3JvdXApIHtcblx0XHRcdGxlZ2VuZC5ncm91cCA9IGxlZ2VuZEdyb3VwLmRlc3Ryb3koKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvc2l0aW9uIHRoZSBjaGVja2JveGVzIGFmdGVyIHRoZSB3aWR0aCBpcyBkZXRlcm1pbmVkXG5cdCAqL1xuXHRwb3NpdGlvbkNoZWNrYm94ZXM6IGZ1bmN0aW9uIChzY3JvbGxPZmZzZXQpIHtcblx0XHR2YXIgYWxpZ25BdHRyID0gdGhpcy5ncm91cC5hbGlnbkF0dHIsXG5cdFx0XHR0cmFuc2xhdGVZLFxuXHRcdFx0Y2xpcEhlaWdodCA9IHRoaXMuY2xpcEhlaWdodCB8fCB0aGlzLmxlZ2VuZEhlaWdodDtcblxuXHRcdGlmIChhbGlnbkF0dHIpIHtcblx0XHRcdHRyYW5zbGF0ZVkgPSBhbGlnbkF0dHIudHJhbnNsYXRlWTtcblx0XHRcdGVhY2godGhpcy5hbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGNoZWNrYm94ID0gaXRlbS5jaGVja2JveCxcblx0XHRcdFx0XHR0b3A7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2hlY2tib3gpIHtcblx0XHRcdFx0XHR0b3AgPSAodHJhbnNsYXRlWSArIGNoZWNrYm94LnkgKyAoc2Nyb2xsT2Zmc2V0IHx8IDApICsgMyk7XG5cdFx0XHRcdFx0Y3NzKGNoZWNrYm94LCB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAoYWxpZ25BdHRyLnRyYW5zbGF0ZVggKyBpdGVtLmxlZ2VuZEl0ZW1XaWR0aCArIGNoZWNrYm94LnggLSAyMCkgKyBQWCxcblx0XHRcdFx0XHRcdHRvcDogdG9wICsgUFgsXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiB0b3AgPiB0cmFuc2xhdGVZIC0gNiAmJiB0b3AgPCB0cmFuc2xhdGVZICsgY2xpcEhlaWdodCAtIDYgPyAnJyA6IE5PTkVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgbGVnZW5kIHRpdGxlIG9uIHRvcCBvZiB0aGUgbGVnZW5kXG5cdCAqL1xuXHRyZW5kZXJUaXRsZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0cGFkZGluZyA9IHRoaXMucGFkZGluZyxcblx0XHRcdHRpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHR0aXRsZUhlaWdodCA9IDAsXG5cdFx0XHRiQm94O1xuXHRcdFxuXHRcdGlmICh0aXRsZU9wdGlvbnMudGV4dCkge1xuXHRcdFx0aWYgKCF0aGlzLnRpdGxlKSB7XG5cdFx0XHRcdHRoaXMudGl0bGUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmxhYmVsKHRpdGxlT3B0aW9ucy50ZXh0LCBwYWRkaW5nIC0gMywgcGFkZGluZyAtIDQsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICdsZWdlbmQtdGl0bGUnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdFx0LmNzcyh0aXRsZU9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLmdyb3VwKTtcblx0XHRcdH1cblx0XHRcdGJCb3ggPSB0aGlzLnRpdGxlLmdldEJCb3goKTtcblx0XHRcdHRpdGxlSGVpZ2h0ID0gYkJveC5oZWlnaHQ7XG5cdFx0XHR0aGlzLm9mZnNldFdpZHRoID0gYkJveC53aWR0aDsgLy8gIzE3MTdcblx0XHRcdHRoaXMuY29udGVudEdyb3VwLmF0dHIoeyB0cmFuc2xhdGVZOiB0aXRsZUhlaWdodCB9KTtcblx0XHR9XG5cdFx0dGhpcy50aXRsZUhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgYSBzaW5nbGUgc3BlY2lmaWMgbGVnZW5kIGl0ZW1cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBzZXJpZXMgb3IgcG9pbnRcblx0ICovXG5cdHJlbmRlckl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGxlZ2VuZC5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRob3Jpem9udGFsID0gb3B0aW9ucy5sYXlvdXQgPT09ICdob3Jpem9udGFsJyxcblx0XHRcdHN5bWJvbFdpZHRoID0gb3B0aW9ucy5zeW1ib2xXaWR0aCxcblx0XHRcdHN5bWJvbFBhZGRpbmcgPSBvcHRpb25zLnN5bWJvbFBhZGRpbmcsXG5cdFx0XHRpdGVtU3R5bGUgPSBsZWdlbmQuaXRlbVN0eWxlLFxuXHRcdFx0aXRlbUhpZGRlblN0eWxlID0gbGVnZW5kLml0ZW1IaWRkZW5TdHlsZSxcblx0XHRcdHBhZGRpbmcgPSBsZWdlbmQucGFkZGluZyxcblx0XHRcdGl0ZW1EaXN0YW5jZSA9IGhvcml6b250YWwgPyBwaWNrKG9wdGlvbnMuaXRlbURpc3RhbmNlLCA4KSA6IDAsXG5cdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRpdGVtSGVpZ2h0LFxuXHRcdFx0d2lkdGhPcHRpb24gPSBvcHRpb25zLndpZHRoLFxuXHRcdFx0aXRlbU1hcmdpbkJvdHRvbSA9IG9wdGlvbnMuaXRlbU1hcmdpbkJvdHRvbSB8fCAwLFxuXHRcdFx0aXRlbU1hcmdpblRvcCA9IGxlZ2VuZC5pdGVtTWFyZ2luVG9wLFxuXHRcdFx0aW5pdGlhbEl0ZW1YID0gbGVnZW5kLmluaXRpYWxJdGVtWCxcblx0XHRcdGJCb3gsXG5cdFx0XHRpdGVtV2lkdGgsXG5cdFx0XHRsaSA9IGl0ZW0ubGVnZW5kSXRlbSxcblx0XHRcdHNlcmllcyA9IGl0ZW0uc2VyaWVzIHx8IGl0ZW0sXG5cdFx0XHRpdGVtT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0c2hvd0NoZWNrYm94ID0gaXRlbU9wdGlvbnMuc2hvd0NoZWNrYm94LFxuXHRcdFx0dXNlSFRNTCA9IG9wdGlvbnMudXNlSFRNTDtcblxuXHRcdGlmICghbGkpIHsgLy8gZ2VuZXJhdGUgaXQgb25jZSwgbGF0ZXIgbW92ZSBpdFxuXG5cdFx0XHQvLyBHZW5lcmF0ZSB0aGUgZ3JvdXAgYm94XG5cdFx0XHQvLyBBIGdyb3VwIHRvIGhvbGQgdGhlIHN5bWJvbCBhbmQgdGV4dC4gVGV4dCBpcyB0byBiZSBhcHBlbmRlZCBpbiBMZWdlbmQgY2xhc3MuXG5cdFx0XHRpdGVtLmxlZ2VuZEdyb3VwID0gcmVuZGVyZXIuZygnbGVnZW5kLWl0ZW0nKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KVxuXHRcdFx0XHQuYWRkKGxlZ2VuZC5zY3JvbGxHcm91cCk7XG5cblx0XHRcdC8vIERyYXcgdGhlIGxlZ2VuZCBzeW1ib2wgaW5zaWRlIHRoZSBncm91cCBib3hcblx0XHRcdHNlcmllcy5kcmF3TGVnZW5kU3ltYm9sKGxlZ2VuZCwgaXRlbSk7XG5cblx0XHRcdC8vIEdlbmVyYXRlIHRoZSBsaXN0IGl0ZW0gdGV4dCBhbmQgYWRkIGl0IHRvIHRoZSBncm91cFxuXHRcdFx0aXRlbS5sZWdlbmRJdGVtID0gbGkgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdG9wdGlvbnMubGFiZWxGb3JtYXQgPyBmb3JtYXQob3B0aW9ucy5sYWJlbEZvcm1hdCwgaXRlbSkgOiBvcHRpb25zLmxhYmVsRm9ybWF0dGVyLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0bHRyID8gc3ltYm9sV2lkdGggKyBzeW1ib2xQYWRkaW5nIDogLXN5bWJvbFBhZGRpbmcsXG5cdFx0XHRcdFx0bGVnZW5kLmJhc2VsaW5lLFxuXHRcdFx0XHRcdHVzZUhUTUxcblx0XHRcdFx0KVxuXHRcdFx0XHQuY3NzKG1lcmdlKGl0ZW0udmlzaWJsZSA/IGl0ZW1TdHlsZSA6IGl0ZW1IaWRkZW5TdHlsZSkpIC8vIG1lcmdlIHRvIHByZXZlbnQgbW9kaWZ5aW5nIG9yaWdpbmFsICgjMTAyMSlcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBsdHIgPyAnbGVmdCcgOiAncmlnaHQnLFxuXHRcdFx0XHRcdHpJbmRleDogMlxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKGl0ZW0ubGVnZW5kR3JvdXApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGV2ZW50cyBvbiB0aGUgaXRlbSBncm91cCwgb3IgaW4gY2FzZSBvZiB1c2VIVE1MLCB0aGUgaXRlbSBpdHNlbGYgKCMxMjQ5KVxuXHRcdFx0KHVzZUhUTUwgPyBsaSA6IGl0ZW0ubGVnZW5kR3JvdXApLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aXRlbS5zZXRTdGF0ZShIT1ZFUl9TVEFURSk7XG5cdFx0XHRcdFx0bGkuY3NzKGxlZ2VuZC5vcHRpb25zLml0ZW1Ib3ZlclN0eWxlKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsaS5jc3MoaXRlbS52aXNpYmxlID8gaXRlbVN0eWxlIDogaXRlbUhpZGRlblN0eWxlKTtcblx0XHRcdFx0XHRpdGVtLnNldFN0YXRlKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHR2YXIgc3RyTGVnZW5kSXRlbUNsaWNrID0gJ2xlZ2VuZEl0ZW1DbGljaycsXG5cdFx0XHRcdFx0XHRmbkxlZ2VuZEl0ZW1DbGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRWaXNpYmxlKCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUGFzcyBvdmVyIHRoZSBjbGljay90b3VjaCBldmVudC4gIzQuXG5cdFx0XHRcdFx0ZXZlbnQgPSB7XG5cdFx0XHRcdFx0XHRicm93c2VyRXZlbnQ6IGV2ZW50XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIGNsaWNrIHRoZSBuYW1lIG9yIHN5bWJvbFxuXHRcdFx0XHRcdGlmIChpdGVtLmZpcmVQb2ludEV2ZW50KSB7IC8vIHBvaW50XG5cdFx0XHRcdFx0XHRpdGVtLmZpcmVQb2ludEV2ZW50KHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZmlyZUV2ZW50KGl0ZW0sIHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDb2xvcml6ZSB0aGUgaXRlbXNcblx0XHRcdGxlZ2VuZC5jb2xvcml6ZUl0ZW0oaXRlbSwgaXRlbS52aXNpYmxlKTtcblxuXHRcdFx0Ly8gYWRkIHRoZSBIVE1MIGNoZWNrYm94IG9uIHRvcFxuXHRcdFx0aWYgKGl0ZW1PcHRpb25zICYmIHNob3dDaGVja2JveCkge1xuXHRcdFx0XHRpdGVtLmNoZWNrYm94ID0gY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG5cdFx0XHRcdFx0dHlwZTogJ2NoZWNrYm94Jyxcblx0XHRcdFx0XHRjaGVja2VkOiBpdGVtLnNlbGVjdGVkLFxuXHRcdFx0XHRcdGRlZmF1bHRDaGVja2VkOiBpdGVtLnNlbGVjdGVkIC8vIHJlcXVpcmVkIGJ5IElFN1xuXHRcdFx0XHR9LCBvcHRpb25zLml0ZW1DaGVja2JveFN0eWxlLCBjaGFydC5jb250YWluZXIpO1xuXG5cdFx0XHRcdGFkZEV2ZW50KGl0ZW0uY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdFx0ZmlyZUV2ZW50KGl0ZW0sICdjaGVja2JveENsaWNrJywge1xuXHRcdFx0XHRcdFx0XHRjaGVja2VkOiB0YXJnZXQuY2hlY2tlZFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aXRlbS5zZWxlY3QoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIG5leHQgbGluZVxuXHRcdGJCb3ggPSBsaS5nZXRCQm94KCk7XG5cblx0XHRpdGVtV2lkdGggPSBpdGVtLmxlZ2VuZEl0ZW1XaWR0aCA9XG5cdFx0XHRvcHRpb25zLml0ZW1XaWR0aCB8fCBzeW1ib2xXaWR0aCArIHN5bWJvbFBhZGRpbmcgKyBiQm94LndpZHRoICsgaXRlbURpc3RhbmNlICtcblx0XHRcdChzaG93Q2hlY2tib3ggPyAyMCA6IDApO1xuXHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gaXRlbUhlaWdodCA9IGJCb3guaGVpZ2h0O1xuXG5cdFx0Ly8gaWYgdGhlIGl0ZW0gZXhjZWVkcyB0aGUgd2lkdGgsIHN0YXJ0IGEgbmV3IGxpbmVcblx0XHRpZiAoaG9yaXpvbnRhbCAmJiBsZWdlbmQuaXRlbVggLSBpbml0aWFsSXRlbVggKyBpdGVtV2lkdGggPlxuXHRcdFx0XHQod2lkdGhPcHRpb24gfHwgKGNoYXJ0LmNoYXJ0V2lkdGggLSAyICogcGFkZGluZyAtIGluaXRpYWxJdGVtWCkpKSB7XG5cdFx0XHRsZWdlbmQuaXRlbVggPSBpbml0aWFsSXRlbVg7XG5cdFx0XHRsZWdlbmQuaXRlbVkgKz0gaXRlbU1hcmdpblRvcCArIGxlZ2VuZC5sYXN0TGluZUhlaWdodCArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSAwOyAvLyByZXNldCBmb3IgbmV4dCBsaW5lXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGl0ZW0gZXhjZWVkcyB0aGUgaGVpZ2h0LCBzdGFydCBhIG5ldyBjb2x1bW5cblx0XHQvKmlmICghaG9yaXpvbnRhbCAmJiBsZWdlbmQuaXRlbVkgKyBvcHRpb25zLnkgKyBpdGVtSGVpZ2h0ID4gY2hhcnQuY2hhcnRIZWlnaHQgLSBzcGFjaW5nVG9wIC0gc3BhY2luZ0JvdHRvbSkge1xuXHRcdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRcdGxlZ2VuZC5pdGVtWCArPSBsZWdlbmQubWF4SXRlbVdpZHRoO1xuXHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0fSovXG5cblx0XHQvLyBTZXQgdGhlIGVkZ2UgcG9zaXRpb25zXG5cdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IG1hdGhNYXgobGVnZW5kLm1heEl0ZW1XaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRsZWdlbmQubGFzdEl0ZW1ZID0gaXRlbU1hcmdpblRvcCArIGxlZ2VuZC5pdGVtWSArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gbWF0aE1heChpdGVtSGVpZ2h0LCBsZWdlbmQubGFzdExpbmVIZWlnaHQpOyAvLyAjOTE1XG5cblx0XHQvLyBjYWNoZSB0aGUgcG9zaXRpb24gb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCBvciByZW9yZGVyZWQgaXRlbXNcblx0XHRpdGVtLl9sZWdlbmRJdGVtUG9zID0gW2xlZ2VuZC5pdGVtWCwgbGVnZW5kLml0ZW1ZXTtcblxuXHRcdC8vIGFkdmFuY2Vcblx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0bGVnZW5kLml0ZW1YICs9IGl0ZW1XaWR0aDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZWdlbmQuaXRlbVkgKz0gaXRlbU1hcmdpblRvcCArIGl0ZW1IZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gaXRlbUhlaWdodDtcblx0XHR9XG5cblx0XHQvLyB0aGUgd2lkdGggb2YgdGhlIHdpZGVzdCBpdGVtXG5cdFx0bGVnZW5kLm9mZnNldFdpZHRoID0gd2lkdGhPcHRpb24gfHwgbWF0aE1heChcblx0XHRcdChob3Jpem9udGFsID8gbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YIC0gaXRlbURpc3RhbmNlIDogaXRlbVdpZHRoKSArIHBhZGRpbmcsXG5cdFx0XHRsZWdlbmQub2Zmc2V0V2lkdGhcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIGxlZ2VuZC4gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBib3RoIGJlZm9yZSBhbmQgYWZ0ZXJcblx0ICogY2hhcnQucmVuZGVyLiBJZiBjYWxsZWQgYWZ0ZXIsIGl0IHdpbGwgb25seSByZWFycmFuZ2UgaXRlbXMgaW5zdGVhZFxuXHQgKiBvZiBjcmVhdGluZyBuZXcgb25lcy5cblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBsZWdlbmQuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0bGVnZW5kR3JvdXAgPSBsZWdlbmQuZ3JvdXAsXG5cdFx0XHRhbGxJdGVtcyxcblx0XHRcdGRpc3BsYXksXG5cdFx0XHRsZWdlbmRXaWR0aCxcblx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdGJveCA9IGxlZ2VuZC5ib3gsXG5cdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRwYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcsXG5cdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRsZWdlbmRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcblxuXHRcdGxlZ2VuZC5pdGVtWCA9IGxlZ2VuZC5pbml0aWFsSXRlbVg7XG5cdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRsZWdlbmQub2Zmc2V0V2lkdGggPSAwO1xuXHRcdGxlZ2VuZC5sYXN0SXRlbVkgPSAwO1xuXG5cdFx0aWYgKCFsZWdlbmRHcm91cCkge1xuXHRcdFx0bGVnZW5kLmdyb3VwID0gbGVnZW5kR3JvdXAgPSByZW5kZXJlci5nKCdsZWdlbmQnKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogNyB9KSBcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cCA9IHJlbmRlcmVyLmcoKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KSAvLyBhYm92ZSBiYWNrZ3JvdW5kXG5cdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApO1xuXHRcdFx0bGVnZW5kLnNjcm9sbEdyb3VwID0gcmVuZGVyZXIuZygpXG5cdFx0XHRcdC5hZGQobGVnZW5kLmNvbnRlbnRHcm91cCk7XG5cdFx0fVxuXHRcdFxuXHRcdGxlZ2VuZC5yZW5kZXJUaXRsZSgpO1xuXG5cdFx0Ly8gYWRkIGVhY2ggc2VyaWVzIG9yIHBvaW50XG5cdFx0YWxsSXRlbXMgPSBbXTtcblx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHR2YXIgc2VyaWVzT3B0aW9ucyA9IHNlcmllLm9wdGlvbnM7XG5cblx0XHRcdGlmICghc2VyaWVzT3B0aW9ucy5zaG93SW5MZWdlbmQgfHwgZGVmaW5lZChzZXJpZXNPcHRpb25zLmxpbmtlZFRvKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVzZSBwb2ludHMgb3Igc2VyaWVzIGZvciB0aGUgbGVnZW5kIGl0ZW0gZGVwZW5kaW5nIG9uIGxlZ2VuZFR5cGVcblx0XHRcdGFsbEl0ZW1zID0gYWxsSXRlbXMuY29uY2F0KFxuXHRcdFx0XHRcdHNlcmllLmxlZ2VuZEl0ZW1zIHx8XG5cdFx0XHRcdFx0KHNlcmllc09wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50JyA/XG5cdFx0XHRcdFx0XHRcdHNlcmllLmRhdGEgOlxuXHRcdFx0XHRcdFx0XHRzZXJpZSlcblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHQvLyBzb3J0IGJ5IGxlZ2VuZEluZGV4XG5cdFx0c3RhYmxlU29ydChhbGxJdGVtcywgZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiAoKGEub3B0aW9ucyAmJiBhLm9wdGlvbnMubGVnZW5kSW5kZXgpIHx8IDApIC0gKChiLm9wdGlvbnMgJiYgYi5vcHRpb25zLmxlZ2VuZEluZGV4KSB8fCAwKTtcblx0XHR9KTtcblxuXHRcdC8vIHJldmVyc2VkIGxlZ2VuZFxuXHRcdGlmIChvcHRpb25zLnJldmVyc2VkKSB7XG5cdFx0XHRhbGxJdGVtcy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0bGVnZW5kLmFsbEl0ZW1zID0gYWxsSXRlbXM7XG5cdFx0bGVnZW5kLmRpc3BsYXkgPSBkaXNwbGF5ID0gISFhbGxJdGVtcy5sZW5ndGg7XG5cblx0XHQvLyByZW5kZXIgdGhlIGl0ZW1zXG5cdFx0ZWFjaChhbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGxlZ2VuZC5yZW5kZXJJdGVtKGl0ZW0pOyBcblx0XHR9KTtcblxuXHRcdC8vIERyYXcgdGhlIGJvcmRlclxuXHRcdGxlZ2VuZFdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBsZWdlbmQub2Zmc2V0V2lkdGg7XG5cdFx0bGVnZW5kSGVpZ2h0ID0gbGVnZW5kLmxhc3RJdGVtWSArIGxlZ2VuZC5sYXN0TGluZUhlaWdodCArIGxlZ2VuZC50aXRsZUhlaWdodDtcblx0XHRcblx0XHRcblx0XHRsZWdlbmRIZWlnaHQgPSBsZWdlbmQuaGFuZGxlT3ZlcmZsb3cobGVnZW5kSGVpZ2h0KTtcblxuXHRcdGlmIChsZWdlbmRCb3JkZXJXaWR0aCB8fCBsZWdlbmRCYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGxlZ2VuZFdpZHRoICs9IHBhZGRpbmc7XG5cdFx0XHRsZWdlbmRIZWlnaHQgKz0gcGFkZGluZztcblxuXHRcdFx0aWYgKCFib3gpIHtcblx0XHRcdFx0bGVnZW5kLmJveCA9IGJveCA9IHJlbmRlcmVyLnJlY3QoXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdFx0XHRvcHRpb25zLmJvcmRlclJhZGl1cyxcblx0XHRcdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCB8fCAwXG5cdFx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsZWdlbmRCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0XHRcdGZpbGw6IGxlZ2VuZEJhY2tncm91bmRDb2xvciB8fCBOT05FXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApXG5cdFx0XHRcdC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdFx0XHRib3guaXNOZXcgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGxlZ2VuZFdpZHRoID4gMCAmJiBsZWdlbmRIZWlnaHQgPiAwKSB7XG5cdFx0XHRcdGJveFtib3guaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRcdGJveC5jcmlzcChudWxsLCBudWxsLCBudWxsLCBsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0KVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRib3guaXNOZXcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGlkZSB0aGUgYm9yZGVyIGlmIG5vIGl0ZW1zXG5cdFx0XHRib3hbZGlzcGxheSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHR9XG5cdFx0XG5cdFx0bGVnZW5kLmxlZ2VuZFdpZHRoID0gbGVnZW5kV2lkdGg7XG5cdFx0bGVnZW5kLmxlZ2VuZEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblxuXHRcdC8vIE5vdyB0aGF0IHRoZSBsZWdlbmQgd2lkdGggYW5kIGhlaWdodCBhcmUgZXN0YWJsaXNoZWQsIHB1dCB0aGUgaXRlbXMgaW4gdGhlIFxuXHRcdC8vIGZpbmFsIHBvc2l0aW9uXG5cdFx0ZWFjaChhbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGxlZ2VuZC5wb3NpdGlvbkl0ZW0oaXRlbSk7XG5cdFx0fSk7XG5cblx0XHQvLyAxLnggY29tcGF0aWJpbGl0eTogcG9zaXRpb25pbmcgYmFzZWQgb24gc3R5bGVcblx0XHQvKnZhciBwcm9wcyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG5cdFx0XHRwcm9wLFxuXHRcdFx0aSA9IDQ7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0aWYgKG9wdGlvbnMuc3R5bGVbcHJvcF0gJiYgb3B0aW9ucy5zdHlsZVtwcm9wXSAhPT0gJ2F1dG8nKSB7XG5cdFx0XHRcdG9wdGlvbnNbaSA8IDIgPyAnYWxpZ24nIDogJ3ZlcnRpY2FsQWxpZ24nXSA9IHByb3A7XG5cdFx0XHRcdG9wdGlvbnNbaSA8IDIgPyAneCcgOiAneSddID0gcEludChvcHRpb25zLnN0eWxlW3Byb3BdKSAqIChpICUgMiA/IC0xIDogMSk7XG5cdFx0XHR9XG5cdFx0fSovXG5cblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0bGVnZW5kR3JvdXAuYWxpZ24oZXh0ZW5kKHtcblx0XHRcdFx0d2lkdGg6IGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGxlZ2VuZEhlaWdodFxuXHRcdFx0fSwgb3B0aW9ucyksIHRydWUsICdzcGFjaW5nQm94Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjaGFydC5pc1Jlc2l6aW5nKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBTZXQgdXAgdGhlIG92ZXJmbG93IGhhbmRsaW5nIGJ5IGFkZGluZyBuYXZpZ2F0aW9uIHdpdGggdXAgYW5kIGRvd24gYXJyb3dzIGJlbG93IHRoZVxuXHQgKiBsZWdlbmQuXG5cdCAqL1xuXHRoYW5kbGVPdmVyZmxvdzogZnVuY3Rpb24gKGxlZ2VuZEhlaWdodCkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdHBhZ2VDb3VudCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRvcHRpb25zWSA9IG9wdGlvbnMueSxcblx0XHRcdGFsaWduVG9wID0gb3B0aW9ucy52ZXJ0aWNhbEFsaWduID09PSAndG9wJyxcblx0XHRcdHNwYWNlSGVpZ2h0ID0gY2hhcnQuc3BhY2luZ0JveC5oZWlnaHQgKyAoYWxpZ25Ub3AgPyAtb3B0aW9uc1kgOiBvcHRpb25zWSkgLSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRtYXhIZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodCxcblx0XHRcdGNsaXBIZWlnaHQsXG5cdFx0XHRjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3QsXG5cdFx0XHRuYXZPcHRpb25zID0gb3B0aW9ucy5uYXZpZ2F0aW9uLFxuXHRcdFx0YW5pbWF0aW9uID0gcGljayhuYXZPcHRpb25zLmFuaW1hdGlvbiwgdHJ1ZSksXG5cdFx0XHRhcnJvd1NpemUgPSBuYXZPcHRpb25zLmFycm93U2l6ZSB8fCAxMixcblx0XHRcdG5hdiA9IHRoaXMubmF2O1xuXHRcdFx0XG5cdFx0Ly8gQWRqdXN0IHRoZSBoZWlnaHRcblx0XHRpZiAob3B0aW9ucy5sYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuXHRcdFx0c3BhY2VIZWlnaHQgLz0gMjtcblx0XHR9XG5cdFx0aWYgKG1heEhlaWdodCkge1xuXHRcdFx0c3BhY2VIZWlnaHQgPSBtYXRoTWluKHNwYWNlSGVpZ2h0LCBtYXhIZWlnaHQpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBSZXNldCB0aGUgbGVnZW5kIGhlaWdodCBhbmQgYWRqdXN0IHRoZSBjbGlwcGluZyByZWN0YW5nbGVcblx0XHRpZiAobGVnZW5kSGVpZ2h0ID4gc3BhY2VIZWlnaHQgJiYgIW9wdGlvbnMudXNlSFRNTCkge1xuXG5cdFx0XHR0aGlzLmNsaXBIZWlnaHQgPSBjbGlwSGVpZ2h0ID0gc3BhY2VIZWlnaHQgLSAyMCAtIHRoaXMudGl0bGVIZWlnaHQ7XG5cdFx0XHR0aGlzLnBhZ2VDb3VudCA9IHBhZ2VDb3VudCA9IG1hdGhDZWlsKGxlZ2VuZEhlaWdodCAvIGNsaXBIZWlnaHQpO1xuXHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IHBpY2sodGhpcy5jdXJyZW50UGFnZSwgMSk7XG5cdFx0XHR0aGlzLmZ1bGxIZWlnaHQgPSBsZWdlbmRIZWlnaHQ7XG5cdFx0XHRcblx0XHRcdC8vIE9ubHkgYXBwbHkgY2xpcHBpbmcgaWYgbmVlZGVkLiBDbGlwcGluZyBjYXVzZXMgYmx1cnJlZCBsZWdlbmQgaW4gUERGIGV4cG9ydCAoIzE3ODcpXG5cdFx0XHRpZiAoIWNsaXBSZWN0KSB7XG5cdFx0XHRcdGNsaXBSZWN0ID0gbGVnZW5kLmNsaXBSZWN0ID0gcmVuZGVyZXIuY2xpcFJlY3QoMCwgMCwgOTk5OSwgMCk7XG5cdFx0XHRcdGxlZ2VuZC5jb250ZW50R3JvdXAuY2xpcChjbGlwUmVjdCk7XG5cdFx0XHR9XG5cdFx0XHRjbGlwUmVjdC5hdHRyKHtcblx0XHRcdFx0aGVpZ2h0OiBjbGlwSGVpZ2h0XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gQWRkIG5hdmlnYXRpb24gZWxlbWVudHNcblx0XHRcdGlmICghbmF2KSB7XG5cdFx0XHRcdHRoaXMubmF2ID0gbmF2ID0gcmVuZGVyZXIuZygpLmF0dHIoeyB6SW5kZXg6IDEgfSkuYWRkKHRoaXMuZ3JvdXApO1xuXHRcdFx0XHR0aGlzLnVwID0gcmVuZGVyZXIuc3ltYm9sKCd0cmlhbmdsZScsIDAsIDAsIGFycm93U2l6ZSwgYXJyb3dTaXplKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRsZWdlbmQuc2Nyb2xsKC0xLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHR0aGlzLnBhZ2VyID0gcmVuZGVyZXIudGV4dCgnJywgMTUsIDEwKVxuXHRcdFx0XHRcdC5jc3MobmF2T3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0XHQuYWRkKG5hdik7XG5cdFx0XHRcdHRoaXMuZG93biA9IHJlbmRlcmVyLnN5bWJvbCgndHJpYW5nbGUtZG93bicsIDAsIDAsIGFycm93U2l6ZSwgYXJyb3dTaXplKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRsZWdlbmQuc2Nyb2xsKDEsIGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkKG5hdik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNldCBpbml0aWFsIHBvc2l0aW9uXG5cdFx0XHRsZWdlbmQuc2Nyb2xsKDApO1xuXHRcdFx0XG5cdFx0XHRsZWdlbmRIZWlnaHQgPSBzcGFjZUhlaWdodDtcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiAobmF2KSB7XG5cdFx0XHRjbGlwUmVjdC5hdHRyKHtcblx0XHRcdFx0aGVpZ2h0OiBjaGFydC5jaGFydEhlaWdodFxuXHRcdFx0fSk7XG5cdFx0XHRuYXYuaGlkZSgpO1xuXHRcdFx0dGhpcy5zY3JvbGxHcm91cC5hdHRyKHtcblx0XHRcdFx0dHJhbnNsYXRlWTogMVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmNsaXBIZWlnaHQgPSAwOyAvLyAjMTM3OVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbGVnZW5kSGVpZ2h0O1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFNjcm9sbCB0aGUgbGVnZW5kIGJ5IGEgbnVtYmVyIG9mIHBhZ2VzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY3JvbGxCeVxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uXG5cdCAqL1xuXHRzY3JvbGw6IGZ1bmN0aW9uIChzY3JvbGxCeSwgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHBhZ2VDb3VudCA9IHRoaXMucGFnZUNvdW50LFxuXHRcdFx0Y3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlICsgc2Nyb2xsQnksXG5cdFx0XHRjbGlwSGVpZ2h0ID0gdGhpcy5jbGlwSGVpZ2h0LFxuXHRcdFx0bmF2T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLFxuXHRcdFx0YWN0aXZlQ29sb3IgPSBuYXZPcHRpb25zLmFjdGl2ZUNvbG9yLFxuXHRcdFx0aW5hY3RpdmVDb2xvciA9IG5hdk9wdGlvbnMuaW5hY3RpdmVDb2xvcixcblx0XHRcdHBhZ2VyID0gdGhpcy5wYWdlcixcblx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRzY3JvbGxPZmZzZXQ7XG5cdFx0XG5cdFx0Ly8gV2hlbiByZXNpemluZyB3aGlsZSBsb29raW5nIGF0IHRoZSBsYXN0IHBhZ2Vcblx0XHRpZiAoY3VycmVudFBhZ2UgPiBwYWdlQ291bnQpIHtcblx0XHRcdGN1cnJlbnRQYWdlID0gcGFnZUNvdW50O1xuXHRcdH1cblx0XHRcblx0XHRpZiAoY3VycmVudFBhZ2UgPiAwKSB7XG5cdFx0XHRcblx0XHRcdGlmIChhbmltYXRpb24gIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCB0aGlzLmNoYXJ0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5uYXYuYXR0cih7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IHBhZGRpbmcsXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IGNsaXBIZWlnaHQgKyA3ICsgdGhpcy50aXRsZUhlaWdodCxcblx0XHRcdFx0dmlzaWJpbGl0eTogVklTSUJMRVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnVwLmF0dHIoe1xuXHRcdFx0XHRcdGZpbGw6IGN1cnJlbnRQYWdlID09PSAxID8gaW5hY3RpdmVDb2xvciA6IGFjdGl2ZUNvbG9yXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdGN1cnNvcjogY3VycmVudFBhZ2UgPT09IDEgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0fSk7XG5cdFx0XHRwYWdlci5hdHRyKHtcblx0XHRcdFx0dGV4dDogY3VycmVudFBhZ2UgKyAnLycgKyB0aGlzLnBhZ2VDb3VudFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvd24uYXR0cih7XG5cdFx0XHRcdFx0eDogMTggKyB0aGlzLnBhZ2VyLmdldEJCb3goKS53aWR0aCwgLy8gYWRqdXN0IHRvIHRleHQgd2lkdGhcblx0XHRcdFx0XHRmaWxsOiBjdXJyZW50UGFnZSA9PT0gcGFnZUNvdW50ID8gaW5hY3RpdmVDb2xvciA6IGFjdGl2ZUNvbG9yXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdGN1cnNvcjogY3VycmVudFBhZ2UgPT09IHBhZ2VDb3VudCA/ICdkZWZhdWx0JyA6ICdwb2ludGVyJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0c2Nyb2xsT2Zmc2V0ID0gLW1hdGhNaW4oY2xpcEhlaWdodCAqIChjdXJyZW50UGFnZSAtIDEpLCB0aGlzLmZ1bGxIZWlnaHQgLSBjbGlwSGVpZ2h0ICsgcGFkZGluZykgKyAxO1xuXHRcdFx0dGhpcy5zY3JvbGxHcm91cC5hbmltYXRlKHtcblx0XHRcdFx0dHJhbnNsYXRlWTogc2Nyb2xsT2Zmc2V0XG5cdFx0XHR9KTtcblx0XHRcdHBhZ2VyLmF0dHIoe1xuXHRcdFx0XHR0ZXh0OiBjdXJyZW50UGFnZSArICcvJyArIHBhZ2VDb3VudFxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IGN1cnJlbnRQYWdlO1xuXHRcdFx0dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoc2Nyb2xsT2Zmc2V0KTtcblx0XHR9XG5cdFx0XHRcblx0fVxuXHRcbn07XG5cbi8vIFdvcmthcm91bmQgZm9yICMyMDMwLCBob3Jpem9udGFsIGxlZ2VuZCBpdGVtcyBub3QgZGlzcGxheWluZyBpbiBJRTExIFByZXZpZXcuXG4vLyBUT0RPOiBXaGVuIElFMTEgaXMgcmVsZWFzZWQsIGNoZWNrIGFnYWluIGZvciB0aGlzIGJ1ZywgYW5kIHJlbW92ZSB0aGUgZml4XG4vLyBvciBtYWtlIGEgYmV0dGVyIG9uZS5cbmlmICgvVHJpZGVudC4qPzExXFwuMC8udGVzdCh1c2VyQWdlbnQpKSB7XG5cdHdyYXAoTGVnZW5kLnByb3RvdHlwZSwgJ3Bvc2l0aW9uSXRlbScsIGZ1bmN0aW9uIChwcm9jZWVkLCBpdGVtKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRwcm9jZWVkLmNhbGwobGVnZW5kLCBpdGVtKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogVGhlIGNoYXJ0IGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIGNoYXJ0IGhhcyBsb2FkZWRcbiAqL1xuZnVuY3Rpb24gQ2hhcnQoKSB7XG5cdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5DaGFydC5wcm90b3R5cGUgPSB7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGNoYXJ0XG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAodXNlck9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0XHQvLyBIYW5kbGUgcmVndWxhciBvcHRpb25zXG5cdFx0dmFyIG9wdGlvbnMsXG5cdFx0XHRzZXJpZXNPcHRpb25zID0gdXNlck9wdGlvbnMuc2VyaWVzOyAvLyBza2lwIG1lcmdpbmcgZGF0YSBwb2ludHMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcblxuXHRcdHVzZXJPcHRpb25zLnNlcmllcyA9IG51bGw7XG5cdFx0b3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCB1c2VyT3B0aW9ucyk7IC8vIGRvIHRoZSBtZXJnZVxuXHRcdG9wdGlvbnMuc2VyaWVzID0gdXNlck9wdGlvbnMuc2VyaWVzID0gc2VyaWVzT3B0aW9uczsgLy8gc2V0IGJhY2sgdGhlIHNlcmllcyBkYXRhXG5cblx0XHR2YXIgb3B0aW9uc0NoYXJ0ID0gb3B0aW9ucy5jaGFydDtcblx0XHRcblx0XHQvLyBDcmVhdGUgbWFyZ2luICYgc3BhY2luZyBhcnJheVxuXHRcdHRoaXMubWFyZ2luID0gdGhpcy5zcGxhc2hBcnJheSgnbWFyZ2luJywgb3B0aW9uc0NoYXJ0KTtcblx0XHR0aGlzLnNwYWNpbmcgPSB0aGlzLnNwbGFzaEFycmF5KCdzcGFjaW5nJywgb3B0aW9uc0NoYXJ0KTtcblxuXHRcdHZhciBjaGFydEV2ZW50cyA9IG9wdGlvbnNDaGFydC5ldmVudHM7XG5cblx0XHQvL3RoaXMucnVuQ2hhcnRDbGljayA9IGNoYXJ0RXZlbnRzICYmICEhY2hhcnRFdmVudHMuY2xpY2s7XG5cdFx0dGhpcy5ib3VuZHMgPSB7IGg6IHt9LCB2OiB7fSB9OyAvLyBQaXhlbCBkYXRhIGJvdW5kcyBmb3IgdG91Y2ggem9vbVxuXG5cdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHRoaXMuaXNSZXNpemluZyA9IDA7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHQvL2NoYXJ0VGl0bGVPcHRpb25zID0gVU5ERUZJTkVEO1xuXHRcdC8vY2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBVTkRFRklORUQ7XG5cblx0XHR0aGlzLmF4ZXMgPSBbXTtcblx0XHR0aGlzLnNlcmllcyA9IFtdO1xuXHRcdHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID0gb3B0aW9uc0NoYXJ0LnNob3dBeGVzO1xuXHRcdC8vdGhpcy5heGlzT2Zmc2V0ID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5tYXhUaWNrcyA9IFVOREVGSU5FRDsgLy8gaGFuZGxlIHRoZSBncmVhdGVzdCBhbW91bnQgb2YgdGlja3Mgb24gZ3JvdXBlZCBheGVzXG5cdFx0Ly90aGlzLmludmVydGVkID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5sb2FkaW5nU2hvd24gPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLmNvbnRhaW5lciA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMuY2hhcnRXaWR0aCA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMuY2hhcnRIZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm1hcmdpblJpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5tYXJnaW5Cb3R0b20gPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLmNvbnRhaW5lcldpZHRoID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5jb250YWluZXJIZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm9sZENoYXJ0V2lkdGggPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm9sZENoYXJ0SGVpZ2h0ID0gVU5ERUZJTkVEO1xuXG5cdFx0Ly90aGlzLnJlbmRlclRvID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5yZW5kZXJUb0Nsb25lID0gVU5ERUZJTkVEO1xuXG5cdFx0Ly90aGlzLnNwYWNpbmdCb3ggPSBVTkRFRklORURcblxuXHRcdC8vdGhpcy5sZWdlbmQgPSBVTkRFRklORUQ7XG5cblx0XHQvLyBFbGVtZW50c1xuXHRcdC8vdGhpcy5jaGFydEJhY2tncm91bmQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLnBsb3RCYWNrZ3JvdW5kID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5wbG90QkdJbWFnZSA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMucGxvdEJvcmRlciA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMubG9hZGluZ0RpdiA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMubG9hZGluZ1NwYW4gPSBVTkRFRklORUQ7XG5cblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlO1xuXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCB0byB0aGUgZ2xvYmFsIGxvb2t1cFxuXHRcdGNoYXJ0LmluZGV4ID0gY2hhcnRzLmxlbmd0aDtcblx0XHRjaGFydHMucHVzaChjaGFydCk7XG5cblx0XHQvLyBTZXQgdXAgYXV0byByZXNpemVcblx0XHRpZiAob3B0aW9uc0NoYXJ0LnJlZmxvdyAhPT0gZmFsc2UpIHtcblx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2hhcnQuaW5pdFJlZmxvdygpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hhcnQgZXZlbnQgaGFuZGxlcnNcblx0XHRpZiAoY2hhcnRFdmVudHMpIHtcblx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGNoYXJ0RXZlbnRzKSB7XG5cdFx0XHRcdGFkZEV2ZW50KGNoYXJ0LCBldmVudFR5cGUsIGNoYXJ0RXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNoYXJ0LnhBeGlzID0gW107XG5cdFx0Y2hhcnQueUF4aXMgPSBbXTtcblxuXHRcdC8vIEV4cG9zZSBtZXRob2RzIGFuZCB2YXJpYWJsZXNcblx0XHRjaGFydC5hbmltYXRpb24gPSB1c2VDYW5WRyA/IGZhbHNlIDogcGljayhvcHRpb25zQ2hhcnQuYW5pbWF0aW9uLCB0cnVlKTtcblx0XHRjaGFydC5wb2ludENvdW50ID0gMDtcblx0XHRjaGFydC5jb3VudGVycyA9IG5ldyBDaGFydENvdW50ZXJzKCk7XG5cblx0XHRjaGFydC5maXJzdFJlbmRlcigpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGFuIGluZGl2aWR1YWwgc2VyaWVzLCBjYWxsZWQgaW50ZXJuYWxseSBiZWZvcmUgcmVuZGVyIHRpbWVcblx0ICovXG5cdGluaXRTZXJpZXM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHR0eXBlID0gb3B0aW9ucy50eXBlIHx8IG9wdGlvbnNDaGFydC50eXBlIHx8IG9wdGlvbnNDaGFydC5kZWZhdWx0U2VyaWVzVHlwZSxcblx0XHRcdHNlcmllcyxcblx0XHRcdGNvbnN0ciA9IHNlcmllc1R5cGVzW3R5cGVdO1xuXG5cdFx0Ly8gTm8gc3VjaCBzZXJpZXMgdHlwZVxuXHRcdGlmICghY29uc3RyKSB7XG5cdFx0XHRlcnJvcigxNywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0c2VyaWVzID0gbmV3IGNvbnN0cigpO1xuXHRcdHNlcmllcy5pbml0KHRoaXMsIG9wdGlvbnMpO1xuXHRcdHJldHVybiBzZXJpZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHNlcmllcyBkeW5hbWljYWxseSBhZnRlciAgdGltZVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgY29uZmlnIG9wdGlvbnNcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IGFmdGVyIGFkZGluZy4gRGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHNlcmllcyBUaGUgbmV3bHkgY3JlYXRlZCBzZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHRhZGRTZXJpZXM6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdHZhciBzZXJpZXMsXG5cdFx0XHRjaGFydCA9IHRoaXM7XG5cblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpOyAvLyBkZWZhdWx0cyB0byB0cnVlXG5cblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2FkZFNlcmllcycsIHsgb3B0aW9uczogb3B0aW9ucyB9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlcmllcyA9IGNoYXJ0LmluaXRTZXJpZXMob3B0aW9ucyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gdHJ1ZTsgLy8gdGhlIHNlcmllcyBhcnJheSBpcyBvdXQgb2Ygc3luYyB3aXRoIHRoZSBkaXNwbGF5XG5cdFx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTtcblx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VyaWVzO1xuXHR9LFxuXG5cdC8qKlxuICAgICAqIEFkZCBhbiBheGlzIHRvIHRoZSBjaGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBheGlzIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNYIFdoZXRoZXIgaXQgaXMgYW4gWCBheGlzIG9yIGEgdmFsdWUgYXhpc1xuICAgICAqL1xuXHRhZGRBeGlzOiBmdW5jdGlvbiAob3B0aW9ucywgaXNYLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdHZhciBrZXkgPSBpc1ggPyAneEF4aXMnIDogJ3lBeGlzJyxcblx0XHRcdGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGF4aXM7XG5cblx0XHQvKmpzbGludCB1bnVzZWQ6IGZhbHNlKi9cblx0XHRheGlzID0gbmV3IEF4aXModGhpcywgbWVyZ2Uob3B0aW9ucywge1xuXHRcdFx0aW5kZXg6IHRoaXNba2V5XS5sZW5ndGgsXG5cdFx0XHRpc1g6IGlzWFxuXHRcdH0pKTtcblx0XHQvKmpzbGludCB1bnVzZWQ6IHRydWUqL1xuXG5cdFx0Ly8gUHVzaCB0aGUgbmV3IGF4aXMgb3B0aW9ucyB0byB0aGUgY2hhcnQgb3B0aW9uc1xuXHRcdGNoYXJ0T3B0aW9uc1trZXldID0gc3BsYXQoY2hhcnRPcHRpb25zW2tleV0gfHwge30pO1xuXHRcdGNoYXJ0T3B0aW9uc1trZXldLnB1c2gob3B0aW9ucyk7XG5cblx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHR0aGlzLnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHBvaW50IGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwbG90WCBQaXhlbCB4IHJlbGF0aXZlIHRvIHRoZSBwbG90IGFyZWFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBsb3RZIFBpeGVsIHkgcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydGVkIFdoZXRoZXIgdGhlIGNoYXJ0IGlzIGludmVydGVkXG5cdCAqL1xuXHRpc0luc2lkZVBsb3Q6IGZ1bmN0aW9uIChwbG90WCwgcGxvdFksIGludmVydGVkKSB7XG5cdFx0dmFyIHggPSBpbnZlcnRlZCA/IHBsb3RZIDogcGxvdFgsXG5cdFx0XHR5ID0gaW52ZXJ0ZWQgPyBwbG90WCA6IHBsb3RZO1xuXHRcdFx0XG5cdFx0cmV0dXJuIHggPj0gMCAmJlxuXHRcdFx0eCA8PSB0aGlzLnBsb3RXaWR0aCAmJlxuXHRcdFx0eSA+PSAwICYmXG5cdFx0XHR5IDw9IHRoaXMucGxvdEhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogQWRqdXN0IGFsbCBheGVzIHRpY2sgYW1vdW50c1xuXHQgKi9cblx0YWRqdXN0VGlja0Ftb3VudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3MgIT09IGZhbHNlKSB7XG5cdFx0XHRlYWNoKHRoaXMuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0YXhpcy5hZGp1c3RUaWNrQW1vdW50KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5tYXhUaWNrcyA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyBsZWdlbmQsIGF4ZXMgb3Igc2VyaWVzIGJhc2VkIG9uIHVwZGF0ZWQgZGF0YVxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHQgKiAgICBjb25maWd1cmF0aW9uXG5cdCAqL1xuXHRyZWRyYXc6IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0YXhlcyA9IGNoYXJ0LmF4ZXMsXG5cdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRwb2ludGVyID0gY2hhcnQucG9pbnRlcixcblx0XHRcdGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCxcblx0XHRcdHJlZHJhd0xlZ2VuZCA9IGNoYXJ0LmlzRGlydHlMZWdlbmQsXG5cdFx0XHRoYXNTdGFja2VkU2VyaWVzLFxuXHRcdFx0aGFzRGlydHlTdGFja3MsXG5cdFx0XHRpc0RpcnR5Qm94ID0gY2hhcnQuaXNEaXJ0eUJveCwgLy8gdG9kbzogY2hlY2sgaWYgaXQgaGFzIGFjdHVhbGx5IGNoYW5nZWQ/XG5cdFx0XHRzZXJpZXNMZW5ndGggPSBzZXJpZXMubGVuZ3RoLFxuXHRcdFx0aSA9IHNlcmllc0xlbmd0aCxcblx0XHRcdHNlcmllLFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdGlzSGlkZGVuQ2hhcnQgPSByZW5kZXJlci5pc0hpZGRlbigpLFxuXHRcdFx0YWZ0ZXJSZWRyYXcgPSBbXTtcblx0XHRcdFxuXHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblx0XHRcblx0XHRpZiAoaXNIaWRkZW5DaGFydCkge1xuXHRcdFx0Y2hhcnQuY2xvbmVSZW5kZXJUbygpO1xuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0aXRsZSBsYXlvdXQgKHJlZmxvdyBtdWx0aWxpbmUgdGV4dClcblx0XHRjaGFydC5sYXlPdXRUaXRsZXMoKTtcblxuXHRcdC8vIGxpbmsgc3RhY2tlZCBzZXJpZXNcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRzZXJpZSA9IHNlcmllc1tpXTtcblxuXHRcdFx0aWYgKHNlcmllLm9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0aGFzU3RhY2tlZFNlcmllcyA9IHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc2VyaWUuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGhhc0RpcnR5U3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaGFzRGlydHlTdGFja3MpIHsgLy8gbWFyayBvdGhlcnMgYXMgZGlydHlcblx0XHRcdGkgPSBzZXJpZXNMZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHNlcmllID0gc2VyaWVzW2ldO1xuXHRcdFx0XHRpZiAoc2VyaWUub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdHNlcmllLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIHVwZGF0ZWQgZGF0YSBpbiB0aGUgc2VyaWVzXG5cdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0aWYgKHNlcmllLmlzRGlydHkpIHsgLy8gcHJlcGFyZSB0aGUgZGF0YSBzbyBheGlzIGNhbiByZWFkIGl0XG5cdFx0XHRcdGlmIChzZXJpZS5vcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHtcblx0XHRcdFx0XHRyZWRyYXdMZWdlbmQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBoYW5kbGUgYWRkZWQgb3IgcmVtb3ZlZCBzZXJpZXNcblx0XHRpZiAocmVkcmF3TGVnZW5kICYmIGxlZ2VuZC5vcHRpb25zLmVuYWJsZWQpIHsgLy8gc2VyaWVzIG9yIHBpZSBwb2ludHMgYXJlIGFkZGVkIG9yIHJlbW92ZWRcblx0XHRcdC8vIGRyYXcgbGVnZW5kIGdyYXBoaWNzXG5cdFx0XHRsZWdlbmQucmVuZGVyKCk7XG5cblx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyByZXNldCBzdGFja3Ncblx0XHRpZiAoaGFzU3RhY2tlZFNlcmllcykge1xuXHRcdFx0Y2hhcnQuZ2V0U3RhY2tzKCk7XG5cdFx0fVxuXG5cblx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHRpZiAoIWNoYXJ0LmlzUmVzaXppbmcpIHtcblxuXHRcdFx0XHQvLyByZXNldCBtYXhUaWNrc1xuXHRcdFx0XHRjaGFydC5tYXhUaWNrcyA9IG51bGw7XG5cblx0XHRcdFx0Ly8gc2V0IGF4ZXMgc2NhbGVzXG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC5hZGp1c3RUaWNrQW1vdW50cygpO1xuXHRcdFx0Y2hhcnQuZ2V0TWFyZ2lucygpO1xuXG5cdFx0XHQvLyBJZiBvbmUgYXhpcyBpcyBkaXJ0eSwgYWxsIGF4ZXMgbXVzdCBiZSByZWRyYXduICgjNzkyLCAjMjE2OSlcblx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVkcmF3IGF4ZXNcblx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEZpcmUgJ2FmdGVyU2V0RXh0cmVtZXMnIG9ubHkgaWYgZXh0cmVtZXMgYXJlIHNldFxuXHRcdFx0XHRpZiAoYXhpcy5pc0RpcnR5RXh0cmVtZXMpIHsgLy8gIzgyMVxuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eUV4dHJlbWVzID0gZmFsc2U7XG5cdFx0XHRcdFx0YWZ0ZXJSZWRyYXcucHVzaChmdW5jdGlvbiAoKSB7IC8vIHByZXZlbnQgYSByZWN1cnNpdmUgY2FsbCB0byBjaGFydC5yZWRyYXcoKSAoIzExMTkpXG5cdFx0XHRcdFx0XHRmaXJlRXZlbnQoYXhpcywgJ2FmdGVyU2V0RXh0cmVtZXMnLCBleHRlbmQoYXhpcy5ldmVudEFyZ3MsIGF4aXMuZ2V0RXh0cmVtZXMoKSkpOyAvLyAjNzQ3LCAjNzUxXG5cdFx0XHRcdFx0XHRkZWxldGUgYXhpcy5ldmVudEFyZ3M7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpc0RpcnR5Qm94IHx8IGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdFx0XHRheGlzLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXG5cdFx0fVxuXHRcdC8vIHRoZSBwbG90IGFyZWFzIHNpemUgaGFzIGNoYW5nZWRcblx0XHRpZiAoaXNEaXJ0eUJveCkge1xuXHRcdFx0Y2hhcnQuZHJhd0NoYXJ0Qm94KCk7XG5cdFx0fVxuXG5cblx0XHQvLyByZWRyYXcgYWZmZWN0ZWQgc2VyaWVzXG5cdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0aWYgKHNlcmllLmlzRGlydHkgJiYgc2VyaWUudmlzaWJsZSAmJlxuXHRcdFx0XHRcdCghc2VyaWUuaXNDYXJ0ZXNpYW4gfHwgc2VyaWUueEF4aXMpKSB7IC8vIGlzc3VlICMxNTNcblx0XHRcdFx0c2VyaWUucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBtb3ZlIHRvb2x0aXAgb3IgcmVzZXRcblx0XHRpZiAocG9pbnRlciAmJiBwb2ludGVyLnJlc2V0KSB7XG5cdFx0XHRwb2ludGVyLnJlc2V0KHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIHJlZHJhdyBpZiBjYW52YXNcblx0XHRyZW5kZXJlci5kcmF3KCk7XG5cblx0XHQvLyBmaXJlIHRoZSBldmVudFxuXHRcdGZpcmVFdmVudChjaGFydCwgJ3JlZHJhdycpOyAvLyBqUXVlcnkgYnJlYWtzIHRoaXMgd2hlbiBjYWxsaW5nIGl0IGZyb20gYWRkRXZlbnQuIE92ZXJ3cml0ZXMgY2hhcnQucmVkcmF3XG5cdFx0XG5cdFx0aWYgKGlzSGlkZGVuQ2hhcnQpIHtcblx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8odHJ1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzIHRoYXQgYXJlIHB1dCBvbiBob2xkIHVudGlsIGFmdGVyIHRoZSByZWRyYXdcblx0XHRlYWNoKGFmdGVyUmVkcmF3LCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrLmNhbGwoKTtcblx0XHR9KTtcblx0fSxcblxuXG5cblx0LyoqXG5cdCAqIERpbSB0aGUgY2hhcnQgYW5kIHNob3cgYSBsb2FkaW5nIHRleHQgb3Igc3ltYm9sXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQW4gb3B0aW9uYWwgdGV4dCB0byBzaG93IGluIHRoZSBsb2FkaW5nIGxhYmVsIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG5cdCAqL1xuXHRzaG93TG9hZGluZzogZnVuY3Rpb24gKHN0cikge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdGxvYWRpbmdEaXYgPSBjaGFydC5sb2FkaW5nRGl2O1xuXG5cdFx0dmFyIGxvYWRpbmdPcHRpb25zID0gb3B0aW9ucy5sb2FkaW5nO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBsYXllciBhdCB0aGUgZmlyc3QgY2FsbFxuXHRcdGlmICghbG9hZGluZ0Rpdikge1xuXHRcdFx0Y2hhcnQubG9hZGluZ0RpdiA9IGxvYWRpbmdEaXYgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRjbGFzc05hbWU6IFBSRUZJWCArICdsb2FkaW5nJ1xuXHRcdFx0fSwgZXh0ZW5kKGxvYWRpbmdPcHRpb25zLnN0eWxlLCB7XG5cdFx0XHRcdHpJbmRleDogMTAsXG5cdFx0XHRcdGRpc3BsYXk6IE5PTkVcblx0XHRcdH0pLCBjaGFydC5jb250YWluZXIpO1xuXG5cdFx0XHRjaGFydC5sb2FkaW5nU3BhbiA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdzcGFuJyxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bG9hZGluZ09wdGlvbnMubGFiZWxTdHlsZSxcblx0XHRcdFx0bG9hZGluZ0RpdlxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSB0ZXh0XG5cdFx0Y2hhcnQubG9hZGluZ1NwYW4uaW5uZXJIVE1MID0gc3RyIHx8IG9wdGlvbnMubGFuZy5sb2FkaW5nO1xuXG5cdFx0Ly8gc2hvdyBpdFxuXHRcdGlmICghY2hhcnQubG9hZGluZ1Nob3duKSB7XG5cdFx0XHRjc3MobG9hZGluZ0RpdiwgeyBcblx0XHRcdFx0b3BhY2l0eTogMCwgXG5cdFx0XHRcdGRpc3BsYXk6ICcnLFxuXHRcdFx0XHRsZWZ0OiBjaGFydC5wbG90TGVmdCArIFBYLFxuXHRcdFx0XHR0b3A6IGNoYXJ0LnBsb3RUb3AgKyBQWCxcblx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RXaWR0aCArIFBYLFxuXHRcdFx0XHRoZWlnaHQ6IGNoYXJ0LnBsb3RIZWlnaHQgKyBQWFxuXHRcdFx0fSk7XG5cdFx0XHRhbmltYXRlKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0b3BhY2l0eTogbG9hZGluZ09wdGlvbnMuc3R5bGUub3BhY2l0eVxuXHRcdFx0fSwge1xuXHRcdFx0XHRkdXJhdGlvbjogbG9hZGluZ09wdGlvbnMuc2hvd0R1cmF0aW9uIHx8IDBcblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQubG9hZGluZ1Nob3duID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIGxvYWRpbmcgbGF5ZXJcblx0ICovXG5cdGhpZGVMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRsb2FkaW5nRGl2ID0gdGhpcy5sb2FkaW5nRGl2O1xuXG5cdFx0aWYgKGxvYWRpbmdEaXYpIHtcblx0XHRcdGFuaW1hdGUobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRvcGFjaXR5OiAwXG5cdFx0XHR9LCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmxvYWRpbmcuaGlkZUR1cmF0aW9uIHx8IDEwMCxcblx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjc3MobG9hZGluZ0RpdiwgeyBkaXNwbGF5OiBOT05FIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5sb2FkaW5nU2hvd24gPSBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGFuIGF4aXMsIHNlcmllcyBvciBwb2ludCBvYmplY3QgYnkgaWQuXG5cdCAqIEBwYXJhbSBpZCB7U3RyaW5nfSBUaGUgaWQgYXMgZ2l2ZW4gaW4gdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbiAoaWQpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0YXhlcyA9IGNoYXJ0LmF4ZXMsXG5cdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXM7XG5cblx0XHR2YXIgaSxcblx0XHRcdGosXG5cdFx0XHRwb2ludHM7XG5cblx0XHQvLyBzZWFyY2ggYXhlc1xuXHRcdGZvciAoaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXhlc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRyZXR1cm4gYXhlc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggc2VyaWVzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHNlcmllc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRyZXR1cm4gc2VyaWVzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNlYXJjaCBwb2ludHNcblx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSBzZXJpZXNbaV0ucG9pbnRzIHx8IFtdO1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAocG9pbnRzW2pdLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBwb2ludHNbal07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgQXhpcyBpbnN0YW5jZXMgYmFzZWQgb24gdGhlIGNvbmZpZyBvcHRpb25zXG5cdCAqL1xuXHRnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR4QXhpc09wdGlvbnMgPSBvcHRpb25zLnhBeGlzID0gc3BsYXQob3B0aW9ucy54QXhpcyB8fCB7fSksXG5cdFx0XHR5QXhpc09wdGlvbnMgPSBvcHRpb25zLnlBeGlzID0gc3BsYXQob3B0aW9ucy55QXhpcyB8fCB7fSksXG5cdFx0XHRvcHRpb25zQXJyYXksXG5cdFx0XHRheGlzO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFyZSBhcnJheXMgYW5kIGFkZCBzb21lIG1lbWJlcnNcblx0XHRlYWNoKHhBeGlzT3B0aW9ucywgZnVuY3Rpb24gKGF4aXMsIGkpIHtcblx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdFx0YXhpcy5pc1ggPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0ZWFjaCh5QXhpc09wdGlvbnMsIGZ1bmN0aW9uIChheGlzLCBpKSB7XG5cdFx0XHRheGlzLmluZGV4ID0gaTtcblx0XHR9KTtcblxuXHRcdC8vIGNvbmNhdGVuYXRlIGFsbCBheGlzIG9wdGlvbnMgaW50byBvbmUgYXJyYXlcblx0XHRvcHRpb25zQXJyYXkgPSB4QXhpc09wdGlvbnMuY29uY2F0KHlBeGlzT3B0aW9ucyk7XG5cblx0XHRlYWNoKG9wdGlvbnNBcnJheSwgZnVuY3Rpb24gKGF4aXNPcHRpb25zKSB7XG5cdFx0XHRheGlzID0gbmV3IEF4aXMoY2hhcnQsIGF4aXNPcHRpb25zKTtcblx0XHR9KTtcblxuXHRcdGNoYXJ0LmFkanVzdFRpY2tBbW91bnRzKCk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcG9pbnRzIGZyb20gYWxsIHNlcmllc1xuXHQgKi9cblx0Z2V0U2VsZWN0ZWRQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9pbnRzID0gW107XG5cdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRwb2ludHMgPSBwb2ludHMuY29uY2F0KGdyZXAoc2VyaWUucG9pbnRzIHx8IFtdLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LnNlbGVjdGVkO1xuXHRcdFx0fSkpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHNlcmllc1xuXHQgKi9cblx0Z2V0U2VsZWN0ZWRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZ3JlcCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRyZXR1cm4gc2VyaWUuc2VsZWN0ZWQ7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHN0YWNrcyBmb3IgZWFjaCBzZXJpZXMgYW5kIGNhbGN1bGF0ZSBzdGFja3MgdG90YWwgdmFsdWVzXG5cdCAqL1xuXHRnZXRTdGFja3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdFx0Ly8gcmVzZXQgc3RhY2tzIGZvciBlYWNoIHlBeGlzXG5cdFx0ZWFjaChjaGFydC55QXhpcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdGlmIChheGlzLnN0YWNrcyAmJiBheGlzLmhhc1Zpc2libGVTZXJpZXMpIHtcblx0XHRcdFx0YXhpcy5vbGRTdGFja3MgPSBheGlzLnN0YWNrcztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuc3RhY2tpbmcgJiYgKHNlcmllcy52aXNpYmxlID09PSB0cnVlIHx8IGNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzID09PSBmYWxzZSkpIHtcblx0XHRcdFx0c2VyaWVzLnN0YWNrS2V5ID0gc2VyaWVzLnR5cGUgKyBwaWNrKHNlcmllcy5vcHRpb25zLnN0YWNrLCAnJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERpc3BsYXkgdGhlIHpvb20gYnV0dG9uXG5cdCAqL1xuXHRzaG93UmVzZXRab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdFx0YnRuT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLFxuXHRcdFx0dGhlbWUgPSBidG5PcHRpb25zLnRoZW1lLFxuXHRcdFx0c3RhdGVzID0gdGhlbWUuc3RhdGVzLFxuXHRcdFx0YWxpZ25UbyA9IGJ0bk9wdGlvbnMucmVsYXRpdmVUbyA9PT0gJ2NoYXJ0JyA/IG51bGwgOiAncGxvdEJveCc7XG5cdFx0XHRcblx0XHR0aGlzLnJlc2V0Wm9vbUJ1dHRvbiA9IGNoYXJ0LnJlbmRlcmVyLmJ1dHRvbihsYW5nLnJlc2V0Wm9vbSwgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKCkgeyBjaGFydC56b29tT3V0KCk7IH0sIHRoZW1lLCBzdGF0ZXMgJiYgc3RhdGVzLmhvdmVyKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRhbGlnbjogYnRuT3B0aW9ucy5wb3NpdGlvbi5hbGlnbixcblx0XHRcdFx0dGl0bGU6IGxhbmcucmVzZXRab29tVGl0bGVcblx0XHRcdH0pXG5cdFx0XHQuYWRkKClcblx0XHRcdC5hbGlnbihidG5PcHRpb25zLnBvc2l0aW9uLCBmYWxzZSwgYWxpZ25Ubyk7XG5cdFx0XHRcblx0fSxcblxuXHQvKipcblx0ICogWm9vbSBvdXQgdG8gMToxXG5cdCAqL1xuXHR6b29tT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblx0XHRmaXJlRXZlbnQoY2hhcnQsICdzZWxlY3Rpb24nLCB7IHJlc2V0U2VsZWN0aW9uOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRjaGFydC56b29tKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFpvb20gaW50byBhIGdpdmVuIHBvcnRpb24gb2YgdGhlIGNoYXJ0IGdpdmVuIGJ5IGF4aXMgY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdCAqL1xuXHR6b29tOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0aGFzWm9vbWVkLFxuXHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRkaXNwbGF5QnV0dG9uID0gZmFsc2UsXG5cdFx0XHRyZXNldFpvb21CdXR0b247XG5cblx0XHQvLyBJZiB6b29tIGlzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVzZXQgdGhlIGF4ZXNcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LnJlc2V0U2VsZWN0aW9uKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbSgpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHsgLy8gZWxzZSwgem9vbSBpbiBvbiBhbGwgYXhlc1xuXHRcdFx0ZWFjaChldmVudC54QXhpcy5jb25jYXQoZXZlbnQueUF4aXMpLCBmdW5jdGlvbiAoYXhpc0RhdGEpIHtcblx0XHRcdFx0dmFyIGF4aXMgPSBheGlzRGF0YS5heGlzLFxuXHRcdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXM7XG5cblx0XHRcdFx0Ly8gZG9uJ3Qgem9vbSBtb3JlIHRoYW4gbWluUmFuZ2Vcblx0XHRcdFx0aWYgKHBvaW50ZXJbaXNYQXhpcyA/ICd6b29tWCcgOiAnem9vbVknXSB8fCBwb2ludGVyW2lzWEF4aXMgPyAncGluY2hYJyA6ICdwaW5jaFknXSkge1xuXHRcdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbShheGlzRGF0YS5taW4sIGF4aXNEYXRhLm1heCk7XG5cdFx0XHRcdFx0aWYgKGF4aXMuZGlzcGxheUJ0bikge1xuXHRcdFx0XHRcdFx0ZGlzcGxheUJ1dHRvbiA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2hvdyBvciBoaWRlIHRoZSBSZXNldCB6b29tIGJ1dHRvblxuXHRcdHJlc2V0Wm9vbUJ1dHRvbiA9IGNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbjtcblx0XHRpZiAoZGlzcGxheUJ1dHRvbiAmJiAhcmVzZXRab29tQnV0dG9uKSB7XG5cdFx0XHRjaGFydC5zaG93UmVzZXRab29tKCk7XG5cdFx0fSBlbHNlIGlmICghZGlzcGxheUJ1dHRvbiAmJiBpc09iamVjdChyZXNldFpvb21CdXR0b24pKSB7XG5cdFx0XHRjaGFydC5yZXNldFpvb21CdXR0b24gPSByZXNldFpvb21CdXR0b24uZGVzdHJveSgpO1xuXHRcdH1cblx0XHRcblxuXHRcdC8vIFJlZHJhd1xuXHRcdGlmIChoYXNab29tZWQpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhcblx0XHRcdFx0cGljayhjaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgZXZlbnQgJiYgZXZlbnQuYW5pbWF0aW9uLCBjaGFydC5wb2ludENvdW50IDwgMTAwKSAvLyBhbmltYXRpb25cblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYW4gdGhlIGNoYXJ0IGJ5IGRyYWdnaW5nIHRoZSBtb3VzZSBhY3Jvc3MgdGhlIHBhbmUuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG5cdCAqIG9uIG1vdXNlIG1vdmUsIGFuZCB0aGUgZGlzdGFuY2UgdG8gcGFuIGlzIGNvbXB1dGVkIGZyb20gY2hhcnRYIGNvbXBhcmVkIHRvXG5cdCAqIHRoZSBmaXJzdCBjaGFydFggcG9zaXRpb24gaW4gdGhlIGRyYWdnaW5nIG9wZXJhdGlvbi5cblx0ICovXG5cdHBhbjogZnVuY3Rpb24gKGUsIHBhbm5pbmcpIHtcblxuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0ZG9SZWRyYXc7XG5cblx0XHQvLyByZW1vdmUgYWN0aXZlIHBvaW50cyBmb3Igc2hhcmVkIHRvb2x0aXBcblx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZWFjaChwYW5uaW5nID09PSAneHknID8gWzEsIDBdIDogWzFdLCBmdW5jdGlvbiAoaXNYKSB7IC8vIHh5IGlzIHVzZWQgaW4gbWFwc1xuXHRcdFx0dmFyIG1vdXNlUG9zID0gZVtpc1ggPyAnY2hhcnRYJyA6ICdjaGFydFknXSxcblx0XHRcdFx0YXhpcyA9IGNoYXJ0W2lzWCA/ICd4QXhpcycgOiAneUF4aXMnXVswXSxcblx0XHRcdFx0c3RhcnRQb3MgPSBjaGFydFtpc1ggPyAnbW91c2VEb3duWCcgOiAnbW91c2VEb3duWSddLFxuXHRcdFx0XHRoYWxmUG9pbnRSYW5nZSA9IChheGlzLnBvaW50UmFuZ2UgfHwgMCkgLyAyLFxuXHRcdFx0XHRleHRyZW1lcyA9IGF4aXMuZ2V0RXh0cmVtZXMoKSxcblx0XHRcdFx0bmV3TWluID0gYXhpcy50b1ZhbHVlKHN0YXJ0UG9zIC0gbW91c2VQb3MsIHRydWUpICsgaGFsZlBvaW50UmFuZ2UsXG5cdFx0XHRcdG5ld01heCA9IGF4aXMudG9WYWx1ZShzdGFydFBvcyArIGNoYXJ0W2lzWCA/ICdwbG90V2lkdGgnIDogJ3Bsb3RIZWlnaHQnXSAtIG1vdXNlUG9zLCB0cnVlKSAtIGhhbGZQb2ludFJhbmdlO1xuXG5cdFx0XHRpZiAoYXhpcy5zZXJpZXMubGVuZ3RoICYmIG5ld01pbiA+IG1hdGhNaW4oZXh0cmVtZXMuZGF0YU1pbiwgZXh0cmVtZXMubWluKSAmJiBuZXdNYXggPCBtYXRoTWF4KGV4dHJlbWVzLmRhdGFNYXgsIGV4dHJlbWVzLm1heCkpIHtcblx0XHRcdFx0YXhpcy5zZXRFeHRyZW1lcyhuZXdNaW4sIG5ld01heCwgZmFsc2UsIGZhbHNlLCB7IHRyaWdnZXI6ICdwYW4nIH0pO1xuXHRcdFx0XHRkb1JlZHJhdyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0W2lzWCA/ICdtb3VzZURvd25YJyA6ICdtb3VzZURvd25ZJ10gPSBtb3VzZVBvczsgLy8gc2V0IG5ldyByZWZlcmVuY2UgZm9yIG5leHQgcnVuXG5cdFx0fSk7XG5cblx0XHRpZiAoZG9SZWRyYXcpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0fVxuXHRcdGNzcyhjaGFydC5jb250YWluZXIsIHsgY3Vyc29yOiAnbW92ZScgfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIHRpdGxlIGFuZCBzdWJ0aXRsZSBvZiB0aGUgY2hhcnRcblx0ICpcblx0ICogQHBhcmFtIHRpdGxlT3B0aW9ucyB7T2JqZWN0fSBOZXcgdGl0bGUgb3B0aW9uc1xuXHQgKiBAcGFyYW0gc3VidGl0bGVPcHRpb25zIHtPYmplY3R9IE5ldyBzdWJ0aXRsZSBvcHRpb25zXG5cdCAqXG5cdCAqL1xuXHRzZXRUaXRsZTogZnVuY3Rpb24gKHRpdGxlT3B0aW9ucywgc3VidGl0bGVPcHRpb25zKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMsXG5cdFx0XHRjaGFydFN1YnRpdGxlT3B0aW9ucztcblxuXHRcdGNoYXJ0VGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSA9IG1lcmdlKG9wdGlvbnMudGl0bGUsIHRpdGxlT3B0aW9ucyk7XG5cdFx0Y2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBvcHRpb25zLnN1YnRpdGxlID0gbWVyZ2Uob3B0aW9ucy5zdWJ0aXRsZSwgc3VidGl0bGVPcHRpb25zKTtcblxuXHRcdC8vIGFkZCB0aXRsZSBhbmQgc3VidGl0bGVcblx0XHRlYWNoKFtcblx0XHRcdFsndGl0bGUnLCB0aXRsZU9wdGlvbnMsIGNoYXJ0VGl0bGVPcHRpb25zXSxcblx0XHRcdFsnc3VidGl0bGUnLCBzdWJ0aXRsZU9wdGlvbnMsIGNoYXJ0U3VidGl0bGVPcHRpb25zXVxuXHRcdF0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdHZhciBuYW1lID0gYXJyWzBdLFxuXHRcdFx0XHR0aXRsZSA9IGNoYXJ0W25hbWVdLFxuXHRcdFx0XHR0aXRsZU9wdGlvbnMgPSBhcnJbMV0sXG5cdFx0XHRcdGNoYXJ0VGl0bGVPcHRpb25zID0gYXJyWzJdO1xuXG5cdFx0XHRpZiAodGl0bGUgJiYgdGl0bGVPcHRpb25zKSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gdGl0bGUgPSB0aXRsZS5kZXN0cm95KCk7IC8vIHJlbW92ZSBvbGRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGNoYXJ0VGl0bGVPcHRpb25zICYmIGNoYXJ0VGl0bGVPcHRpb25zLnRleHQgJiYgIXRpdGxlKSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gY2hhcnQucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBjaGFydFRpdGxlT3B0aW9ucy5hbGlnbixcblx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyBuYW1lLFxuXHRcdFx0XHRcdHpJbmRleDogY2hhcnRUaXRsZU9wdGlvbnMuekluZGV4IHx8IDRcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhjaGFydFRpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVx0XG5cdFx0fSk7XG5cdFx0Y2hhcnQubGF5T3V0VGl0bGVzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExheSBvdXQgdGhlIGNoYXJ0IHRpdGxlcyBhbmQgY2FjaGUgdGhlIGZ1bGwgb2Zmc2V0IGhlaWdodCBmb3IgdXNlIGluIGdldE1hcmdpbnNcblx0ICovXG5cdGxheU91dFRpdGxlczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aXRsZU9mZnNldCA9IDAsXG5cdFx0XHR0aXRsZSA9IHRoaXMudGl0bGUsXG5cdFx0XHRzdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGUsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSxcblx0XHRcdHN1YnRpdGxlT3B0aW9ucyA9IG9wdGlvbnMuc3VidGl0bGUsXG5cdFx0XHRhdXRvV2lkdGggPSB0aGlzLnNwYWNpbmdCb3gud2lkdGggLSA0NDsgLy8gNDQgbWFrZXMgcm9vbSBmb3IgZGVmYXVsdCBjb250ZXh0IGJ1dHRvblxuXG5cdFx0aWYgKHRpdGxlKSB7XG5cdFx0XHR0aXRsZVxuXHRcdFx0XHQuY3NzKHsgd2lkdGg6ICh0aXRsZU9wdGlvbnMud2lkdGggfHwgYXV0b1dpZHRoKSArIFBYIH0pXG5cdFx0XHRcdC5hbGlnbihleHRlbmQoeyB5OiAxNSB9LCB0aXRsZU9wdGlvbnMpLCBmYWxzZSwgJ3NwYWNpbmdCb3gnKTtcblx0XHRcdFxuXHRcdFx0aWYgKCF0aXRsZU9wdGlvbnMuZmxvYXRpbmcgJiYgIXRpdGxlT3B0aW9ucy52ZXJ0aWNhbEFsaWduKSB7XG5cdFx0XHRcdHRpdGxlT2Zmc2V0ID0gdGl0bGUuZ2V0QkJveCgpLmhlaWdodDtcblxuXHRcdFx0XHQvLyBBZGp1c3QgZm9yIGJyb3dzZXIgY29uc2lzdGVuY3kgKyBiYWNrd2FyZHMgY29tcGF0IGFmdGVyICM3NzYgZml4XG5cdFx0XHRcdGlmICh0aXRsZU9mZnNldCA+PSAxOCAmJiB0aXRsZU9mZnNldCA8PSAyNSkge1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0ID0gMTU7IFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdWJ0aXRsZSkge1xuXHRcdFx0c3VidGl0bGVcblx0XHRcdFx0LmNzcyh7IHdpZHRoOiAoc3VidGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHQuYWxpZ24oZXh0ZW5kKHsgeTogdGl0bGVPZmZzZXQgKyB0aXRsZU9wdGlvbnMubWFyZ2luIH0sIHN1YnRpdGxlT3B0aW9ucyksIGZhbHNlLCAnc3BhY2luZ0JveCcpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXN1YnRpdGxlT3B0aW9ucy5mbG9hdGluZyAmJiAhc3VidGl0bGVPcHRpb25zLnZlcnRpY2FsQWxpZ24pIHtcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSBtYXRoQ2VpbCh0aXRsZU9mZnNldCArIHN1YnRpdGxlLmdldEJCb3goKS5oZWlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudGl0bGVPZmZzZXQgPSB0aXRsZU9mZnNldDsgLy8gdXNlZCBpbiBnZXRNYXJnaW5zXG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byBvcHRpb25zIGFuZCBjb250YWluZXIgc2l6ZVxuXHQgKi9cblx0Z2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRyZW5kZXJUbyA9IGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgY2hhcnQucmVuZGVyVG87XG5cblx0XHQvLyBnZXQgaW5uZXIgd2lkdGggYW5kIGhlaWdodCBmcm9tIGpRdWVyeSAoIzgyNClcblx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICd3aWR0aCcpO1xuXHRcdGNoYXJ0LmNvbnRhaW5lckhlaWdodCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICdoZWlnaHQnKTtcblx0XHRcblx0XHRjaGFydC5jaGFydFdpZHRoID0gbWF0aE1heCgwLCBvcHRpb25zQ2hhcnQud2lkdGggfHwgY2hhcnQuY29udGFpbmVyV2lkdGggfHwgNjAwKTsgLy8gIzEzOTMsIDE0NjBcblx0XHRjaGFydC5jaGFydEhlaWdodCA9IG1hdGhNYXgoMCwgcGljayhvcHRpb25zQ2hhcnQuaGVpZ2h0LFxuXHRcdFx0Ly8gdGhlIG9mZnNldEhlaWdodCBvZiBhbiBlbXB0eSBjb250YWluZXIgaXMgMCBpbiBzdGFuZGFyZCBicm93c2VycywgYnV0IDE5IGluIElFNzpcblx0XHRcdGNoYXJ0LmNvbnRhaW5lckhlaWdodCA+IDE5ID8gY2hhcnQuY29udGFpbmVySGVpZ2h0IDogNDAwKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBjaGFydCdzIHJlbmRlclRvIGRpdiBhbmQgcGxhY2UgaXQgb3V0c2lkZSB0aGUgdmlld3BvcnQgdG8gYWxsb3dcblx0ICogc2l6ZSBjb21wdXRhdGlvbiBvbiBjaGFydC5yZW5kZXIgYW5kIGNoYXJ0LnJlZHJhd1xuXHQgKi9cblx0Y2xvbmVSZW5kZXJUbzogZnVuY3Rpb24gKHJldmVydCkge1xuXHRcdHZhciBjbG9uZSA9IHRoaXMucmVuZGVyVG9DbG9uZSxcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXHRcdFxuXHRcdC8vIERlc3Ryb3kgdGhlIGNsb25lIGFuZCBicmluZyB0aGUgY29udGFpbmVyIGJhY2sgdG8gdGhlIHJlYWwgcmVuZGVyVG8gZGl2XG5cdFx0aWYgKHJldmVydCkge1xuXHRcdFx0aWYgKGNsb25lKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyVG8uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdFx0ZGlzY2FyZEVsZW1lbnQoY2xvbmUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5yZW5kZXJUb0Nsb25lO1xuXHRcdFx0fVxuXHRcdFxuXHRcdC8vIFNldCB1cCB0aGUgY2xvbmVcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy5yZW5kZXJUbykge1xuXHRcdFx0XHR0aGlzLnJlbmRlclRvLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7IC8vIGRvIG5vdCBjbG9uZSB0aGlzXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlbmRlclRvQ2xvbmUgPSBjbG9uZSA9IHRoaXMucmVuZGVyVG8uY2xvbmVOb2RlKDApO1xuXHRcdFx0Y3NzKGNsb25lLCB7XG5cdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0dG9wOiAnLTk5OTlweCcsXG5cdFx0XHRcdGRpc3BsYXk6ICdibG9jaycgLy8gIzgzM1xuXHRcdFx0fSk7XG5cdFx0XHRkb2MuYm9keS5hcHBlbmRDaGlsZChjbG9uZSk7XG5cdFx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRcdGNsb25lLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNvbnRhaW5pbmcgZWxlbWVudCwgZGV0ZXJtaW5lIHRoZSBzaXplIGFuZCBjcmVhdGUgdGhlIGlubmVyIGNvbnRhaW5lclxuXHQgKiBkaXYgdG8gaG9sZCB0aGUgY2hhcnRcblx0ICovXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRjb250YWluZXIsXG5cdFx0XHRvcHRpb25zQ2hhcnQgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0LFxuXHRcdFx0cmVuZGVyVG8sXG5cdFx0XHRpbmRleEF0dHJOYW1lID0gJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcsXG5cdFx0XHRvbGRDaGFydEluZGV4LFxuXHRcdFx0Y29udGFpbmVySWQ7XG5cblx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gb3B0aW9uc0NoYXJ0LnJlbmRlclRvO1xuXHRcdGNvbnRhaW5lcklkID0gUFJFRklYICsgaWRDb3VudGVyKys7XG5cblx0XHRpZiAoaXNTdHJpbmcocmVuZGVyVG8pKSB7XG5cdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gZG9jLmdldEVsZW1lbnRCeUlkKHJlbmRlclRvKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRGlzcGxheSBhbiBlcnJvciBpZiB0aGUgcmVuZGVyVG8gaXMgd3Jvbmdcblx0XHRpZiAoIXJlbmRlclRvKSB7XG5cdFx0XHRlcnJvcigxMywgdHJ1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIHRoZSBjb250YWluZXIgYWxyZWFkeSBob2xkcyBhIGNoYXJ0LCBkZXN0cm95IGl0XG5cdFx0b2xkQ2hhcnRJbmRleCA9IHBJbnQoYXR0cihyZW5kZXJUbywgaW5kZXhBdHRyTmFtZSkpO1xuXHRcdGlmICghaXNOYU4ob2xkQ2hhcnRJbmRleCkgJiYgY2hhcnRzW29sZENoYXJ0SW5kZXhdKSB7XG5cdFx0XHRjaGFydHNbb2xkQ2hhcnRJbmRleF0uZGVzdHJveSgpO1xuXHRcdH1cdFx0XG5cdFx0XG5cdFx0Ly8gTWFrZSBhIHJlZmVyZW5jZSB0byB0aGUgY2hhcnQgZnJvbSB0aGUgZGl2XG5cdFx0YXR0cihyZW5kZXJUbywgaW5kZXhBdHRyTmFtZSwgY2hhcnQuaW5kZXgpO1xuXG5cdFx0Ly8gcmVtb3ZlIHByZXZpb3VzIGNoYXJ0XG5cdFx0cmVuZGVyVG8uaW5uZXJIVE1MID0gJyc7XG5cblx0XHQvLyBJZiB0aGUgY29udGFpbmVyIGRvZXNuJ3QgaGF2ZSBhbiBvZmZzZXRXaWR0aCwgaXQgaGFzIG9yIGlzIGEgY2hpbGQgb2YgYSBub2RlXG5cdFx0Ly8gdGhhdCBoYXMgZGlzcGxheTpub25lLiBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IG1vdmUgaXQgb3V0IHRvIGEgdmlzaWJsZVxuXHRcdC8vIHN0YXRlIHRvIGRldGVybWluZSB0aGUgc2l6ZSwgZWxzZSB0aGUgbGVnZW5kIGFuZCB0b29sdGlwcyB3b24ndCByZW5kZXJcblx0XHQvLyBwcm9wZXJseVxuXHRcdGlmICghcmVuZGVyVG8ub2Zmc2V0V2lkdGgpIHtcblx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8oKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHRcblx0XHRjaGFydC5nZXRDaGFydFNpemUoKTtcblx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aDtcblx0XHRjaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0O1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHRjaGFydC5jb250YWluZXIgPSBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRjbGFzc05hbWU6IFBSRUZJWCArICdjb250YWluZXInICtcblx0XHRcdFx0XHQob3B0aW9uc0NoYXJ0LmNsYXNzTmFtZSA/ICcgJyArIG9wdGlvbnNDaGFydC5jbGFzc05hbWUgOiAnJyksXG5cdFx0XHRcdGlkOiBjb250YWluZXJJZFxuXHRcdFx0fSwgZXh0ZW5kKHtcblx0XHRcdFx0cG9zaXRpb246IFJFTEFUSVZFLFxuXHRcdFx0XHRvdmVyZmxvdzogSElEREVOLCAvLyBuZWVkZWQgZm9yIGNvbnRleHQgbWVudSAoYXZvaWQgc2Nyb2xsYmFycykgYW5kXG5cdFx0XHRcdFx0Ly8gY29udGVudCBvdmVyZmxvdyBpbiBJRVxuXHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCArIFBYLFxuXHRcdFx0XHRoZWlnaHQ6IGNoYXJ0SGVpZ2h0ICsgUFgsXG5cdFx0XHRcdHRleHRBbGlnbjogJ2xlZnQnLFxuXHRcdFx0XHRsaW5lSGVpZ2h0OiAnbm9ybWFsJywgLy8gIzQyN1xuXHRcdFx0XHR6SW5kZXg6IDAsIC8vICMxMDcyXG5cdFx0XHRcdCctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKSdcblx0XHRcdH0sIG9wdGlvbnNDaGFydC5zdHlsZSksXG5cdFx0XHRjaGFydC5yZW5kZXJUb0Nsb25lIHx8IHJlbmRlclRvXG5cdFx0KTtcblxuXHRcdC8vIGNhY2hlIHRoZSBjdXJzb3IgKCMxNjUwKVxuXHRcdGNoYXJ0Ll9jdXJzb3IgPSBjb250YWluZXIuc3R5bGUuY3Vyc29yO1xuXG5cdFx0Y2hhcnQucmVuZGVyZXIgPVxuXHRcdFx0b3B0aW9uc0NoYXJ0LmZvckV4cG9ydCA/IC8vIGZvcmNlIFNWRywgdXNlZCBmb3IgU1ZHIGV4cG9ydFxuXHRcdFx0XHRuZXcgU1ZHUmVuZGVyZXIoY29udGFpbmVyLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgdHJ1ZSkgOlxuXHRcdFx0XHRuZXcgUmVuZGVyZXIoY29udGFpbmVyLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCk7XG5cblx0XHRpZiAodXNlQ2FuVkcpIHtcblx0XHRcdC8vIElmIHdlIG5lZWQgY2FudmcgbGlicmFyeSwgZXh0ZW5kIGFuZCBjb25maWd1cmUgdGhlIHJlbmRlcmVyXG5cdFx0XHQvLyB0byBnZXQgdGhlIHRyYWNrZXIgZm9yIHRyYW5zbGF0aW5nIG1vdXNlIGV2ZW50c1xuXHRcdFx0Y2hhcnQucmVuZGVyZXIuY3JlYXRlKGNoYXJ0LCBjb250YWluZXIsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBtYXJnaW5zIGJ5IHJlbmRlcmluZyBheGlzIGxhYmVscyBpbiBhIHByZWxpbWluYXJ5IHBvc2l0aW9uLiBUaXRsZSxcblx0ICogc3VidGl0bGUgYW5kIGxlZ2VuZCBoYXZlIGFscmVhZHkgYmVlbiByZW5kZXJlZCBhdCB0aGlzIHN0YWdlLCBidXQgd2lsbCBiZVxuXHQgKiBtb3ZlZCBpbnRvIHRoZWlyIGZpbmFsIHBvc2l0aW9uc1xuXHQgKi9cblx0Z2V0TWFyZ2luczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRzcGFjaW5nID0gY2hhcnQuc3BhY2luZyxcblx0XHRcdGF4aXNPZmZzZXQsXG5cdFx0XHRsZWdlbmQgPSBjaGFydC5sZWdlbmQsXG5cdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW4sXG5cdFx0XHRsZWdlbmRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5sZWdlbmQsXG5cdFx0XHRsZWdlbmRNYXJnaW4gPSBwaWNrKGxlZ2VuZE9wdGlvbnMubWFyZ2luLCAxMCksXG5cdFx0XHRsZWdlbmRYID0gbGVnZW5kT3B0aW9ucy54LFxuXHRcdFx0bGVnZW5kWSA9IGxlZ2VuZE9wdGlvbnMueSxcblx0XHRcdGFsaWduID0gbGVnZW5kT3B0aW9ucy5hbGlnbixcblx0XHRcdHZlcnRpY2FsQWxpZ24gPSBsZWdlbmRPcHRpb25zLnZlcnRpY2FsQWxpZ24sXG5cdFx0XHR0aXRsZU9mZnNldCA9IGNoYXJ0LnRpdGxlT2Zmc2V0O1xuXG5cdFx0Y2hhcnQucmVzZXRNYXJnaW5zKCk7XG5cdFx0YXhpc09mZnNldCA9IGNoYXJ0LmF4aXNPZmZzZXQ7XG5cblx0XHQvLyBBZGp1c3QgZm9yIHRpdGxlIGFuZCBzdWJ0aXRsZVxuXHRcdGlmICh0aXRsZU9mZnNldCAmJiAhZGVmaW5lZChtYXJnaW5bMF0pKSB7XG5cdFx0XHRjaGFydC5wbG90VG9wID0gbWF0aE1heChjaGFydC5wbG90VG9wLCB0aXRsZU9mZnNldCArIGNoYXJ0Lm9wdGlvbnMudGl0bGUubWFyZ2luICsgc3BhY2luZ1swXSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkanVzdCBmb3IgbGVnZW5kXG5cdFx0aWYgKGxlZ2VuZC5kaXNwbGF5ICYmICFsZWdlbmRPcHRpb25zLmZsb2F0aW5nKSB7XG5cdFx0XHRpZiAoYWxpZ24gPT09ICdyaWdodCcpIHsgLy8gaG9yaXpvbnRhbCBhbGlnbm1lbnQgaGFuZGxlZCBmaXJzdFxuXHRcdFx0XHRpZiAoIWRlZmluZWQobWFyZ2luWzFdKSkge1xuXHRcdFx0XHRcdGNoYXJ0Lm1hcmdpblJpZ2h0ID0gbWF0aE1heChcblx0XHRcdFx0XHRcdGNoYXJ0Lm1hcmdpblJpZ2h0LFxuXHRcdFx0XHRcdFx0bGVnZW5kLmxlZ2VuZFdpZHRoIC0gbGVnZW5kWCArIGxlZ2VuZE1hcmdpbiArIHNwYWNpbmdbMV1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0aWYgKCFkZWZpbmVkKG1hcmdpblszXSkpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90TGVmdCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHRcdGxlZ2VuZC5sZWdlbmRXaWR0aCArIGxlZ2VuZFggKyBsZWdlbmRNYXJnaW4gKyBzcGFjaW5nWzNdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdGlmICghZGVmaW5lZChtYXJnaW5bMF0pKSB7XG5cdFx0XHRcdFx0Y2hhcnQucGxvdFRvcCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRcdFx0bGVnZW5kLmxlZ2VuZEhlaWdodCArIGxlZ2VuZFkgKyBsZWdlbmRNYXJnaW4gKyBzcGFjaW5nWzBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdGlmICghZGVmaW5lZChtYXJnaW5bMl0pKSB7XG5cdFx0XHRcdFx0Y2hhcnQubWFyZ2luQm90dG9tID0gbWF0aE1heChcblx0XHRcdFx0XHRcdGNoYXJ0Lm1hcmdpbkJvdHRvbSxcblx0XHRcdFx0XHRcdGxlZ2VuZC5sZWdlbmRIZWlnaHQgLSBsZWdlbmRZICsgbGVnZW5kTWFyZ2luICsgc3BhY2luZ1syXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhZGp1c3QgZm9yIHNjcm9sbGVyXG5cdFx0aWYgKGNoYXJ0LmV4dHJhQm90dG9tTWFyZ2luKSB7XG5cdFx0XHRjaGFydC5tYXJnaW5Cb3R0b20gKz0gY2hhcnQuZXh0cmFCb3R0b21NYXJnaW47XG5cdFx0fVxuXHRcdGlmIChjaGFydC5leHRyYVRvcE1hcmdpbikge1xuXHRcdFx0Y2hhcnQucGxvdFRvcCArPSBjaGFydC5leHRyYVRvcE1hcmdpbjtcblx0XHR9XG5cblx0XHQvLyBwcmUtcmVuZGVyIGF4ZXMgdG8gZ2V0IGxhYmVscyBvZmZzZXQgd2lkdGhcblx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGF4aXMuZ2V0T2Zmc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFkZWZpbmVkKG1hcmdpblszXSkpIHtcblx0XHRcdGNoYXJ0LnBsb3RMZWZ0ICs9IGF4aXNPZmZzZXRbM107XG5cdFx0fVxuXHRcdGlmICghZGVmaW5lZChtYXJnaW5bMF0pKSB7XG5cdFx0XHRjaGFydC5wbG90VG9wICs9IGF4aXNPZmZzZXRbMF07XG5cdFx0fVxuXHRcdGlmICghZGVmaW5lZChtYXJnaW5bMl0pKSB7XG5cdFx0XHRjaGFydC5tYXJnaW5Cb3R0b20gKz0gYXhpc09mZnNldFsyXTtcblx0XHR9XG5cdFx0aWYgKCFkZWZpbmVkKG1hcmdpblsxXSkpIHtcblx0XHRcdGNoYXJ0Lm1hcmdpblJpZ2h0ICs9IGF4aXNPZmZzZXRbMV07XG5cdFx0fVxuXG5cdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0fSxcblxuXHQvKipcblx0ICogQWRkIHRoZSBldmVudCBoYW5kbGVycyBuZWNlc3NhcnkgZm9yIGF1dG8gcmVzaXppbmdcblx0ICpcblx0ICovXG5cdGluaXRSZWZsb3c6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdHJlbmRlclRvID0gY2hhcnQucmVuZGVyVG8sXG5cdFx0XHRyZWZsb3dUaW1lb3V0O1xuXHRcdFx0XG5cdFx0ZnVuY3Rpb24gcmVmbG93KGUpIHtcblx0XHRcdHZhciB3aWR0aCA9IG9wdGlvbnNDaGFydC53aWR0aCB8fCBhZGFwdGVyUnVuKHJlbmRlclRvLCAnd2lkdGgnKSxcblx0XHRcdFx0aGVpZ2h0ID0gb3B0aW9uc0NoYXJ0LmhlaWdodCB8fCBhZGFwdGVyUnVuKHJlbmRlclRvLCAnaGVpZ2h0JyksXG5cdFx0XHRcdHRhcmdldCA9IGUgPyBlLnRhcmdldCA6IHdpbjsgLy8gIzgwNSAtIE1vb1Rvb2xzIGRvZXNuJ3Qgc3VwcGx5IGVcblx0XHRcdFx0XG5cdFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IGNoZWNrcyBmb3IgZGlzcGxheTpub25lLiBUYXJnZXQgaXMgZG9jIGluIElFOCBhbmQgT3BlcmEsXG5cdFx0XHQvLyB3aW4gaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBJRTkuXG5cdFx0XHRpZiAoIWNoYXJ0Lmhhc1VzZXJTaXplICYmIHdpZHRoICYmIGhlaWdodCAmJiAodGFyZ2V0ID09PSB3aW4gfHwgdGFyZ2V0ID09PSBkb2MpKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAod2lkdGggIT09IGNoYXJ0LmNvbnRhaW5lcldpZHRoIHx8IGhlaWdodCAhPT0gY2hhcnQuY29udGFpbmVySGVpZ2h0KSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHJlZmxvd1RpbWVvdXQpO1xuXHRcdFx0XHRcdGNoYXJ0LnJlZmxvd1RpbWVvdXQgPSByZWZsb3dUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2hhcnQuY29udGFpbmVyKSB7IC8vIEl0IG1heSBoYXZlIGJlZW4gZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEyNTcpXG5cdFx0XHRcdFx0XHRcdGNoYXJ0LnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRjaGFydC5oYXNVc2VyU2l6ZSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMTAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoYXJ0LnJlZmxvdyA9IHJlZmxvdztcblx0XHRhZGRFdmVudCh3aW4sICdyZXNpemUnLCByZWZsb3cpO1xuXHRcdGFkZEV2ZW50KGNoYXJ0LCAnZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZUV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlZmxvdyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gYSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fEJvb2xlYW59IGFuaW1hdGlvblxuXHQgKi9cblx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGlvbikge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRjaGFydFdpZHRoLFxuXHRcdFx0Y2hhcnRIZWlnaHQsXG5cdFx0XHRmaXJlRW5kUmVzaXplO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBpc1Jlc2l6aW5nIGNvdW50ZXJcblx0XHRjaGFydC5pc1Jlc2l6aW5nICs9IDE7XG5cdFx0ZmlyZUVuZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChjaGFydCkge1xuXHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdlbmRSZXNpemUnLCBudWxsLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y2hhcnQuaXNSZXNpemluZyAtPSAxO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc2V0IHRoZSBhbmltYXRpb24gZm9yIHRoZSBjdXJyZW50IHByb2Nlc3Ncblx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHRjaGFydC5vbGRDaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0O1xuXHRcdGNoYXJ0Lm9sZENoYXJ0V2lkdGggPSBjaGFydC5jaGFydFdpZHRoO1xuXHRcdGlmIChkZWZpbmVkKHdpZHRoKSkge1xuXHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCA9IGNoYXJ0V2lkdGggPSBtYXRoTWF4KDAsIG1hdGhSb3VuZCh3aWR0aCkpO1xuXHRcdFx0Y2hhcnQuaGFzVXNlclNpemUgPSAhIWNoYXJ0V2lkdGg7XG5cdFx0fVxuXHRcdGlmIChkZWZpbmVkKGhlaWdodCkpIHtcblx0XHRcdGNoYXJ0LmNoYXJ0SGVpZ2h0ID0gY2hhcnRIZWlnaHQgPSBtYXRoTWF4KDAsIG1hdGhSb3VuZChoZWlnaHQpKTtcblx0XHR9XG5cblx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7XG5cdFx0XHR3aWR0aDogY2hhcnRXaWR0aCArIFBYLFxuXHRcdFx0aGVpZ2h0OiBjaGFydEhlaWdodCArIFBYXG5cdFx0fSk7XG5cdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKHRydWUpO1xuXHRcdGNoYXJ0LnJlbmRlcmVyLnNldFNpemUoY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIGFuaW1hdGlvbik7XG5cblx0XHQvLyBoYW5kbGUgYXhlc1xuXHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDtcblx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRheGlzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0YXhpcy5zZXRTY2FsZSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIG5vbi1jYXJ0ZXNpYW4gc2VyaWVzIGFyZSBhbHNvIGhhbmRsZWRcblx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRzZXJpZS5pc0RpcnR5ID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSB0cnVlOyAvLyBmb3JjZSBsZWdlbmQgcmVkcmF3XG5cdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7IC8vIGZvcmNlIHJlZHJhdyBvZiBwbG90IGFuZCBjaGFydCBib3JkZXJcblxuXHRcdGNoYXJ0LmdldE1hcmdpbnMoKTtcblxuXHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXG5cblx0XHRjaGFydC5vbGRDaGFydEhlaWdodCA9IG51bGw7XG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAncmVzaXplJyk7XG5cblx0XHQvLyBmaXJlIGVuZFJlc2l6ZSBhbmQgc2V0IGlzUmVzaXppbmcgYmFja1xuXHRcdC8vIElmIGFuaW1hdGlvbiBpcyBkaXNhYmxlZCwgZmlyZSB3aXRob3V0IGRlbGF5XG5cdFx0aWYgKGdsb2JhbEFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcblx0XHRcdGZpcmVFbmRSZXNpemUoKTtcblx0XHR9IGVsc2UgeyAvLyBlbHNlIHNldCBhIHRpbWVvdXQgd2l0aCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0XHRzZXRUaW1lb3V0KGZpcmVFbmRSZXNpemUsIChnbG9iYWxBbmltYXRpb24gJiYgZ2xvYmFsQW5pbWF0aW9uLmR1cmF0aW9uKSB8fCA1MDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBwdWJsaWMgY2hhcnQgcHJvcGVydGllcy4gVGhpcyBpcyBkb25lIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHByZS1yZW5kZXJcblx0ICogdG8gZGV0ZXJtaW5lIG1hcmdpbiBzaXplc1xuXHQgKi9cblx0c2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoc2tpcEF4ZXMpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRvcHRpb25zQ2hhcnQgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRjbGlwT2Zmc2V0ID0gY2hhcnQuY2xpcE9mZnNldCxcblx0XHRcdGNsaXBYLFxuXHRcdFx0Y2xpcFksXG5cdFx0XHRwbG90TGVmdCxcblx0XHRcdHBsb3RUb3AsXG5cdFx0XHRwbG90V2lkdGgsXG5cdFx0XHRwbG90SGVpZ2h0LFxuXHRcdFx0cGxvdEJvcmRlcldpZHRoO1xuXG5cdFx0Y2hhcnQucGxvdExlZnQgPSBwbG90TGVmdCA9IG1hdGhSb3VuZChjaGFydC5wbG90TGVmdCk7XG5cdFx0Y2hhcnQucGxvdFRvcCA9IHBsb3RUb3AgPSBtYXRoUm91bmQoY2hhcnQucGxvdFRvcCk7XG5cdFx0Y2hhcnQucGxvdFdpZHRoID0gcGxvdFdpZHRoID0gbWF0aE1heCgwLCBtYXRoUm91bmQoY2hhcnRXaWR0aCAtIHBsb3RMZWZ0IC0gY2hhcnQubWFyZ2luUmlnaHQpKTtcblx0XHRjaGFydC5wbG90SGVpZ2h0ID0gcGxvdEhlaWdodCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGNoYXJ0SGVpZ2h0IC0gcGxvdFRvcCAtIGNoYXJ0Lm1hcmdpbkJvdHRvbSkpO1xuXG5cdFx0Y2hhcnQucGxvdFNpemVYID0gaW52ZXJ0ZWQgPyBwbG90SGVpZ2h0IDogcGxvdFdpZHRoO1xuXHRcdGNoYXJ0LnBsb3RTaXplWSA9IGludmVydGVkID8gcGxvdFdpZHRoIDogcGxvdEhlaWdodDtcblx0XHRcblx0XHRjaGFydC5wbG90Qm9yZGVyV2lkdGggPSBvcHRpb25zQ2hhcnQucGxvdEJvcmRlcldpZHRoIHx8IDA7XG5cblx0XHQvLyBTZXQgYm94ZXMgdXNlZCBmb3IgYWxpZ25tZW50XG5cdFx0Y2hhcnQuc3BhY2luZ0JveCA9IHJlbmRlcmVyLnNwYWNpbmdCb3ggPSB7XG5cdFx0XHR4OiBzcGFjaW5nWzNdLFxuXHRcdFx0eTogc3BhY2luZ1swXSxcblx0XHRcdHdpZHRoOiBjaGFydFdpZHRoIC0gc3BhY2luZ1szXSAtIHNwYWNpbmdbMV0sXG5cdFx0XHRoZWlnaHQ6IGNoYXJ0SGVpZ2h0IC0gc3BhY2luZ1swXSAtIHNwYWNpbmdbMl1cblx0XHR9O1xuXHRcdGNoYXJ0LnBsb3RCb3ggPSByZW5kZXJlci5wbG90Qm94ID0ge1xuXHRcdFx0eDogcGxvdExlZnQsXG5cdFx0XHR5OiBwbG90VG9wLFxuXHRcdFx0d2lkdGg6IHBsb3RXaWR0aCxcblx0XHRcdGhlaWdodDogcGxvdEhlaWdodFxuXHRcdH07XG5cblx0XHRwbG90Qm9yZGVyV2lkdGggPSAyICogbWF0aEZsb29yKGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCAvIDIpO1xuXHRcdGNsaXBYID0gbWF0aENlaWwobWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbM10pIC8gMik7XG5cdFx0Y2xpcFkgPSBtYXRoQ2VpbChtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFswXSkgLyAyKTtcblx0XHRjaGFydC5jbGlwQm94ID0ge1xuXHRcdFx0eDogY2xpcFgsIFxuXHRcdFx0eTogY2xpcFksIFxuXHRcdFx0d2lkdGg6IG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVggLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsxXSkgLyAyIC0gY2xpcFgpLCBcblx0XHRcdGhlaWdodDogbWF0aEZsb29yKGNoYXJ0LnBsb3RTaXplWSAtIG1hdGhNYXgocGxvdEJvcmRlcldpZHRoLCBjbGlwT2Zmc2V0WzJdKSAvIDIgLSBjbGlwWSlcblx0XHR9O1xuXG5cdFx0aWYgKCFza2lwQXhlcykge1xuXHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLnNldEF4aXNTaXplKCk7XG5cdFx0XHRcdGF4aXMuc2V0QXhpc1RyYW5zbGF0aW9uKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluaXRpYWwgbWFyZ2lucyBiZWZvcmUgYXV0byBzaXplIG1hcmdpbnMgYXJlIGFwcGxpZWRcblx0ICovXG5cdHJlc2V0TWFyZ2luczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRzcGFjaW5nID0gY2hhcnQuc3BhY2luZyxcblx0XHRcdG1hcmdpbiA9IGNoYXJ0Lm1hcmdpbjtcblxuXHRcdGNoYXJ0LnBsb3RUb3AgPSBwaWNrKG1hcmdpblswXSwgc3BhY2luZ1swXSk7XG5cdFx0Y2hhcnQubWFyZ2luUmlnaHQgPSBwaWNrKG1hcmdpblsxXSwgc3BhY2luZ1sxXSk7XG5cdFx0Y2hhcnQubWFyZ2luQm90dG9tID0gcGljayhtYXJnaW5bMl0sIHNwYWNpbmdbMl0pO1xuXHRcdGNoYXJ0LnBsb3RMZWZ0ID0gcGljayhtYXJnaW5bM10sIHNwYWNpbmdbM10pO1xuXHRcdGNoYXJ0LmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF07IC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdGNoYXJ0LmNsaXBPZmZzZXQgPSBbMCwgMCwgMCwgMF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIGJvcmRlcnMgYW5kIGJhY2tncm91bmRzIGZvciBjaGFydCBhbmQgcGxvdCBhcmVhXG5cdCAqL1xuXHRkcmF3Q2hhcnRCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRjaGFydEJhY2tncm91bmQgPSBjaGFydC5jaGFydEJhY2tncm91bmQsXG5cdFx0XHRwbG90QmFja2dyb3VuZCA9IGNoYXJ0LnBsb3RCYWNrZ3JvdW5kLFxuXHRcdFx0cGxvdEJvcmRlciA9IGNoYXJ0LnBsb3RCb3JkZXIsXG5cdFx0XHRwbG90QkdJbWFnZSA9IGNoYXJ0LnBsb3RCR0ltYWdlLFxuXHRcdFx0Y2hhcnRCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5ib3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0Y2hhcnRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zQ2hhcnQuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0cGxvdEJhY2tncm91bmRDb2xvciA9IG9wdGlvbnNDaGFydC5wbG90QmFja2dyb3VuZENvbG9yLFxuXHRcdFx0cGxvdEJhY2tncm91bmRJbWFnZSA9IG9wdGlvbnNDaGFydC5wbG90QmFja2dyb3VuZEltYWdlLFxuXHRcdFx0cGxvdEJvcmRlcldpZHRoID0gb3B0aW9uc0NoYXJ0LnBsb3RCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0bWduLFxuXHRcdFx0YmdBdHRyLFxuXHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wLFxuXHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRwbG90Qm94ID0gY2hhcnQucGxvdEJveCxcblx0XHRcdGNsaXBSZWN0ID0gY2hhcnQuY2xpcFJlY3QsXG5cdFx0XHRjbGlwQm94ID0gY2hhcnQuY2xpcEJveDtcblxuXHRcdC8vIENoYXJ0IGFyZWFcblx0XHRtZ24gPSBjaGFydEJvcmRlcldpZHRoICsgKG9wdGlvbnNDaGFydC5zaGFkb3cgPyA4IDogMCk7XG5cblx0XHRpZiAoY2hhcnRCb3JkZXJXaWR0aCB8fCBjaGFydEJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0aWYgKCFjaGFydEJhY2tncm91bmQpIHtcblx0XHRcdFx0XG5cdFx0XHRcdGJnQXR0ciA9IHtcblx0XHRcdFx0XHRmaWxsOiBjaGFydEJhY2tncm91bmRDb2xvciB8fCBOT05FXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChjaGFydEJvcmRlcldpZHRoKSB7IC8vICM5ODBcblx0XHRcdFx0XHRiZ0F0dHIuc3Ryb2tlID0gb3B0aW9uc0NoYXJ0LmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGJnQXR0clsnc3Ryb2tlLXdpZHRoJ10gPSBjaGFydEJvcmRlcldpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYXJ0LmNoYXJ0QmFja2dyb3VuZCA9IHJlbmRlcmVyLnJlY3QobWduIC8gMiwgbWduIC8gMiwgY2hhcnRXaWR0aCAtIG1nbiwgY2hhcnRIZWlnaHQgLSBtZ24sXG5cdFx0XHRcdFx0XHRvcHRpb25zQ2hhcnQuYm9yZGVyUmFkaXVzLCBjaGFydEJvcmRlcldpZHRoKVxuXHRcdFx0XHRcdC5hdHRyKGJnQXR0cilcblx0XHRcdFx0XHQuYWRkKClcblx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnNDaGFydC5zaGFkb3cpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyByZXNpemVcblx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmFuaW1hdGUoXG5cdFx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmNyaXNwKG51bGwsIG51bGwsIG51bGwsIGNoYXJ0V2lkdGggLSBtZ24sIGNoYXJ0SGVpZ2h0IC0gbWduKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly8gUGxvdCBiYWNrZ3JvdW5kXG5cdFx0aWYgKHBsb3RCYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGlmICghcGxvdEJhY2tncm91bmQpIHtcblx0XHRcdFx0Y2hhcnQucGxvdEJhY2tncm91bmQgPSByZW5kZXJlci5yZWN0KHBsb3RMZWZ0LCBwbG90VG9wLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIDApXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ZmlsbDogcGxvdEJhY2tncm91bmRDb2xvclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpXG5cdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zQ2hhcnQucGxvdFNoYWRvdyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbG90QmFja2dyb3VuZC5hbmltYXRlKHBsb3RCb3gpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocGxvdEJhY2tncm91bmRJbWFnZSkge1xuXHRcdFx0aWYgKCFwbG90QkdJbWFnZSkge1xuXHRcdFx0XHRjaGFydC5wbG90QkdJbWFnZSA9IHJlbmRlcmVyLmltYWdlKHBsb3RCYWNrZ3JvdW5kSW1hZ2UsIHBsb3RMZWZ0LCBwbG90VG9wLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQpXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGxvdEJHSW1hZ2UuYW5pbWF0ZShwbG90Qm94KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gUGxvdCBjbGlwXG5cdFx0aWYgKCFjbGlwUmVjdCkge1xuXHRcdFx0Y2hhcnQuY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQm94KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xpcFJlY3QuYW5pbWF0ZSh7XG5cdFx0XHRcdHdpZHRoOiBjbGlwQm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGNsaXBCb3guaGVpZ2h0XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBQbG90IGFyZWEgYm9yZGVyXG5cdFx0aWYgKHBsb3RCb3JkZXJXaWR0aCkge1xuXHRcdFx0aWYgKCFwbG90Qm9yZGVyKSB7XG5cdFx0XHRcdGNoYXJ0LnBsb3RCb3JkZXIgPSByZW5kZXJlci5yZWN0KHBsb3RMZWZ0LCBwbG90VG9wLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIDAsIC1wbG90Qm9yZGVyV2lkdGgpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zQ2hhcnQucGxvdEJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IHBsb3RCb3JkZXJXaWR0aCxcblx0XHRcdFx0XHRcdHpJbmRleDogMVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGxvdEJvcmRlci5hbmltYXRlKFxuXHRcdFx0XHRcdHBsb3RCb3JkZXIuY3Jpc3AobnVsbCwgcGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXNldFxuXHRcdGNoYXJ0LmlzRGlydHlCb3ggPSBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogRGV0ZWN0IHdoZXRoZXIgYSBjZXJ0YWluIGNoYXJ0IHByb3BlcnR5IGlzIG5lZWRlZCBiYXNlZCBvbiBpbnNwZWN0aW5nIGl0cyBvcHRpb25zXG5cdCAqIGFuZCBzZXJpZXMuIFRoaXMgbWFpbmx5IGFwcGxpZXMgdG8gdGhlIGNoYXJ0LmludmVydCBwcm9wZXJ0eSwgYW5kIGluIGV4dGVuc2lvbnMgdG8gXG5cdCAqIHRoZSBjaGFydC5hbmd1bGFyIGFuZCBjaGFydC5wb2xhciBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0cHJvcEZyb21TZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdGtsYXNzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuc2VyaWVzLFxuXHRcdFx0aSxcblx0XHRcdHZhbHVlO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRlYWNoKFsnaW52ZXJ0ZWQnLCAnYW5ndWxhcicsICdwb2xhciddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBkZWZhdWx0IHNlcmllcyB0eXBlJ3MgY2xhc3Ncblx0XHRcdGtsYXNzID0gc2VyaWVzVHlwZXNbb3B0aW9uc0NoYXJ0LnR5cGUgfHwgb3B0aW9uc0NoYXJ0LmRlZmF1bHRTZXJpZXNUeXBlXTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IHRoZSB2YWx1ZSBmcm9tIGF2YWlsYWJsZSBjaGFydC13aWRlIHByb3BlcnRpZXNcblx0XHRcdHZhbHVlID0gKFxuXHRcdFx0XHRjaGFydFtrZXldIHx8IC8vIDEuIGl0IGlzIHNldCBiZWZvcmVcblx0XHRcdFx0b3B0aW9uc0NoYXJ0W2tleV0gfHwgLy8gMi4gaXQgaXMgc2V0IGluIHRoZSBvcHRpb25zXG5cdFx0XHRcdChrbGFzcyAmJiBrbGFzcy5wcm90b3R5cGVba2V5XSkgLy8gMy4gaXQncyBkZWZhdWx0IHNlcmllcyBjbGFzcyByZXF1aXJlcyBpdFxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyA0LiBDaGVjayBpZiBhbnkgdGhlIGNoYXJ0J3Mgc2VyaWVzIHJlcXVpcmUgaXRcblx0XHRcdGkgPSBzZXJpZXNPcHRpb25zICYmIHNlcmllc09wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCF2YWx1ZSAmJiBpLS0pIHtcblx0XHRcdFx0a2xhc3MgPSBzZXJpZXNUeXBlc1tzZXJpZXNPcHRpb25zW2ldLnR5cGVdO1xuXHRcdFx0XHRpZiAoa2xhc3MgJiYga2xhc3MucHJvdG90eXBlW2tleV0pIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZXQgdGhlIGNoYXJ0IHByb3BlcnR5XG5cdFx0XHRjaGFydFtrZXldID0gdmFsdWU7XHRcblx0XHR9KTtcblx0XHRcblx0fSxcblxuXHQvKipcblx0ICogTGluayB0d28gb3IgbW9yZSBzZXJpZXMgdG9nZXRoZXIuIFRoaXMgaXMgZG9uZSBpbml0aWFsbHkgZnJvbSBDaGFydC5yZW5kZXIsXG5cdCAqIGFuZCBhZnRlciBDaGFydC5hZGRTZXJpZXMgYW5kIFNlcmllcy5yZW1vdmUuXG5cdCAqL1xuXHRsaW5rU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzO1xuXG5cdFx0Ly8gUmVzZXQgbGlua3Ncblx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRzZXJpZXMubGlua2VkU2VyaWVzLmxlbmd0aCA9IDA7XG5cdFx0fSk7XG5cblx0XHQvLyBBcHBseSBuZXcgbGlua3Ncblx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHR2YXIgbGlua2VkVG8gPSBzZXJpZXMub3B0aW9ucy5saW5rZWRUbztcblx0XHRcdGlmIChpc1N0cmluZyhsaW5rZWRUbykpIHtcblx0XHRcdFx0aWYgKGxpbmtlZFRvID09PSAnOnByZXZpb3VzJykge1xuXHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuc2VyaWVzW3Nlcmllcy5pbmRleCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuZ2V0KGxpbmtlZFRvKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGlua2VkVG8pIHtcblx0XHRcdFx0XHRsaW5rZWRUby5saW5rZWRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdFx0XHRcdHNlcmllcy5saW5rZWRQYXJlbnQgPSBsaW5rZWRUbztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgYWxsIGdyYXBoaWNzIGZvciB0aGUgY2hhcnRcblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucztcblxuXHRcdHZhciBsYWJlbHMgPSBvcHRpb25zLmxhYmVscyxcblx0XHRcdGNyZWRpdHMgPSBvcHRpb25zLmNyZWRpdHMsXG5cdFx0XHRjcmVkaXRzSHJlZjtcblxuXHRcdC8vIFRpdGxlXG5cdFx0Y2hhcnQuc2V0VGl0bGUoKTtcblxuXG5cdFx0Ly8gTGVnZW5kXG5cdFx0Y2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZChjaGFydCwgb3B0aW9ucy5sZWdlbmQpO1xuXG5cdFx0Y2hhcnQuZ2V0U3RhY2tzKCk7IC8vIHJlbmRlciBzdGFja3NcblxuXHRcdC8vIEdldCBtYXJnaW5zIGJ5IHByZS1yZW5kZXJpbmcgYXhlc1xuXHRcdC8vIHNldCBheGVzIHNjYWxlc1xuXHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdGF4aXMuc2V0U2NhbGUoKTtcblx0XHR9KTtcblxuXHRcdGNoYXJ0LmdldE1hcmdpbnMoKTtcblxuXHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDsgLy8gcmVzZXQgZm9yIHNlY29uZCBwYXNzXG5cdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0YXhpcy5zZXRUaWNrUG9zaXRpb25zKHRydWUpOyAvLyB1cGRhdGUgdG8gcmVmbGVjdCB0aGUgbmV3IG1hcmdpbnNcblx0XHRcdGF4aXMuc2V0TWF4VGlja3MoKTtcblx0XHR9KTtcblx0XHRjaGFydC5hZGp1c3RUaWNrQW1vdW50cygpO1xuXHRcdGNoYXJ0LmdldE1hcmdpbnMoKTsgLy8gc2Vjb25kIHBhc3MgdG8gY2hlY2sgZm9yIG5ldyBsYWJlbHNcblxuXG5cdFx0Ly8gRHJhdyB0aGUgYm9yZGVycyBhbmQgYmFja2dyb3VuZHNcblx0XHRjaGFydC5kcmF3Q2hhcnRCb3goKTtcdFx0XG5cblxuXHRcdC8vIEF4ZXNcblx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGF4aXMucmVuZGVyKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBUaGUgc2VyaWVzXG5cdFx0aWYgKCFjaGFydC5zZXJpZXNHcm91cCkge1xuXHRcdFx0Y2hhcnQuc2VyaWVzR3JvdXAgPSByZW5kZXJlci5nKCdzZXJpZXMtZ3JvdXAnKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMyB9KVxuXHRcdFx0XHQuYWRkKCk7XG5cdFx0fVxuXHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdHNlcmllLnRyYW5zbGF0ZSgpO1xuXHRcdFx0c2VyaWUuc2V0VG9vbHRpcFBvaW50cygpO1xuXHRcdFx0c2VyaWUucmVuZGVyKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBMYWJlbHNcblx0XHRpZiAobGFiZWxzLml0ZW1zKSB7XG5cdFx0XHRlYWNoKGxhYmVscy5pdGVtcywgZnVuY3Rpb24gKGxhYmVsKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IGV4dGVuZChsYWJlbHMuc3R5bGUsIGxhYmVsLnN0eWxlKSxcblx0XHRcdFx0XHR4ID0gcEludChzdHlsZS5sZWZ0KSArIGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHRcdHkgPSBwSW50KHN0eWxlLnRvcCkgKyBjaGFydC5wbG90VG9wICsgMTI7XG5cblx0XHRcdFx0Ly8gZGVsZXRlIHRvIHByZXZlbnQgcmV3cml0aW5nIGluIElFXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZS5sZWZ0O1xuXHRcdFx0XHRkZWxldGUgc3R5bGUudG9wO1xuXG5cdFx0XHRcdHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0bGFiZWwuaHRtbCxcblx0XHRcdFx0XHR4LFxuXHRcdFx0XHRcdHlcblx0XHRcdFx0KVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMiB9KVxuXHRcdFx0XHQuY3NzKHN0eWxlKVxuXHRcdFx0XHQuYWRkKCk7XG5cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIENyZWRpdHNcblx0XHRpZiAoY3JlZGl0cy5lbmFibGVkICYmICFjaGFydC5jcmVkaXRzKSB7XG5cdFx0XHRjcmVkaXRzSHJlZiA9IGNyZWRpdHMuaHJlZjtcblx0XHRcdGNoYXJ0LmNyZWRpdHMgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRjcmVkaXRzLnRleHQsXG5cdFx0XHRcdDAsXG5cdFx0XHRcdDBcblx0XHRcdClcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChjcmVkaXRzSHJlZikge1xuXHRcdFx0XHRcdGxvY2F0aW9uLmhyZWYgPSBjcmVkaXRzSHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0YWxpZ246IGNyZWRpdHMucG9zaXRpb24uYWxpZ24sXG5cdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0fSlcblx0XHRcdC5jc3MoY3JlZGl0cy5zdHlsZSlcblx0XHRcdC5hZGQoKVxuXHRcdFx0LmFsaWduKGNyZWRpdHMucG9zaXRpb24pO1xuXHRcdH1cblxuXHRcdC8vIFNldCBmbGFnXG5cdFx0Y2hhcnQuaGFzUmVuZGVyZWQgPSB0cnVlO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIG1lbW9yeSB1c2FnZVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdHNlcmllcyA9IGNoYXJ0LnNlcmllcyxcblx0XHRcdGNvbnRhaW5lciA9IGNoYXJ0LmNvbnRhaW5lcixcblx0XHRcdGksXG5cdFx0XHRwYXJlbnROb2RlID0gY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlO1xuXHRcdFx0XG5cdFx0Ly8gZmlyZSB0aGUgY2hhcnQuZGVzdG95IGV2ZW50XG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnZGVzdHJveScpO1xuXHRcdFxuXHRcdC8vIERlbGV0ZSB0aGUgY2hhcnQgZnJvbSBjaGFydHMgbG9va3VwIGFycmF5XG5cdFx0Y2hhcnRzW2NoYXJ0LmluZGV4XSA9IFVOREVGSU5FRDtcblx0XHRjaGFydC5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpO1xuXG5cdFx0Ly8gcmVtb3ZlIGV2ZW50c1xuXHRcdHJlbW92ZUV2ZW50KGNoYXJ0KTtcblxuXHRcdC8vID09PT0gRGVzdHJveSBjb2xsZWN0aW9uczpcblx0XHQvLyBEZXN0cm95IGF4ZXNcblx0XHRpID0gYXhlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0YXhlc1tpXSA9IGF4ZXNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIERlc3Ryb3kgZWFjaCBzZXJpZXNcblx0XHRpID0gc2VyaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRzZXJpZXNbaV0gPSBzZXJpZXNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vID09PT0gRGVzdHJveSBjaGFydCBwcm9wZXJ0aWVzOlxuXHRcdGVhY2goWyd0aXRsZScsICdzdWJ0aXRsZScsICdjaGFydEJhY2tncm91bmQnLCAncGxvdEJhY2tncm91bmQnLCAncGxvdEJHSW1hZ2UnLCBcblx0XHRcdFx0J3Bsb3RCb3JkZXInLCAnc2VyaWVzR3JvdXAnLCAnY2xpcFJlY3QnLCAnY3JlZGl0cycsICdwb2ludGVyJywgJ3Njcm9sbGVyJywgXG5cdFx0XHRcdCdyYW5nZVNlbGVjdG9yJywgJ2xlZ2VuZCcsICdyZXNldFpvb21CdXR0b24nLCAndG9vbHRpcCcsICdyZW5kZXJlciddLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0dmFyIHByb3AgPSBjaGFydFtuYW1lXTtcblxuXHRcdFx0aWYgKHByb3AgJiYgcHJvcC5kZXN0cm95KSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gcHJvcC5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyByZW1vdmUgY29udGFpbmVyIGFuZCBhbGwgU1ZHXG5cdFx0aWYgKGNvbnRhaW5lcikgeyAvLyBjYW4gYnJlYWsgaW4gSUUgd2hlbiBkZXN0cm95ZWQgYmVmb3JlIGZpbmlzaGVkIGxvYWRpbmdcblx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblx0XHRcdHJlbW92ZUV2ZW50KGNvbnRhaW5lcik7XG5cdFx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0XHRkaXNjYXJkRWxlbWVudChjb250YWluZXIpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY2xlYW4gaXQgYWxsIHVwXG5cdFx0Zm9yIChpIGluIGNoYXJ0KSB7XG5cdFx0XHRkZWxldGUgY2hhcnRbaV07XG5cdFx0fVxuXG5cdH0sXG5cblxuXHQvKipcblx0ICogVk1MIG5hbWVzcGFjZXMgY2FuJ3QgYmUgYWRkZWQgdW50aWwgYWZ0ZXIgY29tcGxldGUuIExpc3RlbmluZ1xuXHQgKiBmb3IgUGVyaW5pJ3MgZG9TY3JvbGwgaGFjayBpcyBub3QgZW5vdWdoLlxuXHQgKi9cblx0aXNSZWFkeVRvUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblxuXHRcdC8vIE5vdGU6IGluIHNwaXRlIG9mIEpTTGludCdzIGNvbXBsYWludHMsIHdpbiA9PSB3aW4udG9wIGlzIHJlcXVpcmVkXG5cdFx0Lypqc2xpbnQgZXFlcTogdHJ1ZSovXG5cdFx0aWYgKCghaGFzU1ZHICYmICh3aW4gPT0gd2luLnRvcCAmJiBkb2MucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykpIHx8ICh1c2VDYW5WRyAmJiAhd2luLmNhbnZnKSkge1xuXHRcdC8qanNsaW50IGVxZXE6IGZhbHNlKi9cblx0XHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0XHQvLyBEZWxheSByZW5kZXJpbmcgdW50aWwgY2FudmcgbGlicmFyeSBpcyBkb3dubG9hZGVkIGFuZCByZWFkeVxuXHRcdFx0XHRDYW5WR0NvbnRyb2xsZXIucHVzaChmdW5jdGlvbiAoKSB7IGNoYXJ0LmZpcnN0UmVuZGVyKCk7IH0sIGNoYXJ0Lm9wdGlvbnMuZ2xvYmFsLmNhbnZhc1Rvb2xzVVJMKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvYy5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGRvYy5kZXRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgY2hhcnQuZmlyc3RSZW5kZXIpO1xuXHRcdFx0XHRcdGlmIChkb2MucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0XHRcdFx0Y2hhcnQuZmlyc3RSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUHJlcGFyZSBmb3IgZmlyc3QgcmVuZGVyaW5nIGFmdGVyIGFsbCBkYXRhIGFyZSBsb2FkZWRcblx0ICovXG5cdGZpcnN0UmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0Y2FsbGJhY2sgPSBjaGFydC5jYWxsYmFjaztcblxuXHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJ0IGlzIHJlYWR5IHRvIHJlbmRlclxuXHRcdGlmICghY2hhcnQuaXNSZWFkeVRvUmVuZGVyKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgdGhlIGNvbnRhaW5lclxuXHRcdGNoYXJ0LmdldENvbnRhaW5lcigpO1xuXG5cdFx0Ly8gUnVuIGFuIGVhcmx5IGV2ZW50IGFmdGVyIHRoZSBjb250YWluZXIgYW5kIHJlbmRlcmVyIGFyZSBlc3RhYmxpc2hlZFxuXHRcdGZpcmVFdmVudChjaGFydCwgJ2luaXQnKTtcblxuXHRcdFxuXHRcdGNoYXJ0LnJlc2V0TWFyZ2lucygpO1xuXHRcdGNoYXJ0LnNldENoYXJ0U2l6ZSgpO1xuXG5cdFx0Ly8gU2V0IHRoZSBjb21tb24gY2hhcnQgcHJvcGVydGllcyAobWFpbmx5IGludmVydCkgZnJvbSB0aGUgZ2l2ZW4gc2VyaWVzXG5cdFx0Y2hhcnQucHJvcEZyb21TZXJpZXMoKTtcblxuXHRcdC8vIGdldCBheGVzXG5cdFx0Y2hhcnQuZ2V0QXhlcygpO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc2VyaWVzXG5cdFx0ZWFjaChvcHRpb25zLnNlcmllcyB8fCBbXSwgZnVuY3Rpb24gKHNlcmllT3B0aW9ucykge1xuXHRcdFx0Y2hhcnQuaW5pdFNlcmllcyhzZXJpZU9wdGlvbnMpO1xuXHRcdH0pO1xuXG5cdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0Ly8gUnVuIGFuIGV2ZW50IGFmdGVyIGF4ZXMgYW5kIHNlcmllcyBhcmUgaW5pdGlhbGl6ZWQsIGJ1dCBiZWZvcmUgcmVuZGVyLiBBdCB0aGlzIHN0YWdlLFxuXHRcdC8vIHRoZSBzZXJpZXMgZGF0YSBpcyBpbmRleGVkIGFuZCBjYWNoZWQgaW4gdGhlIHhEYXRhIGFuZCB5RGF0YSBhcnJheXMsIHNvIHdlIGNhbiBhY2Nlc3Ncblx0XHQvLyB0aG9zZSBiZWZvcmUgcmVuZGVyaW5nLiBVc2VkIGluIEhpZ2hzdG9jay4gXG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnYmVmb3JlUmVuZGVyJyk7IFxuXG5cdFx0Ly8gZGVwZW5kcyBvbiBpbnZlcnRlZCBhbmQgb24gbWFyZ2lucyBiZWluZyBzZXRcblx0XHRjaGFydC5wb2ludGVyID0gbmV3IFBvaW50ZXIoY2hhcnQsIG9wdGlvbnMpO1xuXG5cdFx0Y2hhcnQucmVuZGVyKCk7XG5cblx0XHQvLyBhZGQgY2FudmFzXG5cdFx0Y2hhcnQucmVuZGVyZXIuZHJhdygpO1xuXHRcdC8vIHJ1biBjYWxsYmFja3Ncblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrLmFwcGx5KGNoYXJ0LCBbY2hhcnRdKTtcblx0XHR9XG5cdFx0ZWFjaChjaGFydC5jYWxsYmFja3MsIGZ1bmN0aW9uIChmbikge1xuXHRcdFx0Zm4uYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdFxuXHRcdC8vIElmIHRoZSBjaGFydCB3YXMgcmVuZGVyZWQgb3V0c2lkZSB0aGUgdG9wIGNvbnRhaW5lciwgcHV0IGl0IGJhY2sgaW5cblx0XHRjaGFydC5jbG9uZVJlbmRlclRvKHRydWUpO1xuXG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnbG9hZCcpO1xuXG5cdH0sXG5cblx0LyoqXG5cdCogQ3JlYXRlcyBhcnJheXMgZm9yIHNwYWNpbmcgYW5kIG1hcmdpbiBmcm9tIGdpdmVuIG9wdGlvbnMuXG5cdCovXG5cdHNwbGFzaEFycmF5OiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG5cdFx0dmFyIG9WYXIgPSBvcHRpb25zW3RhcmdldF0sXG5cdFx0XHR0QXJyYXkgPSBpc09iamVjdChvVmFyKSA/IG9WYXIgOiBbb1Zhciwgb1Zhciwgb1Zhciwgb1Zhcl07XG5cblx0XHRyZXR1cm4gW3BpY2sob3B0aW9uc1t0YXJnZXQgKyAnVG9wJ10sIHRBcnJheVswXSksXG5cdFx0XHRcdHBpY2sob3B0aW9uc1t0YXJnZXQgKyAnUmlnaHQnXSwgdEFycmF5WzFdKSxcblx0XHRcdFx0cGljayhvcHRpb25zW3RhcmdldCArICdCb3R0b20nXSwgdEFycmF5WzJdKSxcblx0XHRcdFx0cGljayhvcHRpb25zW3RhcmdldCArICdMZWZ0J10sIHRBcnJheVszXSldO1xuXHR9XG59OyAvLyBlbmQgQ2hhcnRcblxuLy8gSG9vayBmb3IgZXhwb3J0aW5nIG1vZHVsZVxuQ2hhcnQucHJvdG90eXBlLmNhbGxiYWNrcyA9IFtdO1xuLyoqXG4gKiBUaGUgUG9pbnQgb2JqZWN0IGFuZCBwcm90b3R5cGUuIEluaGVyaXRhYmxlIGFuZCB1c2VkIGFzIGJhc2UgZm9yIFBpZVBvaW50XG4gKi9cbnZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHt9O1xuUG9pbnQucHJvdG90eXBlID0ge1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzIFRoZSBzZXJpZXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhpcyBwb2ludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgZGF0YSBpbiBlaXRoZXIgbnVtYmVyLCBhcnJheSBvciBvYmplY3QgZm9ybWF0XG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoc2VyaWVzLCBvcHRpb25zLCB4KSB7XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0Y29sb3JzO1xuXHRcdHBvaW50LnNlcmllcyA9IHNlcmllcztcblx0XHRwb2ludC5hcHBseU9wdGlvbnMob3B0aW9ucywgeCk7XG5cdFx0cG9pbnQucG9pbnRBdHRyID0ge307XG5cblx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuY29sb3JCeVBvaW50KSB7XG5cdFx0XHRjb2xvcnMgPSBzZXJpZXMub3B0aW9ucy5jb2xvcnMgfHwgc2VyaWVzLmNoYXJ0Lm9wdGlvbnMuY29sb3JzO1xuXHRcdFx0cG9pbnQuY29sb3IgPSBwb2ludC5jb2xvciB8fCBjb2xvcnNbc2VyaWVzLmNvbG9yQ291bnRlcisrXTtcblx0XHRcdC8vIGxvb3AgYmFjayB0byB6ZXJvXG5cdFx0XHRpZiAoc2VyaWVzLmNvbG9yQ291bnRlciA9PT0gY29sb3JzLmxlbmd0aCkge1xuXHRcdFx0XHRzZXJpZXMuY29sb3JDb3VudGVyID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpZXMuY2hhcnQucG9pbnRDb3VudCsrO1xuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblx0LyoqXG5cdCAqIEFwcGx5IHRoZSBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIHggYW5kIHkgZGF0YSBhbmQgcG9zc2libGUgc29tZSBleHRyYSBwcm9wZXJ0aWVzLlxuXHQgKiBUaGlzIGlzIGNhbGxlZCBvbiBwb2ludCBpbml0IG9yIGZyb20gcG9pbnQudXBkYXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0YXBwbHlPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgeCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRwb2ludFZhbEtleSA9IHNlcmllcy5wb2ludFZhbEtleTtcblxuXHRcdG9wdGlvbnMgPSBQb2ludC5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHQvLyBjb3B5IG9wdGlvbnMgZGlyZWN0bHkgdG8gcG9pbnRcblx0XHRleHRlbmQocG9pbnQsIG9wdGlvbnMpO1xuXHRcdHBvaW50Lm9wdGlvbnMgPSBwb2ludC5vcHRpb25zID8gZXh0ZW5kKHBvaW50Lm9wdGlvbnMsIG9wdGlvbnMpIDogb3B0aW9ucztcblx0XHRcdFxuXHRcdC8vIEZvciBoaWdoZXIgZGltZW5zaW9uIHNlcmllcyB0eXBlcy4gRm9yIGluc3RhbmNlLCBmb3IgcmFuZ2VzLCBwb2ludC55IGlzIG1hcHBlZCB0byBwb2ludC5sb3cuXG5cdFx0aWYgKHBvaW50VmFsS2V5KSB7XG5cdFx0XHRwb2ludC55ID0gcG9pbnRbcG9pbnRWYWxLZXldO1xuXHRcdH1cblx0XHRcblx0XHQvLyBJZiBubyB4IGlzIHNldCBieSBub3csIGdldCBhdXRvIGluY3JlbWVudGVkIHZhbHVlLiBBbGwgcG9pbnRzIG11c3QgaGF2ZSBhblxuXHRcdC8vIHggdmFsdWUsIGhvd2V2ZXIgdGhlIHkgdmFsdWUgY2FuIGJlIG51bGwgdG8gY3JlYXRlIGEgZ2FwIGluIHRoZSBzZXJpZXNcblx0XHRpZiAocG9pbnQueCA9PT0gVU5ERUZJTkVEICYmIHNlcmllcykge1xuXHRcdFx0cG9pbnQueCA9IHggPT09IFVOREVGSU5FRCA/IHNlcmllcy5hdXRvSW5jcmVtZW50KCkgOiB4O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybSBudW1iZXIgb3IgYXJyYXkgY29uZmlncyBpbnRvIG9iamVjdHNcblx0ICovXG5cdG9wdGlvbnNUb09iamVjdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmV0LFxuXHRcdFx0c2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRwb2ludEFycmF5TWFwID0gc2VyaWVzLnBvaW50QXJyYXlNYXAgfHwgWyd5J10sXG5cdFx0XHR2YWx1ZUNvdW50ID0gcG9pbnRBcnJheU1hcC5sZW5ndGgsXG5cdFx0XHRmaXJzdEl0ZW1UeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRqID0gMDtcblxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0ID0geyB5OiBvcHRpb25zIH07XG5cblx0XHR9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRcdHJldCA9IHt9O1xuXHRcdFx0Ly8gd2l0aCBsZWFkaW5nIHggdmFsdWVcblx0XHRcdGlmIChvcHRpb25zLmxlbmd0aCA+IHZhbHVlQ291bnQpIHtcblx0XHRcdFx0Zmlyc3RJdGVtVHlwZSA9IHR5cGVvZiBvcHRpb25zWzBdO1xuXHRcdFx0XHRpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXQubmFtZSA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRyZXQueCA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGogPCB2YWx1ZUNvdW50KSB7XG5cdFx0XHRcdHJldFtwb2ludEFycmF5TWFwW2orK11dID0gb3B0aW9uc1tpKytdO1xuXHRcdFx0fVx0XHRcdFxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXQgPSBvcHRpb25zO1xuXG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYXN0ZXN0IHdheSB0byBkZXRlY3QgaWYgdGhlcmUgYXJlIGluZGl2aWR1YWwgcG9pbnQgZGF0YUxhYmVscyB0aGF0IG5lZWQgXG5cdFx0XHQvLyB0byBiZSBjb25zaWRlcmVkIGluIGRyYXdEYXRhTGFiZWxzLiBUaGVzZSBjYW4gb25seSBvY2N1ciBpbiBvYmplY3QgY29uZmlncy5cblx0XHRcdGlmIChvcHRpb25zLmRhdGFMYWJlbHMpIHtcblx0XHRcdFx0c2VyaWVzLl9oYXNQb2ludExhYmVscyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhbWUgYXBwcm9hY2ggYXMgYWJvdmUgZm9yIG1hcmtlcnNcblx0XHRcdGlmIChvcHRpb25zLm1hcmtlcikge1xuXHRcdFx0XHRzZXJpZXMuX2hhc1BvaW50TWFya2VycyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgYSBwb2ludCB0byBjbGVhciBtZW1vcnkuIEl0cyByZWZlcmVuY2Ugc3RpbGwgc3RheXMgaW4gc2VyaWVzLmRhdGEuXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cyxcblx0XHRcdHByb3A7XG5cblx0XHRjaGFydC5wb2ludENvdW50LS07XG5cblx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRlcmFzZShob3ZlclBvaW50cywgcG9pbnQpO1xuXHRcdFx0aWYgKCFob3ZlclBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0fVxuXHRcdGlmIChwb2ludCA9PT0gY2hhcnQuaG92ZXJQb2ludCkge1xuXHRcdFx0cG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdH1cblx0XHRcblx0XHQvLyByZW1vdmUgYWxsIGV2ZW50c1xuXHRcdGlmIChwb2ludC5ncmFwaGljIHx8IHBvaW50LmRhdGFMYWJlbCkgeyAvLyByZW1vdmVFdmVudCBhbmQgZGVzdHJveUVsZW1lbnRzIGFyZSBwZXJmb3JtYW5jZSBleHBlbnNpdmVcblx0XHRcdHJlbW92ZUV2ZW50KHBvaW50KTtcblx0XHRcdHBvaW50LmRlc3Ryb3lFbGVtZW50cygpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludC5sZWdlbmRJdGVtKSB7IC8vIHBpZXMgaGF2ZSBsZWdlbmQgaXRlbXNcblx0XHRcdGNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShwb2ludCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChwcm9wIGluIHBvaW50KSB7XG5cdFx0XHRwb2ludFtwcm9wXSA9IG51bGw7XG5cdFx0fVxuXG5cblx0fSxcblxuXHQvKipcblx0ICogRGVzdHJveSBTVkcgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb2ludFxuXHQgKi9cblx0ZGVzdHJveUVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHByb3BzID0gWydncmFwaGljJywgJ2RhdGFMYWJlbCcsICdkYXRhTGFiZWxVcHBlcicsICdncm91cCcsICdjb25uZWN0b3InLCAnc2hhZG93R3JvdXAnXSxcblx0XHRcdHByb3AsXG5cdFx0XHRpID0gNjtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRpZiAocG9pbnRbcHJvcF0pIHtcblx0XHRcdFx0cG9pbnRbcHJvcF0gPSBwb2ludFtwcm9wXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGNvbmZpZ3VyYXRpb24gaGFzaCBuZWVkZWQgZm9yIHRoZSBkYXRhIGxhYmVsIGFuZCB0b29sdGlwIGZvcm1hdHRlcnNcblx0ICovXG5cdGdldExhYmVsQ29uZmlnOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogcG9pbnQuY2F0ZWdvcnksXG5cdFx0XHR5OiBwb2ludC55LFxuXHRcdFx0a2V5OiBwb2ludC5uYW1lIHx8IHBvaW50LmNhdGVnb3J5LFxuXHRcdFx0c2VyaWVzOiBwb2ludC5zZXJpZXMsXG5cdFx0XHRwb2ludDogcG9pbnQsXG5cdFx0XHRwZXJjZW50YWdlOiBwb2ludC5wZXJjZW50YWdlLFxuXHRcdFx0dG90YWw6IHBvaW50LnRvdGFsIHx8IHBvaW50LnN0YWNrVG90YWxcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIHNlbGVjdGlvbiBzdGF0dXMgb2YgYSBwb2ludFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNlbGVjdGVkIFdoZXRoZXIgdG8gc2VsZWN0IG9yIHVuc2VsZWN0IHRoZSBwb2ludC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhY2N1bXVsYXRlIFdoZXRoZXIgdG8gYWRkIHRvIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsXG5cdCAqICAgICB0aGlzIGhhcHBlbnMgaWYgdGhlIGNvbnRyb2wga2V5IChDbWQgb24gTWFjKSB3YXMgcHJlc3NlZCBkdXJpbmcgY2xpY2tpbmcuXG5cdCAqL1xuXHRzZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZCwgYWNjdW11bGF0ZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdHNlbGVjdGVkID0gcGljayhzZWxlY3RlZCwgIXBvaW50LnNlbGVjdGVkKTtcblxuXHRcdC8vIGZpcmUgdGhlIGV2ZW50IHdpdGggdGhlIGRlZmFsdXQgaGFuZGxlclxuXHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KHNlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5zZWxlY3QnLCB7IGFjY3VtdWxhdGU6IGFjY3VtdWxhdGUgfSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cG9pbnQuc2VsZWN0ZWQgPSBwb2ludC5vcHRpb25zLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhW2luQXJyYXkocG9pbnQsIHNlcmllcy5kYXRhKV0gPSBwb2ludC5vcHRpb25zO1xuXHRcdFx0XG5cdFx0XHRwb2ludC5zZXRTdGF0ZShzZWxlY3RlZCAmJiBTRUxFQ1RfU1RBVEUpO1xuXG5cdFx0XHQvLyB1bnNlbGVjdCBhbGwgb3RoZXIgcG9pbnRzIHVubGVzcyBDdHJsIG9yIENtZCArIGNsaWNrXG5cdFx0XHRpZiAoIWFjY3VtdWxhdGUpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5nZXRTZWxlY3RlZFBvaW50cygpLCBmdW5jdGlvbiAobG9vcFBvaW50KSB7XG5cdFx0XHRcdFx0aWYgKGxvb3BQb2ludC5zZWxlY3RlZCAmJiBsb29wUG9pbnQgIT09IHBvaW50KSB7XG5cdFx0XHRcdFx0XHRsb29wUG9pbnQuc2VsZWN0ZWQgPSBsb29wUG9pbnQub3B0aW9ucy5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KGxvb3BQb2ludCwgc2VyaWVzLmRhdGEpXSA9IGxvb3BQb2ludC5vcHRpb25zO1xuXHRcdFx0XHRcdFx0bG9vcFBvaW50LnNldFN0YXRlKE5PUk1BTF9TVEFURSk7XG5cdFx0XHRcdFx0XHRsb29wUG9pbnQuZmlyZVBvaW50RXZlbnQoJ3Vuc2VsZWN0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogUnVucyBvbiBtb3VzZSBvdmVyIHRoZSBwb2ludFxuXHQgKi9cblx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludDtcblxuXHRcdC8vIHNldCBub3JtYWwgc3RhdGUgdG8gcHJldmlvdXMgc2VyaWVzXG5cdFx0aWYgKGhvdmVyUG9pbnQgJiYgaG92ZXJQb2ludCAhPT0gcG9pbnQpIHtcblx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdH1cblxuXHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50XG5cdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ21vdXNlT3ZlcicpO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwXG5cdFx0aWYgKHRvb2x0aXAgJiYgKCF0b29sdGlwLnNoYXJlZCB8fCBzZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcC5yZWZyZXNoKHBvaW50LCBlKTtcblx0XHR9XG5cblx0XHQvLyBob3ZlciB0aGlzXG5cdFx0cG9pbnQuc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBwb2ludDtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBSdW5zIG9uIG1vdXNlIG91dCBmcm9tIHRoZSBwb2ludFxuXHQgKi9cblx0b25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cztcblx0XHRcblx0XHRpZiAoIWhvdmVyUG9pbnRzIHx8IGluQXJyYXkodGhpcywgaG92ZXJQb2ludHMpID09PSAtMSkgeyAvLyAjODg3XG5cdFx0XHR0aGlzLmZpcmVQb2ludEV2ZW50KCdtb3VzZU91dCcpO1xuXHRcblx0XHRcdHRoaXMuc2V0U3RhdGUoKTtcblx0XHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRXh0ZW5kYWJsZSBtZXRob2QgZm9yIGZvcm1hdHRpbmcgZWFjaCBwb2ludCdzIHRvb2x0aXAgbGluZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHRvIGJlIGNvbmNhdGVuYXRlZCBpbiB0byB0aGUgY29tbW9uIHRvb2x0aXAgdGV4dFxuXHQgKi9cblx0dG9vbHRpcEZvcm1hdHRlcjogZnVuY3Rpb24gKHBvaW50Rm9ybWF0KSB7XG5cdFx0XG5cdFx0Ly8gSW5zZXJ0IG9wdGlvbnMgZm9yIHZhbHVlRGVjaW1hbHMsIHZhbHVlUHJlZml4LCBhbmQgdmFsdWVTdWZmaXhcblx0XHR2YXIgc2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRzZXJpZXNUb29sdGlwT3B0aW9ucyA9IHNlcmllcy50b29sdGlwT3B0aW9ucyxcblx0XHRcdHZhbHVlRGVjaW1hbHMgPSBwaWNrKHNlcmllc1Rvb2x0aXBPcHRpb25zLnZhbHVlRGVjaW1hbHMsICcnKSxcblx0XHRcdHZhbHVlUHJlZml4ID0gc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVQcmVmaXggfHwgJycsXG5cdFx0XHR2YWx1ZVN1ZmZpeCA9IHNlcmllc1Rvb2x0aXBPcHRpb25zLnZhbHVlU3VmZml4IHx8ICcnO1xuXHRcdFx0XG5cdFx0Ly8gTG9vcCBvdmVyIHRoZSBwb2ludCBhcnJheSBtYXAgYW5kIHJlcGxhY2UgdW5mb3JtYXR0ZWQgdmFsdWVzIHdpdGggc3ByaW50ZiBmb3JtYXR0aW5nIG1hcmt1cFxuXHRcdGVhY2goc2VyaWVzLnBvaW50QXJyYXlNYXAgfHwgWyd5J10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGtleSA9ICd7cG9pbnQuJyArIGtleTsgLy8gd2l0aG91dCB0aGUgY2xvc2luZyBicmFja2V0XG5cdFx0XHRpZiAodmFsdWVQcmVmaXggfHwgdmFsdWVTdWZmaXgpIHtcblx0XHRcdFx0cG9pbnRGb3JtYXQgPSBwb2ludEZvcm1hdC5yZXBsYWNlKGtleSArICd9JywgdmFsdWVQcmVmaXggKyBrZXkgKyAnfScgKyB2YWx1ZVN1ZmZpeCk7XG5cdFx0XHR9XG5cdFx0XHRwb2ludEZvcm1hdCA9IHBvaW50Rm9ybWF0LnJlcGxhY2Uoa2V5ICsgJ30nLCBrZXkgKyAnOiwuJyArIHZhbHVlRGVjaW1hbHMgKyAnZn0nKTtcblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gZm9ybWF0KHBvaW50Rm9ybWF0LCB7XG5cdFx0XHRwb2ludDogdGhpcyxcblx0XHRcdHNlcmllczogdGhpcy5zZXJpZXNcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBwb2ludCB3aXRoIG5ldyBvcHRpb25zICh0eXBpY2FsbHkgeC95IGRhdGEpIGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgc2VyaWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQb2ludCBvcHRpb25zIGFzIGRlZmluZWQgaW4gdGhlIHNlcmllcy5kYXRhIGFycmF5XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0ICpcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0aSxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zO1xuXG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0Ly8gZmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiBkb2luZyB0aGUgdXBkYXRlXG5cdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ3VwZGF0ZScsIHsgb3B0aW9uczogb3B0aW9ucyB9LCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHBvaW50LmFwcGx5T3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHZpc3VhbHNcblx0XHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHRcdFx0XHRzZXJpZXMuZ2V0QXR0cmlicygpO1xuXHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLm1hcmtlciAmJiBvcHRpb25zLm1hcmtlci5zeW1ib2wpIHtcblx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z3JhcGhpYy5hdHRyKHBvaW50LnBvaW50QXR0cltwb2ludC5zdGF0ZSB8fCAnJ10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWNvcmQgY2hhbmdlcyBpbiB0aGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHRpID0gaW5BcnJheShwb2ludCwgZGF0YSk7XG5cdFx0XHRzZXJpZXMueERhdGFbaV0gPSBwb2ludC54O1xuXHRcdFx0c2VyaWVzLnlEYXRhW2ldID0gc2VyaWVzLnRvWURhdGEgPyBzZXJpZXMudG9ZRGF0YShwb2ludCkgOiBwb2ludC55O1xuXHRcdFx0c2VyaWVzLnpEYXRhW2ldID0gcG9pbnQuejtcblx0XHRcdHNlcmllc09wdGlvbnMuZGF0YVtpXSA9IHBvaW50Lm9wdGlvbnM7XG5cblx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0c2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0aWYgKCFzZXJpZXMuZml4ZWRCb3ggJiYgc2VyaWVzLmhhc0NhcnRlc2lhblNlcmllcykgeyAvLyAjMTkwNiwgIzIzMjBcblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChzZXJpZXNPcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHsgLy8gIzE4MzEsICMxODg1XG5cdFx0XHRcdGNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShwb2ludCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBwb2ludCBhbmQgb3B0aW9uYWxseSByZWRyYXcgdGhlIHNlcmllcyBhbmQgaWYgbmVjZXNzYXJ5IHRoZSBheGVzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0ICovXG5cdHJlbW92ZTogZnVuY3Rpb24gKHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdGksXG5cdFx0XHRkYXRhID0gc2VyaWVzLmRhdGE7XG5cblx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0Ly8gZmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiByZW1vdmluZyB0aGUgcG9pbnRcblx0XHRwb2ludC5maXJlUG9pbnRFdmVudCgncmVtb3ZlJywgbnVsbCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBzcGxpY2UgYWxsIHRoZSBwYXJhbGxlbCBhcnJheXNcblx0XHRcdGkgPSBpbkFycmF5KHBvaW50LCBkYXRhKTtcblx0XHRcdGlmIChkYXRhLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRwb2ludHMuc3BsaWNlKGksIDEpO1x0XHRcdFxuXHRcdFx0fVxuXHRcdFx0ZGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhLnNwbGljZShpLCAxKTtcblx0XHRcdHNlcmllcy54RGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRzZXJpZXMueURhdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0c2VyaWVzLnpEYXRhLnNwbGljZShpLCAxKTtcblxuXHRcdFx0cG9pbnQuZGVzdHJveSgpO1xuXG5cblx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0c2VyaWVzLmlzRGlydHlEYXRhID0gdHJ1ZTtcblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaXJlIGFuIGV2ZW50IG9uIHRoZSBQb2ludCBvYmplY3QuIE11c3Qgbm90IGJlIHJlbmFtZWQgdG8gZmlyZUV2ZW50LCBhcyB0aGlzXG5cdCAqIGNhdXNlcyBhIG5hbWUgY2xhc2ggaW4gTW9vVG9vbHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmdzIEFkZGl0aW9uYWwgZXZlbnQgYXJndW1lbnRzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRGdW5jdGlvbiBEZWZhdWx0IGV2ZW50IGhhbmRsZXJcblx0ICovXG5cdGZpcmVQb2ludEV2ZW50OiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudEFyZ3MsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucztcblxuXHRcdC8vIGxvYWQgZXZlbnQgaGFuZGxlcnMgb24gZGVtYW5kIHRvIHNhdmUgdGltZSBvbiBtb3VzZW92ZXIvb3V0XG5cdFx0aWYgKHNlcmllc09wdGlvbnMucG9pbnQuZXZlbnRzW2V2ZW50VHlwZV0gfHwgKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5ldmVudHMgJiYgcG9pbnQub3B0aW9ucy5ldmVudHNbZXZlbnRUeXBlXSkpIHtcblx0XHRcdHRoaXMuaW1wb3J0RXZlbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIGRlZmF1bHQgaGFuZGxlciBpZiBpbiBzZWxlY3Rpb24gbW9kZVxuXHRcdGlmIChldmVudFR5cGUgPT09ICdjbGljaycgJiYgc2VyaWVzT3B0aW9ucy5hbGxvd1BvaW50U2VsZWN0KSB7XG5cdFx0XHRkZWZhdWx0RnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0Ly8gQ29udHJvbCBrZXkgaXMgZm9yIFdpbmRvd3MsIG1ldGEgKD0gQ21kIGtleSkgZm9yIE1hYywgU2hpZnQgZm9yIE9wZXJhXG5cdFx0XHRcdHBvaW50LnNlbGVjdChudWxsLCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmaXJlRXZlbnQodGhpcywgZXZlbnRUeXBlLCBldmVudEFyZ3MsIGRlZmF1bHRGdW5jdGlvbik7XG5cdH0sXG5cdC8qKlxuXHQgKiBJbXBvcnQgZXZlbnRzIGZyb20gdGhlIHNlcmllcycgYW5kIHBvaW50J3Mgb3B0aW9ucy4gT25seSBkbyBpdCBvblxuXHQgKiBkZW1hbmQsIHRvIHNhdmUgcHJvY2Vzc2luZyB0aW1lIG9uIGhvdmVyaW5nLlxuXHQgKi9cblx0aW1wb3J0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmhhc0ltcG9ydGVkRXZlbnRzKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gbWVyZ2UocG9pbnQuc2VyaWVzLm9wdGlvbnMucG9pbnQsIHBvaW50Lm9wdGlvbnMpLFxuXHRcdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0ZXZlbnRUeXBlO1xuXG5cdFx0XHRwb2ludC5ldmVudHMgPSBldmVudHM7XG5cblx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudChwb2ludCwgZXZlbnRUeXBlLCBldmVudHNbZXZlbnRUeXBlXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhhc0ltcG9ydGVkRXZlbnRzID0gdHJ1ZTtcblxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBwb2ludCdzIHN0YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZVxuXHQgKi9cblx0c2V0U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0cGxvdFkgPSBwb2ludC5wbG90WSxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdHN0YXRlT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLnN0YXRlcyxcblx0XHRcdG1hcmtlck9wdGlvbnMgPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLm1hcmtlciAmJiBzZXJpZXMub3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRub3JtYWxEaXNhYmxlZCA9IG1hcmtlck9wdGlvbnMgJiYgIW1hcmtlck9wdGlvbnMuZW5hYmxlZCxcblx0XHRcdG1hcmtlclN0YXRlT3B0aW9ucyA9IG1hcmtlck9wdGlvbnMgJiYgbWFya2VyT3B0aW9ucy5zdGF0ZXNbc3RhdGVdLFxuXHRcdFx0c3RhdGVEaXNhYmxlZCA9IG1hcmtlclN0YXRlT3B0aW9ucyAmJiBtYXJrZXJTdGF0ZU9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UsXG5cdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMgPSBzZXJpZXMuc3RhdGVNYXJrZXJHcmFwaGljLFxuXHRcdFx0cG9pbnRNYXJrZXIgPSBwb2ludC5tYXJrZXIgfHwge30sXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHJhZGl1cyxcblx0XHRcdG5ld1N5bWJvbCxcblx0XHRcdHBvaW50QXR0ciA9IHBvaW50LnBvaW50QXR0cjtcblxuXHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFOyAvLyBlbXB0eSBzdHJpbmdcblxuXHRcdGlmIChcblx0XHRcdFx0Ly8gYWxyZWFkeSBoYXMgdGhpcyBzdGF0ZVxuXHRcdFx0XHRzdGF0ZSA9PT0gcG9pbnQuc3RhdGUgfHxcblx0XHRcdFx0Ly8gc2VsZWN0ZWQgcG9pbnRzIGRvbid0IHJlc3BvbmQgdG8gaG92ZXJcblx0XHRcdFx0KHBvaW50LnNlbGVjdGVkICYmIHN0YXRlICE9PSBTRUxFQ1RfU1RBVEUpIHx8XG5cdFx0XHRcdC8vIHNlcmllcycgc3RhdGUgb3B0aW9ucyBpcyBkaXNhYmxlZFxuXHRcdFx0XHQoc3RhdGVPcHRpb25zW3N0YXRlXSAmJiBzdGF0ZU9wdGlvbnNbc3RhdGVdLmVuYWJsZWQgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHQvLyBwb2ludCBtYXJrZXIncyBzdGF0ZSBvcHRpb25zIGlzIGRpc2FibGVkXG5cdFx0XHRcdChzdGF0ZSAmJiAoc3RhdGVEaXNhYmxlZCB8fCAobm9ybWFsRGlzYWJsZWQgJiYgIW1hcmtlclN0YXRlT3B0aW9ucy5lbmFibGVkKSkpXG5cblx0XHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGFwcGx5IGhvdmVyIHN0eWxlcyB0byB0aGUgZXhpc3RpbmcgcG9pbnRcblx0XHRpZiAocG9pbnQuZ3JhcGhpYykge1xuXHRcdFx0cmFkaXVzID0gbWFya2VyT3B0aW9ucyAmJiBwb2ludC5ncmFwaGljLnN5bWJvbE5hbWUgJiYgcG9pbnRBdHRyW3N0YXRlXS5yO1xuXHRcdFx0cG9pbnQuZ3JhcGhpYy5hdHRyKG1lcmdlKFxuXHRcdFx0XHRwb2ludEF0dHJbc3RhdGVdLFxuXHRcdFx0XHRyYWRpdXMgPyB7IC8vIG5ldyBzeW1ib2wgYXR0cmlidXRlcyAoIzUwNywgIzYxMilcblx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHR5OiBwbG90WSAtIHJhZGl1cyxcblx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRoZWlnaHQ6IDIgKiByYWRpdXNcblx0XHRcdFx0fSA6IHt9XG5cdFx0XHQpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgYSBncmFwaGljIGlzIG5vdCBhcHBsaWVkIHRvIGVhY2ggcG9pbnQgaW4gdGhlIG5vcm1hbCBzdGF0ZSwgY3JlYXRlIGEgc2hhcmVkXG5cdFx0XHQvLyBncmFwaGljIGZvciB0aGUgaG92ZXIgc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAmJiBtYXJrZXJTdGF0ZU9wdGlvbnMpIHtcblx0XHRcdFx0cmFkaXVzID0gbWFya2VyU3RhdGVPcHRpb25zLnJhZGl1cztcblx0XHRcdFx0bmV3U3ltYm9sID0gcG9pbnRNYXJrZXIuc3ltYm9sIHx8IHNlcmllcy5zeW1ib2w7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHBvaW50IGhhcyBhbm90aGVyIHN5bWJvbCB0aGFuIHRoZSBwcmV2aW91cyBvbmUsIHRocm93IGF3YXkgdGhlIFxuXHRcdFx0XHQvLyBzdGF0ZSBtYXJrZXIgZ3JhcGhpYyBhbmQgZm9yY2UgYSBuZXcgb25lICgjMTQ1OSlcblx0XHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYyAmJiBzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCAhPT0gbmV3U3ltYm9sKSB7XHRcdFx0XHRcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMgPSBzdGF0ZU1hcmtlckdyYXBoaWMuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIGEgbmV3IHN0YXRlIG1hcmtlciBncmFwaGljXG5cdFx0XHRcdGlmICghc3RhdGVNYXJrZXJHcmFwaGljKSB7XG5cdFx0XHRcdFx0c2VyaWVzLnN0YXRlTWFya2VyR3JhcGhpYyA9IHN0YXRlTWFya2VyR3JhcGhpYyA9IGNoYXJ0LnJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHRcdG5ld1N5bWJvbCxcblx0XHRcdFx0XHRcdHBsb3RYIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0cGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0MiAqIHJhZGl1c1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cihwb2ludEF0dHJbc3RhdGVdKVxuXHRcdFx0XHRcdC5hZGQoc2VyaWVzLm1hcmtlckdyb3VwKTtcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCA9IG5ld1N5bWJvbDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE1vdmUgdGhlIGV4aXN0aW5nIGdyYXBoaWNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuYXR0cih7IC8vICMxMDU0XG5cdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYykge1xuXHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbc3RhdGUgJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBwbG90WSkgPyAnc2hvdycgOiAnaGlkZSddKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cG9pbnQuc3RhdGUgPSBzdGF0ZTtcblx0fVxufTtcblxuLyoqXG4gKiBAY2xhc3NEZXNjcmlwdGlvbiBUaGUgYmFzZSBmdW5jdGlvbiB3aGljaCBhbGwgb3RoZXIgc2VyaWVzIHR5cGVzIGluaGVyaXQgZnJvbS4gVGhlIGRhdGEgaW4gdGhlIHNlcmllcyBpcyBzdG9yZWRcbiAqIGluIHZhcmlvdXMgYXJyYXlzLlxuICpcbiAqIC0gRmlyc3QsIHNlcmllcy5vcHRpb25zLmRhdGEgY29udGFpbnMgYWxsIHRoZSBvcmlnaW5hbCBjb25maWcgb3B0aW9ucyBmb3JcbiAqIGVhY2ggcG9pbnQgd2hldGhlciBhZGRlZCBieSBvcHRpb25zIG9yIG1ldGhvZHMgbGlrZSBzZXJpZXMuYWRkUG9pbnQuXG4gKiAtIE5leHQsIHNlcmllcy5kYXRhIGNvbnRhaW5zIHRob3NlIHZhbHVlcyBjb252ZXJ0ZWQgdG8gcG9pbnRzLCBidXQgaW4gY2FzZSB0aGUgc2VyaWVzIGRhdGEgbGVuZ3RoXG4gKiBleGNlZWRzIHRoZSBjcm9wVGhyZXNob2xkLCBvciBpZiB0aGUgZGF0YSBpcyBncm91cGVkLCBzZXJpZXMuZGF0YSBkb2Vzbid0IGNvbnRhaW4gYWxsIHRoZSBwb2ludHMuIEl0XG4gKiBvbmx5IGNvbnRhaW5zIHRoZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCBvbiBkZW1hbmQuXG4gKiAtIFRoZW4gdGhlcmUncyBzZXJpZXMucG9pbnRzIHRoYXQgY29udGFpbnMgYWxsIGN1cnJlbnRseSB2aXNpYmxlIHBvaW50IG9iamVjdHMuIEluIGNhc2Ugb2YgY3JvcHBpbmcsXG4gKiB0aGUgY3JvcHBlZC1hd2F5IHBvaW50cyBhcmUgbm90IHBhcnQgb2YgdGhpcyBhcnJheS4gVGhlIHNlcmllcy5wb2ludHMgYXJyYXkgc3RhcnRzIGF0IHNlcmllcy5jcm9wU3RhcnRcbiAqIGNvbXBhcmVkIHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMub3B0aW9ucy5kYXRhLiBJZiBob3dldmVyIHRoZSBzZXJpZXMgZGF0YSBpcyBncm91cGVkLCB0aGVzZSBjYW4ndFxuICogYmUgY29ycmVsYXRlZCBvbmUgdG8gb25lLlxuICogLSBzZXJpZXMueERhdGEgYW5kIHNlcmllcy5wcm9jZXNzZWRYRGF0YSBjb250YWluIGNsZWFuIHggdmFsdWVzLCBlcXVpdmFsZW50IHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMucG9pbnRzLlxuICogLSBzZXJpZXMueURhdGEgYW5kIHNlcmllcy5wcm9jZXNzZWRZRGF0YSBjb250YWluIGNsZWFuIHggdmFsdWVzLCBlcXVpdmFsZW50IHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMucG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xudmFyIFNlcmllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5TZXJpZXMucHJvdG90eXBlID0ge1xuXG5cdGlzQ2FydGVzaWFuOiB0cnVlLFxuXHR0eXBlOiAnbGluZScsXG5cdHBvaW50Q2xhc3M6IFBvaW50LFxuXHRzb3J0ZWQ6IHRydWUsIC8vIHJlcXVpcmVzIHRoZSBkYXRhIHRvIGJlIHNvcnRlZFxuXHRyZXF1aXJlU29ydGluZzogdHJ1ZSxcblx0cG9pbnRBdHRyVG9PcHRpb25zOiB7IC8vIG1hcHBpbmcgYmV0d2VlbiBTVkcgYXR0cmlidXRlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW9uc1xuXHRcdHN0cm9rZTogJ2xpbmVDb2xvcicsXG5cdFx0J3N0cm9rZS13aWR0aCc6ICdsaW5lV2lkdGgnLFxuXHRcdGZpbGw6ICdmaWxsQ29sb3InLFxuXHRcdHI6ICdyYWRpdXMnXG5cdH0sXG5cdGNvbG9yQ291bnRlcjogMCxcblx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRldmVudFR5cGUsXG5cdFx0XHRldmVudHMsXG5cdFx0XHRjaGFydFNlcmllcyA9IGNoYXJ0LnNlcmllcztcblxuXHRcdHNlcmllcy5jaGFydCA9IGNoYXJ0O1xuXHRcdHNlcmllcy5vcHRpb25zID0gb3B0aW9ucyA9IHNlcmllcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBtZXJnZSB3aXRoIHBsb3RPcHRpb25zXG5cdFx0c2VyaWVzLmxpbmtlZFNlcmllcyA9IFtdO1xuXG5cdFx0Ly8gYmluZCB0aGUgYXhlc1xuXHRcdHNlcmllcy5iaW5kQXhlcygpO1xuXG5cdFx0Ly8gc2V0IHNvbWUgdmFyaWFibGVzXG5cdFx0ZXh0ZW5kKHNlcmllcywge1xuXHRcdFx0bmFtZTogb3B0aW9ucy5uYW1lLFxuXHRcdFx0c3RhdGU6IE5PUk1BTF9TVEFURSxcblx0XHRcdHBvaW50QXR0cjoge30sXG5cdFx0XHR2aXNpYmxlOiBvcHRpb25zLnZpc2libGUgIT09IGZhbHNlLCAvLyB0cnVlIGJ5IGRlZmF1bHRcblx0XHRcdHNlbGVjdGVkOiBvcHRpb25zLnNlbGVjdGVkID09PSB0cnVlIC8vIGZhbHNlIGJ5IGRlZmF1bHRcblx0XHR9KTtcblx0XHRcblx0XHQvLyBzcGVjaWFsXG5cdFx0aWYgKHVzZUNhblZHKSB7XG5cdFx0XHRvcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRcdGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0YWRkRXZlbnQoc2VyaWVzLCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHR9XG5cdFx0aWYgKFxuXHRcdFx0KGV2ZW50cyAmJiBldmVudHMuY2xpY2spIHx8XG5cdFx0XHQob3B0aW9ucy5wb2ludCAmJiBvcHRpb25zLnBvaW50LmV2ZW50cyAmJiBvcHRpb25zLnBvaW50LmV2ZW50cy5jbGljaykgfHxcblx0XHRcdG9wdGlvbnMuYWxsb3dQb2ludFNlbGVjdFxuXHRcdCkge1xuXHRcdFx0Y2hhcnQucnVuVHJhY2tlckNsaWNrID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRzZXJpZXMuZ2V0Q29sb3IoKTtcblx0XHRzZXJpZXMuZ2V0U3ltYm9sKCk7XG5cblx0XHQvLyBzZXQgdGhlIGRhdGFcblx0XHRzZXJpZXMuc2V0RGF0YShvcHRpb25zLmRhdGEsIGZhbHNlKTtcblx0XHRcblx0XHQvLyBNYXJrIGNhcnRlc2lhblxuXHRcdGlmIChzZXJpZXMuaXNDYXJ0ZXNpYW4pIHtcblx0XHRcdGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVnaXN0ZXIgaXQgaW4gdGhlIGNoYXJ0XG5cdFx0Y2hhcnRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdHNlcmllcy5faSA9IGNoYXJ0U2VyaWVzLmxlbmd0aCAtIDE7XG5cdFx0XG5cdFx0Ly8gU29ydCBzZXJpZXMgYWNjb3JkaW5nIHRvIGluZGV4IG9wdGlvbiAoIzI0OCwgIzExMjMpXG5cdFx0c3RhYmxlU29ydChjaGFydFNlcmllcywgZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBwaWNrKGEub3B0aW9ucy5pbmRleCwgYS5faSkgLSBwaWNrKGIub3B0aW9ucy5pbmRleCwgYS5faSk7XG5cdFx0fSk7XG5cdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcywgaSkge1xuXHRcdFx0c2VyaWVzLmluZGV4ID0gaTtcblx0XHRcdHNlcmllcy5uYW1lID0gc2VyaWVzLm5hbWUgfHwgJ1NlcmllcyAnICsgKGkgKyAxKTtcblx0XHR9KTtcblxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgeEF4aXMgYW5kIHlBeGlzIHByb3BlcnRpZXMgb2YgY2FydGVzaWFuIHNlcmllcywgYW5kIHJlZ2lzdGVyIHRoZSBzZXJpZXNcblx0ICogaW4gdGhlIGF4aXMuc2VyaWVzIGFycmF5XG5cdCAqL1xuXHRiaW5kQXhlczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRheGlzT3B0aW9ucztcblx0XHRcdFxuXHRcdGlmIChzZXJpZXMuaXNDYXJ0ZXNpYW4pIHtcblx0XHRcdFxuXHRcdFx0ZWFjaChbJ3hBeGlzJywgJ3lBeGlzJ10sIGZ1bmN0aW9uIChBWElTKSB7IC8vIHJlcGVhdCBmb3IgeEF4aXMgYW5kIHlBeGlzXG5cdFx0XHRcdFxuXHRcdFx0XHRlYWNoKGNoYXJ0W0FYSVNdLCBmdW5jdGlvbiAoYXhpcykgeyAvLyBsb29wIHRocm91Z2ggdGhlIGNoYXJ0J3MgYXhpcyBvYmplY3RzXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YXhpc09wdGlvbnMgPSBheGlzLm9wdGlvbnM7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gYXBwbHkgaWYgdGhlIHNlcmllcyB4QXhpcyBvciB5QXhpcyBvcHRpb24gbWF0aGNoZXMgdGhlIG51bWJlciBvZiB0aGUgXG5cdFx0XHRcdFx0Ly8gYXhpcywgb3IgaWYgdW5kZWZpbmVkLCB1c2UgdGhlIGZpcnN0IGF4aXNcblx0XHRcdFx0XHRpZiAoKHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmluZGV4KSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSAhPT0gVU5ERUZJTkVEICYmIHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmlkKSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSA9PT0gVU5ERUZJTkVEICYmIGF4aXNPcHRpb25zLmluZGV4ID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHNlcmllcyBpbiB0aGUgYXhpcy5zZXJpZXMgbG9va3VwXG5cdFx0XHRcdFx0XHRheGlzLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIHNldCB0aGlzIHNlcmllcy54QXhpcyBvciBzZXJpZXMueUF4aXMgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRzZXJpZXNbQVhJU10gPSBheGlzO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBtYXJrIGRpcnR5IGZvciByZWRyYXdcblx0XHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBUaGUgc2VyaWVzIG5lZWRzIGFuIFggYW5kIGFuIFkgYXhpc1xuXHRcdFx0XHRpZiAoIXNlcmllc1tBWElTXSkge1xuXHRcdFx0XHRcdGVycm9yKDE4LCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogUmV0dXJuIGFuIGF1dG8gaW5jcmVtZW50ZWQgeCB2YWx1ZSBiYXNlZCBvbiB0aGUgcG9pbnRTdGFydCBhbmQgcG9pbnRJbnRlcnZhbCBvcHRpb25zLlxuXHQgKiBUaGlzIGlzIG9ubHkgdXNlZCBpZiBhbiB4IHZhbHVlIGlzIG5vdCBnaXZlbiBmb3IgdGhlIHBvaW50IHRoYXQgY2FsbHMgYXV0b0luY3JlbWVudC5cblx0ICovXG5cdGF1dG9JbmNyZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHhJbmNyZW1lbnQgPSBzZXJpZXMueEluY3JlbWVudDtcblxuXHRcdHhJbmNyZW1lbnQgPSBwaWNrKHhJbmNyZW1lbnQsIG9wdGlvbnMucG9pbnRTdGFydCwgMCk7XG5cblx0XHRzZXJpZXMucG9pbnRJbnRlcnZhbCA9IHBpY2soc2VyaWVzLnBvaW50SW50ZXJ2YWwsIG9wdGlvbnMucG9pbnRJbnRlcnZhbCwgMSk7XG5cblx0XHRzZXJpZXMueEluY3JlbWVudCA9IHhJbmNyZW1lbnQgKyBzZXJpZXMucG9pbnRJbnRlcnZhbDtcblx0XHRyZXR1cm4geEluY3JlbWVudDtcblx0fSxcblxuXHQvKipcblx0ICogRGl2aWRlIHRoZSBzZXJpZXMgZGF0YSBpbnRvIHNlZ21lbnRzIGRpdmlkZWQgYnkgbnVsbCB2YWx1ZXMuXG5cdCAqL1xuXHRnZXRTZWdtZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0bGFzdE51bGwgPSAtMSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRpLFxuXHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdHBvaW50c0xlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAocG9pbnRzTGVuZ3RoKSB7IC8vIG5vIGFjdGlvbiByZXF1aXJlZCBmb3IgW11cblx0XHRcdFxuXHRcdFx0Ly8gaWYgY29ubmVjdCBudWxscywganVzdCByZW1vdmUgbnVsbCBwb2ludHNcblx0XHRcdGlmIChzZXJpZXMub3B0aW9ucy5jb25uZWN0TnVsbHMpIHtcblx0XHRcdFx0aSA9IHBvaW50c0xlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChwb2ludHNbaV0ueSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtwb2ludHNdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0Ly8gZWxzZSwgc3BsaXQgb24gbnVsbCBwb2ludHNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdFx0XHRpZiAocG9pbnQueSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKGkgPiBsYXN0TnVsbCArIDEpIHtcblx0XHRcdFx0XHRcdFx0c2VnbWVudHMucHVzaChwb2ludHMuc2xpY2UobGFzdE51bGwgKyAxLCBpKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsYXN0TnVsbCA9IGk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSBwb2ludHNMZW5ndGggLSAxKSB7IC8vIGxhc3QgdmFsdWVcblx0XHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gocG9pbnRzLnNsaWNlKGxhc3ROdWxsICsgMSwgaSArIDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyByZWdpc3RlciBpdFxuXHRcdHNlcmllcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgc2VyaWVzIG9wdGlvbnMgYnkgbWVyZ2luZyBmcm9tIHRoZSBvcHRpb25zIHRyZWVcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1PcHRpb25zXG5cdCAqL1xuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAoaXRlbU9wdGlvbnMpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0Y2hhcnRPcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdHBsb3RPcHRpb25zID0gY2hhcnRPcHRpb25zLnBsb3RPcHRpb25zLFxuXHRcdFx0dHlwZU9wdGlvbnMgPSBwbG90T3B0aW9uc1t0aGlzLnR5cGVdLFxuXHRcdFx0b3B0aW9ucztcblxuXHRcdHRoaXMudXNlck9wdGlvbnMgPSBpdGVtT3B0aW9ucztcblxuXHRcdG9wdGlvbnMgPSBtZXJnZShcblx0XHRcdHR5cGVPcHRpb25zLFxuXHRcdFx0cGxvdE9wdGlvbnMuc2VyaWVzLFxuXHRcdFx0aXRlbU9wdGlvbnNcblx0XHQpO1xuXHRcdFxuXHRcdC8vIHRoZSB0b29sdGlwIG9wdGlvbnMgYXJlIG1lcmdlZCBiZXR3ZWVuIGdsb2JhbCBhbmQgc2VyaWVzIHNwZWNpZmljIG9wdGlvbnNcblx0XHR0aGlzLnRvb2x0aXBPcHRpb25zID0gbWVyZ2UoY2hhcnRPcHRpb25zLnRvb2x0aXAsIG9wdGlvbnMudG9vbHRpcCk7XG5cdFx0XG5cdFx0Ly8gRGVsdGUgbWFya2VyIG9iamVjdCBpZiBub3QgYWxsb3dlZCAoIzExMjUpXG5cdFx0aWYgKHR5cGVPcHRpb25zLm1hcmtlciA9PT0gbnVsbCkge1xuXHRcdFx0ZGVsZXRlIG9wdGlvbnMubWFya2VyO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gb3B0aW9ucztcblxuXHR9LFxuXHQvKipcblx0ICogR2V0IHRoZSBzZXJpZXMnIGNvbG9yXG5cdCAqL1xuXHRnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dXNlck9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0ZGVmYXVsdENvbG9ycyA9IHRoaXMuY2hhcnQub3B0aW9ucy5jb2xvcnMsXG5cdFx0XHRjb3VudGVycyA9IHRoaXMuY2hhcnQuY291bnRlcnMsXG5cdFx0XHRjb2xvcixcblx0XHRcdGNvbG9ySW5kZXg7XG5cblx0XHRjb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgZGVmYXVsdFBsb3RPcHRpb25zW3RoaXMudHlwZV0uY29sb3I7XG5cblx0XHRpZiAoIWNvbG9yICYmICFvcHRpb25zLmNvbG9yQnlQb2ludCkge1xuXHRcdFx0aWYgKGRlZmluZWQodXNlck9wdGlvbnMuX2NvbG9ySW5kZXgpKSB7IC8vIGFmdGVyIFNlcmllcy51cGRhdGUoKVxuXHRcdFx0XHRjb2xvckluZGV4ID0gdXNlck9wdGlvbnMuX2NvbG9ySW5kZXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1c2VyT3B0aW9ucy5fY29sb3JJbmRleCA9IGNvdW50ZXJzLmNvbG9yO1xuXHRcdFx0XHRjb2xvckluZGV4ID0gY291bnRlcnMuY29sb3IrKztcblx0XHRcdH1cblx0XHRcdGNvbG9yID0gZGVmYXVsdENvbG9yc1tjb2xvckluZGV4XTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcdGNvdW50ZXJzLndyYXBDb2xvcihkZWZhdWx0Q29sb3JzLmxlbmd0aCk7XG5cdH0sXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sXG5cdCAqL1xuXHRnZXRTeW1ib2w6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHVzZXJPcHRpb25zID0gc2VyaWVzLnVzZXJPcHRpb25zLFxuXHRcdFx0c2VyaWVzTWFya2VyT3B0aW9uID0gc2VyaWVzLm9wdGlvbnMubWFya2VyLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRkZWZhdWx0U3ltYm9scyA9IGNoYXJ0Lm9wdGlvbnMuc3ltYm9scyxcblx0XHRcdGNvdW50ZXJzID0gY2hhcnQuY291bnRlcnMsXG5cdFx0XHRzeW1ib2xJbmRleDtcblxuXHRcdHNlcmllcy5zeW1ib2wgPSBzZXJpZXNNYXJrZXJPcHRpb24uc3ltYm9sO1xuXHRcdGlmICghc2VyaWVzLnN5bWJvbCkge1xuXHRcdFx0aWYgKGRlZmluZWQodXNlck9wdGlvbnMuX3N5bWJvbEluZGV4KSkgeyAvLyBhZnRlciBTZXJpZXMudXBkYXRlKClcblx0XHRcdFx0c3ltYm9sSW5kZXggPSB1c2VyT3B0aW9ucy5fc3ltYm9sSW5kZXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1c2VyT3B0aW9ucy5fc3ltYm9sSW5kZXggPSBjb3VudGVycy5zeW1ib2w7XG5cdFx0XHRcdHN5bWJvbEluZGV4ID0gY291bnRlcnMuc3ltYm9sKys7XG5cdFx0XHR9XG5cdFx0XHRzZXJpZXMuc3ltYm9sID0gZGVmYXVsdFN5bWJvbHNbc3ltYm9sSW5kZXhdO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IHN1YnN0cmFjdCByYWRpdXMgaW4gaW1hZ2Ugc3ltYm9scyAoIzYwNClcblx0XHRpZiAoL151cmwvLnRlc3Qoc2VyaWVzLnN5bWJvbCkpIHtcblx0XHRcdHNlcmllc01hcmtlck9wdGlvbi5yYWRpdXMgPSAwO1xuXHRcdH1cblx0XHRjb3VudGVycy53cmFwU3ltYm9sKGRlZmF1bHRTeW1ib2xzLmxlbmd0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc2VyaWVzJyBzeW1ib2wgaW4gdGhlIGxlZ2VuZC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRhYmxlIHRvIGNyZWF0ZSBjdXN0b20gXG5cdCAqIHN5bWJvbHMgdGhyb3VnaCBIaWdoY2hhcnRzLnNlcmllc1R5cGVzW3R5cGVdLnByb3RvdHlwZS5kcmF3TGVnZW5kU3ltYm9scy5cblx0ICogXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmQgVGhlIGxlZ2VuZCBvYmplY3Rcblx0ICovXG5cdGRyYXdMZWdlbmRTeW1ib2w6IGZ1bmN0aW9uIChsZWdlbmQpIHtcblx0XHRcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdG1hcmtlck9wdGlvbnMgPSBvcHRpb25zLm1hcmtlcixcblx0XHRcdHJhZGl1cyxcblx0XHRcdGxlZ2VuZE9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdGxlZ2VuZFN5bWJvbCxcblx0XHRcdHN5bWJvbFdpZHRoID0gbGVnZW5kT3B0aW9ucy5zeW1ib2xXaWR0aCxcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5jaGFydC5yZW5kZXJlcixcblx0XHRcdGxlZ2VuZEl0ZW1Hcm91cCA9IHRoaXMubGVnZW5kR3JvdXAsXG5cdFx0XHR2ZXJ0aWNhbENlbnRlciA9IGxlZ2VuZC5iYXNlbGluZSAtIG1hdGhSb3VuZChyZW5kZXJlci5mb250TWV0cmljcyhsZWdlbmRPcHRpb25zLml0ZW1TdHlsZS5mb250U2l6ZSkuYiAqIDAuMyksXG5cdFx0XHRhdHRyO1xuXHRcdFx0XG5cdFx0Ly8gRHJhdyB0aGUgbGluZVxuXHRcdGlmIChvcHRpb25zLmxpbmVXaWR0aCkge1xuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMubGluZVdpZHRoXG5cdFx0XHR9O1xuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaFN0eWxlKSB7XG5cdFx0XHRcdGF0dHIuZGFzaHN0eWxlID0gb3B0aW9ucy5kYXNoU3R5bGU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZ2VuZExpbmUgPSByZW5kZXJlci5wYXRoKFtcblx0XHRcdFx0TSxcblx0XHRcdFx0MCxcblx0XHRcdFx0dmVydGljYWxDZW50ZXIsXG5cdFx0XHRcdEwsXG5cdFx0XHRcdHN5bWJvbFdpZHRoLFxuXHRcdFx0XHR2ZXJ0aWNhbENlbnRlclxuXHRcdFx0XSlcblx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHQuYWRkKGxlZ2VuZEl0ZW1Hcm91cCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIERyYXcgdGhlIG1hcmtlclxuXHRcdGlmIChtYXJrZXJPcHRpb25zICYmIG1hcmtlck9wdGlvbnMuZW5hYmxlZCkge1xuXHRcdFx0cmFkaXVzID0gbWFya2VyT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHR0aGlzLmxlZ2VuZFN5bWJvbCA9IGxlZ2VuZFN5bWJvbCA9IHJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0dGhpcy5zeW1ib2wsXG5cdFx0XHRcdChzeW1ib2xXaWR0aCAvIDIpIC0gcmFkaXVzLFxuXHRcdFx0XHR2ZXJ0aWNhbENlbnRlciAtIHJhZGl1cyxcblx0XHRcdFx0MiAqIHJhZGl1cyxcblx0XHRcdFx0MiAqIHJhZGl1c1xuXHRcdFx0KVxuXHRcdFx0LmFkZChsZWdlbmRJdGVtR3JvdXApO1xuXHRcdFx0bGVnZW5kU3ltYm9sLmlzTWFya2VyID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHBvaW50IGR5bmFtaWNhbGx5IGFmdGVyIGNoYXJ0IGxvYWQgdGltZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQb2ludCBvcHRpb25zIGFzIGdpdmVuIGluIHNlcmllcy5kYXRhXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hpZnQgSWYgc2hpZnQgaXMgdHJ1ZSwgYSBwb2ludCBpcyBzaGlmdGVkIG9mZiB0aGUgc3RhcnRcblx0ICogICAgb2YgdGhlIHNlcmllcyBhcyBvbmUgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZC5cblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKi9cblx0YWRkUG9pbnQ6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIHNoaWZ0LCBhbmltYXRpb24pIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0YXJlYSA9IHNlcmllcy5hcmVhLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YSxcblx0XHRcdHlEYXRhID0gc2VyaWVzLnlEYXRhLFxuXHRcdFx0ekRhdGEgPSBzZXJpZXMuekRhdGEsXG5cdFx0XHRuYW1lcyA9IHNlcmllcy5uYW1lcyxcblx0XHRcdGN1cnJlbnRTaGlmdCA9IChncmFwaCAmJiBncmFwaC5zaGlmdCkgfHwgMCxcblx0XHRcdGRhdGFPcHRpb25zID0gc2VyaWVzT3B0aW9ucy5kYXRhLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHRpc0luVGhlTWlkZGxlLFxuXHRcdFx0eCxcblx0XHRcdGk7XG5cblx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHQvLyBNYWtlIGdyYXBoIGFuaW1hdGUgc2lkZXdheXNcblx0XHRpZiAoc2hpZnQpIHtcblx0XHRcdGVhY2goW2dyYXBoLCBhcmVhLCBzZXJpZXMuZ3JhcGhOZWcsIHNlcmllcy5hcmVhTmVnXSwgZnVuY3Rpb24gKHNoYXBlKSB7XG5cdFx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHRcdHNoYXBlLnNoaWZ0ID0gY3VycmVudFNoaWZ0ICsgMTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRhcmVhLmlzQXJlYSA9IHRydWU7IC8vIG5lZWRlZCBpbiBhbmltYXRpb24sIGJvdGggd2l0aCBhbmQgd2l0aG91dCBzaGlmdFxuXHRcdH1cblx0XHRcblx0XHQvLyBPcHRpb25hbCByZWRyYXcsIGRlZmF1bHRzIHRvIHRydWVcblx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHQvLyBHZXQgb3B0aW9ucyBhbmQgcHVzaCB0aGUgcG9pbnQgdG8geERhdGEsIHlEYXRhIGFuZCBzZXJpZXMub3B0aW9ucy4gSW4gc2VyaWVzLmdlbmVyYXRlUG9pbnRzXG5cdFx0Ly8gdGhlIFBvaW50IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCBvbiBkZW1hbmQgYW5kIHB1c2hlZCB0byB0aGUgc2VyaWVzLmRhdGEgYXJyYXkuXG5cdFx0cG9pbnQgPSB7IHNlcmllczogc2VyaWVzIH07XG5cdFx0c2VyaWVzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShwb2ludCwgW29wdGlvbnNdKTtcblx0XHR4ID0gcG9pbnQueDtcblxuXHRcdC8vIEdldCB0aGUgaW5zZXJ0aW9uIHBvaW50XG5cdFx0aSA9IHhEYXRhLmxlbmd0aDtcblx0XHRpZiAoc2VyaWVzLnJlcXVpcmVTb3J0aW5nICYmIHggPCB4RGF0YVtpIC0gMV0pIHtcblx0XHRcdGlzSW5UaGVNaWRkbGUgPSB0cnVlO1xuXHRcdFx0d2hpbGUgKGkgJiYgeERhdGFbaSAtIDFdID4geCkge1xuXHRcdFx0XHRpLS07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHhEYXRhLnNwbGljZShpLCAwLCB4KTtcblx0XHR5RGF0YS5zcGxpY2UoaSwgMCwgc2VyaWVzLnRvWURhdGEgPyBzZXJpZXMudG9ZRGF0YShwb2ludCkgOiBwb2ludC55KTtcblx0XHR6RGF0YS5zcGxpY2UoaSwgMCwgcG9pbnQueik7XG5cdFx0aWYgKG5hbWVzKSB7XG5cdFx0XHRuYW1lc1t4XSA9IHBvaW50Lm5hbWU7XG5cdFx0fVxuXHRcdGRhdGFPcHRpb25zLnNwbGljZShpLCAwLCBvcHRpb25zKTtcblxuXHRcdGlmIChpc0luVGhlTWlkZGxlKSB7XG5cdFx0XHRzZXJpZXMuZGF0YS5zcGxpY2UoaSwgMCwgbnVsbCk7XG5cdFx0XHRzZXJpZXMucHJvY2Vzc0RhdGEoKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gR2VuZXJhdGUgcG9pbnRzIHRvIGJlIGFkZGVkIHRvIHRoZSBsZWdlbmQgKCMxMzI5KSBcblx0XHRpZiAoc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnKSB7XG5cdFx0XHRzZXJpZXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHR9XG5cblx0XHQvLyBTaGlmdCB0aGUgZmlyc3QgcG9pbnQgb2ZmIHRoZSBwYXJhbGxlbCBhcnJheXNcblx0XHQvLyB0b2RvOiBjb25zaWRlciBzZXJpZXMucmVtb3ZlUG9pbnQoaSkgbWV0aG9kXG5cdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRpZiAoZGF0YVswXSAmJiBkYXRhWzBdLnJlbW92ZSkge1xuXHRcdFx0XHRkYXRhWzBdLnJlbW92ZShmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhLnNoaWZ0KCk7XG5cdFx0XHRcdHhEYXRhLnNoaWZ0KCk7XG5cdFx0XHRcdHlEYXRhLnNoaWZ0KCk7XG5cdFx0XHRcdHpEYXRhLnNoaWZ0KCk7XG5cdFx0XHRcdGRhdGFPcHRpb25zLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVkcmF3XG5cdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0c2VyaWVzLmdldEF0dHJpYnMoKTsgLy8gIzE5Mzdcblx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVwbGFjZSB0aGUgc2VyaWVzIGRhdGEgd2l0aCBhIG5ldyBzZXQgb2YgZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVkcmF3XG5cdCAqL1xuXHRzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSwgcmVkcmF3KSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRvbGREYXRhID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0Zmlyc3RQb2ludCA9IG51bGwsXG5cdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdG5hbWVzID0geEF4aXMgJiYgeEF4aXMuY2F0ZWdvcmllcyAmJiAheEF4aXMuY2F0ZWdvcmllcy5sZW5ndGggPyBbXSA6IG51bGwsXG5cdFx0XHRpO1xuXG5cdFx0Ly8gcmVzZXQgcHJvcGVydGllc1xuXHRcdHNlcmllcy54SW5jcmVtZW50ID0gbnVsbDtcblx0XHRzZXJpZXMucG9pbnRSYW5nZSA9IHhBeGlzICYmIHhBeGlzLmNhdGVnb3JpZXMgPyAxIDogb3B0aW9ucy5wb2ludFJhbmdlO1xuXG5cdFx0c2VyaWVzLmNvbG9yQ291bnRlciA9IDA7IC8vIGZvciBzZXJpZXMgd2l0aCBjb2xvckJ5UG9pbnQgKCMxNTQ3KVxuXHRcdFxuXHRcdC8vIHBhcmFsbGVsIGFycmF5c1xuXHRcdHZhciB4RGF0YSA9IFtdLFxuXHRcdFx0eURhdGEgPSBbXSxcblx0XHRcdHpEYXRhID0gW10sXG5cdFx0XHRkYXRhTGVuZ3RoID0gZGF0YSA/IGRhdGEubGVuZ3RoIDogW10sXG5cdFx0XHR0dXJib1RocmVzaG9sZCA9IHBpY2sob3B0aW9ucy50dXJib1RocmVzaG9sZCwgMTAwMCksXG5cdFx0XHRwdCxcblx0XHRcdHBvaW50QXJyYXlNYXAgPSBzZXJpZXMucG9pbnRBcnJheU1hcCxcblx0XHRcdHZhbHVlQ291bnQgPSBwb2ludEFycmF5TWFwICYmIHBvaW50QXJyYXlNYXAubGVuZ3RoLFxuXHRcdFx0aGFzVG9ZRGF0YSA9ICEhc2VyaWVzLnRvWURhdGE7XG5cblx0XHQvLyBJbiB0dXJibyBtb2RlLCBvbmx5IG9uZS0gb3IgdHdvZGltZW5zaW9uYWwgYXJyYXlzIG9mIG51bWJlcnMgYXJlIGFsbG93ZWQuIFRoZVxuXHRcdC8vIGZpcnN0IHZhbHVlIGlzIHRlc3RlZCwgYW5kIHdlIGFzc3VtZSB0aGF0IGFsbCB0aGUgcmVzdCBhcmUgZGVmaW5lZCB0aGUgc2FtZVxuXHRcdC8vIHdheS4gQWx0aG91Z2ggdGhlICdmb3InIGxvb3BzIGFyZSBzaW1pbGFyLCB0aGV5IGFyZSByZXBlYXRlZCBpbnNpZGUgZWFjaFxuXHRcdC8vIGlmLWVsc2UgY29uZGl0aW9uYWwgZm9yIG1heCBwZXJmb3JtYW5jZS5cblx0XHRpZiAodHVyYm9UaHJlc2hvbGQgJiYgZGF0YUxlbmd0aCA+IHR1cmJvVGhyZXNob2xkKSB7IFxuXHRcdFx0XG5cdFx0XHQvLyBmaW5kIHRoZSBmaXJzdCBub24tbnVsbCBwb2ludFxuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoZmlyc3RQb2ludCA9PT0gbnVsbCAmJiBpIDwgZGF0YUxlbmd0aCkge1xuXHRcdFx0XHRmaXJzdFBvaW50ID0gZGF0YVtpXTtcblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFxuXHRcdFx0aWYgKGlzTnVtYmVyKGZpcnN0UG9pbnQpKSB7IC8vIGFzc3VtZSBhbGwgcG9pbnRzIGFyZSBudW1iZXJzXG5cdFx0XHRcdHZhciB4ID0gcGljayhvcHRpb25zLnBvaW50U3RhcnQsIDApLFxuXHRcdFx0XHRcdHBvaW50SW50ZXJ2YWwgPSBwaWNrKG9wdGlvbnMucG9pbnRJbnRlcnZhbCwgMSk7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHhEYXRhW2ldID0geDtcblx0XHRcdFx0XHR5RGF0YVtpXSA9IGRhdGFbaV07XG5cdFx0XHRcdFx0eCArPSBwb2ludEludGVydmFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlcmllcy54SW5jcmVtZW50ID0geDtcblx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShmaXJzdFBvaW50KSkgeyAvLyBhc3N1bWUgYWxsIHBvaW50cyBhcmUgYXJyYXlzXG5cdFx0XHRcdGlmICh2YWx1ZUNvdW50KSB7IC8vIFt4LCBsb3csIGhpZ2hdIG9yIFt4LCBvLCBoLCBsLCBjXVxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHB0ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHR5RGF0YVtpXSA9IHB0LnNsaWNlKDEsIHZhbHVlQ291bnQgKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IC8vIFt4LCB5XVxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHB0ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHR5RGF0YVtpXSA9IHB0WzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXJyb3IoMTIpOyAvLyBIaWdoY2hhcnRzIGV4cGVjdHMgY29uZmlncyB0byBiZSBudW1iZXJzIG9yIGFycmF5cyBpbiB0dXJibyBtb2RlXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGRhdGFbaV0gIT09IFVOREVGSU5FRCkgeyAvLyBzdHJheSBjb21tYXMgaW4gb2xkSUVcblx0XHRcdFx0XHRwdCA9IHsgc2VyaWVzOiBzZXJpZXMgfTtcblx0XHRcdFx0XHRzZXJpZXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHB0LCBbZGF0YVtpXV0pO1xuXHRcdFx0XHRcdHhEYXRhW2ldID0gcHQueDtcblx0XHRcdFx0XHR5RGF0YVtpXSA9IGhhc1RvWURhdGEgPyBzZXJpZXMudG9ZRGF0YShwdCkgOiBwdC55O1xuXHRcdFx0XHRcdHpEYXRhW2ldID0gcHQuejtcblx0XHRcdFx0XHRpZiAobmFtZXMgJiYgcHQubmFtZSkge1xuXHRcdFx0XHRcdFx0bmFtZXNbcHQueF0gPSBwdC5uYW1lOyAvLyAjMjA0NlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBGb3JnZXR0aW5nIHRvIGNhc3Qgc3RyaW5ncyB0byBudW1iZXJzIGlzIGEgY29tbW9uIGNhdmVhdCB3aGVuIGhhbmRsaW5nIENTViBvciBKU09OXHRcdFxuXHRcdGlmIChpc1N0cmluZyh5RGF0YVswXSkpIHtcblx0XHRcdGVycm9yKDE0LCB0cnVlKTtcblx0XHR9IFxuXG5cdFx0c2VyaWVzLmRhdGEgPSBbXTtcblx0XHRzZXJpZXMub3B0aW9ucy5kYXRhID0gZGF0YTtcblx0XHRzZXJpZXMueERhdGEgPSB4RGF0YTtcblx0XHRzZXJpZXMueURhdGEgPSB5RGF0YTtcblx0XHRzZXJpZXMuekRhdGEgPSB6RGF0YTtcblx0XHRzZXJpZXMubmFtZXMgPSBuYW1lcztcblxuXHRcdC8vIGRlc3Ryb3kgb2xkIHBvaW50c1xuXHRcdGkgPSAob2xkRGF0YSAmJiBvbGREYXRhLmxlbmd0aCkgfHwgMDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAob2xkRGF0YVtpXSAmJiBvbGREYXRhW2ldLmRlc3Ryb3kpIHtcblx0XHRcdFx0b2xkRGF0YVtpXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgbWluUmFuZ2UgKCM4NzgpXG5cdFx0aWYgKHhBeGlzKSB7XG5cdFx0XHR4QXhpcy5taW5SYW5nZSA9IHhBeGlzLnVzZXJNaW5SYW5nZTtcblx0XHR9XG5cblx0XHQvLyByZWRyYXdcblx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzZXJpZXMgYW5kIG9wdGlvbmFsbHkgcmVkcmF3IHRoZSBjaGFydFxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgb3Igd2FpdCBmb3IgYW4gZXhwbGljaXQgY2FsbFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHQgKiAgICBjb25maWd1cmF0aW9uXG5cdCAqL1xuXG5cdHJlbW92ZTogZnVuY3Rpb24gKHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRpZiAoIXNlcmllcy5pc1JlbW92aW5nKSB7ICAvKiBwcmV2ZW50IHRyaWdnZXJpbmcgbmF0aXZlIGV2ZW50IGluIGpRdWVyeVxuXHRcdFx0XHQoY2FsbGluZyB0aGUgcmVtb3ZlIGZ1bmN0aW9uIGZyb20gdGhlIHJlbW92ZSBldmVudCkgKi9cblx0XHRcdHNlcmllcy5pc1JlbW92aW5nID0gdHJ1ZTtcblxuXHRcdFx0Ly8gZmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiByZW1vdmluZyB0aGUgcG9pbnRcblx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdyZW1vdmUnLCBudWxsLCBmdW5jdGlvbiAoKSB7XG5cblxuXHRcdFx0XHQvLyBkZXN0cm95IGVsZW1lbnRzXG5cdFx0XHRcdHNlcmllcy5kZXN0cm95KCk7XG5cblxuXHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHRjaGFydC5saW5rU2VyaWVzKCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fVxuXHRcdHNlcmllcy5pc1JlbW92aW5nID0gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgdGhlIGRhdGEgYnkgY3JvcHBpbmcgYXdheSB1bnVzZWQgZGF0YSBwb2ludHMgaWYgdGhlIHNlcmllcyBpcyBsb25nZXJcblx0ICogdGhhbiB0aGUgY3JvcCB0aHJlc2hvbGQuIFRoaXMgc2F2ZXMgY29tcHV0aW5nIHRpbWUgZm9yIGxhZ2Ugc2VyaWVzLlxuXHQgKi9cblx0cHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIChmb3JjZSkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMueERhdGEsIC8vIGNvcGllZCBkdXJpbmcgc2xpY2Ugb3BlcmF0aW9uIGJlbG93XG5cdFx0XHRwcm9jZXNzZWRZRGF0YSA9IHNlcmllcy55RGF0YSxcblx0XHRcdGRhdGFMZW5ndGggPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRjcm9wcGVkRGF0YSxcblx0XHRcdGNyb3BTdGFydCA9IDAsXG5cdFx0XHRjcm9wcGVkLFxuXHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0aSwgLy8gbG9vcCB2YXJpYWJsZVxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0Y3JvcFRocmVzaG9sZCA9IG9wdGlvbnMuY3JvcFRocmVzaG9sZCxcblx0XHRcdGlzQ2FydGVzaWFuID0gc2VyaWVzLmlzQ2FydGVzaWFuO1xuXG5cdFx0Ly8gSWYgdGhlIHNlcmllcyBkYXRhIG9yIGF4ZXMgaGF2ZW4ndCBjaGFuZ2VkLCBkb24ndCBnbyB0aHJvdWdoIHRoaXMuIFJldHVybiBmYWxzZSB0byBwYXNzXG5cdFx0Ly8gdGhlIG1lc3NhZ2Ugb24gdG8gb3ZlcnJpZGUgbWV0aG9kcyBsaWtlIGluIGRhdGEgZ3JvdXBpbmcuIFxuXHRcdGlmIChpc0NhcnRlc2lhbiAmJiAhc2VyaWVzLmlzRGlydHkgJiYgIXhBeGlzLmlzRGlydHkgJiYgIXNlcmllcy55QXhpcy5pc0RpcnR5ICYmICFmb3JjZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRcblxuXHRcdC8vIG9wdGlvbmFsbHkgZmlsdGVyIG91dCBwb2ludHMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhXG5cdFx0aWYgKGlzQ2FydGVzaWFuICYmIHNlcmllcy5zb3J0ZWQgJiYgKCFjcm9wVGhyZXNob2xkIHx8IGRhdGFMZW5ndGggPiBjcm9wVGhyZXNob2xkIHx8IHNlcmllcy5mb3JjZUNyb3ApKSB7XG5cdFx0XHR2YXIgbWluID0geEF4aXMubWluLFxuXHRcdFx0XHRtYXggPSB4QXhpcy5tYXg7XG5cblx0XHRcdC8vIGl0J3Mgb3V0c2lkZSBjdXJyZW50IGV4dHJlbWVzXG5cdFx0XHRpZiAocHJvY2Vzc2VkWERhdGFbZGF0YUxlbmd0aCAtIDFdIDwgbWluIHx8IHByb2Nlc3NlZFhEYXRhWzBdID4gbWF4KSB7XG5cdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gW107XG5cdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gW107XG5cdFx0XHRcblx0XHRcdC8vIG9ubHkgY3JvcCBpZiBpdCdzIGFjdHVhbGx5IHNwaWxsaW5nIG91dFxuXHRcdFx0fSBlbHNlIGlmIChwcm9jZXNzZWRYRGF0YVswXSA8IG1pbiB8fCBwcm9jZXNzZWRYRGF0YVtkYXRhTGVuZ3RoIC0gMV0gPiBtYXgpIHtcblx0XHRcdFx0Y3JvcHBlZERhdGEgPSB0aGlzLmNyb3BEYXRhKHNlcmllcy54RGF0YSwgc2VyaWVzLnlEYXRhLCBtaW4sIG1heCk7XG5cdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gY3JvcHBlZERhdGEueERhdGE7XG5cdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gY3JvcHBlZERhdGEueURhdGE7XG5cdFx0XHRcdGNyb3BTdGFydCA9IGNyb3BwZWREYXRhLnN0YXJ0O1xuXHRcdFx0XHRjcm9wcGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHByb2Nlc3NlZCBwb2ludHNcblx0XHRmb3IgKGkgPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcm9jZXNzZWRYRGF0YVtpXSAtIHByb2Nlc3NlZFhEYXRhW2kgLSAxXTtcblx0XHRcdGlmIChkaXN0YW5jZSA+IDAgJiYgKGNsb3Nlc3RQb2ludFJhbmdlID09PSBVTkRFRklORUQgfHwgZGlzdGFuY2UgPCBjbG9zZXN0UG9pbnRSYW5nZSkpIHtcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0Ly8gVW5zb3J0ZWQgZGF0YSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBsaW5lIHRvb2x0aXAsIGFzIHdlbGwgYXMgZGF0YSBncm91cGluZyBhbmQgXG5cdFx0XHQvLyBuYXZpZ2F0aW9uIGluIFN0b2NrIGNoYXJ0cyAoIzcyNSkgYW5kIHdpZHRoIGNhbGN1bGF0aW9uIG9mIGNvbHVtbnMgKCMxOTAwKVxuXHRcdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA8IDAgJiYgc2VyaWVzLnJlcXVpcmVTb3J0aW5nKSB7XG5cdFx0XHRcdGVycm9yKDE1KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZWNvcmQgdGhlIHByb3BlcnRpZXNcblx0XHRzZXJpZXMuY3JvcHBlZCA9IGNyb3BwZWQ7IC8vIHVuZGVmaW5lZCBvciB0cnVlXG5cdFx0c2VyaWVzLmNyb3BTdGFydCA9IGNyb3BTdGFydDtcblx0XHRzZXJpZXMucHJvY2Vzc2VkWERhdGEgPSBwcm9jZXNzZWRYRGF0YTtcblx0XHRzZXJpZXMucHJvY2Vzc2VkWURhdGEgPSBwcm9jZXNzZWRZRGF0YTtcblxuXHRcdGlmIChvcHRpb25zLnBvaW50UmFuZ2UgPT09IG51bGwpIHsgLy8gbnVsbCBtZWFucyBhdXRvLCBhcyBmb3IgY29sdW1ucywgY2FuZGxlc3RpY2tzIGFuZCBPSExDXG5cdFx0XHRzZXJpZXMucG9pbnRSYW5nZSA9IGNsb3Nlc3RQb2ludFJhbmdlIHx8IDE7XG5cdFx0fVxuXHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZSA9IGNsb3Nlc3RQb2ludFJhbmdlO1xuXHRcdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJdGVyYXRlIG92ZXIgeERhdGEgYW5kIGNyb3AgdmFsdWVzIGJldHdlZW4gbWluIGFuZCBtYXguIFJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgY3JvcCBzdGFydC9lbmRcblx0ICogY3JvcHBlZCB4RGF0YSB3aXRoIGNvcnJlc3BvbmRpbmcgcGFydCBvZiB5RGF0YSwgZGF0YU1pbiBhbmQgZGF0YU1heCB3aXRoaW4gdGhlIGNyb3BwZWQgcmFuZ2Vcblx0ICovXG5cdGNyb3BEYXRhOiBmdW5jdGlvbiAoeERhdGEsIHlEYXRhLCBtaW4sIG1heCkge1xuXHRcdHZhciBkYXRhTGVuZ3RoID0geERhdGEubGVuZ3RoLFxuXHRcdFx0Y3JvcFN0YXJ0ID0gMCxcblx0XHRcdGNyb3BFbmQgPSBkYXRhTGVuZ3RoLFxuXHRcdFx0Y3JvcFNob3VsZGVyID0gcGljayh0aGlzLmNyb3BTaG91bGRlciwgMSksIC8vIGxpbmUtdHlwZSBzZXJpZXMgbmVlZCBvbmUgcG9pbnQgb3V0c2lkZVxuXHRcdFx0aTtcblxuXHRcdC8vIGl0ZXJhdGUgdXAgdG8gZmluZCBzbGljZSBzdGFydFxuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh4RGF0YVtpXSA+PSBtaW4pIHtcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gbWF0aE1heCgwLCBpIC0gY3JvcFNob3VsZGVyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcHJvY2VlZCB0byBmaW5kIHNsaWNlIGVuZFxuXHRcdGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeERhdGFbaV0gPiBtYXgpIHtcblx0XHRcdFx0Y3JvcEVuZCA9IGkgKyBjcm9wU2hvdWxkZXI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4RGF0YTogeERhdGEuc2xpY2UoY3JvcFN0YXJ0LCBjcm9wRW5kKSxcblx0XHRcdHlEYXRhOiB5RGF0YS5zbGljZShjcm9wU3RhcnQsIGNyb3BFbmQpLFxuXHRcdFx0c3RhcnQ6IGNyb3BTdGFydCxcblx0XHRcdGVuZDogY3JvcEVuZFxuXHRcdH07XG5cdH0sXG5cblxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIGRhdGEgcG9pbnQgYWZ0ZXIgdGhlIGRhdGEgaGFzIGJlZW4gcHJvY2Vzc2VkIGJ5IGNyb3BwaW5nIGF3YXlcblx0ICogdW51c2VkIHBvaW50cyBhbmQgb3B0aW9uYWxseSBncm91cGVkIGluIEhpZ2hjaGFydHMgU3RvY2suXG5cdCAqL1xuXHRnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0ZGF0YU9wdGlvbnMgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEsXG5cdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0XHRwcm9jZXNzZWRZRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRZRGF0YSxcblx0XHRcdHBvaW50Q2xhc3MgPSBzZXJpZXMucG9pbnRDbGFzcyxcblx0XHRcdHByb2Nlc3NlZERhdGFMZW5ndGggPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRjcm9wU3RhcnQgPSBzZXJpZXMuY3JvcFN0YXJ0IHx8IDAsXG5cdFx0XHRjdXJzb3IsXG5cdFx0XHRoYXNHcm91cGVkRGF0YSA9IHNlcmllcy5oYXNHcm91cGVkRGF0YSxcblx0XHRcdHBvaW50LFxuXHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCFkYXRhICYmICFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0YXJyLmxlbmd0aCA9IGRhdGFPcHRpb25zLmxlbmd0aDtcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSA9IGFycjtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvY2Vzc2VkRGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjdXJzb3IgPSBjcm9wU3RhcnQgKyBpO1xuXHRcdFx0aWYgKCFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0XHRpZiAoZGF0YVtjdXJzb3JdKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBkYXRhW2N1cnNvcl07XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YU9wdGlvbnNbY3Vyc29yXSAhPT0gVU5ERUZJTkVEKSB7IC8vICM5NzBcblx0XHRcdFx0XHRkYXRhW2N1cnNvcl0gPSBwb2ludCA9IChuZXcgcG9pbnRDbGFzcygpKS5pbml0KHNlcmllcywgZGF0YU9wdGlvbnNbY3Vyc29yXSwgcHJvY2Vzc2VkWERhdGFbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50c1tpXSA9IHBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc3BsYXQgdGhlIHkgZGF0YSBpbiBjYXNlIG9mIG9obGMgZGF0YSBhcnJheVxuXHRcdFx0XHRwb2ludHNbaV0gPSAobmV3IHBvaW50Q2xhc3MoKSkuaW5pdChzZXJpZXMsIFtwcm9jZXNzZWRYRGF0YVtpXV0uY29uY2F0KHNwbGF0KHByb2Nlc3NlZFlEYXRhW2ldKSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhpZGUgY3JvcHBlZC1hd2F5IHBvaW50cyAtIHRoaXMgb25seSBydW5zIHdoZW4gdGhlIG51bWJlciBvZiBwb2ludHMgaXMgYWJvdmUgY3JvcFRocmVzaG9sZCwgb3Igd2hlblxuXHRcdC8vIHN3aXRoY2hpbmcgdmlldyBmcm9tIG5vbi1ncm91cGVkIGRhdGEgdG8gZ3JvdXBlZCBkYXRhICgjNjM3KVx0XG5cdFx0aWYgKGRhdGEgJiYgKHByb2Nlc3NlZERhdGFMZW5ndGggIT09IChkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgpIHx8IGhhc0dyb3VwZWREYXRhKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaSA9PT0gY3JvcFN0YXJ0ICYmICFoYXNHcm91cGVkRGF0YSkgeyAvLyB3aGVuIGhhcyBncm91cGVkIGRhdGEsIGNsZWFyIGFsbCBwb2ludHNcblx0XHRcdFx0XHRpICs9IHByb2Nlc3NlZERhdGFMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGFbaV0pIHtcblx0XHRcdFx0XHRkYXRhW2ldLmRlc3Ryb3lFbGVtZW50cygpO1xuXHRcdFx0XHRcdGRhdGFbaV0ucGxvdFggPSBVTkRFRklORUQ7IC8vICMxMDAzXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpZXMuZGF0YSA9IGRhdGE7XG5cdFx0c2VyaWVzLnBvaW50cyA9IHBvaW50cztcblx0fSxcblxuXHQvKipcblx0ICogQWRkcyBzZXJpZXMnIHBvaW50cyB2YWx1ZSB0byBjb3JyZXNwb25kaW5nIHN0YWNrXG5cdCAqL1xuXHRzZXRTdGFja2VkUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuc3RhY2tpbmcgfHwgKHRoaXMudmlzaWJsZSAhPT0gdHJ1ZSAmJiB0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzICE9PSBmYWxzZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHhEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFhEYXRhLFxuXHRcdFx0eURhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWURhdGEsXG5cdFx0XHRzdGFja2VkWURhdGEgPSBbXSxcblx0XHRcdHlEYXRhTGVuZ3RoID0geURhdGEubGVuZ3RoLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0dGhyZXNob2xkID0gc2VyaWVzT3B0aW9ucy50aHJlc2hvbGQsXG5cdFx0XHRzdGFja09wdGlvbiA9IHNlcmllc09wdGlvbnMuc3RhY2ssXG5cdFx0XHRzdGFja2luZyA9IHNlcmllc09wdGlvbnMuc3RhY2tpbmcsXG5cdFx0XHRzdGFja0tleSA9IHNlcmllcy5zdGFja0tleSxcblx0XHRcdG5lZ0tleSA9ICctJyArIHN0YWNrS2V5LFxuXHRcdFx0bmVnU3RhY2tzID0gc2VyaWVzLm5lZ1N0YWNrcyxcblx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0c3RhY2tzID0geUF4aXMuc3RhY2tzLFxuXHRcdFx0b2xkU3RhY2tzID0geUF4aXMub2xkU3RhY2tzLFxuXHRcdFx0aXNOZWdhdGl2ZSxcblx0XHRcdHN0YWNrLFxuXHRcdFx0b3RoZXIsXG5cdFx0XHRrZXksXG5cdFx0XHRpLFxuXHRcdFx0eCxcblx0XHRcdHk7XG5cblx0XHQvLyBsb29wIG92ZXIgdGhlIG5vbi1udWxsIHkgdmFsdWVzIGFuZCByZWFkIHRoZW0gaW50byBhIGxvY2FsIGFycmF5XG5cdFx0Zm9yIChpID0gMDsgaSA8IHlEYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdHggPSB4RGF0YVtpXTtcblx0XHRcdHkgPSB5RGF0YVtpXTtcblxuXHRcdFx0Ly8gUmVhZCBzdGFja2VkIHZhbHVlcyBpbnRvIGEgc3RhY2sgYmFzZWQgb24gdGhlIHggdmFsdWUsXG5cdFx0XHQvLyB0aGUgc2lnbiBvZiB5IGFuZCB0aGUgc3RhY2sga2V5LiBTdGFja2luZyBpcyBhbHNvIGhhbmRsZWQgZm9yIG51bGwgdmFsdWVzICgjNzM5KVxuXHRcdFx0aXNOZWdhdGl2ZSA9IG5lZ1N0YWNrcyAmJiB5IDwgdGhyZXNob2xkO1xuXHRcdFx0a2V5ID0gaXNOZWdhdGl2ZSA/IG5lZ0tleSA6IHN0YWNrS2V5O1xuXG5cdFx0XHQvLyBDcmVhdGUgZW1wdHkgb2JqZWN0IGZvciB0aGlzIHN0YWNrIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG5cdFx0XHRpZiAoIXN0YWNrc1trZXldKSB7XG5cdFx0XHRcdHN0YWNrc1trZXldID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgU3RhY2tJdGVtIGZvciB0aGlzIHhcblx0XHRcdGlmICghc3RhY2tzW2tleV1beF0pIHtcblx0XHRcdFx0aWYgKG9sZFN0YWNrc1trZXldICYmIG9sZFN0YWNrc1trZXldW3hdKSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBvbGRTdGFja3Nba2V5XVt4XTtcblx0XHRcdFx0XHRzdGFja3Nba2V5XVt4XS50b3RhbCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBuZXcgU3RhY2tJdGVtKHlBeGlzLCB5QXhpcy5vcHRpb25zLnN0YWNrTGFiZWxzLCBpc05lZ2F0aXZlLCB4LCBzdGFja09wdGlvbiwgc3RhY2tpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBTdGFja0l0ZW0gZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0IGZpcnN0XG5cdFx0XHRzdGFjayA9IHN0YWNrc1trZXldW3hdO1xuXHRcdFx0c3RhY2sucG9pbnRzW3Nlcmllcy5pbmRleF0gPSBbc3RhY2suY3VtIHx8IDBdO1xuXG5cdFx0XHQvLyBBZGQgdmFsdWUgdG8gdGhlIHN0YWNrIHRvdGFsXG5cdFx0XHRpZiAoc3RhY2tpbmcgPT09ICdwZXJjZW50Jykge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gUGVyY2VudCBzdGFja2VkIGNvbHVtbiwgdG90YWxzIGFyZSB0aGUgc2FtZSBmb3IgdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBzdGFja3Ncblx0XHRcdFx0b3RoZXIgPSBpc05lZ2F0aXZlID8gc3RhY2tLZXkgOiBuZWdLZXk7XG5cdFx0XHRcdGlmIChuZWdTdGFja3MgJiYgc3RhY2tzW290aGVyXSAmJiBzdGFja3Nbb3RoZXJdW3hdKSB7XG5cdFx0XHRcdFx0b3RoZXIgPSBzdGFja3Nbb3RoZXJdW3hdO1xuXHRcdFx0XHRcdHN0YWNrLnRvdGFsID0gb3RoZXIudG90YWwgPSBtYXRoTWF4KG90aGVyLnRvdGFsLCBzdGFjay50b3RhbCkgKyBtYXRoQWJzKHkpIHx8IDA7XG5cblx0XHRcdFx0Ly8gUGVyY2VudCBzdGFja2VkIGFyZWFzXHRcdFx0XHRcdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YWNrLnRvdGFsICs9IG1hdGhBYnMoeSkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhY2sudG90YWwgKz0geSB8fCAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5jdW0gPSAoc3RhY2suY3VtIHx8IDApICsgKHkgfHwgMCk7XG5cblx0XHRcdHN0YWNrLnBvaW50c1tzZXJpZXMuaW5kZXhdLnB1c2goc3RhY2suY3VtKTtcblx0XHRcdHN0YWNrZWRZRGF0YVtpXSA9IHN0YWNrLmN1bTtcblxuXHRcdH1cblxuXHRcdGlmIChzdGFja2luZyA9PT0gJ3BlcmNlbnQnKSB7XG5cdFx0XHR5QXhpcy51c2VQZXJjZW50YWdlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YWNrZWRZRGF0YSA9IHN0YWNrZWRZRGF0YTsgLy8gVG8gYmUgdXNlZCBpbiBnZXRFeHRyZW1lc1xuXHRcdFxuXHRcdC8vIFJlc2V0IG9sZCBzdGFja3Ncblx0XHR5QXhpcy5vbGRTdGFja3MgPSB7fTtcblx0fSxcblxuXHQvKipcblx0ICogSXRlcmF0ZSBvdmVyIGFsbCBzdGFja3MgYW5kIGNvbXB1dGUgdGhlIGFic29sdXRlIHZhbHVlcyB0byBwZXJjZW50XG5cdCAqL1xuXHRzZXRQZXJjZW50U3RhY2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRzdGFja0tleSA9IHNlcmllcy5zdGFja0tleSxcblx0XHRcdHN0YWNrcyA9IHNlcmllcy55QXhpcy5zdGFja3M7XG5cdFx0XG5cdFx0ZWFjaChbc3RhY2tLZXksICctJyArIHN0YWNrS2V5XSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIGkgPSBzZXJpZXMueERhdGEubGVuZ3RoLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHRzdGFjayxcblx0XHRcdFx0cG9pbnRFeHRyZW1lcyxcblx0XHRcdFx0dG90YWxGYWN0b3I7XG5cblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0eCA9IHNlcmllcy54RGF0YVtpXTtcblx0XHRcdFx0c3RhY2sgPSBzdGFja3Nba2V5XSAmJiBzdGFja3Nba2V5XVt4XTtcblx0XHRcdFx0cG9pbnRFeHRyZW1lcyA9IHN0YWNrICYmIHN0YWNrLnBvaW50c1tzZXJpZXMuaW5kZXhdO1xuXHRcdFx0XHRpZiAocG9pbnRFeHRyZW1lcykge1xuXHRcdFx0XHRcdHRvdGFsRmFjdG9yID0gc3RhY2sudG90YWwgPyAxMDAgLyBzdGFjay50b3RhbCA6IDA7XG5cdFx0XHRcdFx0cG9pbnRFeHRyZW1lc1swXSA9IGNvcnJlY3RGbG9hdChwb2ludEV4dHJlbWVzWzBdICogdG90YWxGYWN0b3IpOyAvLyBZIGJvdHRvbSB2YWx1ZVxuXHRcdFx0XHRcdHBvaW50RXh0cmVtZXNbMV0gPSBjb3JyZWN0RmxvYXQocG9pbnRFeHRyZW1lc1sxXSAqIHRvdGFsRmFjdG9yKTsgLy8gWSB2YWx1ZVxuXHRcdFx0XHRcdHNlcmllcy5zdGFja2VkWURhdGFbaV0gPSBwb2ludEV4dHJlbWVzWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBZIGV4dHJlbWVzIGZvciB2aXNpYmxlIGRhdGFcblx0ICovXG5cdGdldEV4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHhBeGlzID0gdGhpcy54QXhpcyxcblx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdHhEYXRhID0gdGhpcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdHlEYXRhID0gdGhpcy5zdGFja2VkWURhdGEgfHwgdGhpcy5wcm9jZXNzZWRZRGF0YSxcblx0XHRcdHlEYXRhTGVuZ3RoID0geURhdGEubGVuZ3RoLFxuXHRcdFx0YWN0aXZlWURhdGEgPSBbXSxcblx0XHRcdGFjdGl2ZUNvdW50ZXIgPSAwLFxuXHRcdFx0eEV4dHJlbWVzID0geEF4aXMuZ2V0RXh0cmVtZXMoKSwgLy8gIzIxMTcsIG5lZWQgdG8gY29tcGVuc2F0ZSBmb3IgbG9nIFggYXhpc1xuXHRcdFx0eE1pbiA9IHhFeHRyZW1lcy5taW4sXG5cdFx0XHR4TWF4ID0geEV4dHJlbWVzLm1heCxcblx0XHRcdHZhbGlkVmFsdWUsXG5cdFx0XHR3aXRoaW5SYW5nZSxcblx0XHRcdGRhdGFNaW4sXG5cdFx0XHRkYXRhTWF4LFxuXHRcdFx0eCxcblx0XHRcdHksXG5cdFx0XHRpLFxuXHRcdFx0ajtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB5RGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcblx0XHRcdHggPSB4RGF0YVtpXTtcblx0XHRcdHkgPSB5RGF0YVtpXTtcblxuXHRcdFx0Ly8gRm9yIHBvaW50cyB3aXRoaW4gdGhlIHZpc2libGUgcmFuZ2UsIGluY2x1ZGluZyB0aGUgZmlyc3QgcG9pbnQgb3V0c2lkZSB0aGVcblx0XHRcdC8vIHZpc2libGUgcmFuZ2UsIGNvbnNpZGVyIHkgZXh0cmVtZXNcblx0XHRcdHZhbGlkVmFsdWUgPSB5ICE9PSBudWxsICYmIHkgIT09IFVOREVGSU5FRCAmJiAoIXlBeGlzLmlzTG9nIHx8ICh5Lmxlbmd0aCB8fCB5ID4gMCkpO1xuXHRcdFx0d2l0aGluUmFuZ2UgPSB0aGlzLmdldEV4dHJlbWVzRnJvbUFsbCB8fCB0aGlzLmNyb3BwZWQgfHwgKCh4RGF0YVtpICsgMV0gfHwgeCkgPj0geE1pbiAmJiBcblx0XHRcdFx0KHhEYXRhW2kgLSAxXSB8fCB4KSA8PSB4TWF4KTtcblxuXHRcdFx0aWYgKHZhbGlkVmFsdWUgJiYgd2l0aGluUmFuZ2UpIHtcblxuXHRcdFx0XHRqID0geS5sZW5ndGg7XG5cdFx0XHRcdGlmIChqKSB7IC8vIGFycmF5LCBsaWtlIG9obGMgb3IgcmFuZ2UgZGF0YVxuXHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdGlmICh5W2pdICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGFjdGl2ZVlEYXRhW2FjdGl2ZUNvdW50ZXIrK10gPSB5W2pdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY3RpdmVZRGF0YVthY3RpdmVDb3VudGVyKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmRhdGFNaW4gPSBwaWNrKGRhdGFNaW4sIGFycmF5TWluKGFjdGl2ZVlEYXRhKSk7XG5cdFx0dGhpcy5kYXRhTWF4ID0gcGljayhkYXRhTWF4LCBhcnJheU1heChhY3RpdmVZRGF0YSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGUgZGF0YSBwb2ludHMgZnJvbSByYXcgZGF0YSB2YWx1ZXMgdG8gY2hhcnQgc3BlY2lmaWMgcG9zaXRpb25pbmcgZGF0YVxuXHQgKiBuZWVkZWQgbGF0ZXIgaW4gZHJhd1BvaW50cywgZHJhd0dyYXBoIGFuZCBkcmF3VHJhY2tlci5cblx0ICovXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5wcm9jZXNzZWRYRGF0YSkgeyAvLyBoaWRkZW4gc2VyaWVzXG5cdFx0XHR0aGlzLnByb2Nlc3NEYXRhKCk7XG5cdFx0fVxuXHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHN0YWNraW5nID0gb3B0aW9ucy5zdGFja2luZyxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0Y2F0ZWdvcmllcyA9IHhBeGlzLmNhdGVnb3JpZXMsXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRkYXRhTGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdGhhc01vZGlmeVZhbHVlID0gISFzZXJpZXMubW9kaWZ5VmFsdWUsXG5cdFx0XHRpLFxuXHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBvcHRpb25zLnBvaW50UGxhY2VtZW50LFxuXHRcdFx0ZHluYW1pY2FsbHlQbGFjZWQgPSBwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nIHx8IGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSxcblx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkO1xuXG5cdFx0XG5cdFx0Ly8gVHJhbnNsYXRlIGVhY2ggcG9pbnRcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbaV0sXG5cdFx0XHRcdHhWYWx1ZSA9IHBvaW50LngsXG5cdFx0XHRcdHlWYWx1ZSA9IHBvaW50LnksXG5cdFx0XHRcdHlCb3R0b20gPSBwb2ludC5sb3csXG5cdFx0XHRcdHN0YWNrID0geUF4aXMuc3RhY2tzWyhzZXJpZXMubmVnU3RhY2tzICYmIHlWYWx1ZSA8IHRocmVzaG9sZCA/ICctJyA6ICcnKSArIHNlcmllcy5zdGFja0tleV0sXG5cdFx0XHRcdHBvaW50U3RhY2ssXG5cdFx0XHRcdHN0YWNrVmFsdWVzO1xuXG5cdFx0XHQvLyBEaXNjYXJkIGRpc2FsbG93ZWQgeSB2YWx1ZXMgZm9yIGxvZyBheGVzXG5cdFx0XHRpZiAoeUF4aXMuaXNMb2cgJiYgeVZhbHVlIDw9IDApIHtcblx0XHRcdFx0cG9pbnQueSA9IHlWYWx1ZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEdldCB0aGUgcGxvdFggdHJhbnNsYXRpb25cblx0XHRcdHBvaW50LnBsb3RYID0geEF4aXMudHJhbnNsYXRlKHhWYWx1ZSwgMCwgMCwgMCwgMSwgcG9pbnRQbGFjZW1lbnQsIHRoaXMudHlwZSA9PT0gJ2ZsYWdzJyk7IC8vIE1hdGgucm91bmQgZml4ZXMgIzU5MVxuXHRcdFx0XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYm90dG9tIHkgdmFsdWUgZm9yIHN0YWNrZWQgc2VyaWVzXG5cdFx0XHRpZiAoc3RhY2tpbmcgJiYgc2VyaWVzLnZpc2libGUgJiYgc3RhY2sgJiYgc3RhY2tbeFZhbHVlXSkge1xuXG5cdFx0XHRcdHBvaW50U3RhY2sgPSBzdGFja1t4VmFsdWVdO1xuXHRcdFx0XHRzdGFja1ZhbHVlcyA9IHBvaW50U3RhY2sucG9pbnRzW3Nlcmllcy5pbmRleF07XG5cdFx0XHRcdHlCb3R0b20gPSBzdGFja1ZhbHVlc1swXTtcblx0XHRcdFx0eVZhbHVlID0gc3RhY2tWYWx1ZXNbMV07XG5cblx0XHRcdFx0aWYgKHlCb3R0b20gPT09IDApIHtcblx0XHRcdFx0XHR5Qm90dG9tID0gcGljayh0aHJlc2hvbGQsIHlBeGlzLm1pbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHlBeGlzLmlzTG9nICYmIHlCb3R0b20gPD0gMCkgeyAvLyAjMTIwMCwgIzEyMzJcblx0XHRcdFx0XHR5Qm90dG9tID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvaW50LnBlcmNlbnRhZ2UgPSBzdGFja2luZyA9PT0gJ3BlcmNlbnQnICYmIHlWYWx1ZTtcblx0XHRcdFx0cG9pbnQudG90YWwgPSBwb2ludC5zdGFja1RvdGFsID0gcG9pbnRTdGFjay50b3RhbDtcblx0XHRcdFx0cG9pbnQuc3RhY2tZID0geVZhbHVlO1xuXG5cdFx0XHRcdC8vIFBsYWNlIHRoZSBzdGFjayBsYWJlbFxuXHRcdFx0XHRwb2ludFN0YWNrLnNldE9mZnNldChzZXJpZXMucG9pbnRYT2Zmc2V0IHx8IDAsIHNlcmllcy5iYXJXIHx8IDApO1xuXHRcdFx0XHRcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRyYW5zbGF0ZWQgeUJvdHRvbSBvciByZW1vdmUgaXRcblx0XHRcdHBvaW50LnlCb3R0b20gPSBkZWZpbmVkKHlCb3R0b20pID8gXG5cdFx0XHRcdHlBeGlzLnRyYW5zbGF0ZSh5Qm90dG9tLCAwLCAxLCAwLCAxKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gZ2VuZXJhbCBob29rLCB1c2VkIGZvciBIaWdoc3RvY2sgY29tcGFyZSBtb2RlXG5cdFx0XHRpZiAoaGFzTW9kaWZ5VmFsdWUpIHtcblx0XHRcdFx0eVZhbHVlID0gc2VyaWVzLm1vZGlmeVZhbHVlKHlWYWx1ZSwgcG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIHRoZSBwbG90WSB2YWx1ZSwgcmVzZXQgaXQgZm9yIHJlZHJhd3Ncblx0XHRcdHBvaW50LnBsb3RZID0gKHR5cGVvZiB5VmFsdWUgPT09ICdudW1iZXInICYmIHlWYWx1ZSAhPT0gSW5maW5pdHkpID8gXG5cdFx0XHRcdC8vbWF0aFJvdW5kKHlBeGlzLnRyYW5zbGF0ZSh5VmFsdWUsIDAsIDEsIDAsIDEpICogMTApIC8gMTAgOiAvLyBNYXRoLnJvdW5kIGZpeGVzICM1OTFcblx0XHRcdFx0eUF4aXMudHJhbnNsYXRlKHlWYWx1ZSwgMCwgMSwgMCwgMSkgOiBcblx0XHRcdFx0VU5ERUZJTkVEO1xuXHRcdFx0XG5cdFx0XHQvLyBTZXQgY2xpZW50IHJlbGF0ZWQgcG9zaXRpb25zIGZvciBtb3VzZSB0cmFja2luZ1xuXHRcdFx0cG9pbnQuY2xpZW50WCA9IGR5bmFtaWNhbGx5UGxhY2VkID8geEF4aXMudHJhbnNsYXRlKHhWYWx1ZSwgMCwgMCwgMCwgMSkgOiBwb2ludC5wbG90WDsgLy8gIzE1MTRcblx0XHRcdFx0XG5cdFx0XHRwb2ludC5uZWdhdGl2ZSA9IHBvaW50LnkgPCAodGhyZXNob2xkIHx8IDApO1xuXG5cdFx0XHQvLyBzb21lIEFQSSBkYXRhXG5cdFx0XHRwb2ludC5jYXRlZ29yeSA9IGNhdGVnb3JpZXMgJiYgY2F0ZWdvcmllc1twb2ludC54XSAhPT0gVU5ERUZJTkVEID9cblx0XHRcdFx0Y2F0ZWdvcmllc1twb2ludC54XSA6IHBvaW50Lng7XG5cblxuXHRcdH1cblxuXHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIGNyb3BwZWQgZGF0YSwgYnVpbGQgdGhlIHNlZ21lbnRzXG5cdFx0c2VyaWVzLmdldFNlZ21lbnRzKCk7XG5cdH0sXG5cdC8qKlxuXHQgKiBNZW1vaXplIHRvb2x0aXAgdGV4dHMgYW5kIHBvc2l0aW9uc1xuXHQgKi9cblx0c2V0VG9vbHRpcFBvaW50czogZnVuY3Rpb24gKHJlbmV3KSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRwb2ludHMgPSBbXSxcblx0XHRcdHBvaW50c0xlbmd0aCxcblx0XHRcdGxvdyxcblx0XHRcdGhpZ2gsXG5cdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdHhFeHRyZW1lcyA9IHhBeGlzICYmIHhBeGlzLmdldEV4dHJlbWVzKCksXG5cdFx0XHRheGlzTGVuZ3RoID0geEF4aXMgPyAoeEF4aXMudG9vbHRpcExlbiB8fCB4QXhpcy5sZW4pIDogc2VyaWVzLmNoYXJ0LnBsb3RTaXplWCwgLy8gdG9vbHRpcExlbiBhbmQgdG9vbHRpcFBvc05hbWUgdXNlZCBpbiBwb2xhclxuXHRcdFx0cG9pbnQsXG5cdFx0XHRwb2ludFgsXG5cdFx0XHRuZXh0UG9pbnQsXG5cdFx0XHRpLFxuXHRcdFx0dG9vbHRpcFBvaW50cyA9IFtdOyAvLyBhIGxvb2t1cCBhcnJheSBmb3IgZWFjaCBwaXhlbCBpbiB0aGUgeCBkaW1lbnNpb25cblxuXHRcdC8vIGRvbid0IHdhc3RlIHJlc291cmNlcyBpZiB0cmFja2VyIGlzIGRpc2FibGVkXG5cdFx0aWYgKHNlcmllcy5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZXdcblx0XHRpZiAocmVuZXcpIHtcblx0XHRcdHNlcmllcy50b29sdGlwUG9pbnRzID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBjb25jYXQgc2VnbWVudHMgdG8gb3ZlcmNvbWUgbnVsbCB2YWx1ZXNcblx0XHRlYWNoKHNlcmllcy5zZWdtZW50cyB8fCBzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmNvbmNhdChzZWdtZW50KTtcblx0XHR9KTtcblxuXHRcdC8vIFJldmVyc2UgdGhlIHBvaW50cyBpbiBjYXNlIHRoZSBYIGF4aXMgaXMgcmV2ZXJzZWRcblx0XHRpZiAoeEF4aXMgJiYgeEF4aXMucmV2ZXJzZWQpIHtcblx0XHRcdHBvaW50cyA9IHBvaW50cy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gUG9sYXIgbmVlZHMgYWRkaXRpb25hbCBzaGFwaW5nXG5cdFx0aWYgKHNlcmllcy5vcmRlclRvb2x0aXBQb2ludHMpIHtcblx0XHRcdHNlcmllcy5vcmRlclRvb2x0aXBQb2ludHMocG9pbnRzKTtcblx0XHR9XG5cblx0XHQvLyBBc3NpZ24gZWFjaCBwaXhlbCBwb3NpdGlvbiB0byB0aGUgbmVhcmVzdCBwb2ludFxuXHRcdHBvaW50c0xlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbmd0aDsgaSsrKSB7XG5cdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdHBvaW50WCA9IHBvaW50Lng7XG5cdFx0XHRpZiAocG9pbnRYID49IHhFeHRyZW1lcy5taW4gJiYgcG9pbnRYIDw9IHhFeHRyZW1lcy5tYXgpIHsgLy8gIzExNDlcblx0XHRcdFx0bmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFNldCB0aGlzIHJhbmdlJ3MgbG93IHRvIHRoZSBsYXN0IHJhbmdlJ3MgaGlnaCBwbHVzIG9uZVxuXHRcdFx0XHRsb3cgPSBoaWdoID09PSBVTkRFRklORUQgPyAwIDogaGlnaCArIDE7XG5cdFx0XHRcdC8vIE5vdyBmaW5kIHRoZSBuZXcgaGlnaFxuXHRcdFx0XHRoaWdoID0gcG9pbnRzW2kgKyAxXSA/XG5cdFx0XHRcdFx0bWF0aE1pbihtYXRoTWF4KDAsIG1hdGhGbG9vciggLy8gIzIwNzBcblx0XHRcdFx0XHRcdChwb2ludC5jbGllbnRYICsgKG5leHRQb2ludCA/IChuZXh0UG9pbnQud3JhcHBlZENsaWVudFggfHwgbmV4dFBvaW50LmNsaWVudFgpIDogYXhpc0xlbmd0aCkpIC8gMlxuXHRcdFx0XHRcdCkpLCBheGlzTGVuZ3RoKSA6XG5cdFx0XHRcdFx0YXhpc0xlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAobG93ID49IDAgJiYgbG93IDw9IGhpZ2gpIHtcblx0XHRcdFx0XHR0b29sdGlwUG9pbnRzW2xvdysrXSA9IHBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNlcmllcy50b29sdGlwUG9pbnRzID0gdG9vbHRpcFBvaW50cztcblx0fSxcblxuXHQvKipcblx0ICogRm9ybWF0IHRoZSBoZWFkZXIgb2YgdGhlIHRvb2x0aXBcblx0ICovXG5cdHRvb2x0aXBIZWFkZXJGb3JtYXR0ZXI6IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0dG9vbHRpcE9wdGlvbnMgPSBzZXJpZXMudG9vbHRpcE9wdGlvbnMsXG5cdFx0XHR4RGF0ZUZvcm1hdCA9IHRvb2x0aXBPcHRpb25zLnhEYXRlRm9ybWF0LFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHMgPSB0b29sdGlwT3B0aW9ucy5kYXRlVGltZUxhYmVsRm9ybWF0cyxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0aXNEYXRlVGltZSA9IHhBeGlzICYmIHhBeGlzLm9wdGlvbnMudHlwZSA9PT0gJ2RhdGV0aW1lJyxcblx0XHRcdGhlYWRlckZvcm1hdCA9IHRvb2x0aXBPcHRpb25zLmhlYWRlckZvcm1hdCxcblx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlID0geEF4aXMgJiYgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRuO1xuXHRcdFx0XG5cdFx0Ly8gR3Vlc3MgdGhlIGJlc3QgZGF0ZSBmb3JtYXQgYmFzZWQgb24gdGhlIGNsb3Nlc3QgcG9pbnQgZGlzdGFuY2UgKCM1NjgpXG5cdFx0aWYgKGlzRGF0ZVRpbWUgJiYgIXhEYXRlRm9ybWF0KSB7XG5cdFx0XHRpZiAoY2xvc2VzdFBvaW50UmFuZ2UpIHtcblx0XHRcdFx0Zm9yIChuIGluIHRpbWVVbml0cykge1xuXHRcdFx0XHRcdGlmICh0aW1lVW5pdHNbbl0gPj0gY2xvc2VzdFBvaW50UmFuZ2UpIHtcblx0XHRcdFx0XHRcdHhEYXRlRm9ybWF0ID0gZGF0ZVRpbWVMYWJlbEZvcm1hdHNbbl07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHhEYXRlRm9ybWF0ID0gZGF0ZVRpbWVMYWJlbEZvcm1hdHMuZGF5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBJbnNlcnQgdGhlIGhlYWRlciBkYXRlIGZvcm1hdCBpZiBhbnlcblx0XHRpZiAoaXNEYXRlVGltZSAmJiB4RGF0ZUZvcm1hdCAmJiBpc051bWJlcihwb2ludC5rZXkpKSB7XG5cdFx0XHRoZWFkZXJGb3JtYXQgPSBoZWFkZXJGb3JtYXQucmVwbGFjZSgne3BvaW50LmtleX0nLCAne3BvaW50LmtleTonICsgeERhdGVGb3JtYXQgKyAnfScpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZm9ybWF0KGhlYWRlckZvcm1hdCwge1xuXHRcdFx0cG9pbnQ6IHBvaW50LFxuXHRcdFx0c2VyaWVzOiBzZXJpZXNcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2VyaWVzIG1vdXNlIG92ZXIgaGFuZGxlclxuXHQgKi9cblx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aG92ZXJTZXJpZXMgPSBjaGFydC5ob3ZlclNlcmllcztcblxuXHRcdC8vIHNldCBub3JtYWwgc3RhdGUgdG8gcHJldmlvdXMgc2VyaWVzXG5cdFx0aWYgKGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdGhvdmVyU2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHR9XG5cblx0XHQvLyB0cmlnZ2VyIHRoZSBldmVudCwgYnV0IHRvIHNhdmUgcHJvY2Vzc2luZyB0aW1lLFxuXHRcdC8vIG9ubHkgaWYgZGVmaW5lZFxuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyKSB7XG5cdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAnbW91c2VPdmVyJyk7XG5cdFx0fVxuXG5cdFx0Ly8gaG92ZXIgdGhpc1xuXHRcdHNlcmllcy5zZXRTdGF0ZShIT1ZFUl9TVEFURSk7XG5cdFx0Y2hhcnQuaG92ZXJTZXJpZXMgPSBzZXJpZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNlcmllcyBtb3VzZSBvdXQgaGFuZGxlclxuXHQgKi9cblx0b25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50IG9ubHkgaWYgbGlzdGVuZXJzIGV4aXN0XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQ7XG5cblx0XHQvLyB0cmlnZ2VyIG1vdXNlIG91dCBvbiB0aGUgcG9pbnQsIHdoaWNoIG11c3QgYmUgaW4gdGhpcyBzZXJpZXNcblx0XHRpZiAoaG92ZXJQb2ludCkge1xuXHRcdFx0aG92ZXJQb2ludC5vbk1vdXNlT3V0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gZmlyZSB0aGUgbW91c2Ugb3V0IGV2ZW50XG5cdFx0aWYgKHNlcmllcyAmJiBvcHRpb25zLmV2ZW50cy5tb3VzZU91dCkge1xuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ21vdXNlT3V0Jyk7XG5cdFx0fVxuXG5cblx0XHQvLyBoaWRlIHRoZSB0b29sdGlwXG5cdFx0aWYgKHRvb2x0aXAgJiYgIW9wdGlvbnMuc3RpY2t5VHJhY2tpbmcgJiYgKCF0b29sdGlwLnNoYXJlZCB8fCBzZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcC5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IG5vcm1hbCBzdGF0ZVxuXHRcdHNlcmllcy5zZXRTdGF0ZSgpO1xuXHRcdGNoYXJ0LmhvdmVyU2VyaWVzID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogQW5pbWF0ZSBpbiB0aGUgc2VyaWVzXG5cdCAqL1xuXHRhbmltYXRlOiBmdW5jdGlvbiAoaW5pdCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0Y2xpcFJlY3QsXG5cdFx0XHRtYXJrZXJDbGlwUmVjdCxcblx0XHRcdGFuaW1hdGlvbiA9IHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbixcblx0XHRcdGNsaXBCb3ggPSBjaGFydC5jbGlwQm94LFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdHNoYXJlZENsaXBLZXk7XG5cblx0XHQvLyBBbmltYXRpb24gb3B0aW9uIGlzIHNldCB0byB0cnVlXG5cdFx0aWYgKGFuaW1hdGlvbiAmJiAhaXNPYmplY3QoYW5pbWF0aW9uKSkge1xuXHRcdFx0YW5pbWF0aW9uID0gZGVmYXVsdFBsb3RPcHRpb25zW3Nlcmllcy50eXBlXS5hbmltYXRpb247XG5cdFx0fVxuXHRcdHNoYXJlZENsaXBLZXkgPSAnX3NoYXJlZENsaXAnICsgYW5pbWF0aW9uLmR1cmF0aW9uICsgYW5pbWF0aW9uLmVhc2luZztcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdGlvbi4gU2V0IHVwIHRoZSBjbGlwcGluZyByZWN0YW5nbGUuXG5cdFx0aWYgKGluaXQpIHsgXG5cdFx0XHRcblx0XHRcdC8vIElmIGEgY2xpcHBpbmcgcmVjdGFuZ2xlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBpcyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgY2hhcnQsIHVzZSB0aGF0LiBcblx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV07XG5cdFx0XHRtYXJrZXJDbGlwUmVjdCA9IGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddO1xuXHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5XSA9IGNsaXBSZWN0ID0gcmVuZGVyZXIuY2xpcFJlY3QoXG5cdFx0XHRcdFx0ZXh0ZW5kKGNsaXBCb3gsIHsgd2lkdGg6IDAgfSlcblx0XHRcdFx0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddID0gbWFya2VyQ2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChcblx0XHRcdFx0XHQtOTksIC8vIGluY2x1ZGUgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBtYXJrZXJcblx0XHRcdFx0XHRpbnZlcnRlZCA/IC1jaGFydC5wbG90TGVmdCA6IC1jaGFydC5wbG90VG9wLCBcblx0XHRcdFx0XHQ5OSxcblx0XHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LmNoYXJ0V2lkdGggOiBjaGFydC5jaGFydEhlaWdodFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0c2VyaWVzLmdyb3VwLmNsaXAoY2xpcFJlY3QpO1xuXHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwLmNsaXAobWFya2VyQ2xpcFJlY3QpO1xuXHRcdFx0c2VyaWVzLnNoYXJlZENsaXBLZXkgPSBzaGFyZWRDbGlwS2V5O1xuXG5cdFx0Ly8gUnVuIHRoZSBhbmltYXRpb25cblx0XHR9IGVsc2UgeyBcblx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV07XG5cdFx0XHRpZiAoY2xpcFJlY3QpIHtcblx0XHRcdFx0Y2xpcFJlY3QuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RTaXplWFxuXHRcdFx0XHR9LCBhbmltYXRpb24pO1xuXHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXS5hbmltYXRlKHtcblx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFNpemVYICsgOTlcblx0XHRcdFx0fSwgYW5pbWF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgaXQgb25seSBvbmNlXG5cdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIENhbGwgdGhlIGFmdGVyQW5pbWF0ZSBmdW5jdGlvbiBvbiBhbmltYXRpb24gY29tcGxldGUgKGJ1dCBkb24ndCBvdmVyd3JpdGUgdGhlIGFuaW1hdGlvbi5jb21wbGV0ZSBvcHRpb25cblx0XHRcdC8vIHdoaWNoIHNob3VsZCBiZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIpLlxuXHRcdFx0c2VyaWVzLmFuaW1hdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdFx0fSwgYW5pbWF0aW9uLmR1cmF0aW9uKTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0ICogVGhpcyBydW5zIGFmdGVyIGFuaW1hdGlvbiB0byBsYW5kIG9uIHRoZSBmaW5hbCBwbG90IGNsaXBwaW5nXG5cdCAqL1xuXHRhZnRlckFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0c2hhcmVkQ2xpcEtleSA9IHRoaXMuc2hhcmVkQ2xpcEtleSxcblx0XHRcdGdyb3VwID0gdGhpcy5ncm91cDtcblx0XHRcdFxuXHRcdGlmIChncm91cCAmJiB0aGlzLm9wdGlvbnMuY2xpcCAhPT0gZmFsc2UpIHtcblx0XHRcdGdyb3VwLmNsaXAoY2hhcnQuY2xpcFJlY3QpO1xuXHRcdFx0dGhpcy5tYXJrZXJHcm91cC5jbGlwKCk7IC8vIG5vIGNsaXBcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUmVtb3ZlIHRoZSBzaGFyZWQgY2xpcHBpbmcgcmVjdGFuY2dsZSB3aGVuIGFsbCBzZXJpZXMgYXJlIHNob3duXHRcdFxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNoYXJlZENsaXBLZXkgJiYgY2hhcnRbc2hhcmVkQ2xpcEtleV0pIHtcblx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleV0gPSBjaGFydFtzaGFyZWRDbGlwS2V5XS5kZXN0cm95KCk7XG5cdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddID0gY2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0sIDEwMCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIG1hcmtlcnNcblx0ICovXG5cdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHBvaW50QXR0cixcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHBsb3RYLFxuXHRcdFx0cGxvdFksXG5cdFx0XHRpLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHRzeW1ib2wsXG5cdFx0XHRpc0ltYWdlLFxuXHRcdFx0Z3JhcGhpYyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHNlcmllc01hcmtlck9wdGlvbnMgPSBvcHRpb25zLm1hcmtlcixcblx0XHRcdHBvaW50TWFya2VyT3B0aW9ucyxcblx0XHRcdGVuYWJsZWQsXG5cdFx0XHRpc0luc2lkZSxcblx0XHRcdG1hcmtlckdyb3VwID0gc2VyaWVzLm1hcmtlckdyb3VwO1xuXG5cdFx0aWYgKHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCB8fCBzZXJpZXMuX2hhc1BvaW50TWFya2Vycykge1xuXHRcdFx0XG5cdFx0XHRpID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdHBsb3RYID0gbWF0aEZsb29yKHBvaW50LnBsb3RYKTsgLy8gIzE4NDNcblx0XHRcdFx0cGxvdFkgPSBwb2ludC5wbG90WTtcblx0XHRcdFx0Z3JhcGhpYyA9IHBvaW50LmdyYXBoaWM7XG5cdFx0XHRcdHBvaW50TWFya2VyT3B0aW9ucyA9IHBvaW50Lm1hcmtlciB8fCB7fTtcblx0XHRcdFx0ZW5hYmxlZCA9IChzZXJpZXNNYXJrZXJPcHRpb25zLmVuYWJsZWQgJiYgcG9pbnRNYXJrZXJPcHRpb25zLmVuYWJsZWQgPT09IFVOREVGSU5FRCkgfHwgcG9pbnRNYXJrZXJPcHRpb25zLmVuYWJsZWQ7XG5cdFx0XHRcdGlzSW5zaWRlID0gY2hhcnQuaXNJbnNpZGVQbG90KG1hdGhSb3VuZChwbG90WCksIHBsb3RZLCBjaGFydC5pbnZlcnRlZCk7IC8vICMxODU4XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBvbmx5IGRyYXcgdGhlIHBvaW50IGlmIHkgaXMgZGVmaW5lZFxuXHRcdFx0XHRpZiAoZW5hYmxlZCAmJiBwbG90WSAhPT0gVU5ERUZJTkVEICYmICFpc05hTihwbG90WSkgJiYgcG9pbnQueSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdFx0Ly8gc2hvcnRjdXRzXG5cdFx0XHRcdFx0cG9pbnRBdHRyID0gcG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXTtcblx0XHRcdFx0XHRyYWRpdXMgPSBwb2ludEF0dHIucjtcblx0XHRcdFx0XHRzeW1ib2wgPSBwaWNrKHBvaW50TWFya2VyT3B0aW9ucy5zeW1ib2wsIHNlcmllcy5zeW1ib2wpO1xuXHRcdFx0XHRcdGlzSW1hZ2UgPSBzeW1ib2wuaW5kZXhPZigndXJsJykgPT09IDA7XG5cblx0XHRcdFx0XHRpZiAoZ3JhcGhpYykgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRcdGdyYXBoaWNcblx0XHRcdFx0XHRcdFx0LmF0dHIoeyAvLyBTaW5jZSB0aGUgbWFya2VyIGdyb3VwIGlzbid0IGNsaXBwZWQsIGVhY2ggaW5kaXZpZHVhbCBtYXJrZXIgbXVzdCBiZSB0b2dnbGVkXG5cdFx0XHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogaXNJbnNpZGUgPyAoaGFzU1ZHID8gJ2luaGVyaXQnIDogVklTSUJMRSkgOiBISURERU5cblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0LmFuaW1hdGUoZXh0ZW5kKHtcblx0XHRcdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHR5OiBwbG90WSAtIHJhZGl1c1xuXHRcdFx0XHRcdFx0XHR9LCBncmFwaGljLnN5bWJvbE5hbWUgPyB7IC8vIGRvbid0IGFwcGx5IHRvIGltYWdlIHN5bWJvbHMgIzUwN1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDogMiAqIHJhZGl1c1xuXHRcdFx0XHRcdFx0XHR9IDoge30pKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzSW5zaWRlICYmIChyYWRpdXMgPiAwIHx8IGlzSW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IGNoYXJ0LnJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHRcdFx0c3ltYm9sLFxuXHRcdFx0XHRcdFx0XHRwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0cGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdDIgKiByYWRpdXNcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKHBvaW50QXR0cilcblx0XHRcdFx0XHRcdC5hZGQobWFya2VyR3JvdXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0fSBlbHNlIGlmIChncmFwaGljKSB7XG5cdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMuZGVzdHJveSgpOyAvLyAjMTI2OVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0sXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgc3RhdGUgcHJvcGVydGllcyBmcm9tIEFQSSBuYW1pbmcgY29udmVudGlvbnMgdG8gU1ZHIGF0dHJpYnV0ZXNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQVBJIG9wdGlvbnMgb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiYXNlMSBTVkcgYXR0cmlidXRlIG9iamVjdCB0byBpbmhlcml0IGZyb21cblx0ICogQHBhcmFtIHtPYmplY3R9IGJhc2UyIFNlY29uZCBsZXZlbCBTVkcgYXR0cmlidXRlIG9iamVjdCB0byBpbmhlcml0IGZyb21cblx0ICovXG5cdGNvbnZlcnRBdHRyaWJzOiBmdW5jdGlvbiAob3B0aW9ucywgYmFzZTEsIGJhc2UyLCBiYXNlMykge1xuXHRcdHZhciBjb252ZXJzaW9uID0gdGhpcy5wb2ludEF0dHJUb09wdGlvbnMsXG5cdFx0XHRhdHRyLFxuXHRcdFx0b3B0aW9uLFxuXHRcdFx0b2JqID0ge307XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRiYXNlMSA9IGJhc2UxIHx8IHt9O1xuXHRcdGJhc2UyID0gYmFzZTIgfHwge307XG5cdFx0YmFzZTMgPSBiYXNlMyB8fCB7fTtcblxuXHRcdGZvciAoYXR0ciBpbiBjb252ZXJzaW9uKSB7XG5cdFx0XHRvcHRpb24gPSBjb252ZXJzaW9uW2F0dHJdO1xuXHRcdFx0b2JqW2F0dHJdID0gcGljayhvcHRpb25zW29wdGlvbl0sIGJhc2UxW2F0dHJdLCBiYXNlMlthdHRyXSwgYmFzZTNbYXR0cl0pO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHN0YXRlIGF0dHJpYnV0ZXMuIEVhY2ggc2VyaWVzIHR5cGUgaGFzIGl0cyBvd24gc2V0IG9mIGF0dHJpYnV0ZXNcblx0ICogdGhhdCBhcmUgYWxsb3dlZCB0byBjaGFuZ2Ugb24gYSBwb2ludCdzIHN0YXRlIGNoYW5nZS4gU2VyaWVzIHdpZGUgYXR0cmlidXRlcyBhcmUgc3RvcmVkIGZvclxuXHQgKiBhbGwgc2VyaWVzLCBhbmQgYWRkaXRpb25hbGx5IHBvaW50IHNwZWNpZmljIGF0dHJpYnV0ZXMgYXJlIHN0b3JlZCBmb3IgYWxsXG5cdCAqIHBvaW50cyB3aXRoIGluZGl2aWR1YWwgbWFya2VyIG9wdGlvbnMuIElmIHN1Y2ggb3B0aW9ucyBhcmUgbm90IGRlZmluZWQgZm9yIHRoZSBwb2ludCxcblx0ICogYSByZWZlcmVuY2UgdG8gdGhlIHNlcmllcyB3aWRlIGF0dHJpYnV0ZXMgaXMgc3RvcmVkIGluIHBvaW50LnBvaW50QXR0ci5cblx0ICovXG5cdGdldEF0dHJpYnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdG5vcm1hbE9wdGlvbnMgPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLm1hcmtlciA/IHNlcmllc09wdGlvbnMubWFya2VyIDogc2VyaWVzT3B0aW9ucyxcblx0XHRcdHN0YXRlT3B0aW9ucyA9IG5vcm1hbE9wdGlvbnMuc3RhdGVzLFxuXHRcdFx0c3RhdGVPcHRpb25zSG92ZXIgPSBzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdLFxuXHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3Zlcixcblx0XHRcdHNlcmllc0NvbG9yID0gc2VyaWVzLmNvbG9yLFxuXHRcdFx0bm9ybWFsRGVmYXVsdHMgPSB7XG5cdFx0XHRcdHN0cm9rZTogc2VyaWVzQ29sb3IsXG5cdFx0XHRcdGZpbGw6IHNlcmllc0NvbG9yXG5cdFx0XHR9LFxuXHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyB8fCBbXSwgLy8gIzkyN1xuXHRcdFx0aSxcblx0XHRcdHBvaW50LFxuXHRcdFx0c2VyaWVzUG9pbnRBdHRyID0gW10sXG5cdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRwb2ludEF0dHJUb09wdGlvbnMgPSBzZXJpZXMucG9pbnRBdHRyVG9PcHRpb25zLFxuXHRcdFx0aGFzUG9pbnRTcGVjaWZpY09wdGlvbnMsXG5cdFx0XHRuZWdhdGl2ZUNvbG9yID0gc2VyaWVzT3B0aW9ucy5uZWdhdGl2ZUNvbG9yLFxuXHRcdFx0ZGVmYXVsdExpbmVDb2xvciA9IG5vcm1hbE9wdGlvbnMubGluZUNvbG9yLFxuXHRcdFx0a2V5O1xuXG5cdFx0Ly8gc2VyaWVzIHR5cGUgc3BlY2lmaWMgbW9kaWZpY2F0aW9uc1xuXHRcdGlmIChzZXJpZXNPcHRpb25zLm1hcmtlcikgeyAvLyBsaW5lLCBzcGxpbmUsIGFyZWEsIGFyZWFzcGxpbmUsIHNjYXR0ZXJcblxuXHRcdFx0Ly8gaWYgbm8gaG92ZXIgcmFkaXVzIGlzIGdpdmVuLCBkZWZhdWx0IHRvIG5vcm1hbCByYWRpdXMgKyAyXG5cdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgPSBzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgfHwgbm9ybWFsT3B0aW9ucy5yYWRpdXMgKyAyO1xuXHRcdFx0c3RhdGVPcHRpb25zSG92ZXIubGluZVdpZHRoID0gc3RhdGVPcHRpb25zSG92ZXIubGluZVdpZHRoIHx8IG5vcm1hbE9wdGlvbnMubGluZVdpZHRoICsgMTtcblx0XHRcdFxuXHRcdH0gZWxzZSB7IC8vIGNvbHVtbiwgYmFyLCBwaWVcblxuXHRcdFx0Ly8gaWYgbm8gaG92ZXIgY29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgY29sb3Jcblx0XHRcdHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yID0gc3RhdGVPcHRpb25zSG92ZXIuY29sb3IgfHxcblx0XHRcdFx0Q29sb3Ioc3RhdGVPcHRpb25zSG92ZXIuY29sb3IgfHwgc2VyaWVzQ29sb3IpXG5cdFx0XHRcdFx0LmJyaWdodGVuKHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpLmdldCgpO1xuXHRcdH1cblxuXHRcdC8vIGdlbmVyYWwgcG9pbnQgYXR0cmlidXRlcyBmb3IgdGhlIHNlcmllcyBub3JtYWwgc3RhdGVcblx0XHRzZXJpZXNQb2ludEF0dHJbTk9STUFMX1NUQVRFXSA9IHNlcmllcy5jb252ZXJ0QXR0cmlicyhub3JtYWxPcHRpb25zLCBub3JtYWxEZWZhdWx0cyk7XG5cblx0XHQvLyBIT1ZFUl9TVEFURSBhbmQgU0VMRUNUX1NUQVRFIHN0YXRlcyBpbmhlcml0IGZyb20gbm9ybWFsIHN0YXRlIGV4Y2VwdCB0aGUgZGVmYXVsdCByYWRpdXNcblx0XHRlYWNoKFtIT1ZFUl9TVEFURSwgU0VMRUNUX1NUQVRFXSwgZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHRzZXJpZXNQb2ludEF0dHJbc3RhdGVdID1cblx0XHRcdFx0XHRzZXJpZXMuY29udmVydEF0dHJpYnMoc3RhdGVPcHRpb25zW3N0YXRlXSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gc2V0IGl0XG5cdFx0c2VyaWVzLnBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblxuXG5cdFx0Ly8gR2VuZXJhdGUgdGhlIHBvaW50LXNwZWNpZmljIGF0dHJpYnV0ZSBjb2xsZWN0aW9ucyBpZiBzcGVjaWZpYyBwb2ludFxuXHRcdC8vIG9wdGlvbnMgYXJlIGdpdmVuLiBJZiBub3QsIGNyZWF0ZSBhIHJlZmVyYW5jZSB0byB0aGUgc2VyaWVzIHdpZGUgcG9pbnRcblx0XHQvLyBhdHRyaWJ1dGVzXG5cdFx0aSA9IHBvaW50cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRub3JtYWxPcHRpb25zID0gKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5tYXJrZXIpIHx8IHBvaW50Lm9wdGlvbnM7XG5cdFx0XHRpZiAobm9ybWFsT3B0aW9ucyAmJiBub3JtYWxPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdG5vcm1hbE9wdGlvbnMucmFkaXVzID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHBvaW50Lm5lZ2F0aXZlICYmIG5lZ2F0aXZlQ29sb3IpIHtcblx0XHRcdFx0cG9pbnQuY29sb3IgPSBwb2ludC5maWxsQ29sb3IgPSBuZWdhdGl2ZUNvbG9yO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRoYXNQb2ludFNwZWNpZmljT3B0aW9ucyA9IHNlcmllc09wdGlvbnMuY29sb3JCeVBvaW50IHx8IHBvaW50LmNvbG9yOyAvLyAjODY4XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSBwb2ludCBoYXMgc3BlY2lmaWMgdmlzdWFsIG9wdGlvbnNcblx0XHRcdGlmIChwb2ludC5vcHRpb25zKSB7XG5cdFx0XHRcdGZvciAoa2V5IGluIHBvaW50QXR0clRvT3B0aW9ucykge1xuXHRcdFx0XHRcdGlmIChkZWZpbmVkKG5vcm1hbE9wdGlvbnNbcG9pbnRBdHRyVG9PcHRpb25zW2tleV1dKSkge1xuXHRcdFx0XHRcdFx0aGFzUG9pbnRTcGVjaWZpY09wdGlvbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhIHNwZWNpZmljIG1hcmtlciBjb25maWcgb2JqZWN0IGlzIGRlZmluZWQgZm9yIHRoZSBpbmRpdmlkdWFsIHBvaW50OlxuXHRcdFx0Ly8gY3JlYXRlIGl0J3Mgb3duIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRpZiAoaGFzUG9pbnRTcGVjaWZpY09wdGlvbnMpIHtcblx0XHRcdFx0bm9ybWFsT3B0aW9ucyA9IG5vcm1hbE9wdGlvbnMgfHwge307XG5cdFx0XHRcdHBvaW50QXR0ciA9IFtdO1xuXHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBub3JtYWxPcHRpb25zLnN0YXRlcyB8fCB7fTsgLy8gcmVhc3NpZ24gZm9yIGluZGl2aWR1YWwgcG9pbnRcblx0XHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3ZlciA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0gPSBzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdIHx8IHt9O1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBjb2xvcnMgZm9yIGNvbHVtbiBhbmQgcGllc1xuXHRcdFx0XHRpZiAoIXNlcmllc09wdGlvbnMubWFya2VyKSB7IC8vIGNvbHVtbiwgYmFyLCBwb2ludFxuXHRcdFx0XHRcdC8vIGlmIG5vIGhvdmVyIGNvbG9yIGlzIGdpdmVuLCBicmlnaHRlbiB0aGUgbm9ybWFsIGNvbG9yXG5cdFx0XHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciA9XG5cdFx0XHRcdFx0XHRDb2xvcihwb2ludFN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8IHBvaW50LmNvbG9yKVxuXHRcdFx0XHRcdFx0XHQuYnJpZ2h0ZW4ocG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzIHx8XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIuYnJpZ2h0bmVzcykuZ2V0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vcm1hbCBwb2ludCBzdGF0ZSBpbmhlcml0cyBzZXJpZXMgd2lkZSBub3JtYWwgc3RhdGVcblx0XHRcdFx0cG9pbnRBdHRyW05PUk1BTF9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMoZXh0ZW5kKHtcblx0XHRcdFx0XHRjb2xvcjogcG9pbnQuY29sb3IsIC8vICM4Njhcblx0XHRcdFx0XHRmaWxsQ29sb3I6IHBvaW50LmNvbG9yLCAvLyBJbmRpdmlkdWFsIHBvaW50IGNvbG9yIG9yIG5lZ2F0aXZlIGNvbG9yIG1hcmtlcnMgKCMyMjE5KVxuXHRcdFx0XHRcdGxpbmVDb2xvcjogZGVmYXVsdExpbmVDb2xvciA9PT0gbnVsbCA/IHBvaW50LmNvbG9yIDogVU5ERUZJTkVEIC8vIEJ1YmJsZXMgdGFrZSBwb2ludCBjb2xvciwgbGluZSBtYXJrZXJzIHVzZSB3aGl0ZVxuXHRcdFx0XHR9LCBub3JtYWxPcHRpb25zKSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXG5cdFx0XHRcdC8vIGluaGVyaXQgZnJvbSBwb2ludCBub3JtYWwgYW5kIHNlcmllcyBob3ZlclxuXHRcdFx0XHRwb2ludEF0dHJbSE9WRVJfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0sXG5cdFx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW0hPVkVSX1NUQVRFXSxcblx0XHRcdFx0XHRwb2ludEF0dHJbTk9STUFMX1NUQVRFXVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaW5oZXJpdCBmcm9tIHBvaW50IG5vcm1hbCBhbmQgc2VyaWVzIGhvdmVyXG5cdFx0XHRcdHBvaW50QXR0cltTRUxFQ1RfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdHN0YXRlT3B0aW9uc1tTRUxFQ1RfU1RBVEVdLFxuXHRcdFx0XHRcdHNlcmllc1BvaW50QXR0cltTRUxFQ1RfU1RBVEVdLFxuXHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdCk7XG5cblxuXHRcdFx0Ly8gbm8gbWFya2VyIGNvbmZpZyBvYmplY3QgaXMgY3JlYXRlZDogY29weSBhIHJlZmVyZW5jZSB0byB0aGUgc2VyaWVzLXdpZGVcblx0XHRcdC8vIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEF0dHIgPSBzZXJpZXNQb2ludEF0dHI7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50LnBvaW50QXR0ciA9IHBvaW50QXR0cjtcblxuXHRcdH1cblxuXHR9LFxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzZXJpZXMgd2l0aCBhIG5ldyBzZXQgb2Ygb3B0aW9uc1xuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAobmV3T3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdC8vIG11c3QgdXNlIHVzZXIgb3B0aW9ucyB3aGVuIGNoYW5naW5nIHR5cGUgYmVjYXVzZSB0aGlzLm9wdGlvbnMgaXMgbWVyZ2VkXG5cdFx0XHQvLyBpbiB3aXRoIHR5cGUgc3BlY2lmaWMgcGxvdE9wdGlvbnNcblx0XHRcdG9sZE9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0b2xkVHlwZSA9IHRoaXMudHlwZSxcblx0XHRcdHByb3RvID0gc2VyaWVzVHlwZXNbb2xkVHlwZV0ucHJvdG90eXBlLFxuXHRcdFx0bjtcblxuXHRcdC8vIERvIHRoZSBtZXJnZSwgd2l0aCBzb21lIGZvcmNlZCBvcHRpb25zXG5cdFx0bmV3T3B0aW9ucyA9IG1lcmdlKG9sZE9wdGlvbnMsIHtcblx0XHRcdGFuaW1hdGlvbjogZmFsc2UsXG5cdFx0XHRpbmRleDogdGhpcy5pbmRleCxcblx0XHRcdHBvaW50U3RhcnQ6IHRoaXMueERhdGFbMF0gLy8gd2hlbiB1cGRhdGluZyBhZnRlciBhZGRQb2ludFxuXHRcdH0sIHsgZGF0YTogdGhpcy5vcHRpb25zLmRhdGEgfSwgbmV3T3B0aW9ucyk7XG5cblx0XHQvLyBEZXN0cm95IHRoZSBzZXJpZXMgYW5kIHJlaW5zZXJ0IG1ldGhvZHMgZnJvbSB0aGUgdHlwZSBwcm90b3R5cGVcblx0XHR0aGlzLnJlbW92ZShmYWxzZSk7XG5cdFx0Zm9yIChuIGluIHByb3RvKSB7IC8vIE92ZXJ3cml0ZSBzZXJpZXMtdHlwZSBzcGVjaWZpYyBtZXRob2RzICgjMjI3MClcblx0XHRcdGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuKSkge1xuXHRcdFx0XHR0aGlzW25dID0gVU5ERUZJTkVEO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRleHRlbmQodGhpcywgc2VyaWVzVHlwZXNbbmV3T3B0aW9ucy50eXBlIHx8IG9sZFR5cGVdLnByb3RvdHlwZSk7XG5cdFx0XG5cblx0XHR0aGlzLmluaXQoY2hhcnQsIG5ld09wdGlvbnMpO1xuXHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDbGVhciBET00gb2JqZWN0cyBhbmQgZnJlZSB1cCBtZW1vcnlcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aXNzdWUxMzQgPSAvQXBwbGVXZWJLaXRcXC81MzMvLnRlc3QodXNlckFnZW50KSxcblx0XHRcdGRlc3Ryb3ksXG5cdFx0XHRpLFxuXHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhIHx8IFtdLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHRwcm9wLFxuXHRcdFx0YXhpcztcblxuXHRcdC8vIGFkZCBldmVudCBob29rXG5cdFx0ZmlyZUV2ZW50KHNlcmllcywgJ2Rlc3Ryb3knKTtcblxuXHRcdC8vIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0cmVtb3ZlRXZlbnQoc2VyaWVzKTtcblx0XHRcblx0XHQvLyBlcmFzZSBmcm9tIGF4ZXNcblx0XHRlYWNoKFsneEF4aXMnLCAneUF4aXMnXSwgZnVuY3Rpb24gKEFYSVMpIHtcblx0XHRcdGF4aXMgPSBzZXJpZXNbQVhJU107XG5cdFx0XHRpZiAoYXhpcykge1xuXHRcdFx0XHRlcmFzZShheGlzLnNlcmllcywgc2VyaWVzKTtcblx0XHRcdFx0YXhpcy5pc0RpcnR5ID0gYXhpcy5mb3JjZVJlZHJhdyA9IHRydWU7XG5cdFx0XHRcdGF4aXMuc3RhY2tzID0ge307IC8vIFJlYnVpbGQgc3RhY2tzIHdoZW4gdXBkYXRpbmcgKCMyMjI5KVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gcmVtb3ZlIGxlZ2VuZCBpdGVtc1xuXHRcdGlmIChzZXJpZXMubGVnZW5kSXRlbSkge1xuXHRcdFx0c2VyaWVzLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShzZXJpZXMpO1xuXHRcdH1cblxuXHRcdC8vIGRlc3Ryb3kgYWxsIHBvaW50cyB3aXRoIHRoZWlyIGVsZW1lbnRzXG5cdFx0aSA9IGRhdGEubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHBvaW50ID0gZGF0YVtpXTtcblx0XHRcdGlmIChwb2ludCAmJiBwb2ludC5kZXN0cm95KSB7XG5cdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2VyaWVzLnBvaW50cyA9IG51bGw7XG5cblx0XHQvLyBDbGVhciB0aGUgYW5pbWF0aW9uIHRpbWVvdXQgaWYgd2UgYXJlIGRlc3Ryb3lpbmcgdGhlIHNlcmllcyBkdXJpbmcgaW5pdGlhbCBhbmltYXRpb25cblx0XHRjbGVhclRpbWVvdXQoc2VyaWVzLmFuaW1hdGlvblRpbWVvdXQpO1xuXG5cdFx0Ly8gZGVzdHJveSBhbGwgU1ZHRWxlbWVudHMgYXNzb2NpYXRlZCB0byB0aGUgc2VyaWVzXG5cdFx0ZWFjaChbJ2FyZWEnLCAnZ3JhcGgnLCAnZGF0YUxhYmVsc0dyb3VwJywgJ2dyb3VwJywgJ21hcmtlckdyb3VwJywgJ3RyYWNrZXInLFxuXHRcdFx0XHQnZ3JhcGhOZWcnLCAnYXJlYU5lZycsICdwb3NDbGlwJywgJ25lZ0NsaXAnXSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdGlmIChzZXJpZXNbcHJvcF0pIHtcblxuXHRcdFx0XHQvLyBpc3N1ZSAxMzQgd29ya2Fyb3VuZFxuXHRcdFx0XHRkZXN0cm95ID0gaXNzdWUxMzQgJiYgcHJvcCA9PT0gJ2dyb3VwJyA/XG5cdFx0XHRcdFx0J2hpZGUnIDpcblx0XHRcdFx0XHQnZGVzdHJveSc7XG5cblx0XHRcdFx0c2VyaWVzW3Byb3BdW2Rlc3Ryb3ldKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyByZW1vdmUgZnJvbSBob3ZlclNlcmllc1xuXHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyA9PT0gc2VyaWVzKSB7XG5cdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IG51bGw7XG5cdFx0fVxuXHRcdGVyYXNlKGNoYXJ0LnNlcmllcywgc2VyaWVzKTtcblxuXHRcdC8vIGNsZWFyIGFsbCBtZW1iZXJzXG5cdFx0Zm9yIChwcm9wIGluIHNlcmllcykge1xuXHRcdFx0ZGVsZXRlIHNlcmllc1twcm9wXTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIGRhdGEgbGFiZWxzXG5cdCAqL1xuXHRkcmF3RGF0YUxhYmVsczogZnVuY3Rpb24gKCkge1xuXHRcdFxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllc09wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRwb2ludE9wdGlvbnMsXG5cdFx0XHRnZW5lcmFsT3B0aW9ucyxcblx0XHRcdHN0cixcblx0XHRcdGRhdGFMYWJlbHNHcm91cDtcblx0XHRcblx0XHRpZiAob3B0aW9ucy5lbmFibGVkIHx8IHNlcmllcy5faGFzUG9pbnRMYWJlbHMpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0Ly8gUHJvY2VzcyBkZWZhdWx0IGFsaWdubWVudCBvZiBkYXRhIGxhYmVscyBmb3IgY29sdW1uc1xuXHRcdFx0aWYgKHNlcmllcy5kbFByb2Nlc3NPcHRpb25zKSB7XG5cdFx0XHRcdHNlcmllcy5kbFByb2Nlc3NPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIGRhdGEgbGFiZWxzIHRvIGF2b2lkIHJvdGF0aW9uXG5cdFx0XHRkYXRhTGFiZWxzR3JvdXAgPSBzZXJpZXMucGxvdEdyb3VwKFxuXHRcdFx0XHQnZGF0YUxhYmVsc0dyb3VwJywgXG5cdFx0XHRcdCdkYXRhLWxhYmVscycsIFxuXHRcdFx0XHRzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sIFxuXHRcdFx0XHRvcHRpb25zLnpJbmRleCB8fCA2XG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHQvLyBNYWtlIHRoZSBsYWJlbHMgZm9yIGVhY2ggcG9pbnRcblx0XHRcdGdlbmVyYWxPcHRpb25zID0gb3B0aW9ucztcblx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBlbmFibGVkLFxuXHRcdFx0XHRcdGRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbCxcblx0XHRcdFx0XHRsYWJlbENvbmZpZyxcblx0XHRcdFx0XHRhdHRyLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0cm90YXRpb24sXG5cdFx0XHRcdFx0Y29ubmVjdG9yID0gcG9pbnQuY29ubmVjdG9yLFxuXHRcdFx0XHRcdGlzTmV3ID0gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIERldGVybWluZSBpZiBlYWNoIGRhdGEgbGFiZWwgaXMgZW5hYmxlZFxuXHRcdFx0XHRwb2ludE9wdGlvbnMgPSBwb2ludC5vcHRpb25zICYmIHBvaW50Lm9wdGlvbnMuZGF0YUxhYmVscztcblx0XHRcdFx0ZW5hYmxlZCA9IHBpY2socG9pbnRPcHRpb25zICYmIHBvaW50T3B0aW9ucy5lbmFibGVkLCBnZW5lcmFsT3B0aW9ucy5lbmFibGVkKTsgLy8gIzIyODJcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB0aGUgcG9pbnQgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBkZXN0cm95IGl0LiAjNjc4LCAjODIwXG5cdFx0XHRcdGlmIChkYXRhTGFiZWwgJiYgIWVuYWJsZWQpIHtcblx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSW5kaXZpZHVhbCBsYWJlbHMgYXJlIGRpc2FibGVkIGlmIHRoZSBhcmUgZXhwbGljaXRseSBkaXNhYmxlZCBcblx0XHRcdFx0Ly8gaW4gdGhlIHBvaW50IG9wdGlvbnMsIG9yIGlmIHRoZXkgZmFsbCBvdXRzaWRlIHRoZSBwbG90IGFyZWEuXG5cdFx0XHRcdH0gZWxzZSBpZiAoZW5hYmxlZCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIENyZWF0ZSBpbmRpdmlkdWFsIG9wdGlvbnMgc3RydWN0dXJlIHRoYXQgY2FuIGJlIGV4dGVuZGVkIHdpdGhvdXQgXG5cdFx0XHRcdFx0Ly8gYWZmZWN0aW5nIG90aGVyc1xuXHRcdFx0XHRcdG9wdGlvbnMgPSBtZXJnZShnZW5lcmFsT3B0aW9ucywgcG9pbnRPcHRpb25zKTtcblxuXHRcdFx0XHRcdHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBHZXQgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdGxhYmVsQ29uZmlnID0gcG9pbnQuZ2V0TGFiZWxDb25maWcoKTtcblx0XHRcdFx0XHRzdHIgPSBvcHRpb25zLmZvcm1hdCA/XG5cdFx0XHRcdFx0XHRmb3JtYXQob3B0aW9ucy5mb3JtYXQsIGxhYmVsQ29uZmlnKSA6IFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIuY2FsbChsYWJlbENvbmZpZywgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSBjb2xvclxuXHRcdFx0XHRcdG9wdGlvbnMuc3R5bGUuY29sb3IgPSBwaWNrKG9wdGlvbnMuY29sb3IsIG9wdGlvbnMuc3R5bGUuY29sb3IsIHNlcmllcy5jb2xvciwgJ2JsYWNrJyk7XG5cdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBleGlzdGluZyBsYWJlbFxuXHRcdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQoc3RyKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhTGFiZWxcblx0XHRcdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBzdHJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aXNOZXcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gIzE0MzcgLSB0aGUgbGFiZWwgaXMgc2hvd24gY29uZGl0aW9uYWxseVxuXHRcdFx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuY29ubmVjdG9yID0gY29ubmVjdG9yLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIG5ldyBsYWJlbFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVmaW5lZChzdHIpKSB7XG5cdFx0XHRcdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRcdFx0XHQvL2FsaWduOiBhbGlnbixcblx0XHRcdFx0XHRcdFx0ZmlsbDogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdHI6IG9wdGlvbnMuYm9yZGVyUmFkaXVzIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJvdGF0aW9uOiByb3RhdGlvbixcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogb3B0aW9ucy5wYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDFcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdW51c2VkIGF0dHJpYnV0ZXMgKCM5NDcpXG5cdFx0XHRcdFx0XHRmb3IgKG5hbWUgaW4gYXR0cikge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cltuYW1lXSA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGF0dHJbbmFtZV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyW3JvdGF0aW9uID8gJ3RleHQnIDogJ2xhYmVsJ10oIC8vIGxhYmVscyBkb24ndCBzdXBwb3J0IHJvdGF0aW9uXG5cdFx0XHRcdFx0XHRcdHN0cixcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0LTk5OSxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cihhdHRyKVxuXHRcdFx0XHRcdFx0LmNzcyhvcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdFx0LmFkZChkYXRhTGFiZWxzR3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHQvLyBOb3cgdGhlIGRhdGEgbGFiZWwgaXMgY3JlYXRlZCBhbmQgcGxhY2VkIGF0IDAsMCwgc28gd2UgbmVlZCB0byBhbGlnbiBpdFxuXHRcdFx0XHRcdFx0c2VyaWVzLmFsaWduRGF0YUxhYmVsKHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIG51bGwsIGlzTmV3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBBbGlnbiBlYWNoIGluZGl2aWR1YWwgZGF0YSBsYWJlbFxuXHQgKi9cblx0YWxpZ25EYXRhTGFiZWw6IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnblRvLCBpc05ldykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0cGxvdFggPSBwaWNrKHBvaW50LnBsb3RYLCAtOTk5KSxcblx0XHRcdHBsb3RZID0gcGljayhwb2ludC5wbG90WSwgLTk5OSksXG5cdFx0XHRiQm94ID0gZGF0YUxhYmVsLmdldEJCb3goKSxcblx0XHRcdHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBvaW50LnBsb3RYLCBwb2ludC5wbG90WSwgaW52ZXJ0ZWQpLFxuXHRcdFx0YWxpZ25BdHRyOyAvLyB0aGUgZmluYWwgcG9zaXRpb247XG5cdFx0XHRcdFxuXHRcdGlmICh2aXNpYmxlKSB7XG5cblx0XHRcdC8vIFRoZSBhbGlnbm1lbnQgYm94IGlzIGEgc2luZ3VsYXIgcG9pbnRcblx0XHRcdGFsaWduVG8gPSBleHRlbmQoe1xuXHRcdFx0XHR4OiBpbnZlcnRlZCA/IGNoYXJ0LnBsb3RXaWR0aCAtIHBsb3RZIDogcGxvdFgsXG5cdFx0XHRcdHk6IG1hdGhSb3VuZChpbnZlcnRlZCA/IGNoYXJ0LnBsb3RIZWlnaHQgLSBwbG90WCA6IHBsb3RZKSxcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdGhlaWdodDogMFxuXHRcdFx0fSwgYWxpZ25Ubyk7XG5cdFx0XHRcblx0XHRcdC8vIEFkZCB0aGUgdGV4dCBzaXplIGZvciBhbGlnbm1lbnQgY2FsY3VsYXRpb25cblx0XHRcdGV4dGVuZChvcHRpb25zLCB7XG5cdFx0XHRcdHdpZHRoOiBiQm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGJCb3guaGVpZ2h0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWxsb3cgYSBob29rIGZvciBjaGFuZ2luZyBhbGlnbm1lbnQgaW4gdGhlIGxhc3QgbW9tZW50LCB0aGVuIGRvIHRoZSBhbGlnbm1lbnRcblx0XHRcdGlmIChvcHRpb25zLnJvdGF0aW9uKSB7IC8vIEZhbmN5IGJveCBhbGlnbm1lbnQgaXNuJ3Qgc3VwcG9ydGVkIGZvciByb3RhdGVkIHRleHRcblx0XHRcdFx0YWxpZ25BdHRyID0ge1xuXHRcdFx0XHRcdGFsaWduOiBvcHRpb25zLmFsaWduLFxuXHRcdFx0XHRcdHg6IGFsaWduVG8ueCArIG9wdGlvbnMueCArIGFsaWduVG8ud2lkdGggLyAyLFxuXHRcdFx0XHRcdHk6IGFsaWduVG8ueSArIG9wdGlvbnMueSArIGFsaWduVG8uaGVpZ2h0IC8gMlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRhTGFiZWxbaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKGFsaWduQXR0cik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhTGFiZWwuYWxpZ24ob3B0aW9ucywgbnVsbCwgYWxpZ25Ubyk7XG5cdFx0XHRcdGFsaWduQXR0ciA9IGRhdGFMYWJlbC5hbGlnbkF0dHI7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGp1c3RpZnkgb3IgY3JvcFxuXHRcdFx0XHRpZiAocGljayhvcHRpb25zLm92ZXJmbG93LCAnanVzdGlmeScpID09PSAnanVzdGlmeScpIHsgLy8gZG9jczogb3ZlcmZsb3c6IGp1c3RpZnksIGFsc28gY3JvcCBvbmx5IGFwcGxpZXMgd2hlbiBub3QganVzdGlmeVxuXHRcdFx0XHRcdHRoaXMuanVzdGlmeURhdGFMYWJlbChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpO1xuXHRcdFx0XHRcblx0XHRcdFx0fSBlbHNlIGlmIChwaWNrKG9wdGlvbnMuY3JvcCwgdHJ1ZSkpIHtcblx0XHRcdFx0XHQvLyBOb3cgY2hlY2sgdGhhdCB0aGUgZGF0YSBsYWJlbCBpcyB3aXRoaW4gdGhlIHBsb3QgYXJlYVxuXHRcdFx0XHRcdHZpc2libGUgPSBjaGFydC5pc0luc2lkZVBsb3QoYWxpZ25BdHRyLngsIGFsaWduQXR0ci55KSAmJiBjaGFydC5pc0luc2lkZVBsb3QoYWxpZ25BdHRyLnggKyBiQm94LndpZHRoLCBhbGlnbkF0dHIueSArIGJCb3guaGVpZ2h0KTtcblx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cdFx0XG5cdFx0fVxuXG5cdFx0Ly8gU2hvdyBvciBoaWRlIGJhc2VkIG9uIHRoZSBmaW5hbCBhbGlnbmVkIHBvc2l0aW9uXG5cdFx0aWYgKCF2aXNpYmxlKSB7XG5cdFx0XHRkYXRhTGFiZWwuYXR0cih7IHk6IC05OTkgfSk7XG5cdFx0fVxuXHRcdFx0XHRcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBJZiBkYXRhIGxhYmVscyBmYWxsIHBhcnRseSBvdXRzaWRlIHRoZSBwbG90IGFyZWEsIGFsaWduIHRoZW0gYmFjayBpbiwgaW4gYSB3YXkgdGhhdFxuXHQgKiBkb2Vzbid0IGhpZGUgdGhlIHBvaW50LlxuXHQgKi9cblx0anVzdGlmeURhdGFMYWJlbDogZnVuY3Rpb24gKGRhdGFMYWJlbCwgb3B0aW9ucywgYWxpZ25BdHRyLCBiQm94LCBhbGlnblRvLCBpc05ldykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRhbGlnbiA9IG9wdGlvbnMuYWxpZ24sXG5cdFx0XHR2ZXJ0aWNhbEFsaWduID0gb3B0aW9ucy52ZXJ0aWNhbEFsaWduLFxuXHRcdFx0b2ZmLFxuXHRcdFx0anVzdGlmaWVkO1xuXG5cdFx0Ly8gT2ZmIGxlZnRcblx0XHRvZmYgPSBhbGlnbkF0dHIueDtcblx0XHRpZiAob2ZmIDwgMCkge1xuXHRcdFx0aWYgKGFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24gPSAnbGVmdCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnggPSAtb2ZmO1xuXHRcdFx0fVxuXHRcdFx0anVzdGlmaWVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPZmYgcmlnaHRcblx0XHRvZmYgPSBhbGlnbkF0dHIueCArIGJCb3gud2lkdGg7XG5cdFx0aWYgKG9mZiA+IGNoYXJ0LnBsb3RXaWR0aCkge1xuXHRcdFx0aWYgKGFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdyaWdodCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnggPSBjaGFydC5wbG90V2lkdGggLSBvZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiB0b3Bcblx0XHRvZmYgPSBhbGlnbkF0dHIueTtcblx0XHRpZiAob2ZmIDwgMCkge1xuXHRcdFx0aWYgKHZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdG9wdGlvbnMudmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy55ID0gLW9mZjtcblx0XHRcdH1cblx0XHRcdGp1c3RpZmllZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2ZmIGJvdHRvbVxuXHRcdG9mZiA9IGFsaWduQXR0ci55ICsgYkJveC5oZWlnaHQ7XG5cdFx0aWYgKG9mZiA+IGNoYXJ0LnBsb3RIZWlnaHQpIHtcblx0XHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueSA9IGNoYXJ0LnBsb3RIZWlnaHQgLSBvZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoanVzdGlmaWVkKSB7XG5cdFx0XHRkYXRhTGFiZWwucGxhY2VkID0gIWlzTmV3O1xuXHRcdFx0ZGF0YUxhYmVsLmFsaWduKG9wdGlvbnMsIG51bGwsIGFsaWduVG8pO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGdyYXBoIHBhdGggb2YgYSBzZWdtZW50XG5cdCAqL1xuXHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcdFx0XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRzZWdtZW50UGF0aCA9IFtdLFxuXHRcdFx0c3RlcCA9IHNlcmllcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRcblx0XHQvLyBidWlsZCB0aGUgc2VnbWVudCBsaW5lXG5cdFx0ZWFjaChzZWdtZW50LCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdGxhc3RQb2ludDtcblxuXHRcdFx0aWYgKHNlcmllcy5nZXRQb2ludFNwbGluZSkgeyAvLyBnZW5lcmF0ZSB0aGUgc3BsaW5lIGFzIGRlZmluZWQgaW4gdGhlIFNwbGluZVNlcmllcyBvYmplY3Rcblx0XHRcdFx0c2VnbWVudFBhdGgucHVzaC5hcHBseShzZWdtZW50UGF0aCwgc2VyaWVzLmdldFBvaW50U3BsaW5lKHNlZ21lbnQsIHBvaW50LCBpKSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbW92ZVRvIG9yIGxpbmVUb1xuXHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKGkgPyBMIDogTSk7XG5cblx0XHRcdFx0Ly8gc3RlcCBsaW5lP1xuXHRcdFx0XHRpZiAoc3RlcCAmJiBpKSB7XG5cdFx0XHRcdFx0bGFzdFBvaW50ID0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHRcdFx0aWYgKHN0ZXAgPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WCxcblx0XHRcdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0ZXAgPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHQobGFzdFBvaW50LnBsb3RYICsgcGxvdFgpIC8gMixcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdFx0XHQobGFzdFBvaW50LnBsb3RYICsgcGxvdFgpIC8gMixcblx0XHRcdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChcblx0XHRcdFx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3JtYWwgbGluZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0cG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0cG9pbnQucGxvdFlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHRyZXR1cm4gc2VnbWVudFBhdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZ3JhcGggcGF0aFxuXHQgKi9cblx0Z2V0R3JhcGhQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRncmFwaFBhdGggPSBbXSxcblx0XHRcdHNlZ21lbnRQYXRoLFxuXHRcdFx0c2luZ2xlUG9pbnRzID0gW107IC8vIHVzZWQgaW4gZHJhd1RyYWNrZXJcblxuXHRcdC8vIERpdmlkZSBpbnRvIHNlZ21lbnRzIGFuZCBidWlsZCBncmFwaCBhbmQgYXJlYSBwYXRoc1xuXHRcdGVhY2goc2VyaWVzLnNlZ21lbnRzLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFx0XG5cdFx0XHRzZWdtZW50UGF0aCA9IHNlcmllcy5nZXRTZWdtZW50UGF0aChzZWdtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gYWRkIHRoZSBzZWdtZW50IHRvIHRoZSBncmFwaCwgb3IgYSBzaW5nbGUgcG9pbnQgZm9yIHRyYWNraW5nXG5cdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGdyYXBoUGF0aCA9IGdyYXBoUGF0aC5jb25jYXQoc2VnbWVudFBhdGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2luZ2xlUG9pbnRzLnB1c2goc2VnbWVudFswXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBSZWNvcmQgaXQgZm9yIHVzZSBpbiBkcmF3R3JhcGggYW5kIGRyYXdUcmFja2VyLCBhbmQgcmV0dXJuIGdyYXBoUGF0aFxuXHRcdHNlcmllcy5zaW5nbGVQb2ludHMgPSBzaW5nbGVQb2ludHM7XG5cdFx0c2VyaWVzLmdyYXBoUGF0aCA9IGdyYXBoUGF0aDtcblx0XHRcblx0XHRyZXR1cm4gZ3JhcGhQYXRoO1xuXHRcdFxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIGFjdHVhbCBncmFwaFxuXHQgKi9cblx0ZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0cHJvcHMgPSBbWydncmFwaCcsIG9wdGlvbnMubGluZUNvbG9yIHx8IHRoaXMuY29sb3JdXSxcblx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0ZGFzaFN0eWxlID0gIG9wdGlvbnMuZGFzaFN0eWxlLFxuXHRcdFx0Z3JhcGhQYXRoID0gdGhpcy5nZXRHcmFwaFBhdGgoKSxcblx0XHRcdG5lZ2F0aXZlQ29sb3IgPSBvcHRpb25zLm5lZ2F0aXZlQ29sb3I7XG5cdFx0XHRcblx0XHRpZiAobmVnYXRpdmVDb2xvcikge1xuXHRcdFx0cHJvcHMucHVzaChbJ2dyYXBoTmVnJywgbmVnYXRpdmVDb2xvcl0pO1xuXHRcdH1cblx0XHRcblx0XHQvLyBkcmF3IHRoZSBncmFwaFxuXHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wLCBpKSB7XG5cdFx0XHR2YXIgZ3JhcGhLZXkgPSBwcm9wWzBdLFxuXHRcdFx0XHRncmFwaCA9IHNlcmllc1tncmFwaEtleV0sXG5cdFx0XHRcdGF0dHJpYnM7XG5cdFx0XHRcblx0XHRcdGlmIChncmFwaCkge1xuXHRcdFx0XHRzdG9wKGdyYXBoKTsgLy8gY2FuY2VsIHJ1bm5pbmcgYW5pbWF0aW9ucywgIzQ1OVxuXHRcdFx0XHRncmFwaC5hbmltYXRlKHsgZDogZ3JhcGhQYXRoIH0pO1xuXHRcblx0XHRcdH0gZWxzZSBpZiAobGluZVdpZHRoICYmIGdyYXBoUGF0aC5sZW5ndGgpIHsgLy8gIzE0ODdcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRzdHJva2U6IHByb3BbMV0sXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHR6SW5kZXg6IDEgLy8gIzEwNjlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gZGFzaFN0eWxlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS1saW5lY2FwJ10gPSBhdHRyaWJzWydzdHJva2UtbGluZWpvaW4nXSA9ICdyb3VuZCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXJpZXNbZ3JhcGhLZXldID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZ3JhcGhQYXRoKVxuXHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpXG5cdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApXG5cdFx0XHRcdFx0LnNoYWRvdyghaSAmJiBvcHRpb25zLnNoYWRvdyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogQ2xpcCB0aGUgZ3JhcGhzIGludG8gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb2xvdXJlZCBncmFwaHNcblx0ICovXG5cdGNsaXBOZWc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRuZWdhdGl2ZUNvbG9yID0gb3B0aW9ucy5uZWdhdGl2ZUNvbG9yIHx8IG9wdGlvbnMubmVnYXRpdmVGaWxsQ29sb3IsXG5cdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkLFxuXHRcdFx0cG9zQXR0cixcblx0XHRcdG5lZ0F0dHIsXG5cdFx0XHRncmFwaCA9IHRoaXMuZ3JhcGgsXG5cdFx0XHRhcmVhID0gdGhpcy5hcmVhLFxuXHRcdFx0cG9zQ2xpcCA9IHRoaXMucG9zQ2xpcCxcblx0XHRcdG5lZ0NsaXAgPSB0aGlzLm5lZ0NsaXAsXG5cdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRjaGFydFNpemVNYXggPSBtYXRoTWF4KGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0KSxcblx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdGFib3ZlLFxuXHRcdFx0YmVsb3c7XG5cdFx0XG5cdFx0aWYgKG5lZ2F0aXZlQ29sb3IgJiYgKGdyYXBoIHx8IGFyZWEpKSB7XG5cdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkID0gbWF0aFJvdW5kKHlBeGlzLnRvUGl4ZWxzKG9wdGlvbnMudGhyZXNob2xkIHx8IDAsIHRydWUpKTtcblx0XHRcdGFib3ZlID0ge1xuXHRcdFx0XHR4OiAwLFxuXHRcdFx0XHR5OiAwLFxuXHRcdFx0XHR3aWR0aDogY2hhcnRTaXplTWF4LFxuXHRcdFx0XHRoZWlnaHQ6IHRyYW5zbGF0ZWRUaHJlc2hvbGRcblx0XHRcdH07XG5cdFx0XHRiZWxvdyA9IHtcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogdHJhbnNsYXRlZFRocmVzaG9sZCxcblx0XHRcdFx0d2lkdGg6IGNoYXJ0U2l6ZU1heCxcblx0XHRcdFx0aGVpZ2h0OiBjaGFydFNpemVNYXhcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXG5cdFx0XHRcdGFib3ZlLmhlaWdodCA9IGJlbG93LnkgPSBjaGFydC5wbG90V2lkdGggLSB0cmFuc2xhdGVkVGhyZXNob2xkO1xuXHRcdFx0XHRpZiAocmVuZGVyZXIuaXNWTUwpIHtcblx0XHRcdFx0XHRhYm92ZSA9IHtcblx0XHRcdFx0XHRcdHg6IGNoYXJ0LnBsb3RXaWR0aCAtIHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJlbG93ID0ge1xuXHRcdFx0XHRcdFx0eDogdHJhbnNsYXRlZFRocmVzaG9sZCArIGNoYXJ0LnBsb3RMZWZ0IC0gY2hhcnRXaWR0aCxcblx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdExlZnQgKyB0cmFuc2xhdGVkVGhyZXNob2xkLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydFdpZHRoXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoeUF4aXMucmV2ZXJzZWQpIHtcblx0XHRcdFx0cG9zQXR0ciA9IGJlbG93O1xuXHRcdFx0XHRuZWdBdHRyID0gYWJvdmU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NBdHRyID0gYWJvdmU7XG5cdFx0XHRcdG5lZ0F0dHIgPSBiZWxvdztcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChwb3NDbGlwKSB7IC8vIHVwZGF0ZVxuXHRcdFx0XHRwb3NDbGlwLmFuaW1hdGUocG9zQXR0cik7XG5cdFx0XHRcdG5lZ0NsaXAuYW5pbWF0ZShuZWdBdHRyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnBvc0NsaXAgPSBwb3NDbGlwID0gcmVuZGVyZXIuY2xpcFJlY3QocG9zQXR0cik7XG5cdFx0XHRcdHRoaXMubmVnQ2xpcCA9IG5lZ0NsaXAgPSByZW5kZXJlci5jbGlwUmVjdChuZWdBdHRyKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChncmFwaCAmJiB0aGlzLmdyYXBoTmVnKSB7XG5cdFx0XHRcdFx0Z3JhcGguY2xpcChwb3NDbGlwKTtcblx0XHRcdFx0XHR0aGlzLmdyYXBoTmVnLmNsaXAobmVnQ2xpcCk7XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFyZWEpIHtcblx0XHRcdFx0XHRhcmVhLmNsaXAocG9zQ2xpcCk7XG5cdFx0XHRcdFx0dGhpcy5hcmVhTmVnLmNsaXAobmVnQ2xpcCk7XG5cdFx0XHRcdH0gXG5cdFx0XHR9IFxuXHRcdH1cdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGFuZCBwZXJmb3JtIGdyb3VwIGludmVyc2lvbiBvbiBzZXJpZXMuZ3JvdXAgYW5kIHNlcmllcy5tYXJrZXJHcm91cFxuXHQgKi9cblx0aW52ZXJ0R3JvdXBzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdC8vIFBpZSwgZ28gYXdheSAoIzE3MzYpXG5cdFx0aWYgKCFzZXJpZXMueEF4aXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQSBmaXhlZCBzaXplIGlzIG5lZWRlZCBmb3IgaW52ZXJzaW9uIHRvIHdvcmtcblx0XHRmdW5jdGlvbiBzZXRJbnZlcnQoKSB7XHRcdFx0XG5cdFx0XHR2YXIgc2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IHNlcmllcy55QXhpcy5sZW4sXG5cdFx0XHRcdGhlaWdodDogc2VyaWVzLnhBeGlzLmxlblxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0ZWFjaChbJ2dyb3VwJywgJ21hcmtlckdyb3VwJ10sIGZ1bmN0aW9uIChncm91cE5hbWUpIHtcblx0XHRcdFx0aWYgKHNlcmllc1tncm91cE5hbWVdKSB7XG5cdFx0XHRcdFx0c2VyaWVzW2dyb3VwTmFtZV0uYXR0cihzaXplKS5pbnZlcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0YWRkRXZlbnQoY2hhcnQsICdyZXNpemUnLCBzZXRJbnZlcnQpOyAvLyBkbyBpdCBvbiByZXNpemVcblx0XHRhZGRFdmVudChzZXJpZXMsICdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlRXZlbnQoY2hhcnQsICdyZXNpemUnLCBzZXRJbnZlcnQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRG8gaXQgbm93XG5cdFx0c2V0SW52ZXJ0KCk7IC8vIGRvIGl0IG5vd1xuXHRcdFxuXHRcdC8vIE9uIHN1YnNlcXVlbnQgcmVuZGVyIGFuZCByZWRyYXcsIGp1c3QgZG8gc2V0SW52ZXJ0IHdpdGhvdXQgc2V0dGluZyB1cCBldmVudHMgYWdhaW5cblx0XHRzZXJpZXMuaW52ZXJ0R3JvdXBzID0gc2V0SW52ZXJ0O1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYWwgYWJzdHJhY3Rpb24gZm9yIGNyZWF0aW5nIHBsb3QgZ3JvdXBzIGxpa2Ugc2VyaWVzLmdyb3VwLCBzZXJpZXMuZGF0YUxhYmVsc0dyb3VwIGFuZCBcblx0ICogc2VyaWVzLm1hcmtlckdyb3VwLiBPbiBzdWJzZXF1ZW50IGNhbGxzLCB0aGUgZ3JvdXAgd2lsbCBvbmx5IGJlIGFkanVzdGVkIHRvIHRoZSB1cGRhdGVkIHBsb3Qgc2l6ZS5cblx0ICovXG5cdHBsb3RHcm91cDogZnVuY3Rpb24gKHByb3AsIG5hbWUsIHZpc2liaWxpdHksIHpJbmRleCwgcGFyZW50KSB7XG5cdFx0dmFyIGdyb3VwID0gdGhpc1twcm9wXSxcblx0XHRcdGlzTmV3ID0gIWdyb3VwO1xuXHRcdFxuXHRcdC8vIEdlbmVyYXRlIGl0IG9uIGZpcnN0IGNhbGxcblx0XHRpZiAoaXNOZXcpIHtcdFxuXHRcdFx0dGhpc1twcm9wXSA9IGdyb3VwID0gdGhpcy5jaGFydC5yZW5kZXJlci5nKG5hbWUpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuXHRcdFx0XHRcdHpJbmRleDogekluZGV4IHx8IDAuMSAvLyBJRTggbmVlZHMgdGhpc1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKHBhcmVudCk7XG5cdFx0fVxuXHRcdC8vIFBsYWNlIGl0IG9uIGZpcnN0IGFuZCBzdWJzZXF1ZW50IChyZWRyYXcpIGNhbGxzXG5cdFx0Z3JvdXBbaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHRoaXMuZ2V0UGxvdEJveCgpKTtcblx0XHRyZXR1cm4gZ3JvdXA7XHRcdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRyYW5zbGF0aW9uIGFuZCBzY2FsZSBmb3IgdGhlIHBsb3QgYXJlYSBvZiB0aGlzIHNlcmllc1xuXHQgKi9cblx0Z2V0UGxvdEJveDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0cmFuc2xhdGVYOiB0aGlzLnhBeGlzID8gdGhpcy54QXhpcy5sZWZ0IDogdGhpcy5jaGFydC5wbG90TGVmdCwgXG5cdFx0XHR0cmFuc2xhdGVZOiB0aGlzLnlBeGlzID8gdGhpcy55QXhpcy50b3AgOiB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRzY2FsZVg6IDEsIC8vICMxNjIzXG5cdFx0XHRzY2FsZVk6IDFcblx0XHR9O1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgZ3JhcGggYW5kIG1hcmtlcnNcblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRncm91cCxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBhbmltYXRpb24gJiYgISFzZXJpZXMuYW5pbWF0ZSAmJiBcblx0XHRcdFx0Y2hhcnQucmVuZGVyZXIuaXNTVkcsIC8vIHRoaXMgYW5pbWF0aW9uIGRvZXNuJ3Qgd29yayBpbiBJRTggcXVpcmtzIHdoZW4gdGhlIGdyb3VwIGRpdiBpcyBoaWRkZW4sXG5cdFx0XHRcdC8vIGFuZCBsb29rcyBiYWQgaW4gb3RoZXIgb2xkSUVcblx0XHRcdHZpc2liaWxpdHkgPSBzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sXG5cdFx0XHR6SW5kZXggPSBvcHRpb25zLnpJbmRleCxcblx0XHRcdGhhc1JlbmRlcmVkID0gc2VyaWVzLmhhc1JlbmRlcmVkLFxuXHRcdFx0Y2hhcnRTZXJpZXNHcm91cCA9IGNoYXJ0LnNlcmllc0dyb3VwO1xuXHRcdFxuXHRcdC8vIHRoZSBncm91cFxuXHRcdGdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdCdncm91cCcsIFxuXHRcdFx0J3NlcmllcycsIFxuXHRcdFx0dmlzaWJpbGl0eSwgXG5cdFx0XHR6SW5kZXgsIFxuXHRcdFx0Y2hhcnRTZXJpZXNHcm91cFxuXHRcdCk7XG5cdFx0XG5cdFx0c2VyaWVzLm1hcmtlckdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdCdtYXJrZXJHcm91cCcsIFxuXHRcdFx0J21hcmtlcnMnLCBcblx0XHRcdHZpc2liaWxpdHksIFxuXHRcdFx0ekluZGV4LCBcblx0XHRcdGNoYXJ0U2VyaWVzR3JvdXBcblx0XHQpO1xuXHRcdFxuXHRcdC8vIGluaXRpYXRlIHRoZSBhbmltYXRpb25cblx0XHRpZiAoZG9BbmltYXRpb24pIHtcblx0XHRcdHNlcmllcy5hbmltYXRlKHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgZm9yIHNoYXBlc1xuXHRcdHNlcmllcy5nZXRBdHRyaWJzKCk7XG5cblx0XHQvLyBTVkdSZW5kZXJlciBuZWVkcyB0byBrbm93IHRoaXMgYmVmb3JlIGRyYXdpbmcgZWxlbWVudHMgKCMxMDg5LCAjMTc5NSlcblx0XHRncm91cC5pbnZlcnRlZCA9IHNlcmllcy5pc0NhcnRlc2lhbiA/IGNoYXJ0LmludmVydGVkIDogZmFsc2U7XG5cdFx0XG5cdFx0Ly8gZHJhdyB0aGUgZ3JhcGggaWYgYW55XG5cdFx0aWYgKHNlcmllcy5kcmF3R3JhcGgpIHtcblx0XHRcdHNlcmllcy5kcmF3R3JhcGgoKTtcblx0XHRcdHNlcmllcy5jbGlwTmVnKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyB0aGUgZGF0YSBsYWJlbHMgKGlubiBwaWVzIHRoZXkgZ28gYmVmb3JlIHRoZSBwb2ludHMpXG5cdFx0c2VyaWVzLmRyYXdEYXRhTGFiZWxzKCk7XG5cdFx0XG5cdFx0Ly8gZHJhdyB0aGUgcG9pbnRzXG5cdFx0c2VyaWVzLmRyYXdQb2ludHMoKTtcblxuXG5cdFx0Ly8gZHJhdyB0aGUgbW91c2UgdHJhY2tpbmcgYXJlYVxuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nICE9PSBmYWxzZSkge1xuXHRcdFx0c2VyaWVzLmRyYXdUcmFja2VyKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEhhbmRsZSBpbnZlcnRlZCBzZXJpZXMgYW5kIHRyYWNrZXIgZ3JvdXBzXG5cdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRzZXJpZXMuaW52ZXJ0R3JvdXBzKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEluaXRpYWwgY2xpcHBpbmcsIG11c3QgYmUgZGVmaW5lZCBhZnRlciBpbnZlcnRpbmcgZ3JvdXBzIGZvciBWTUxcblx0XHRpZiAob3B0aW9ucy5jbGlwICE9PSBmYWxzZSAmJiAhc2VyaWVzLnNoYXJlZENsaXBLZXkgJiYgIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRncm91cC5jbGlwKGNoYXJ0LmNsaXBSZWN0KTtcblx0XHR9XG5cblx0XHQvLyBSdW4gdGhlIGFuaW1hdGlvblxuXHRcdGlmIChkb0FuaW1hdGlvbikge1xuXHRcdFx0c2VyaWVzLmFuaW1hdGUoKTtcblx0XHR9IGVsc2UgaWYgKCFoYXNSZW5kZXJlZCkge1xuXHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdH1cblxuXHRcdHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gZmFsc2U7IC8vIG1lYW5zIGRhdGEgaXMgaW4gYWNjb3JkYW5jZSB3aXRoIHdoYXQgeW91IHNlZVxuXHRcdC8vIChTZWUgIzMyMikgc2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSBmYWxzZTsgLy8gbWVhbnMgZGF0YSBpcyBpbiBhY2NvcmRhbmNlIHdpdGggd2hhdCB5b3Ugc2VlXG5cdFx0c2VyaWVzLmhhc1JlbmRlcmVkID0gdHJ1ZTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHNlcmllcyBhZnRlciBhbiB1cGRhdGUgaW4gdGhlIGF4ZXMuXG5cdCAqL1xuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0d2FzRGlydHlEYXRhID0gc2VyaWVzLmlzRGlydHlEYXRhLCAvLyBjYWNoZSBpdCBoZXJlIGFzIGl0IGlzIHNldCB0byBmYWxzZSBpbiByZW5kZXIsIGJ1dCB1c2VkIGFmdGVyXG5cdFx0XHRncm91cCA9IHNlcmllcy5ncm91cCxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXM7XG5cblx0XHQvLyByZXBvc2l0aW9uIG9uIHJlc2l6ZVxuXHRcdGlmIChncm91cCkge1xuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdGdyb3VwLmF0dHIoe1xuXHRcdFx0XHRcdHdpZHRoOiBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5wbG90SGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5hbmltYXRlKHtcblx0XHRcdFx0dHJhbnNsYXRlWDogcGljayh4QXhpcyAmJiB4QXhpcy5sZWZ0LCBjaGFydC5wbG90TGVmdCksXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IHBpY2soeUF4aXMgJiYgeUF4aXMudG9wLCBjaGFydC5wbG90VG9wKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c2VyaWVzLnRyYW5zbGF0ZSgpO1xuXHRcdHNlcmllcy5zZXRUb29sdGlwUG9pbnRzKHRydWUpO1xuXG5cdFx0c2VyaWVzLnJlbmRlcigpO1xuXHRcdGlmICh3YXNEaXJ0eURhdGEpIHtcblx0XHRcdGZpcmVFdmVudChzZXJpZXMsICd1cGRhdGVkRGF0YScpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgZ3JhcGhcblx0ICovXG5cdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0Z3JhcGhOZWcgPSBzZXJpZXMuZ3JhcGhOZWcsXG5cdFx0XHRzdGF0ZU9wdGlvbnMgPSBvcHRpb25zLnN0YXRlcyxcblx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0YXR0cmlicztcblxuXHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFO1xuXG5cdFx0aWYgKHNlcmllcy5zdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdHNlcmllcy5zdGF0ZSA9IHN0YXRlO1xuXG5cdFx0XHRpZiAoc3RhdGVPcHRpb25zW3N0YXRlXSAmJiBzdGF0ZU9wdGlvbnNbc3RhdGVdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlKSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHN0YXRlT3B0aW9uc1tzdGF0ZV0ubGluZVdpZHRoIHx8IGxpbmVXaWR0aCArIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChncmFwaCAmJiAhZ3JhcGguZGFzaHN0eWxlKSB7IC8vIGhvdmVyIGlzIHR1cm5lZCBvZmYgZm9yIGRhc2hlZCBsaW5lcyBpbiBWTUxcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogbGluZVdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHVzZSBhdHRyIGJlY2F1c2UgYW5pbWF0ZSB3aWxsIGNhdXNlIGFueSBvdGhlciBhbmltYXRpb24gb24gdGhlIGdyYXBoIHRvIHN0b3Bcblx0XHRcdFx0Z3JhcGguYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0aWYgKGdyYXBoTmVnKSB7XG5cdFx0XHRcdFx0Z3JhcGhOZWcuYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBncmFwaFxuXHQgKlxuXHQgKiBAcGFyYW0gdmlzIHtCb29sZWFufSBUcnVlIHRvIHNob3cgdGhlIHNlcmllcywgZmFsc2UgdG8gaGlkZS4gSWYgVU5ERUZJTkVELFxuXHQgKiAgICAgICAgdGhlIHZpc2liaWxpdHkgaXMgdG9nZ2xlZC5cblx0ICovXG5cdHNldFZpc2libGU6IGZ1bmN0aW9uICh2aXMsIHJlZHJhdykge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRsZWdlbmRJdGVtID0gc2VyaWVzLmxlZ2VuZEl0ZW0sXG5cdFx0XHRzaG93T3JIaWRlLFxuXHRcdFx0aWdub3JlSGlkZGVuU2VyaWVzID0gY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMsXG5cdFx0XHRvbGRWaXNpYmlsaXR5ID0gc2VyaWVzLnZpc2libGU7XG5cblx0XHQvLyBpZiBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgdG9nZ2xlIHZpc2liaWxpdHlcblx0XHRzZXJpZXMudmlzaWJsZSA9IHZpcyA9IHNlcmllcy51c2VyT3B0aW9ucy52aXNpYmxlID0gdmlzID09PSBVTkRFRklORUQgPyAhb2xkVmlzaWJpbGl0eSA6IHZpcztcblx0XHRzaG93T3JIaWRlID0gdmlzID8gJ3Nob3cnIDogJ2hpZGUnO1xuXG5cdFx0Ly8gc2hvdyBvciBoaWRlIGVsZW1lbnRzXG5cdFx0ZWFjaChbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCcsICdtYXJrZXJHcm91cCcsICd0cmFja2VyJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmIChzZXJpZXNba2V5XSkge1xuXHRcdFx0XHRzZXJpZXNba2V5XVtzaG93T3JIaWRlXSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0XG5cdFx0Ly8gaGlkZSB0b29sdGlwICgjMTM2MSlcblx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgPT09IHNlcmllcykge1xuXHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHR9XG5cblxuXHRcdGlmIChsZWdlbmRJdGVtKSB7XG5cdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHNlcmllcywgdmlzKTtcblx0XHR9XG5cblxuXHRcdC8vIHJlc2NhbGUgb3IgYWRhcHQgdG8gcmVzaXplZCBjaGFydFxuXHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHQvLyBpbiBhIHN0YWNrLCBhbGwgb3RoZXIgc2VyaWVzIGFyZSBhZmZlY3RlZFxuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRpZiAob3RoZXJTZXJpZXMub3B0aW9ucy5zdGFja2luZyAmJiBvdGhlclNlcmllcy52aXNpYmxlKSB7XG5cdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHNob3cgb3IgaGlkZSBsaW5rZWQgc2VyaWVzXG5cdFx0ZWFjaChzZXJpZXMubGlua2VkU2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdG90aGVyU2VyaWVzLnNldFZpc2libGUodmlzLCBmYWxzZSk7XG5cdFx0fSk7XG5cblx0XHRpZiAoaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHJlZHJhdyAhPT0gZmFsc2UpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdH1cblxuXHRcdGZpcmVFdmVudChzZXJpZXMsIHNob3dPckhpZGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSBncmFwaFxuXHQgKi9cblx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0VmlzaWJsZSh0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgZ3JhcGhcblx0ICovXG5cdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGdyYXBoXG5cdCAqXG5cdCAqIEBwYXJhbSBzZWxlY3RlZCB7Qm9vbGVhbn0gVHJ1ZSB0byBzZWxlY3QgdGhlIHNlcmllcywgZmFsc2UgdG8gdW5zZWxlY3QuIElmXG5cdCAqICAgICAgICBVTkRFRklORUQsIHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgdG9nZ2xlZC5cblx0ICovXG5cdHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXM7XG5cdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZVxuXHRcdHNlcmllcy5zZWxlY3RlZCA9IHNlbGVjdGVkID0gKHNlbGVjdGVkID09PSBVTkRFRklORUQpID8gIXNlcmllcy5zZWxlY3RlZCA6IHNlbGVjdGVkO1xuXG5cdFx0aWYgKHNlcmllcy5jaGVja2JveCkge1xuXHRcdFx0c2VyaWVzLmNoZWNrYm94LmNoZWNrZWQgPSBzZWxlY3RlZDtcblx0XHR9XG5cblx0XHRmaXJlRXZlbnQoc2VyaWVzLCBzZWxlY3RlZCA/ICdzZWxlY3QnIDogJ3Vuc2VsZWN0Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIHRyYWNrZXIgb2JqZWN0IHRoYXQgc2l0cyBhYm92ZSBhbGwgZGF0YSBsYWJlbHMgYW5kIG1hcmtlcnMgdG9cblx0ICogdHJhY2sgbW91c2UgZXZlbnRzIG9uIHRoZSBncmFwaCBvciBwb2ludHMuIEZvciB0aGUgbGluZSB0eXBlIGNoYXJ0c1xuXHQgKiB0aGUgdHJhY2tlciB1c2VzIHRoZSBzYW1lIGdyYXBoUGF0aCwgYnV0IHdpdGggYSBncmVhdGVyIHN0cm9rZSB3aWR0aFxuXHQgKiBmb3IgYmV0dGVyIGNvbnRyb2wuXG5cdCAqL1xuXHRkcmF3VHJhY2tlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0dHJhY2tCeUFyZWEgPSBvcHRpb25zLnRyYWNrQnlBcmVhLFxuXHRcdFx0dHJhY2tlclBhdGggPSBbXS5jb25jYXQodHJhY2tCeUFyZWEgPyBzZXJpZXMuYXJlYVBhdGggOiBzZXJpZXMuZ3JhcGhQYXRoKSxcblx0XHRcdHRyYWNrZXJQYXRoTGVuZ3RoID0gdHJhY2tlclBhdGgubGVuZ3RoLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRwb2ludGVyID0gY2hhcnQucG9pbnRlcixcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRzbmFwID0gY2hhcnQub3B0aW9ucy50b29sdGlwLnNuYXAsXG5cdFx0XHR0cmFja2VyID0gc2VyaWVzLnRyYWNrZXIsXG5cdFx0XHRjdXJzb3IgPSBvcHRpb25zLmN1cnNvcixcblx0XHRcdGNzcyA9IGN1cnNvciAmJiB7IGN1cnNvcjogY3Vyc29yIH0sXG5cdFx0XHRzaW5nbGVQb2ludHMgPSBzZXJpZXMuc2luZ2xlUG9pbnRzLFxuXHRcdFx0c2luZ2xlUG9pbnQsXG5cdFx0XHRpLFxuXHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdmVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBFeHRlbmQgZW5kIHBvaW50cy4gQSBiZXR0ZXIgd2F5IHdvdWxkIGJlIHRvIHVzZSByb3VuZCBsaW5lY2Fwcyxcblx0XHQvLyBidXQgdGhvc2UgYXJlIG5vdCBjbGlja2FibGUgaW4gVk1MLlxuXHRcdGlmICh0cmFja2VyUGF0aExlbmd0aCAmJiAhdHJhY2tCeUFyZWEpIHtcblx0XHRcdGkgPSB0cmFja2VyUGF0aExlbmd0aCArIDE7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmICh0cmFja2VyUGF0aFtpXSA9PT0gTSkgeyAvLyBleHRlbmQgbGVmdCBzaWRlXG5cdFx0XHRcdFx0dHJhY2tlclBhdGguc3BsaWNlKGkgKyAxLCAwLCB0cmFja2VyUGF0aFtpICsgMV0gLSBzbmFwLCB0cmFja2VyUGF0aFtpICsgMl0sIEwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgoaSAmJiB0cmFja2VyUGF0aFtpXSA9PT0gTSkgfHwgaSA9PT0gdHJhY2tlclBhdGhMZW5ndGgpIHsgLy8gZXh0ZW5kIHJpZ2h0IHNpZGVcblx0XHRcdFx0XHR0cmFja2VyUGF0aC5zcGxpY2UoaSwgMCwgTCwgdHJhY2tlclBhdGhbaSAtIDJdICsgc25hcCwgdHJhY2tlclBhdGhbaSAtIDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzaW5nbGUgcG9pbnRzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNpbmdsZVBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2luZ2xlUG9pbnQgPSBzaW5nbGVQb2ludHNbaV07XG5cdFx0XHR0cmFja2VyUGF0aC5wdXNoKE0sIHNpbmdsZVBvaW50LnBsb3RYIC0gc25hcCwgc2luZ2xlUG9pbnQucGxvdFksXG5cdFx0XHRcdEwsIHNpbmdsZVBvaW50LnBsb3RYICsgc25hcCwgc2luZ2xlUG9pbnQucGxvdFkpO1xuXHRcdH1cblx0XHRcblx0XHRcblxuXHRcdC8vIGRyYXcgdGhlIHRyYWNrZXJcblx0XHRpZiAodHJhY2tlcikge1xuXHRcdFx0dHJhY2tlci5hdHRyKHsgZDogdHJhY2tlclBhdGggfSk7XG5cblx0XHR9IGVsc2UgeyAvLyBjcmVhdGVcblx0XHRcdFx0XG5cdFx0XHRzZXJpZXMudHJhY2tlciA9IHJlbmRlcmVyLnBhdGgodHJhY2tlclBhdGgpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHQnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJywgLy8gIzEyMjVcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiBzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sXG5cdFx0XHRcdFx0c3Ryb2tlOiBUUkFDS0VSX0ZJTEwsXG5cdFx0XHRcdFx0ZmlsbDogdHJhY2tCeUFyZWEgPyBUUkFDS0VSX0ZJTEwgOiBOT05FLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnIDogb3B0aW9ucy5saW5lV2lkdGggKyAodHJhY2tCeUFyZWEgPyAwIDogMiAqIHNuYXApLFxuXHRcdFx0XHRcdHpJbmRleDogMlxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKHNlcmllcy5ncm91cCk7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gVGhlIHRyYWNrZXIgaXMgYWRkZWQgdG8gdGhlIHNlcmllcyBncm91cCwgd2hpY2ggaXMgY2xpcHBlZCwgYnV0IGlzIGNvdmVyZWQgXG5cdFx0XHQvLyBieSB0aGUgbWFya2VyIGdyb3VwLiBTbyB0aGUgbWFya2VyIGdyb3VwIGFsc28gbmVlZHMgdG8gY2FwdHVyZSBldmVudHMuXG5cdFx0XHRlYWNoKFtzZXJpZXMudHJhY2tlciwgc2VyaWVzLm1hcmtlckdyb3VwXSwgZnVuY3Rpb24gKHRyYWNrZXIpIHtcblx0XHRcdFx0dHJhY2tlci5hZGRDbGFzcyhQUkVGSVggKyAndHJhY2tlcicpXG5cdFx0XHRcdFx0Lm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcilcblx0XHRcdFx0XHQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHsgcG9pbnRlci5vblRyYWNrZXJNb3VzZU91dChlKTsgfSlcblx0XHRcdFx0XHQuY3NzKGNzcyk7XG5cblx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0dHJhY2tlci5vbigndG91Y2hzdGFydCcsIG9uTW91c2VPdmVyKTtcblx0XHRcdFx0fSBcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cbn07IC8vIGVuZCBTZXJpZXMgcHJvdG90eXBlXG5cblxuLyoqXG4gKiBMaW5lU2VyaWVzIG9iamVjdFxuICovXG52YXIgTGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcyk7XG5zZXJpZXNUeXBlcy5saW5lID0gTGluZVNlcmllcztcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYXJlYVxuICovXG5kZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdHRocmVzaG9sZDogMFxuXHQvLyB0cmFja0J5QXJlYTogZmFsc2UsXG5cdC8vIGxpbmVDb2xvcjogbnVsbCwgLy8gb3ZlcnJpZGVzIGNvbG9yLCBidXQgbGV0cyBmaWxsQ29sb3IgYmUgdW5hbHRlcmVkXG5cdC8vIGZpbGxPcGFjaXR5OiAwLjc1LFxuXHQvLyBmaWxsQ29sb3I6IG51bGxcbn0pO1xuXG4vKipcbiAqIEFyZWFTZXJpZXMgb2JqZWN0XG4gKi9cbnZhciBBcmVhU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdHR5cGU6ICdhcmVhJyxcblx0XG5cdC8qKlxuXHQgKiBGb3Igc3RhY2tzLCBkb24ndCBzcGxpdCBzZWdtZW50cyBvbiBudWxsIHZhbHVlcy4gSW5zdGVhZCwgZHJhdyBudWxsIHZhbHVlcyB3aXRoIFxuXHQgKiBubyBtYXJrZXIuIEFsc28gaW5zZXJ0IGR1bW15IHBvaW50cyBmb3IgYW55IFggcG9zaXRpb24gdGhhdCBleGlzdHMgaW4gb3RoZXIgc2VyaWVzXG5cdCAqIGluIHRoZSBzdGFjay5cblx0ICovIFxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudCA9IFtdLFxuXHRcdFx0a2V5cyA9IFtdLFxuXHRcdFx0eEF4aXMgPSB0aGlzLnhBeGlzLFxuXHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0c3RhY2sgPSB5QXhpcy5zdGFja3NbdGhpcy5zdGFja0tleV0sXG5cdFx0XHRwb2ludE1hcCA9IHt9LFxuXHRcdFx0cGxvdFgsXG5cdFx0XHRwbG90WSxcblx0XHRcdHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0Y29ubmVjdE51bGxzID0gdGhpcy5vcHRpb25zLmNvbm5lY3ROdWxscyxcblx0XHRcdHZhbCxcblx0XHRcdGksXG5cdFx0XHR4O1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zdGFja2luZyAmJiAhdGhpcy5jcm9wcGVkKSB7IC8vIGNyb3BwZWQgY2F1c2VzIGFydGVmYWN0cyBpbiBTdG9jaywgYW5kIHBlcmYgaXNzdWVcblx0XHRcdC8vIENyZWF0ZSBhIG1hcCB3aGVyZSB3ZSBjYW4gcXVpY2tseSBsb29rIHVwIHRoZSBwb2ludHMgYnkgdGhlaXIgWCB2YWx1ZS5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cG9pbnRNYXBbcG9pbnRzW2ldLnhdID0gcG9pbnRzW2ldO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb3J0IHRoZSBrZXlzICgjMTY1MSlcblx0XHRcdGZvciAoeCBpbiBzdGFjaykge1xuXHRcdFx0XHRrZXlzLnB1c2goK3gpO1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhIC0gYjtcblx0XHRcdH0pO1xuXG5cdFx0XHRlYWNoKGtleXMsIGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdGlmIChjb25uZWN0TnVsbHMgJiYgKCFwb2ludE1hcFt4XSB8fCBwb2ludE1hcFt4XS55ID09PSBudWxsKSkgeyAvLyAjMTgzNlxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHQvLyBUaGUgcG9pbnQgZXhpc3RzLCBwdXNoIGl0IHRvIHRoZSBzZWdtZW50XG5cdFx0XHRcdH0gZWxzZSBpZiAocG9pbnRNYXBbeF0pIHtcblx0XHRcdFx0XHRzZWdtZW50LnB1c2gocG9pbnRNYXBbeF0pO1xuXG5cdFx0XHRcdC8vIFRoZXJlIGlzIG5vIHBvaW50IGZvciB0aGlzIFggdmFsdWUgaW4gdGhpcyBzZXJpZXMsIHNvIHdlIFxuXHRcdFx0XHQvLyBpbnNlcnQgYSBkdW1teSBwb2ludCBpbiBvcmRlciBmb3IgdGhlIGFyZWFzIHRvIGJlIGRyYXduXG5cdFx0XHRcdC8vIGNvcnJlY3RseS5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbG90WCA9IHhBeGlzLnRyYW5zbGF0ZSh4KTtcblx0XHRcdFx0XHR2YWwgPSBzdGFja1t4XS5wZXJjZW50ID8gKHN0YWNrW3hdLnRvdGFsID8gc3RhY2tbeF0uY3VtICogMTAwIC8gc3RhY2tbeF0udG90YWwgOiAwKSA6IHN0YWNrW3hdLmN1bTsgLy8gIzE5OTFcblx0XHRcdFx0XHRwbG90WSA9IHlBeGlzLnRvUGl4ZWxzKHZhbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0c2VnbWVudC5wdXNoKHsgXG5cdFx0XHRcdFx0XHR5OiBudWxsLCBcblx0XHRcdFx0XHRcdHBsb3RYOiBwbG90WCxcblx0XHRcdFx0XHRcdGNsaWVudFg6IHBsb3RYLCBcblx0XHRcdFx0XHRcdHBsb3RZOiBwbG90WSwgXG5cdFx0XHRcdFx0XHR5Qm90dG9tOiBwbG90WSxcblx0XHRcdFx0XHRcdG9uTW91c2VPdmVyOiBub29wXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc2VnbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0c2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmdldFNlZ21lbnRzLmNhbGwodGhpcyk7XG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEV4dGVuZCB0aGUgYmFzZSBTZXJpZXMgZ2V0U2VnbWVudFBhdGggbWV0aG9kIGJ5IGFkZGluZyB0aGUgcGF0aCBmb3IgdGhlIGFyZWEuXG5cdCAqIFRoaXMgcGF0aCBpcyBwdXNoZWQgdG8gdGhlIHNlcmllcy5hcmVhUGF0aCBwcm9wZXJ0eS5cblx0ICovXG5cdGdldFNlZ21lbnRQYXRoOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFxuXHRcdHZhciBzZWdtZW50UGF0aCA9IFNlcmllcy5wcm90b3R5cGUuZ2V0U2VnbWVudFBhdGguY2FsbCh0aGlzLCBzZWdtZW50KSwgLy8gY2FsbCBiYXNlIG1ldGhvZFxuXHRcdFx0YXJlYVNlZ21lbnRQYXRoID0gW10uY29uY2F0KHNlZ21lbnRQYXRoKSwgLy8gd29yayBvbiBhIGNvcHkgZm9yIHRoZSBhcmVhIHBhdGhcblx0XHRcdGksXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0c2VnTGVuZ3RoID0gc2VnbWVudFBhdGgubGVuZ3RoLFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHRoaXMueUF4aXMuZ2V0VGhyZXNob2xkKG9wdGlvbnMudGhyZXNob2xkKSwgLy8gIzIxODFcblx0XHRcdHlCb3R0b207XG5cdFx0XG5cdFx0aWYgKHNlZ0xlbmd0aCA9PT0gMykgeyAvLyBmb3IgYW5pbWF0aW9uIGZyb20gMSB0byB0d28gcG9pbnRzXG5cdFx0XHRhcmVhU2VnbWVudFBhdGgucHVzaChMLCBzZWdtZW50UGF0aFsxXSwgc2VnbWVudFBhdGhbMl0pO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5zdGFja2luZyAmJiAhdGhpcy5jbG9zZWRTdGFja3MpIHtcblx0XHRcdFxuXHRcdFx0Ly8gRm9sbG93IHN0YWNrIGJhY2suIFRvZG86IGltcGxlbWVudCBhcmVhc3BsaW5lLiBBIGdlbmVyYWwgc29sdXRpb24gY291bGQgYmUgdG8gXG5cdFx0XHQvLyByZXZlcnNlIHRoZSBlbnRpcmUgZ3JhcGhQYXRoIG9mIHRoZSBwcmV2aW91cyBzZXJpZXMsIHRob3VnaCBtYXkgYmUgaGFyZCB3aXRoXG5cdFx0XHQvLyBzcGxpbmVzIGFuZCB3aXRoIHNlcmllcyB3aXRoIGRpZmZlcmVudCBleHRyZW1lc1xuXHRcdFx0Zm9yIChpID0gc2VnbWVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXG5cdFx0XHRcdHlCb3R0b20gPSBwaWNrKHNlZ21lbnRbaV0ueUJvdHRvbSwgdHJhbnNsYXRlZFRocmVzaG9sZCk7XG5cdFx0XHRcblx0XHRcdFx0Ly8gc3RlcCBsaW5lP1xuXHRcdFx0XHRpZiAoaSA8IHNlZ21lbnQubGVuZ3RoIC0gMSAmJiBvcHRpb25zLnN0ZXApIHtcblx0XHRcdFx0XHRhcmVhU2VnbWVudFBhdGgucHVzaChzZWdtZW50W2kgKyAxXS5wbG90WCwgeUJvdHRvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGFyZWFTZWdtZW50UGF0aC5wdXNoKHNlZ21lbnRbaV0ucGxvdFgsIHlCb3R0b20pO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHsgLy8gZm9sbG93IHplcm8gbGluZSBiYWNrXG5cdFx0XHR0aGlzLmNsb3NlU2VnbWVudChhcmVhU2VnbWVudFBhdGgsIHNlZ21lbnQsIHRyYW5zbGF0ZWRUaHJlc2hvbGQpO1xuXHRcdH1cblx0XHR0aGlzLmFyZWFQYXRoID0gdGhpcy5hcmVhUGF0aC5jb25jYXQoYXJlYVNlZ21lbnRQYXRoKTtcblx0XHRyZXR1cm4gc2VnbWVudFBhdGg7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogRXh0ZW5kYWJsZSBtZXRob2QgdG8gY2xvc2UgdGhlIHNlZ21lbnQgcGF0aCBvZiBhbiBhcmVhLiBUaGlzIGlzIG92ZXJyaWRkZW4gaW4gcG9sYXIgXG5cdCAqIGNoYXJ0cy5cblx0ICovXG5cdGNsb3NlU2VnbWVudDogZnVuY3Rpb24gKHBhdGgsIHNlZ21lbnQsIHRyYW5zbGF0ZWRUaHJlc2hvbGQpIHtcblx0XHRwYXRoLnB1c2goXG5cdFx0XHRMLFxuXHRcdFx0c2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdLnBsb3RYLFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCxcblx0XHRcdEwsXG5cdFx0XHRzZWdtZW50WzBdLnBsb3RYLFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZFxuXHRcdCk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgZ3JhcGggYW5kIHRoZSB1bmRlcmx5aW5nIGFyZWEuIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBTZXJpZXMgYmFzZVxuXHQgKiBmdW5jdGlvbiBhbmQgYWRkcyB0aGUgYXJlYS4gVGhlIGFyZWFQYXRoIGlzIGNhbGN1bGF0ZWQgaW4gdGhlIGdldFNlZ21lbnRQYXRoXG5cdCAqIG1ldGhvZCBjYWxsZWQgZnJvbSBTZXJpZXMucHJvdG90eXBlLmRyYXdHcmFwaC5cblx0ICovXG5cdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFxuXHRcdC8vIERlZmluZSBvciByZXNldCBhcmVhUGF0aFxuXHRcdHRoaXMuYXJlYVBhdGggPSBbXTtcblx0XHRcblx0XHQvLyBDYWxsIHRoZSBiYXNlIG1ldGhvZFxuXHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO1xuXHRcdFxuXHRcdC8vIERlZmluZSBsb2NhbCB2YXJpYWJsZXNcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGFyZWFQYXRoID0gdGhpcy5hcmVhUGF0aCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRuZWdhdGl2ZUNvbG9yID0gb3B0aW9ucy5uZWdhdGl2ZUNvbG9yLFxuXHRcdFx0bmVnYXRpdmVGaWxsQ29sb3IgPSBvcHRpb25zLm5lZ2F0aXZlRmlsbENvbG9yLFxuXHRcdFx0cHJvcHMgPSBbWydhcmVhJywgdGhpcy5jb2xvciwgb3B0aW9ucy5maWxsQ29sb3JdXTsgLy8gYXJlYSBuYW1lLCBtYWluIGNvbG9yLCBmaWxsIGNvbG9yXG5cdFx0XG5cdFx0aWYgKG5lZ2F0aXZlQ29sb3IgfHwgbmVnYXRpdmVGaWxsQ29sb3IpIHtcblx0XHRcdHByb3BzLnB1c2goWydhcmVhTmVnJywgbmVnYXRpdmVDb2xvciwgbmVnYXRpdmVGaWxsQ29sb3JdKTtcblx0XHR9XG5cdFx0XG5cdFx0ZWFjaChwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdHZhciBhcmVhS2V5ID0gcHJvcFswXSxcblx0XHRcdFx0YXJlYSA9IHNlcmllc1thcmVhS2V5XTtcblx0XHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgb3IgdXBkYXRlIHRoZSBhcmVhXG5cdFx0XHRpZiAoYXJlYSkgeyAvLyB1cGRhdGVcblx0XHRcdFx0YXJlYS5hbmltYXRlKHsgZDogYXJlYVBhdGggfSk7XG5cdFxuXHRcdFx0fSBlbHNlIHsgLy8gY3JlYXRlXG5cdFx0XHRcdHNlcmllc1thcmVhS2V5XSA9IHNlcmllcy5jaGFydC5yZW5kZXJlci5wYXRoKGFyZWFQYXRoKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGZpbGw6IHBpY2soXG5cdFx0XHRcdFx0XHRcdHByb3BbMl0sXG5cdFx0XHRcdFx0XHRcdENvbG9yKHByb3BbMV0pLnNldE9wYWNpdHkocGljayhvcHRpb25zLmZpbGxPcGFjaXR5LCAwLjc1KSkuZ2V0KClcblx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDAgLy8gIzEwNjlcblx0XHRcdFx0XHR9KS5hZGQoc2VyaWVzLmdyb3VwKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sIGluIHRoZSBsZWdlbmRcblx0ICogXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmQgVGhlIGxlZ2VuZCBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHNlcmllcyAodGhpcykgb3IgcG9pbnRcblx0ICovXG5cdGRyYXdMZWdlbmRTeW1ib2w6IGZ1bmN0aW9uIChsZWdlbmQsIGl0ZW0pIHtcblx0XHRcblx0XHRpdGVtLmxlZ2VuZFN5bWJvbCA9IHRoaXMuY2hhcnQucmVuZGVyZXIucmVjdChcblx0XHRcdDAsXG5cdFx0XHRsZWdlbmQuYmFzZWxpbmUgLSAxMSxcblx0XHRcdGxlZ2VuZC5vcHRpb25zLnN5bWJvbFdpZHRoLFxuXHRcdFx0MTIsXG5cdFx0XHQyXG5cdFx0KS5hdHRyKHtcblx0XHRcdHpJbmRleDogM1xuXHRcdH0pLmFkZChpdGVtLmxlZ2VuZEdyb3VwKTtcdFx0XG5cdFx0XG5cdH1cbn0pO1xuXG5zZXJpZXNUeXBlcy5hcmVhID0gQXJlYVNlcmllczsvKipcbiAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBzcGxpbmVcbiAqL1xuZGVmYXVsdFBsb3RPcHRpb25zLnNwbGluZSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zKTtcblxuLyoqXG4gKiBTcGxpbmVTZXJpZXMgb2JqZWN0XG4gKi9cbnZhciBTcGxpbmVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0dHlwZTogJ3NwbGluZScsXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc3BsaW5lIHNlZ21lbnQgZnJvbSBhIGdpdmVuIHBvaW50J3MgcHJldmlvdXMgbmVpZ2hib3VyIHRvIHRoZSBnaXZlbiBwb2ludFxuXHQgKi9cblx0Z2V0UG9pbnRTcGxpbmU6IGZ1bmN0aW9uIChzZWdtZW50LCBwb2ludCwgaSkge1xuXHRcdHZhciBzbW9vdGhpbmcgPSAxLjUsIC8vIDEgbWVhbnMgY29udHJvbCBwb2ludHMgbWlkd2F5IGJldHdlZW4gcG9pbnRzLCAyIG1lYW5zIDEvMyBmcm9tIHRoZSBwb2ludCwgMyBpcyAxLzQgZXRjXG5cdFx0XHRkZW5vbSA9IHNtb290aGluZyArIDEsXG5cdFx0XHRwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0cGxvdFkgPSBwb2ludC5wbG90WSxcblx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdLFxuXHRcdFx0bmV4dFBvaW50ID0gc2VnbWVudFtpICsgMV0sXG5cdFx0XHRsZWZ0Q29udFgsXG5cdFx0XHRsZWZ0Q29udFksXG5cdFx0XHRyaWdodENvbnRYLFxuXHRcdFx0cmlnaHRDb250WSxcblx0XHRcdHJldDtcblxuXHRcdC8vIGZpbmQgY29udHJvbCBwb2ludHNcblx0XHRpZiAobGFzdFBvaW50ICYmIG5leHRQb2ludCkge1xuXHRcdFxuXHRcdFx0dmFyIGxhc3RYID0gbGFzdFBvaW50LnBsb3RYLFxuXHRcdFx0XHRsYXN0WSA9IGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0bmV4dFggPSBuZXh0UG9pbnQucGxvdFgsXG5cdFx0XHRcdG5leHRZID0gbmV4dFBvaW50LnBsb3RZLFxuXHRcdFx0XHRjb3JyZWN0aW9uO1xuXG5cdFx0XHRsZWZ0Q29udFggPSAoc21vb3RoaW5nICogcGxvdFggKyBsYXN0WCkgLyBkZW5vbTtcblx0XHRcdGxlZnRDb250WSA9IChzbW9vdGhpbmcgKiBwbG90WSArIGxhc3RZKSAvIGRlbm9tO1xuXHRcdFx0cmlnaHRDb250WCA9IChzbW9vdGhpbmcgKiBwbG90WCArIG5leHRYKSAvIGRlbm9tO1xuXHRcdFx0cmlnaHRDb250WSA9IChzbW9vdGhpbmcgKiBwbG90WSArIG5leHRZKSAvIGRlbm9tO1xuXG5cdFx0XHQvLyBoYXZlIHRoZSB0d28gY29udHJvbCBwb2ludHMgbWFrZSBhIHN0cmFpZ2h0IGxpbmUgdGhyb3VnaCBtYWluIHBvaW50XG5cdFx0XHRjb3JyZWN0aW9uID0gKChyaWdodENvbnRZIC0gbGVmdENvbnRZKSAqIChyaWdodENvbnRYIC0gcGxvdFgpKSAvXG5cdFx0XHRcdChyaWdodENvbnRYIC0gbGVmdENvbnRYKSArIHBsb3RZIC0gcmlnaHRDb250WTtcblxuXHRcdFx0bGVmdENvbnRZICs9IGNvcnJlY3Rpb247XG5cdFx0XHRyaWdodENvbnRZICs9IGNvcnJlY3Rpb247XG5cblx0XHRcdC8vIHRvIHByZXZlbnQgZmFsc2UgZXh0cmVtZXMsIGNoZWNrIHRoYXQgY29udHJvbCBwb2ludHMgYXJlIGJldHdlZW5cblx0XHRcdC8vIG5laWdoYm91cmluZyBwb2ludHMnIHkgdmFsdWVzXG5cdFx0XHRpZiAobGVmdENvbnRZID4gbGFzdFkgJiYgbGVmdENvbnRZID4gcGxvdFkpIHtcblx0XHRcdFx0bGVmdENvbnRZID0gbWF0aE1heChsYXN0WSwgcGxvdFkpO1xuXHRcdFx0XHRyaWdodENvbnRZID0gMiAqIHBsb3RZIC0gbGVmdENvbnRZOyAvLyBtaXJyb3Igb2YgbGVmdCBjb250cm9sIHBvaW50XG5cdFx0XHR9IGVsc2UgaWYgKGxlZnRDb250WSA8IGxhc3RZICYmIGxlZnRDb250WSA8IHBsb3RZKSB7XG5cdFx0XHRcdGxlZnRDb250WSA9IG1hdGhNaW4obGFzdFksIHBsb3RZKTtcblx0XHRcdFx0cmlnaHRDb250WSA9IDIgKiBwbG90WSAtIGxlZnRDb250WTtcblx0XHRcdH1cblx0XHRcdGlmIChyaWdodENvbnRZID4gbmV4dFkgJiYgcmlnaHRDb250WSA+IHBsb3RZKSB7XG5cdFx0XHRcdHJpZ2h0Q29udFkgPSBtYXRoTWF4KG5leHRZLCBwbG90WSk7XG5cdFx0XHRcdGxlZnRDb250WSA9IDIgKiBwbG90WSAtIHJpZ2h0Q29udFk7XG5cdFx0XHR9IGVsc2UgaWYgKHJpZ2h0Q29udFkgPCBuZXh0WSAmJiByaWdodENvbnRZIDwgcGxvdFkpIHtcblx0XHRcdFx0cmlnaHRDb250WSA9IG1hdGhNaW4obmV4dFksIHBsb3RZKTtcblx0XHRcdFx0bGVmdENvbnRZID0gMiAqIHBsb3RZIC0gcmlnaHRDb250WTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVjb3JkIGZvciBkcmF3aW5nIGluIG5leHQgcG9pbnRcblx0XHRcdHBvaW50LnJpZ2h0Q29udFggPSByaWdodENvbnRYO1xuXHRcdFx0cG9pbnQucmlnaHRDb250WSA9IHJpZ2h0Q29udFk7XG5cblx0XHR9XG5cdFx0XG5cdFx0Ly8gVmlzdWFsaXplIGNvbnRyb2wgcG9pbnRzIGZvciBkZWJ1Z2dpbmdcblx0XHQvKlxuXHRcdGlmIChsZWZ0Q29udFgpIHtcblx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIuY2lyY2xlKGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCwgMilcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHN0cm9rZTogJ3JlZCcsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0ZmlsbDogJ25vbmUnXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIucGF0aChbJ00nLCBsZWZ0Q29udFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBsZWZ0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdCdMJywgcGxvdFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBwbG90WSArIHRoaXMuY2hhcnQucGxvdFRvcF0pXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRzdHJva2U6ICdyZWQnLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIuY2lyY2xlKHJpZ2h0Q29udFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCByaWdodENvbnRZICsgdGhpcy5jaGFydC5wbG90VG9wLCAyKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiAnZ3JlZW4nLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRcdGZpbGw6ICdub25lJ1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoWydNJywgcmlnaHRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHJpZ2h0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdCdMJywgcGxvdFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBwbG90WSArIHRoaXMuY2hhcnQucGxvdFRvcF0pXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDFcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZCgpO1xuXHRcdH1cblx0XHQqL1xuXG5cdFx0Ly8gbW92ZVRvIG9yIGxpbmVUb1xuXHRcdGlmICghaSkge1xuXHRcdFx0cmV0ID0gW00sIHBsb3RYLCBwbG90WV07XG5cdFx0fSBlbHNlIHsgLy8gY3VydmUgZnJvbSBsYXN0IHBvaW50IHRvIHRoaXNcblx0XHRcdHJldCA9IFtcblx0XHRcdFx0J0MnLFxuXHRcdFx0XHRsYXN0UG9pbnQucmlnaHRDb250WCB8fCBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdGxhc3RQb2ludC5yaWdodENvbnRZIHx8IGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0bGVmdENvbnRYIHx8IHBsb3RYLFxuXHRcdFx0XHRsZWZ0Q29udFkgfHwgcGxvdFksXG5cdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRwbG90WVxuXHRcdFx0XTtcblx0XHRcdGxhc3RQb2ludC5yaWdodENvbnRYID0gbGFzdFBvaW50LnJpZ2h0Q29udFkgPSBudWxsOyAvLyByZXNldCBmb3IgdXBkYXRpbmcgc2VyaWVzIGxhdGVyXG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cbn0pO1xuc2VyaWVzVHlwZXMuc3BsaW5lID0gU3BsaW5lU2VyaWVzO1xuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBhcmVhc3BsaW5lXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5hcmVhc3BsaW5lID0gbWVyZ2UoZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEpO1xuXG4vKipcbiAqIEFyZWFTcGxpbmVTZXJpZXMgb2JqZWN0XG4gKi9cbnZhciBhcmVhUHJvdG8gPSBBcmVhU2VyaWVzLnByb3RvdHlwZSxcblx0QXJlYVNwbGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNwbGluZVNlcmllcywge1xuXHRcdHR5cGU6ICdhcmVhc3BsaW5lJyxcblx0XHRjbG9zZWRTdGFja3M6IHRydWUsIC8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBwcmV2aW91cyBncmFwaCBiYWNrLCBmb2xsb3cgdGhlIHRocmVzaG9sZCBiYWNrXG5cdFx0XG5cdFx0Ly8gTWl4IGluIG1ldGhvZHMgZnJvbSB0aGUgYXJlYSBzZXJpZXNcblx0XHRnZXRTZWdtZW50UGF0aDogYXJlYVByb3RvLmdldFNlZ21lbnRQYXRoLFxuXHRcdGNsb3NlU2VnbWVudDogYXJlYVByb3RvLmNsb3NlU2VnbWVudCxcblx0XHRkcmF3R3JhcGg6IGFyZWFQcm90by5kcmF3R3JhcGgsXG5cdFx0ZHJhd0xlZ2VuZFN5bWJvbDogYXJlYVByb3RvLmRyYXdMZWdlbmRTeW1ib2xcblx0fSk7XG5zZXJpZXNUeXBlcy5hcmVhc3BsaW5lID0gQXJlYVNwbGluZVNlcmllcztcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgY29sdW1uXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5jb2x1bW4gPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRib3JkZXJDb2xvcjogJyNGRkZGRkYnLFxuXHRib3JkZXJXaWR0aDogMSxcblx0Ym9yZGVyUmFkaXVzOiAwLFxuXHQvL2NvbG9yQnlQb2ludDogdW5kZWZpbmVkLFxuXHRncm91cFBhZGRpbmc6IDAuMixcblx0Ly9ncm91cGluZzogdHJ1ZSxcblx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRwb2ludFBhZGRpbmc6IDAuMSxcblx0Ly9wb2ludFdpZHRoOiBudWxsLFxuXHRtaW5Qb2ludExlbmd0aDogMCxcblx0Y3JvcFRocmVzaG9sZDogNTAsIC8vIHdoZW4gdGhlcmUgYXJlIG1vcmUgcG9pbnRzLCB0aGV5IHdpbGwgbm90IGFuaW1hdGUgb3V0IG9mIHRoZSBjaGFydCBvbiB4QXhpcy5zZXRFeHRyZW1lc1xuXHRwb2ludFJhbmdlOiBudWxsLCAvLyBudWxsIG1lYW5zIGF1dG8sIG1lYW5pbmcgMSBpbiBhIGNhdGVnb3JpemVkIGF4aXMgYW5kIGxlYXN0IGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIGlmIG5vdCBjYXRlZ29yaWVzXG5cdHN0YXRlczoge1xuXHRcdGhvdmVyOiB7XG5cdFx0XHRicmlnaHRuZXNzOiAwLjEsXG5cdFx0XHRzaGFkb3c6IGZhbHNlXG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGNvbG9yOiAnI0MwQzBDMCcsXG5cdFx0XHRib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0c2hhZG93OiBmYWxzZVxuXHRcdH1cblx0fSxcblx0ZGF0YUxhYmVsczoge1xuXHRcdGFsaWduOiBudWxsLCAvLyBhdXRvXG5cdFx0dmVydGljYWxBbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdHk6IG51bGxcblx0fSxcblx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuXHR0aHJlc2hvbGQ6IDBcbn0pO1xuXG4vKipcbiAqIENvbHVtblNlcmllcyBvYmplY3RcbiAqL1xudmFyIENvbHVtblNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcywge1xuXHR0eXBlOiAnY29sdW1uJyxcblx0cG9pbnRBdHRyVG9PcHRpb25zOiB7IC8vIG1hcHBpbmcgYmV0d2VlbiBTVkcgYXR0cmlidXRlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW9uc1xuXHRcdHN0cm9rZTogJ2JvcmRlckNvbG9yJyxcblx0XHQnc3Ryb2tlLXdpZHRoJzogJ2JvcmRlcldpZHRoJyxcblx0XHRmaWxsOiAnY29sb3InLFxuXHRcdHI6ICdib3JkZXJSYWRpdXMnXG5cdH0sXG5cdGNyb3BTaG91bGRlcjogMCxcblx0dHJhY2tlckdyb3VwczogWydncm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0bmVnU3RhY2tzOiB0cnVlLCAvLyB1c2Ugc2VwYXJhdGUgbmVnYXRpdmUgc3RhY2tzLCB1bmxpa2UgYXJlYSBzdGFja3Mgd2hlcmUgYSBuZWdhdGl2ZSBcblx0XHQvLyBwb2ludCBpcyBzdWJzdHJhY3RlZCBmcm9tIHByZXZpb3VzICgjMTkxMClcblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBzZXJpZXNcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRTZXJpZXMucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHQvLyBpZiB0aGUgc2VyaWVzIGlzIGFkZGVkIGR5bmFtaWNhbGx5LCBmb3JjZSByZWRyYXcgb2Ygb3RoZXJcblx0XHQvLyBzZXJpZXMgYWZmZWN0ZWQgYnkgYSBuZXcgY29sdW1uXG5cdFx0aWYgKGNoYXJ0Lmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSkge1xuXHRcdFx0XHRcdG90aGVyU2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgd2lkdGggYW5kIHggb2Zmc2V0IG9mIHRoZSBjb2x1bW5zIGFkanVzdGVkIGZvciBncm91cGluZywgZ3JvdXBQYWRkaW5nLCBwb2ludFBhZGRpbmcsXG5cdCAqIHBvaW50V2lkdGggZXRjLiBcblx0ICovXG5cdGdldENvbHVtbk1ldHJpY3M6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHJldmVyc2VkWEF4aXMgPSB4QXhpcy5yZXZlcnNlZCxcblx0XHRcdHN0YWNrS2V5LFxuXHRcdFx0c3RhY2tHcm91cHMgPSB7fSxcblx0XHRcdGNvbHVtbkluZGV4LFxuXHRcdFx0Y29sdW1uQ291bnQgPSAwO1xuXG5cdFx0Ly8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1uIHR5cGUgc2VyaWVzLlxuXHRcdC8vIFRoaXMgaXMgY2FsbGVkIG9uIGV2ZXJ5IHNlcmllcy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgbG9naWMgdG8gYVxuXHRcdC8vIGNoYXJ0Lm9yZGVyU3RhY2tzKCkgZnVuY3Rpb24gYW5kIGNhbGwgaXQgb24gaW5pdCwgYWRkU2VyaWVzIGFuZCByZW1vdmVTZXJpZXNcblx0XHRpZiAob3B0aW9ucy5ncm91cGluZyA9PT0gZmFsc2UpIHtcblx0XHRcdGNvbHVtbkNvdW50ID0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWFjaChzZXJpZXMuY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0dmFyIG90aGVyT3B0aW9ucyA9IG90aGVyU2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdFx0b3RoZXJZQXhpcyA9IG90aGVyU2VyaWVzLnlBeGlzO1xuXHRcdFx0XHRpZiAob3RoZXJTZXJpZXMudHlwZSA9PT0gc2VyaWVzLnR5cGUgJiYgb3RoZXJTZXJpZXMudmlzaWJsZSAmJlxuXHRcdFx0XHRcdFx0eUF4aXMubGVuID09PSBvdGhlcllBeGlzLmxlbiAmJiB5QXhpcy5wb3MgPT09IG90aGVyWUF4aXMucG9zKSB7ICAvLyAjNjQyLCAjMjA4NlxuXHRcdFx0XHRcdGlmIChvdGhlck9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0XHRcdHN0YWNrS2V5ID0gb3RoZXJTZXJpZXMuc3RhY2tLZXk7XG5cdFx0XHRcdFx0XHRpZiAoc3RhY2tHcm91cHNbc3RhY2tLZXldID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0c3RhY2tHcm91cHNbc3RhY2tLZXldID0gY29sdW1uQ291bnQrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbHVtbkluZGV4ID0gc3RhY2tHcm91cHNbc3RhY2tLZXldO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAob3RoZXJPcHRpb25zLmdyb3VwaW5nICE9PSBmYWxzZSkgeyAvLyAjMTE2MlxuXHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBjb2x1bW5Db3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvdGhlclNlcmllcy5jb2x1bW5JbmRleCA9IGNvbHVtbkluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgY2F0ZWdvcnlXaWR0aCA9IG1hdGhNaW4oXG5cdFx0XHRcdG1hdGhBYnMoeEF4aXMudHJhbnNBKSAqICh4QXhpcy5vcmRpbmFsU2xvcGUgfHwgb3B0aW9ucy5wb2ludFJhbmdlIHx8IHhBeGlzLmNsb3Nlc3RQb2ludFJhbmdlIHx8IDEpLCBcblx0XHRcdFx0eEF4aXMubGVuIC8vICMxNTM1XG5cdFx0XHQpLFxuXHRcdFx0Z3JvdXBQYWRkaW5nID0gY2F0ZWdvcnlXaWR0aCAqIG9wdGlvbnMuZ3JvdXBQYWRkaW5nLFxuXHRcdFx0Z3JvdXBXaWR0aCA9IGNhdGVnb3J5V2lkdGggLSAyICogZ3JvdXBQYWRkaW5nLFxuXHRcdFx0cG9pbnRPZmZzZXRXaWR0aCA9IGdyb3VwV2lkdGggLyBjb2x1bW5Db3VudCxcblx0XHRcdG9wdGlvblBvaW50V2lkdGggPSBvcHRpb25zLnBvaW50V2lkdGgsXG5cdFx0XHRwb2ludFBhZGRpbmcgPSBkZWZpbmVkKG9wdGlvblBvaW50V2lkdGgpID8gKHBvaW50T2Zmc2V0V2lkdGggLSBvcHRpb25Qb2ludFdpZHRoKSAvIDIgOlxuXHRcdFx0XHRwb2ludE9mZnNldFdpZHRoICogb3B0aW9ucy5wb2ludFBhZGRpbmcsXG5cdFx0XHRwb2ludFdpZHRoID0gcGljayhvcHRpb25Qb2ludFdpZHRoLCBwb2ludE9mZnNldFdpZHRoIC0gMiAqIHBvaW50UGFkZGluZyksIC8vIGV4YWN0IHBvaW50IHdpZHRoLCB1c2VkIGluIHBvbGFyIGNoYXJ0c1xuXHRcdFx0Y29sSW5kZXggPSAocmV2ZXJzZWRYQXhpcyA/IFxuXHRcdFx0XHRjb2x1bW5Db3VudCAtIChzZXJpZXMuY29sdW1uSW5kZXggfHwgMCkgOiAvLyAjMTI1MVxuXHRcdFx0XHRzZXJpZXMuY29sdW1uSW5kZXgpIHx8IDAsXG5cdFx0XHRwb2ludFhPZmZzZXQgPSBwb2ludFBhZGRpbmcgKyAoZ3JvdXBQYWRkaW5nICsgY29sSW5kZXggKlxuXHRcdFx0XHRwb2ludE9mZnNldFdpZHRoIC0gKGNhdGVnb3J5V2lkdGggLyAyKSkgKlxuXHRcdFx0XHQocmV2ZXJzZWRYQXhpcyA/IC0xIDogMSk7XG5cblx0XHQvLyBTYXZlIGl0IGZvciByZWFkaW5nIGluIGxpbmtlZCBzZXJpZXMgKEVycm9yIGJhcnMgcGFydGljdWxhcmx5KVxuXHRcdHJldHVybiAoc2VyaWVzLmNvbHVtbk1ldHJpY3MgPSB7IFxuXHRcdFx0d2lkdGg6IHBvaW50V2lkdGgsIFxuXHRcdFx0b2Zmc2V0OiBwb2ludFhPZmZzZXQgXG5cdFx0fSk7XG5cdFx0XHRcblx0fSxcblxuXHQvKipcblx0ICogVHJhbnNsYXRlIGVhY2ggcG9pbnQgdG8gdGhlIHBsb3QgYXJlYSBjb29yZGluYXRlIHN5c3RlbSBhbmQgZmluZCBzaGFwZSBwb3NpdGlvbnNcblx0ICovXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHNlcmllcy50cmFuc2xhdGVkVGhyZXNob2xkID0geUF4aXMuZ2V0VGhyZXNob2xkKHRocmVzaG9sZCksXG5cdFx0XHRtaW5Qb2ludExlbmd0aCA9IHBpY2sob3B0aW9ucy5taW5Qb2ludExlbmd0aCwgNSksXG5cdFx0XHRtZXRyaWNzID0gc2VyaWVzLmdldENvbHVtbk1ldHJpY3MoKSxcblx0XHRcdHBvaW50V2lkdGggPSBtZXRyaWNzLndpZHRoLFxuXHRcdFx0c2VyaWVzQmFyVyA9IHNlcmllcy5iYXJXID0gbWF0aENlaWwobWF0aE1heChwb2ludFdpZHRoLCAxICsgMiAqIGJvcmRlcldpZHRoKSksIC8vIHJvdW5kZWQgYW5kIHBvc3Rwcm9jZXNzZWQgZm9yIGJvcmRlciB3aWR0aFxuXHRcdFx0cG9pbnRYT2Zmc2V0ID0gc2VyaWVzLnBvaW50WE9mZnNldCA9IG1ldHJpY3Mub2Zmc2V0LFxuXHRcdFx0eENyaXNwID0gLShib3JkZXJXaWR0aCAlIDIgPyAwLjUgOiAwKSxcblx0XHRcdHlDcmlzcCA9IGJvcmRlcldpZHRoICUgMiA/IDAuNSA6IDE7XG5cblx0XHRpZiAoY2hhcnQucmVuZGVyZXIuaXNWTUwgJiYgY2hhcnQuaW52ZXJ0ZWQpIHtcblx0XHRcdHlDcmlzcCArPSAxO1xuXHRcdH1cblxuXHRcdFNlcmllcy5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KHNlcmllcyk7XG5cblx0XHQvLyByZWNvcmQgdGhlIG5ldyB2YWx1ZXNcblx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIHlCb3R0b20gPSBwaWNrKHBvaW50LnlCb3R0b20sIHRyYW5zbGF0ZWRUaHJlc2hvbGQpLFxuXHRcdFx0XHRwbG90WSA9IG1hdGhNaW4obWF0aE1heCgtOTk5IC0geUJvdHRvbSwgcG9pbnQucGxvdFkpLCB5QXhpcy5sZW4gKyA5OTkgKyB5Qm90dG9tKSwgLy8gRG9uJ3QgZHJhdyB0b28gZmFyIG91dHNpZGUgcGxvdCBhcmVhICgjMTMwMywgIzIyNDEpXG5cdFx0XHRcdGJhclggPSBwb2ludC5wbG90WCArIHBvaW50WE9mZnNldCxcblx0XHRcdFx0YmFyVyA9IHNlcmllc0JhclcsXG5cdFx0XHRcdGJhclkgPSBtYXRoTWluKHBsb3RZLCB5Qm90dG9tKSxcblx0XHRcdFx0cmlnaHQsXG5cdFx0XHRcdGJvdHRvbSxcblx0XHRcdFx0ZnJvbVRvcCxcblx0XHRcdFx0ZnJvbUxlZnQsXG5cdFx0XHRcdGJhckggPSBtYXRoTWF4KHBsb3RZLCB5Qm90dG9tKSAtIGJhclk7XG5cblx0XHRcdC8vIEhhbmRsZSBvcHRpb25zLm1pblBvaW50TGVuZ3RoXG5cdFx0XHRpZiAobWF0aEFicyhiYXJIKSA8IG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChtaW5Qb2ludExlbmd0aCkge1xuXHRcdFx0XHRcdGJhckggPSBtaW5Qb2ludExlbmd0aDtcblx0XHRcdFx0XHRiYXJZID1cblx0XHRcdFx0XHRcdG1hdGhSb3VuZChtYXRoQWJzKGJhclkgLSB0cmFuc2xhdGVkVGhyZXNob2xkKSA+IG1pblBvaW50TGVuZ3RoID8gLy8gc3RhY2tlZFxuXHRcdFx0XHRcdFx0XHR5Qm90dG9tIC0gbWluUG9pbnRMZW5ndGggOiAvLyBrZWVwIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSAoeUF4aXMudHJhbnNsYXRlKHBvaW50LnksIDAsIDEsIDAsIDEpIDw9IHRyYW5zbGF0ZWRUaHJlc2hvbGQgPyBtaW5Qb2ludExlbmd0aCA6IDApKTsgLy8gdXNlIGV4YWN0IHlBeGlzLnRyYW5zbGF0aW9uICgjMTQ4NSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSBmb3IgYWNjZXNzIGluIHBvbGFyXG5cdFx0XHRwb2ludC5iYXJYID0gYmFyWDtcblx0XHRcdHBvaW50LnBvaW50V2lkdGggPSBwb2ludFdpZHRoO1xuXG5cblx0XHRcdC8vIFJvdW5kIG9mZiB0byBvYnRhaW4gY3Jpc3AgZWRnZXNcblx0XHRcdGZyb21MZWZ0ID0gbWF0aEFicyhiYXJYKSA8IDAuNTtcblx0XHRcdHJpZ2h0ID0gbWF0aFJvdW5kKGJhclggKyBiYXJXKSArIHhDcmlzcDtcblx0XHRcdGJhclggPSBtYXRoUm91bmQoYmFyWCkgKyB4Q3Jpc3A7XG5cdFx0XHRiYXJXID0gcmlnaHQgLSBiYXJYO1xuXG5cdFx0XHRmcm9tVG9wID0gbWF0aEFicyhiYXJZKSA8IDAuNTtcblx0XHRcdGJvdHRvbSA9IG1hdGhSb3VuZChiYXJZICsgYmFySCkgKyB5Q3Jpc3A7XG5cdFx0XHRiYXJZID0gbWF0aFJvdW5kKGJhclkpICsgeUNyaXNwO1xuXHRcdFx0YmFySCA9IGJvdHRvbSAtIGJhclk7XG5cblx0XHRcdC8vIFRvcCBhbmQgbGVmdCBlZGdlcyBhcmUgZXhjZXB0aW9uc1xuXHRcdFx0aWYgKGZyb21MZWZ0KSB7XG5cdFx0XHRcdGJhclggKz0gMTtcblx0XHRcdFx0YmFyVyAtPSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZyb21Ub3ApIHtcblx0XHRcdFx0YmFyWSAtPSAxO1xuXHRcdFx0XHRiYXJIICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZ2lzdGVyIHNoYXBlIHR5cGUgYW5kIGFyZ3VtZW50cyB0byBiZSB1c2VkIGluIGRyYXdQb2ludHNcblx0XHRcdHBvaW50LnNoYXBlVHlwZSA9ICdyZWN0Jztcblx0XHRcdHBvaW50LnNoYXBlQXJncyA9IHtcblx0XHRcdFx0eDogYmFyWCxcblx0XHRcdFx0eTogYmFyWSxcblx0XHRcdFx0d2lkdGg6IGJhclcsXG5cdFx0XHRcdGhlaWdodDogYmFySFxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHR9LFxuXG5cdGdldFN5bWJvbDogbm9vcCxcblx0XG5cdC8qKlxuXHQgKiBVc2UgYSBzb2xpZCByZWN0YW5nbGUgbGlrZSB0aGUgYXJlYSBzZXJpZXMgdHlwZXNcblx0ICovXG5cdGRyYXdMZWdlbmRTeW1ib2w6IEFyZWFTZXJpZXMucHJvdG90eXBlLmRyYXdMZWdlbmRTeW1ib2wsXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbHVtbnMgaGF2ZSBubyBncmFwaFxuXHQgKi9cblx0ZHJhd0dyYXBoOiBub29wLFxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBjb2x1bW5zLiBGb3IgYmFycywgdGhlIHNlcmllcy5ncm91cCBpcyByb3RhdGVkLCBzbyB0aGUgc2FtZSBjb29yZGluYXRlc1xuXHQgKiBhcHBseSBmb3IgY29sdW1ucyBhbmQgYmFycy4gVGhpcyBtZXRob2QgaXMgaW5oZXJpdGVkIGJ5IHNjYXR0ZXIgc2VyaWVzLlxuXHQgKlxuXHQgKi9cblx0ZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0cmVuZGVyZXIgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRzaGFwZUFyZ3M7XG5cblxuXHRcdC8vIGRyYXcgdGhlIGNvbHVtbnNcblx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljO1xuXG5cdFx0XHRpZiAocGxvdFkgIT09IFVOREVGSU5FRCAmJiAhaXNOYU4ocGxvdFkpICYmIHBvaW50LnkgIT09IG51bGwpIHtcblx0XHRcdFx0c2hhcGVBcmdzID0gcG9pbnQuc2hhcGVBcmdzO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGdyYXBoaWMpIHsgLy8gdXBkYXRlXG5cdFx0XHRcdFx0c3RvcChncmFwaGljKTtcblx0XHRcdFx0XHRncmFwaGljLmFuaW1hdGUobWVyZ2Uoc2hhcGVBcmdzKSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IHJlbmRlcmVyW3BvaW50LnNoYXBlVHlwZV0oc2hhcGVBcmdzKVxuXHRcdFx0XHRcdFx0LmF0dHIocG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXSlcblx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zLnNoYWRvdywgbnVsbCwgb3B0aW9ucy5zdGFja2luZyAmJiAhb3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7IC8vICMxMjY5XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCB0cmFja2luZyBldmVudCBsaXN0ZW5lciB0byB0aGUgc2VyaWVzIGdyb3VwLCBzbyB0aGUgcG9pbnQgZ3JhcGhpY3Ncblx0ICogdGhlbXNlbHZlcyBhY3QgYXMgdHJhY2tlcnNcblx0ICovXG5cdGRyYXdUcmFja2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHBvaW50ZXIgPSBjaGFydC5wb2ludGVyLFxuXHRcdFx0Y3Vyc29yID0gc2VyaWVzLm9wdGlvbnMuY3Vyc29yLFxuXHRcdFx0Y3NzID0gY3Vyc29yICYmIHsgY3Vyc29yOiBjdXJzb3IgfSxcblx0XHRcdG9uTW91c2VPdmVyID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdFx0XHRcdHBvaW50O1xuXG5cdFx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdmVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKHRhcmdldCAmJiAhcG9pbnQpIHtcblx0XHRcdFx0XHRwb2ludCA9IHRhcmdldC5wb2ludDtcblx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocG9pbnQgIT09IFVOREVGSU5FRCAmJiBwb2ludCAhPT0gY2hhcnQuaG92ZXJQb2ludCkgeyAvLyB1bmRlZmluZWQgb24gZ3JhcGggaW4gc2NhdHRlcmNoYXJ0XG5cdFx0XHRcdFx0cG9pbnQub25Nb3VzZU92ZXIoZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBZGQgcmVmZXJlbmNlIHRvIHRoZSBwb2ludFxuXHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRpZiAocG9pbnQuZ3JhcGhpYykge1xuXHRcdFx0XHRwb2ludC5ncmFwaGljLmVsZW1lbnQucG9pbnQgPSBwb2ludDtcblx0XHRcdH1cblx0XHRcdGlmIChwb2ludC5kYXRhTGFiZWwpIHtcblx0XHRcdFx0cG9pbnQuZGF0YUxhYmVsLmVsZW1lbnQucG9pbnQgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzLCB3ZSBuZWVkIHRvIGRvIHRoaXMgb25seSBvbmNlXG5cdFx0aWYgKCFzZXJpZXMuX2hhc1RyYWNraW5nKSB7XG5cdFx0XHRlYWNoKHNlcmllcy50cmFja2VyR3JvdXBzLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChzZXJpZXNba2V5XSkgeyAvLyB3ZSBkb24ndCBhbHdheXMgaGF2ZSBkYXRhTGFiZWxzR3JvdXBcblx0XHRcdFx0XHRzZXJpZXNba2V5XVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArICd0cmFja2VyJylcblx0XHRcdFx0XHRcdC5vbignbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpXG5cdFx0XHRcdFx0XHQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHsgcG9pbnRlci5vblRyYWNrZXJNb3VzZU91dChlKTsgfSlcblx0XHRcdFx0XHRcdC5jc3MoY3NzKTtcblx0XHRcdFx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdFx0XHRcdHNlcmllc1trZXldLm9uKCd0b3VjaHN0YXJ0Jywgb25Nb3VzZU92ZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRzZXJpZXMuX2hhc1RyYWNraW5nID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKiogXG5cdCAqIE92ZXJyaWRlIHRoZSBiYXNpYyBkYXRhIGxhYmVsIGFsaWdubWVudCBieSBhZGp1c3RpbmcgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uXG5cdCAqL1xuXHRhbGlnbkRhdGFMYWJlbDogZnVuY3Rpb24gKHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsICBhbGlnblRvLCBpc05ldykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0ZGxCb3ggPSBwb2ludC5kbEJveCB8fCBwb2ludC5zaGFwZUFyZ3MsIC8vIGRhdGEgbGFiZWwgYm94IGZvciBhbGlnbm1lbnRcblx0XHRcdGJlbG93ID0gcG9pbnQuYmVsb3cgfHwgKHBvaW50LnBsb3RZID4gcGljayh0aGlzLnRyYW5zbGF0ZWRUaHJlc2hvbGQsIGNoYXJ0LnBsb3RTaXplWSkpLFxuXHRcdFx0aW5zaWRlID0gcGljayhvcHRpb25zLmluc2lkZSwgISF0aGlzLm9wdGlvbnMuc3RhY2tpbmcpOyAvLyBkcmF3IGl0IGluc2lkZSB0aGUgYm94P1xuXHRcdFxuXHRcdC8vIEFsaWduIHRvIHRoZSBjb2x1bW4gaXRzZWxmLCBvciB0aGUgdG9wIG9mIGl0XG5cdFx0aWYgKGRsQm94KSB7IC8vIEFyZWEgcmFuZ2UgdXNlcyB0aGlzIG1ldGhvZCBidXQgbm90IGFsaWduVG9cblx0XHRcdGFsaWduVG8gPSBtZXJnZShkbEJveCk7XG5cdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0YWxpZ25UbyA9IHtcblx0XHRcdFx0XHR4OiBjaGFydC5wbG90V2lkdGggLSBhbGlnblRvLnkgLSBhbGlnblRvLmhlaWdodCxcblx0XHRcdFx0XHR5OiBjaGFydC5wbG90SGVpZ2h0IC0gYWxpZ25Uby54IC0gYWxpZ25Uby53aWR0aCxcblx0XHRcdFx0XHR3aWR0aDogYWxpZ25Uby5oZWlnaHQsXG5cdFx0XHRcdFx0aGVpZ2h0OiBhbGlnblRvLndpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0Ly8gQ29tcHV0ZSB0aGUgYWxpZ25tZW50IGJveFxuXHRcdFx0aWYgKCFpbnNpZGUpIHtcblx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0YWxpZ25Uby54ICs9IGJlbG93ID8gMCA6IGFsaWduVG8ud2lkdGg7XG5cdFx0XHRcdFx0YWxpZ25Uby53aWR0aCA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWxpZ25Uby55ICs9IGJlbG93ID8gYWxpZ25Uby5oZWlnaHQgOiAwO1xuXHRcdFx0XHRcdGFsaWduVG8uaGVpZ2h0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBXaGVuIGFsaWdubWVudCBpcyB1bmRlZmluZWQgKHR5cGljYWxseSBjb2x1bW5zIGFuZCBiYXJzKSwgZGlzcGxheSB0aGUgaW5kaXZpZHVhbCBcblx0XHQvLyBwb2ludCBiZWxvdyBvciBhYm92ZSB0aGUgcG9pbnQgZGVwZW5kaW5nIG9uIHRoZSB0aHJlc2hvbGRcblx0XHRvcHRpb25zLmFsaWduID0gcGljayhcblx0XHRcdG9wdGlvbnMuYWxpZ24sIFxuXHRcdFx0IWludmVydGVkIHx8IGluc2lkZSA/ICdjZW50ZXInIDogYmVsb3cgPyAncmlnaHQnIDogJ2xlZnQnXG5cdFx0KTtcblx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24gPSBwaWNrKFxuXHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduLCBcblx0XHRcdGludmVydGVkIHx8IGluc2lkZSA/ICdtaWRkbGUnIDogYmVsb3cgPyAndG9wJyA6ICdib3R0b20nXG5cdFx0KTtcblx0XHRcblx0XHQvLyBDYWxsIHRoZSBwYXJlbnQgbWV0aG9kXG5cdFx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsIHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduVG8sIGlzTmV3KTtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBBbmltYXRlIHRoZSBjb2x1bW4gaGVpZ2h0cyBvbmUgYnkgb25lIGZyb20gemVyb1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgV2hldGhlciB0byBpbml0aWFsaXplIHRoZSBhbmltYXRpb24gb3IgcnVuIGl0XG5cdCAqL1xuXHRhbmltYXRlOiBmdW5jdGlvbiAoaW5pdCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0aW52ZXJ0ZWQgPSB0aGlzLmNoYXJ0LmludmVydGVkLFxuXHRcdFx0YXR0ciA9IHt9LFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZDtcblxuXHRcdGlmIChoYXNTVkcpIHsgLy8gVk1MIGlzIHRvbyBzbG93IGFueXdheVxuXHRcdFx0aWYgKGluaXQpIHtcblx0XHRcdFx0YXR0ci5zY2FsZVkgPSAwLjAwMTtcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IG1hdGhNaW4oeUF4aXMucG9zICsgeUF4aXMubGVuLCBtYXRoTWF4KHlBeGlzLnBvcywgeUF4aXMudG9QaXhlbHMob3B0aW9ucy50aHJlc2hvbGQpKSk7XG5cdFx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHRcdGF0dHIudHJhbnNsYXRlWCA9IHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSB5QXhpcy5sZW47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVZID0gdHJhbnNsYXRlZFRocmVzaG9sZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXJpZXMuZ3JvdXAuYXR0cihhdHRyKTtcblxuXHRcdFx0fSBlbHNlIHsgLy8gcnVuIHRoZSBhbmltYXRpb25cblx0XHRcdFx0XG5cdFx0XHRcdGF0dHIuc2NhbGVZID0gMTtcblx0XHRcdFx0YXR0cltpbnZlcnRlZCA/ICd0cmFuc2xhdGVYJyA6ICd0cmFuc2xhdGVZJ10gPSB5QXhpcy5wb3M7XG5cdFx0XHRcdHNlcmllcy5ncm91cC5hbmltYXRlKGF0dHIsIHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbik7XG5cblx0XHRcdFx0Ly8gZGVsZXRlIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgaXQgb25seSBvbmNlXG5cdFx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIHRoaXMgc2VyaWVzIGZyb20gdGhlIGNoYXJ0XG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXG5cdFx0Ly8gY29sdW1uIGFuZCBiYXIgc2VyaWVzIGFmZmVjdHMgb3RoZXIgc2VyaWVzIG9mIHRoZSBzYW1lIHR5cGVcblx0XHQvLyBhcyB0aGV5IGFyZSBlaXRoZXIgc3RhY2tlZCBvciBncm91cGVkXG5cdFx0aWYgKGNoYXJ0Lmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSkge1xuXHRcdFx0XHRcdG90aGVyU2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRTZXJpZXMucHJvdG90eXBlLnJlbW92ZS5hcHBseShzZXJpZXMsIGFyZ3VtZW50cyk7XG5cdH1cbn0pO1xuc2VyaWVzVHlwZXMuY29sdW1uID0gQ29sdW1uU2VyaWVzO1xuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYmFyXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5iYXIgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuY29sdW1uKTtcbi8qKlxuICogVGhlIEJhciBzZXJpZXMgY2xhc3NcbiAqL1xudmFyIEJhclNlcmllcyA9IGV4dGVuZENsYXNzKENvbHVtblNlcmllcywge1xuXHR0eXBlOiAnYmFyJyxcblx0aW52ZXJ0ZWQ6IHRydWVcbn0pO1xuc2VyaWVzVHlwZXMuYmFyID0gQmFyU2VyaWVzO1xuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBzY2F0dGVyXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5zY2F0dGVyID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0bGluZVdpZHRoOiAwLFxuXHR0b29sdGlwOiB7XG5cdFx0aGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHg7IGNvbG9yOntzZXJpZXMuY29sb3J9XCI+e3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicsXG5cdFx0cG9pbnRGb3JtYXQ6ICd4OiA8Yj57cG9pbnQueH08L2I+PGJyLz55OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLFxuXHRcdGZvbGxvd1BvaW50ZXI6IHRydWVcblx0fSxcblx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBUaGUgc2NhdHRlciBzZXJpZXMgY2xhc3NcbiAqL1xudmFyIFNjYXR0ZXJTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0dHlwZTogJ3NjYXR0ZXInLFxuXHRzb3J0ZWQ6IGZhbHNlLFxuXHRyZXF1aXJlU29ydGluZzogZmFsc2UsXG5cdG5vU2hhcmVkVG9vbHRpcDogdHJ1ZSxcblx0dHJhY2tlckdyb3VwczogWydtYXJrZXJHcm91cCddLFxuXG5cdGRyYXdUcmFja2VyOiBDb2x1bW5TZXJpZXMucHJvdG90eXBlLmRyYXdUcmFja2VyLFxuXHRcblx0c2V0VG9vbHRpcFBvaW50czogbm9vcFxufSk7XG5zZXJpZXNUeXBlcy5zY2F0dGVyID0gU2NhdHRlclNlcmllcztcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgcGllXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5waWUgPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRib3JkZXJDb2xvcjogJyNGRkZGRkYnLFxuXHRib3JkZXJXaWR0aDogMSxcblx0Y2VudGVyOiBbbnVsbCwgbnVsbF0sXG5cdGNsaXA6IGZhbHNlLFxuXHRjb2xvckJ5UG9pbnQ6IHRydWUsIC8vIGFsd2F5cyB0cnVlIGZvciBwaWVzXG5cdGRhdGFMYWJlbHM6IHtcblx0XHQvLyBhbGlnbjogbnVsbCxcblx0XHQvLyBjb25uZWN0b3JXaWR0aDogMSxcblx0XHQvLyBjb25uZWN0b3JDb2xvcjogcG9pbnQuY29sb3IsXG5cdFx0Ly8gY29ubmVjdG9yUGFkZGluZzogNSxcblx0XHRkaXN0YW5jZTogMzAsXG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnBvaW50Lm5hbWU7XG5cdFx0fVxuXHRcdC8vIHNvZnRDb25uZWN0b3I6IHRydWUsXG5cdFx0Ly95OiAwXG5cdH0sXG5cdGlnbm9yZUhpZGRlblBvaW50OiB0cnVlLFxuXHQvL2lubmVyU2l6ZTogMCxcblx0bGVnZW5kVHlwZTogJ3BvaW50Jyxcblx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRzaXplOiBudWxsLFxuXHRzaG93SW5MZWdlbmQ6IGZhbHNlLFxuXHRzbGljZWRPZmZzZXQ6IDEwLFxuXHRzdGF0ZXM6IHtcblx0XHRob3Zlcjoge1xuXHRcdFx0YnJpZ2h0bmVzczogMC4xLFxuXHRcdFx0c2hhZG93OiBmYWxzZVxuXHRcdH1cblx0fSxcblx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuXHR0b29sdGlwOiB7XG5cdFx0Zm9sbG93UG9pbnRlcjogdHJ1ZVxuXHR9XG59KTtcblxuLyoqXG4gKiBFeHRlbmRlZCBwb2ludCBvYmplY3QgZm9yIHBpZXNcbiAqL1xudmFyIFBpZVBvaW50ID0gZXh0ZW5kQ2xhc3MoUG9pbnQsIHtcblx0LyoqXG5cdCAqIEluaXRpYXRlIHRoZSBwaWUgc2xpY2Vcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFBvaW50LnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0dG9nZ2xlU2xpY2U7XG5cblx0XHQvLyBEaXNhbGxvdyBuZWdhdGl2ZSB2YWx1ZXMgKCMxNTMwKVxuXHRcdGlmIChwb2ludC55IDwgMCkge1xuXHRcdFx0cG9pbnQueSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly92aXNpYmxlOiBvcHRpb25zLnZpc2libGUgIT09IGZhbHNlLFxuXHRcdGV4dGVuZChwb2ludCwge1xuXHRcdFx0dmlzaWJsZTogcG9pbnQudmlzaWJsZSAhPT0gZmFsc2UsXG5cdFx0XHRuYW1lOiBwaWNrKHBvaW50Lm5hbWUsICdTbGljZScpXG5cdFx0fSk7XG5cblx0XHQvLyBhZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHNlbGVjdFxuXHRcdHRvZ2dsZVNsaWNlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdHBvaW50LnNsaWNlKGUudHlwZSA9PT0gJ3NlbGVjdCcpO1xuXHRcdH07XG5cdFx0YWRkRXZlbnQocG9pbnQsICdzZWxlY3QnLCB0b2dnbGVTbGljZSk7XG5cdFx0YWRkRXZlbnQocG9pbnQsICd1bnNlbGVjdCcsIHRvZ2dsZVNsaWNlKTtcblxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwaWUgc2xpY2Vcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXMgV2hldGhlciB0byBzaG93IHRoZSBzbGljZSBvciBub3QuIElmIHVuZGVmaW5lZCwgdGhlXG5cdCAqICAgIHZpc2liaWxpdHkgaXMgdG9nZ2xlZFxuXHQgKi9cblx0c2V0VmlzaWJsZTogZnVuY3Rpb24gKHZpcykge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdG1ldGhvZDtcblxuXHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGUgdmlzaWJpbGl0eVxuXHRcdHBvaW50LnZpc2libGUgPSBwb2ludC5vcHRpb25zLnZpc2libGUgPSB2aXMgPSB2aXMgPT09IFVOREVGSU5FRCA/ICFwb2ludC52aXNpYmxlIDogdmlzO1xuXHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShwb2ludCwgc2VyaWVzLmRhdGEpXSA9IHBvaW50Lm9wdGlvbnM7IC8vIHVwZGF0ZSB1c2VyT3B0aW9ucy5kYXRhXG5cdFx0XG5cdFx0bWV0aG9kID0gdmlzID8gJ3Nob3cnIDogJ2hpZGUnO1xuXG5cdFx0Ly8gU2hvdyBhbmQgaGlkZSBhc3NvY2lhdGVkIGVsZW1lbnRzXG5cdFx0ZWFjaChbJ2dyYXBoaWMnLCAnZGF0YUxhYmVsJywgJ2Nvbm5lY3RvcicsICdzaGFkb3dHcm91cCddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAocG9pbnRba2V5XSkge1xuXHRcdFx0XHRwb2ludFtrZXldW21ldGhvZF0oKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChwb2ludC5sZWdlbmRJdGVtKSB7XG5cdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHBvaW50LCB2aXMpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBIYW5kbGUgaWdub3JlIGhpZGRlbiBzbGljZXNcblx0XHRpZiAoIXNlcmllcy5pc0RpcnR5ICYmIHNlcmllcy5vcHRpb25zLmlnbm9yZUhpZGRlblBvaW50KSB7XG5cdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBvciB0b2dnbGUgd2hldGhlciB0aGUgc2xpY2UgaXMgY3V0IG91dCBmcm9tIHRoZSBwaWVcblx0ICogQHBhcmFtIHtCb29sZWFufSBzbGljZWQgV2hlbiB1bmRlZmluZWQsIHRoZSBzbGljZSBzdGF0ZSBpcyB0b2dnbGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydC4gVHJ1ZSBieSBkZWZhdWx0LlxuXHQgKi9cblx0c2xpY2U6IGZ1bmN0aW9uIChzbGljZWQsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0dHJhbnNsYXRpb247XG5cblx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHQvLyByZWRyYXcgaXMgdHJ1ZSBieSBkZWZhdWx0XG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZVxuXHRcdHBvaW50LnNsaWNlZCA9IHBvaW50Lm9wdGlvbnMuc2xpY2VkID0gc2xpY2VkID0gZGVmaW5lZChzbGljZWQpID8gc2xpY2VkIDogIXBvaW50LnNsaWNlZDtcblx0XHRzZXJpZXMub3B0aW9ucy5kYXRhW2luQXJyYXkocG9pbnQsIHNlcmllcy5kYXRhKV0gPSBwb2ludC5vcHRpb25zOyAvLyB1cGRhdGUgdXNlck9wdGlvbnMuZGF0YVxuXG5cdFx0dHJhbnNsYXRpb24gPSBzbGljZWQgPyBwb2ludC5zbGljZWRUcmFuc2xhdGlvbiA6IHtcblx0XHRcdHRyYW5zbGF0ZVg6IDAsXG5cdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0fTtcblxuXHRcdHBvaW50LmdyYXBoaWMuYW5pbWF0ZSh0cmFuc2xhdGlvbik7XG5cdFx0XG5cdFx0aWYgKHBvaW50LnNoYWRvd0dyb3VwKSB7XG5cdFx0XHRwb2ludC5zaGFkb3dHcm91cC5hbmltYXRlKHRyYW5zbGF0aW9uKTtcblx0XHR9XG5cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIFBpZSBzZXJpZXMgY2xhc3NcbiAqL1xudmFyIFBpZVNlcmllcyA9IHtcblx0dHlwZTogJ3BpZScsXG5cdGlzQ2FydGVzaWFuOiBmYWxzZSxcblx0cG9pbnRDbGFzczogUGllUG9pbnQsXG5cdHJlcXVpcmVTb3J0aW5nOiBmYWxzZSxcblx0bm9TaGFyZWRUb29sdGlwOiB0cnVlLFxuXHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0c3Ryb2tlOiAnYm9yZGVyQ29sb3InLFxuXHRcdCdzdHJva2Utd2lkdGgnOiAnYm9yZGVyV2lkdGgnLFxuXHRcdGZpbGw6ICdjb2xvcidcblx0fSxcblxuXHQvKipcblx0ICogUGllcyBoYXZlIG9uZSBjb2xvciBlYWNoIHBvaW50XG5cdCAqL1xuXHRnZXRDb2xvcjogbm9vcCxcblxuXHQvKipcblx0ICogQW5pbWF0ZSB0aGUgcGllcyBpblxuXHQgKi9cblx0YW5pbWF0ZTogZnVuY3Rpb24gKGluaXQpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRzdGFydEFuZ2xlUmFkID0gc2VyaWVzLnN0YXJ0QW5nbGVSYWQ7XG5cblx0XHRpZiAoIWluaXQpIHtcblx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0dmFyIGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRcdGFyZ3MgPSBwb2ludC5zaGFwZUFyZ3M7XG5cblx0XHRcdFx0aWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHQvLyBzdGFydCB2YWx1ZXNcblx0XHRcdFx0XHRncmFwaGljLmF0dHIoe1xuXHRcdFx0XHRcdFx0cjogc2VyaWVzLmNlbnRlclszXSAvIDIsIC8vIGFuaW1hdGUgZnJvbSBpbm5lciByYWRpdXMgKCM3NzkpXG5cdFx0XHRcdFx0XHRzdGFydDogc3RhcnRBbmdsZVJhZCxcblx0XHRcdFx0XHRcdGVuZDogc3RhcnRBbmdsZVJhZFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gYW5pbWF0ZVxuXHRcdFx0XHRcdGdyYXBoaWMuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHRyOiBhcmdzLnIsXG5cdFx0XHRcdFx0XHRzdGFydDogYXJncy5zdGFydCxcblx0XHRcdFx0XHRcdGVuZDogYXJncy5lbmRcblx0XHRcdFx0XHR9LCBzZXJpZXMub3B0aW9ucy5hbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZGVsZXRlIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgaXQgb25seSBvbmNlXG5cdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgdGhlIGJhc2ljIHNldERhdGEgbWV0aG9kIGJ5IHJ1bm5pbmcgcHJvY2Vzc0RhdGEgYW5kIGdlbmVyYXRlUG9pbnRzIGltbWVkaWF0ZWx5LFxuXHQgKiBpbiBvcmRlciB0byBhY2Nlc3MgdGhlIHBvaW50cyBmcm9tIHRoZSBsZWdlbmQuXG5cdCAqL1xuXHRzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSwgcmVkcmF3KSB7XG5cdFx0U2VyaWVzLnByb3RvdHlwZS5zZXREYXRhLmNhbGwodGhpcywgZGF0YSwgZmFsc2UpO1xuXHRcdHRoaXMucHJvY2Vzc0RhdGEoKTtcblx0XHR0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG5cdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0dGhpcy5jaGFydC5yZWRyYXcoKTtcblx0XHR9IFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgdGhlIGdlbmVyYXRlUG9pbnRzIG1ldGhvZCBieSBhZGRpbmcgdG90YWwgYW5kIHBlcmNlbnRhZ2UgcHJvcGVydGllcyB0byBlYWNoIHBvaW50XG5cdCAqL1xuXHRnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpLFxuXHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0cG9pbnRzLFxuXHRcdFx0bGVuLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHRpZ25vcmVIaWRkZW5Qb2ludCA9IHRoaXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcblxuXHRcdFNlcmllcy5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFBvcHVsYXRlIGxvY2FsIHZhcnNcblx0XHRwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRsZW4gPSBwb2ludHMubGVuZ3RoO1xuXHRcdFxuXHRcdC8vIEdldCB0aGUgdG90YWwgc3VtXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdHRvdGFsICs9IChpZ25vcmVIaWRkZW5Qb2ludCAmJiAhcG9pbnQudmlzaWJsZSkgPyAwIDogcG9pbnQueTtcblx0XHR9XG5cdFx0dGhpcy50b3RhbCA9IHRvdGFsO1xuXG5cdFx0Ly8gU2V0IGVhY2ggcG9pbnQncyBwcm9wZXJ0aWVzXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdHBvaW50LnBlcmNlbnRhZ2UgPSB0b3RhbCA+IDAgPyAocG9pbnQueSAvIHRvdGFsKSAqIDEwMCA6IDA7XG5cdFx0XHRwb2ludC50b3RhbCA9IHRvdGFsO1xuXHRcdH1cblx0XHRcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgcGllIGJhc2VkIG9uIHRoZSBzaXplIGFuZCBjZW50ZXIgb3B0aW9ucyByZWxhdGl2ZSB0byB0aGUgIFxuXHQgKiBwbG90IGFyZWEuIEJvcnJvd2VkIGJ5IHRoZSBwb2xhciBhbmQgZ2F1Z2Ugc2VyaWVzIHR5cGVzLlxuXHQgKi9cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRzbGljaW5nUm9vbSA9IDIgKiAob3B0aW9ucy5zbGljZWRPZmZzZXQgfHwgMCksXG5cdFx0XHRoYW5kbGVTbGljaW5nUm9vbSxcblx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCAtIDIgKiBzbGljaW5nUm9vbSxcblx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0IC0gMiAqIHNsaWNpbmdSb29tLFxuXHRcdFx0Y2VudGVyT3B0aW9uID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRwb3NpdGlvbnMgPSBbcGljayhjZW50ZXJPcHRpb25bMF0sICc1MCUnKSwgcGljayhjZW50ZXJPcHRpb25bMV0sICc1MCUnKSwgb3B0aW9ucy5zaXplIHx8ICcxMDAlJywgb3B0aW9ucy5pbm5lclNpemUgfHwgMF0sXG5cdFx0XHRzbWFsbGVzdFNpemUgPSBtYXRoTWluKHBsb3RXaWR0aCwgcGxvdEhlaWdodCksXG5cdFx0XHRpc1BlcmNlbnQ7XG5cdFx0XG5cdFx0cmV0dXJuIG1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uIChsZW5ndGgsIGkpIHtcblx0XHRcdGlzUGVyY2VudCA9IC8lJC8udGVzdChsZW5ndGgpO1xuXHRcdFx0aGFuZGxlU2xpY2luZ1Jvb20gPSBpIDwgMiB8fCAoaSA9PT0gMiAmJiBpc1BlcmNlbnQpO1xuXHRcdFx0cmV0dXJuIChpc1BlcmNlbnQgP1xuXHRcdFx0XHQvLyBpID09IDA6IGNlbnRlclgsIHJlbGF0aXZlIHRvIHdpZHRoXG5cdFx0XHRcdC8vIGkgPT0gMTogY2VudGVyWSwgcmVsYXRpdmUgdG8gaGVpZ2h0XG5cdFx0XHRcdC8vIGkgPT0gMjogc2l6ZSwgcmVsYXRpdmUgdG8gc21hbGxlc3RTaXplXG5cdFx0XHRcdC8vIGkgPT0gNDogaW5uZXJTaXplLCByZWxhdGl2ZSB0byBzbWFsbGVzdFNpemVcblx0XHRcdFx0W3Bsb3RXaWR0aCwgcGxvdEhlaWdodCwgc21hbGxlc3RTaXplLCBzbWFsbGVzdFNpemVdW2ldICpcblx0XHRcdFx0XHRwSW50KGxlbmd0aCkgLyAxMDAgOlxuXHRcdFx0XHRsZW5ndGgpICsgKGhhbmRsZVNsaWNpbmdSb29tID8gc2xpY2luZ1Jvb20gOiAwKTtcblx0XHR9KTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBEbyB0cmFuc2xhdGlvbiBmb3IgcGllIHNsaWNlc1xuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAocG9zaXRpb25zKSB7XG5cdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y3VtdWxhdGl2ZSA9IDAsXG5cdFx0XHRwcmVjaXNpb24gPSAxMDAwLCAvLyBpc3N1ZSAjMTcyXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRzbGljZWRPZmZzZXQgPSBvcHRpb25zLnNsaWNlZE9mZnNldCxcblx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IHNsaWNlZE9mZnNldCArIG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRzdGFydCxcblx0XHRcdGVuZCxcblx0XHRcdGFuZ2xlLFxuXHRcdFx0c3RhcnRBbmdsZSA9IG9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwLFxuXHRcdFx0c3RhcnRBbmdsZVJhZCA9IHNlcmllcy5zdGFydEFuZ2xlUmFkID0gbWF0aFBJIC8gMTgwICogKHN0YXJ0QW5nbGUgLSA5MCksXG5cdFx0XHRlbmRBbmdsZVJhZCA9IHNlcmllcy5lbmRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqICgob3B0aW9ucy5lbmRBbmdsZSB8fCAoc3RhcnRBbmdsZSArIDM2MCkpIC0gOTApLCAvLyBkb2NzXG5cdFx0XHRjaXJjID0gZW5kQW5nbGVSYWQgLSBzdGFydEFuZ2xlUmFkLCAvLzIgKiBtYXRoUEksXG5cdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0cmFkaXVzWCwgLy8gdGhlIHggY29tcG9uZW50IG9mIHRoZSByYWRpdXMgdmVjdG9yIGZvciBhIGdpdmVuIHBvaW50XG5cdFx0XHRyYWRpdXNZLFxuXHRcdFx0bGFiZWxEaXN0YW5jZSA9IG9wdGlvbnMuZGF0YUxhYmVscy5kaXN0YW5jZSxcblx0XHRcdGlnbm9yZUhpZGRlblBvaW50ID0gb3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludCxcblx0XHRcdGksXG5cdFx0XHRsZW4gPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0cG9pbnQ7XG5cblx0XHQvLyBHZXQgcG9zaXRpb25zIC0gZWl0aGVyIGFuIGludGVnZXIgb3IgYSBwZXJjZW50YWdlIHN0cmluZyBtdXN0IGJlIGdpdmVuLlxuXHRcdC8vIElmIHBvc2l0aW9ucyBhcmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLCB3ZSdyZSBpbiBhIHJlY3Vyc2l2ZSBsb29wIGZvciBhZGp1c3Rpbmdcblx0XHQvLyBzcGFjZSBmb3IgZGF0YSBsYWJlbHMuXG5cdFx0aWYgKCFwb3NpdGlvbnMpIHtcblx0XHRcdHNlcmllcy5jZW50ZXIgPSBwb3NpdGlvbnMgPSBzZXJpZXMuZ2V0Q2VudGVyKCk7XG5cdFx0fVxuXG5cdFx0Ly8gdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgeCB2YWx1ZSBmcm9tIGEgZ2l2ZW4geSwgdXNlZCBmb3IgYW50aWNvbGxpc2lvbiBsb2dpYyBpbiBkYXRhIGxhYmVsc1xuXHRcdHNlcmllcy5nZXRYID0gZnVuY3Rpb24gKHksIGxlZnQpIHtcblxuXHRcdFx0YW5nbGUgPSBtYXRoLmFzaW4oKHkgLSBwb3NpdGlvbnNbMV0pIC8gKHBvc2l0aW9uc1syXSAvIDIgKyBsYWJlbERpc3RhbmNlKSk7XG5cblx0XHRcdHJldHVybiBwb3NpdGlvbnNbMF0gK1xuXHRcdFx0XHQobGVmdCA/IC0xIDogMSkgKlxuXHRcdFx0XHQobWF0aENvcyhhbmdsZSkgKiAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpKTtcblx0XHR9O1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBnZW9tZXRyeSBmb3IgZWFjaCBwb2ludFxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XG5cdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0IHN0YXJ0IGFuZCBlbmQgYW5nbGVcblx0XHRcdHN0YXJ0ID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cdFx0XHRpZiAoIWlnbm9yZUhpZGRlblBvaW50IHx8IHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0Y3VtdWxhdGl2ZSArPSBwb2ludC5wZXJjZW50YWdlIC8gMTAwO1xuXHRcdFx0fVxuXHRcdFx0ZW5kID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cblx0XHRcdC8vIHNldCB0aGUgc2hhcGVcblx0XHRcdHBvaW50LnNoYXBlVHlwZSA9ICdhcmMnO1xuXHRcdFx0cG9pbnQuc2hhcGVBcmdzID0ge1xuXHRcdFx0XHR4OiBwb3NpdGlvbnNbMF0sXG5cdFx0XHRcdHk6IHBvc2l0aW9uc1sxXSxcblx0XHRcdFx0cjogcG9zaXRpb25zWzJdIC8gMixcblx0XHRcdFx0aW5uZXJSOiBwb3NpdGlvbnNbM10gLyAyLFxuXHRcdFx0XHRzdGFydDogbWF0aFJvdW5kKHN0YXJ0ICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbixcblx0XHRcdFx0ZW5kOiBtYXRoUm91bmQoZW5kICogcHJlY2lzaW9uKSAvIHByZWNpc2lvblxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gY2VudGVyIGZvciB0aGUgc2xpY2VkIG91dCBzbGljZVxuXHRcdFx0YW5nbGUgPSAoZW5kICsgc3RhcnQpIC8gMjtcblx0XHRcdGlmIChhbmdsZSA+IDAuNzUgKiBjaXJjKSB7XG5cdFx0XHRcdGFuZ2xlIC09IDIgKiBtYXRoUEk7XG5cdFx0XHR9XG5cdFx0XHRwb2ludC5zbGljZWRUcmFuc2xhdGlvbiA9IHtcblx0XHRcdFx0dHJhbnNsYXRlWDogbWF0aFJvdW5kKG1hdGhDb3MoYW5nbGUpICogc2xpY2VkT2Zmc2V0KSxcblx0XHRcdFx0dHJhbnNsYXRlWTogbWF0aFJvdW5kKG1hdGhTaW4oYW5nbGUpICogc2xpY2VkT2Zmc2V0KVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBhbmNob3IgcG9pbnQgZm9yIHRvb2x0aXBzXG5cdFx0XHRyYWRpdXNYID0gbWF0aENvcyhhbmdsZSkgKiBwb3NpdGlvbnNbMl0gLyAyO1xuXHRcdFx0cmFkaXVzWSA9IG1hdGhTaW4oYW5nbGUpICogcG9zaXRpb25zWzJdIC8gMjtcblx0XHRcdHBvaW50LnRvb2x0aXBQb3MgPSBbXG5cdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1ggKiAwLjcsXG5cdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1kgKiAwLjdcblx0XHRcdF07XG5cdFx0XHRcblx0XHRcdHBvaW50LmhhbGYgPSBhbmdsZSA8IC1tYXRoUEkgLyAyIHx8IGFuZ2xlID4gbWF0aFBJIC8gMiA/IDEgOiAwO1xuXHRcdFx0cG9pbnQuYW5nbGUgPSBhbmdsZTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBhbmNob3IgcG9pbnQgZm9yIGRhdGEgbGFiZWxzXG5cdFx0XHRjb25uZWN0b3JPZmZzZXQgPSBtYXRoTWluKGNvbm5lY3Rvck9mZnNldCwgbGFiZWxEaXN0YW5jZSAvIDIpOyAvLyAjMTY3OFxuXHRcdFx0cG9pbnQubGFiZWxQb3MgPSBbXG5cdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1ggKyBtYXRoQ29zKGFuZ2xlKSAqIGxhYmVsRGlzdGFuY2UsIC8vIGZpcnN0IGJyZWFrIG9mIGNvbm5lY3RvclxuXHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZICsgbWF0aFNpbihhbmdsZSkgKiBsYWJlbERpc3RhbmNlLCAvLyBhL2Fcblx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBzZWNvbmQgYnJlYWssIHJpZ2h0IG91dHNpZGUgcGllXG5cdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1kgKyBtYXRoU2luKGFuZ2xlKSAqIGNvbm5lY3Rvck9mZnNldCwgLy8gYS9hXG5cdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1gsIC8vIGxhbmRpbmcgcG9pbnQgZm9yIGNvbm5lY3RvclxuXHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZLCAvLyBhL2Fcblx0XHRcdFx0bGFiZWxEaXN0YW5jZSA8IDAgPyAvLyBhbGlnbm1lbnRcblx0XHRcdFx0XHQnY2VudGVyJyA6XG5cdFx0XHRcdFx0cG9pbnQuaGFsZiA/ICdyaWdodCcgOiAnbGVmdCcsIC8vIGFsaWdubWVudFxuXHRcdFx0XHRhbmdsZSAvLyBjZW50ZXIgYW5nbGVcblx0XHRcdF07XG5cblx0XHR9XG5cdH0sXG5cblx0c2V0VG9vbHRpcFBvaW50czogbm9vcCxcblx0ZHJhd0dyYXBoOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBkYXRhIHBvaW50c1xuXHQgKi9cblx0ZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0Z3JvdXBUcmFuc2xhdGlvbixcblx0XHRcdC8vY2VudGVyLFxuXHRcdFx0Z3JhcGhpYyxcblx0XHRcdC8vZ3JvdXAsXG5cdFx0XHRzaGFkb3cgPSBzZXJpZXMub3B0aW9ucy5zaGFkb3csXG5cdFx0XHRzaGFkb3dHcm91cCxcblx0XHRcdHNoYXBlQXJncztcblxuXHRcdGlmIChzaGFkb3cgJiYgIXNlcmllcy5zaGFkb3dHcm91cCkge1xuXHRcdFx0c2VyaWVzLnNoYWRvd0dyb3VwID0gcmVuZGVyZXIuZygnc2hhZG93Jylcblx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApO1xuXHRcdH1cblxuXHRcdC8vIGRyYXcgdGhlIHNsaWNlc1xuXHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYztcblx0XHRcdHNoYXBlQXJncyA9IHBvaW50LnNoYXBlQXJncztcblx0XHRcdHNoYWRvd0dyb3VwID0gcG9pbnQuc2hhZG93R3JvdXA7XG5cblx0XHRcdC8vIHB1dCB0aGUgc2hhZG93IGJlaGluZCBhbGwgcG9pbnRzXG5cdFx0XHRpZiAoc2hhZG93ICYmICFzaGFkb3dHcm91cCkge1xuXHRcdFx0XHRzaGFkb3dHcm91cCA9IHBvaW50LnNoYWRvd0dyb3VwID0gcmVuZGVyZXIuZygnc2hhZG93Jylcblx0XHRcdFx0XHQuYWRkKHNlcmllcy5zaGFkb3dHcm91cCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBwb2ludCBpcyBzbGljZWQsIHVzZSBzcGVjaWFsIHRyYW5zbGF0aW9uLCBlbHNlIHVzZSBwbG90IGFyZWEgdHJhc2xhdGlvblxuXHRcdFx0Z3JvdXBUcmFuc2xhdGlvbiA9IHBvaW50LnNsaWNlZCA/IHBvaW50LnNsaWNlZFRyYW5zbGF0aW9uIDoge1xuXHRcdFx0XHR0cmFuc2xhdGVYOiAwLFxuXHRcdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHQvL2dyb3VwLnRyYW5zbGF0ZShncm91cFRyYW5zbGF0aW9uWzBdLCBncm91cFRyYW5zbGF0aW9uWzFdKTtcblx0XHRcdGlmIChzaGFkb3dHcm91cCkge1xuXHRcdFx0XHRzaGFkb3dHcm91cC5hdHRyKGdyb3VwVHJhbnNsYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHRoZSBzbGljZVxuXHRcdFx0aWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0Z3JhcGhpYy5hbmltYXRlKGV4dGVuZChzaGFwZUFyZ3MsIGdyb3VwVHJhbnNsYXRpb24pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljID0gcmVuZGVyZXIuYXJjKHNoYXBlQXJncylcblx0XHRcdFx0XHQuc2V0UmFkaWFsUmVmZXJlbmNlKHNlcmllcy5jZW50ZXIpXG5cdFx0XHRcdFx0LmF0dHIoXG5cdFx0XHRcdFx0XHRwb2ludC5wb2ludEF0dHJbcG9pbnQuc2VsZWN0ZWQgPyBTRUxFQ1RfU1RBVEUgOiBOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKHsgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcgfSlcblx0XHRcdFx0XHQuYXR0cihncm91cFRyYW5zbGF0aW9uKVxuXHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdC5zaGFkb3coc2hhZG93LCBzaGFkb3dHcm91cCk7XHRcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZWN0IHBvaW50IHNwZWNpZmljIHZpc2liaWxpdHlcblx0XHRcdGlmIChwb2ludC52aXNpYmxlID09PSBmYWxzZSkge1xuXHRcdFx0XHRwb2ludC5zZXRWaXNpYmxlKGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIHNvcnRpbmcgZGF0YSBsYWJlbHNcblx0ICovXG5cdHNvcnRCeUFuZ2xlOiBmdW5jdGlvbiAocG9pbnRzLCBzaWduKSB7XG5cdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmFuZ2xlICE9PSB1bmRlZmluZWQgJiYgKGIuYW5nbGUgLSBhLmFuZ2xlKSAqIHNpZ247XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIHRoZSBiYXNlIGRyYXdEYXRhTGFiZWxzIG1ldGhvZCBieSBwaWUgc3BlY2lmaWMgZnVuY3Rpb25hbGl0eVxuXHQgKi9cblx0ZHJhd0RhdGFMYWJlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdHBvaW50LFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdGNvbm5lY3RvclBhZGRpbmcgPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yUGFkZGluZywgMTApLFxuXHRcdFx0Y29ubmVjdG9yV2lkdGggPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yV2lkdGgsIDEpLFxuXHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRjb25uZWN0b3IsXG5cdFx0XHRjb25uZWN0b3JQYXRoLFxuXHRcdFx0c29mdENvbm5lY3RvciA9IHBpY2sob3B0aW9ucy5zb2Z0Q29ubmVjdG9yLCB0cnVlKSxcblx0XHRcdGRpc3RhbmNlT3B0aW9uID0gb3B0aW9ucy5kaXN0YW5jZSxcblx0XHRcdHNlcmllc0NlbnRlciA9IHNlcmllcy5jZW50ZXIsXG5cdFx0XHRyYWRpdXMgPSBzZXJpZXNDZW50ZXJbMl0gLyAyLFxuXHRcdFx0Y2VudGVyWSA9IHNlcmllc0NlbnRlclsxXSxcblx0XHRcdG91dHNpZGUgPSBkaXN0YW5jZU9wdGlvbiA+IDAsXG5cdFx0XHRkYXRhTGFiZWwsXG5cdFx0XHRkYXRhTGFiZWxXaWR0aCxcblx0XHRcdGxhYmVsUG9zLFxuXHRcdFx0bGFiZWxIZWlnaHQsXG5cdFx0XHRoYWx2ZXMgPSBbLy8gZGl2aWRlIHRoZSBwb2ludHMgaW50byByaWdodCBhbmQgbGVmdCBoYWx2ZXMgZm9yIGFudGkgY29sbGlzaW9uXG5cdFx0XHRcdFtdLCAvLyByaWdodFxuXHRcdFx0XHRbXSAgLy8gbGVmdFxuXHRcdFx0XSxcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdHJhbmtBcnIsXG5cdFx0XHRpLFxuXHRcdFx0aixcblx0XHRcdG92ZXJmbG93ID0gWzAsIDAsIDAsIDBdLCAvLyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcblx0XHRcdHNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYi55IC0gYS55O1xuXHRcdFx0fTtcblxuXHRcdC8vIGdldCBvdXQgaWYgbm90IGVuYWJsZWRcblx0XHRpZiAoIXNlcmllcy52aXNpYmxlIHx8ICghb3B0aW9ucy5lbmFibGVkICYmICFzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHJ1biBwYXJlbnQgbWV0aG9kXG5cdFx0U2VyaWVzLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShzZXJpZXMpO1xuXG5cdFx0Ly8gYXJyYW5nZSBwb2ludHMgZm9yIGRldGVjdGlvbiBjb2xsaXNpb25cblx0XHRlYWNoKGRhdGEsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkgeyAvLyBpdCBtYXkgaGF2ZSBiZWVuIGNhbmNlbGxlZCBpbiB0aGUgYmFzZSBtZXRob2QgKCM0MDcpXG5cdFx0XHRcdGhhbHZlc1twb2ludC5oYWxmXS5wdXNoKHBvaW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGFzc3VtZSBlcXVhbCBsYWJlbCBoZWlnaHRzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCFsYWJlbEhlaWdodCAmJiBkYXRhW2ldKSB7IC8vICMxNTY5XG5cdFx0XHRsYWJlbEhlaWdodCA9IGRhdGFbaV0gJiYgZGF0YVtpXS5kYXRhTGFiZWwgJiYgKGRhdGFbaV0uZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHQgfHwgMjEpOyAvLyAyMSBpcyBmb3IgIzk2OFxuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdC8qIExvb3Agb3ZlciB0aGUgcG9pbnRzIGluIGVhY2ggaGFsZiwgc3RhcnRpbmcgZnJvbSB0aGUgdG9wIGFuZCBib3R0b21cblx0XHQgKiBvZiB0aGUgcGllIHRvIGRldGVjdCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdFx0ICovXG5cdFx0aSA9IDI7XG5cdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHR2YXIgc2xvdHMgPSBbXSxcblx0XHRcdFx0c2xvdHNMZW5ndGgsXG5cdFx0XHRcdHVzZWRTbG90cyA9IFtdLFxuXHRcdFx0XHRwb2ludHMgPSBoYWx2ZXNbaV0sXG5cdFx0XHRcdHBvcyxcblx0XHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdFx0c2xvdEluZGV4O1xuXHRcdFx0XHRcblx0XHRcdC8vIFNvcnQgYnkgYW5nbGVcblx0XHRcdHNlcmllcy5zb3J0QnlBbmdsZShwb2ludHMsIGkgLSAwLjUpO1xuXG5cdFx0XHQvLyBPbmx5IGRvIGFudGktY29sbGlzaW9uIHdoZW4gd2UgYXJlIG91dHNpZGUgdGhlIHBpZSBhbmQgaGF2ZSBjb25uZWN0b3JzICgjODU2KVxuXHRcdFx0aWYgKGRpc3RhbmNlT3B0aW9uID4gMCkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gYnVpbGQgdGhlIHNsb3RzXG5cdFx0XHRcdGZvciAocG9zID0gY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uOyBwb3MgPD0gY2VudGVyWSArIHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uOyBwb3MgKz0gbGFiZWxIZWlnaHQpIHtcblx0XHRcdFx0XHRzbG90cy5wdXNoKHBvcyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gdmlzdWFsaXplIHRoZSBzbG90XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHR2YXIgc2xvdFggPSBzZXJpZXMuZ2V0WChwb3MsIGkpICsgY2hhcnQucGxvdExlZnQgLSAoaSA/IDEwMCA6IDApLFxuXHRcdFx0XHRcdFx0c2xvdFkgPSBwb3MgKyBjaGFydC5wbG90VG9wO1xuXHRcdFx0XHRcdGlmICghaXNOYU4oc2xvdFgpKSB7XG5cdFx0XHRcdFx0XHRjaGFydC5yZW5kZXJlci5yZWN0KHNsb3RYLCBzbG90WSAtIDcsIDEwMCwgbGFiZWxIZWlnaHQsIDEpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2U6ICdzaWx2ZXInXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLnRleHQoJ1Nsb3QgJysgKHNsb3RzLmxlbmd0aCAtIDEpLCBzbG90WCwgc2xvdFkgKyA0KVxuXHRcdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3NpbHZlcidcblx0XHRcdFx0XHRcdFx0fSkuYWRkKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdH1cblx0XHRcdFx0c2xvdHNMZW5ndGggPSBzbG90cy5sZW5ndGg7XG5cdFxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgdGhhbiBhdmFpbGFibGUgc2xvdHMsIHJlbW92ZSBsb3dlc3QgdmFsdWVzXG5cdFx0XHRcdGlmIChsZW5ndGggPiBzbG90c0xlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhbiBhcnJheSBmb3Igc29ydGluZyBhbmQgcmFua2luZyB0aGUgcG9pbnRzIHdpdGhpbiBlYWNoIHF1YXJ0ZXJcblx0XHRcdFx0XHRyYW5rQXJyID0gW10uY29uY2F0KHBvaW50cyk7XG5cdFx0XHRcdFx0cmFua0Fyci5zb3J0KHNvcnQpO1xuXHRcdFx0XHRcdGogPSBsZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0cmFua0FycltqXS5yYW5rID0gajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aiA9IGxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0XHRpZiAocG9pbnRzW2pdLnJhbmsgPj0gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShqLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVGhlIGxhYmVsIGdvZXMgdG8gdGhlIG5lYXJlc3Qgb3BlbiBzbG90LCBidXQgbm90IGNsb3NlciB0byB0aGUgZWRnZSB0aGFuXG5cdFx0XHRcdC8vIHRoZSBsYWJlbCdzIGluZGV4LlxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XG5cdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbal07XG5cdFx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XG5cdFx0XHRcdFx0dmFyIGNsb3Nlc3QgPSA5OTk5LFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRzbG90STtcblx0XG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgY2xvc2VzdCBzbG90IGluZGV4XG5cdFx0XHRcdFx0Zm9yIChzbG90SSA9IDA7IHNsb3RJIDwgc2xvdHNMZW5ndGg7IHNsb3RJKyspIHtcblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gbWF0aEFicyhzbG90c1tzbG90SV0gLSBsYWJlbFBvc1sxXSk7XG5cdFx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBjbG9zZXN0KSB7XG5cdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSBkaXN0YW5jZTtcblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdEk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBpZiB0aGF0IHNsb3QgaW5kZXggaXMgY2xvc2VyIHRvIHRoZSBlZGdlcyBvZiB0aGUgc2xvdHMsIG1vdmUgaXRcblx0XHRcdFx0XHQvLyB0byB0aGUgY2xvc2VzdCBhcHByb3ByaWF0ZSBzbG90XG5cdFx0XHRcdFx0aWYgKHNsb3RJbmRleCA8IGogJiYgc2xvdHNbal0gIT09IG51bGwpIHsgLy8gY2x1c3RlciBhdCB0aGUgdG9wXG5cdFx0XHRcdFx0XHRzbG90SW5kZXggPSBqO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc2xvdHNMZW5ndGggIDwgbGVuZ3RoIC0gaiArIHNsb3RJbmRleCAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSBib3R0b21cblx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IHNsb3RzTGVuZ3RoIC0gbGVuZ3RoICsgajtcblx0XHRcdFx0XHRcdHdoaWxlIChzbG90c1tzbG90SW5kZXhdID09PSBudWxsKSB7IC8vIG1ha2Ugc3VyZSBpdCBpcyBub3QgdGFrZW5cblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFNsb3QgaXMgdGFrZW4sIGZpbmQgbmV4dCBmcmVlIHNsb3QgYmVsb3cuIEluIHRoZSBuZXh0IHJ1biwgdGhlIG5leHQgc2xpY2Ugd2lsbCBmaW5kIHRoZVxuXHRcdFx0XHRcdFx0Ly8gc2xvdCBhYm92ZSB0aGVzZSwgYmVjYXVzZSBpdCBpcyB0aGUgY2xvc2VzdCBvbmVcblx0XHRcdFx0XHRcdHdoaWxlIChzbG90c1tzbG90SW5kZXhdID09PSBudWxsKSB7IC8vIG1ha2Ugc3VyZSBpdCBpcyBub3QgdGFrZW5cblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHR1c2VkU2xvdHMucHVzaCh7IGk6IHNsb3RJbmRleCwgeTogc2xvdHNbc2xvdEluZGV4XSB9KTtcblx0XHRcdFx0XHRzbG90c1tzbG90SW5kZXhdID0gbnVsbDsgLy8gbWFyayBhcyB0YWtlblxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNvcnQgdGhlbSBpbiBvcmRlciB0byBmaWxsIGluIGZyb20gdGhlIHRvcFxuXHRcdFx0XHR1c2VkU2xvdHMuc29ydChzb3J0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm93IHRoZSB1c2VkIHNsb3RzIGFyZSBzb3J0ZWQsIGZpbGwgdGhlbSB1cCBzZXF1ZW50aWFsbHlcblx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHNsb3QsIG5hdHVyYWxZO1xuXG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzW2pdO1xuXHRcdFx0XHRsYWJlbFBvcyA9IHBvaW50LmxhYmVsUG9zO1xuXHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWw7XG5cdFx0XHRcdHZpc2liaWxpdHkgPSBwb2ludC52aXNpYmxlID09PSBmYWxzZSA/IEhJRERFTiA6IFZJU0lCTEU7XG5cdFx0XHRcdG5hdHVyYWxZID0gbGFiZWxQb3NbMV07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZGlzdGFuY2VPcHRpb24gPiAwKSB7XG5cdFx0XHRcdFx0c2xvdCA9IHVzZWRTbG90cy5wb3AoKTtcblx0XHRcdFx0XHRzbG90SW5kZXggPSBzbG90Lmk7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgc2xvdCBuZXh0IHRvIGN1cnJyZW50IHNsb3QgaXMgZnJlZSwgdGhlIHkgdmFsdWUgaXMgYWxsb3dlZFxuXHRcdFx0XHRcdC8vIHRvIGZhbGwgYmFjayB0byB0aGUgbmF0dXJhbCBwb3NpdGlvblxuXHRcdFx0XHRcdHkgPSBzbG90Lnk7XG5cdFx0XHRcdFx0aWYgKChuYXR1cmFsWSA+IHkgJiYgc2xvdHNbc2xvdEluZGV4ICsgMV0gIT09IG51bGwpIHx8XG5cdFx0XHRcdFx0XHRcdChuYXR1cmFsWSA8IHkgJiYgIHNsb3RzW3Nsb3RJbmRleCAtIDFdICE9PSBudWxsKSkge1xuXHRcdFx0XHRcdFx0eSA9IG5hdHVyYWxZO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gbmF0dXJhbFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZXQgdGhlIHggLSB1c2UgdGhlIG5hdHVyYWwgeCBwb3NpdGlvbiBmb3IgZmlyc3QgYW5kIGxhc3Qgc2xvdCwgdG8gcHJldmVudCB0aGUgdG9wXG5cdFx0XHRcdC8vIGFuZCBib3R0b24gc2xpY2UgY29ubmVjdG9ycyBmcm9tIHRvdWNoaW5nIGVhY2ggb3RoZXIgb24gZWl0aGVyIHNpZGVcblx0XHRcdFx0eCA9IG9wdGlvbnMuanVzdGlmeSA/IFxuXHRcdFx0XHRcdHNlcmllc0NlbnRlclswXSArIChpID8gLTEgOiAxKSAqIChyYWRpdXMgKyBkaXN0YW5jZU9wdGlvbikgOlxuXHRcdFx0XHRcdHNlcmllcy5nZXRYKHNsb3RJbmRleCA9PT0gMCB8fCBzbG90SW5kZXggPT09IHNsb3RzLmxlbmd0aCAtIDEgPyBuYXR1cmFsWSA6IHksIGkpO1xuXHRcdFx0XHRcblx0XHRcdFxuXHRcdFx0XHQvLyBSZWNvcmQgdGhlIHBsYWNlbWVudCBhbmQgdmlzaWJpbGl0eVxuXHRcdFx0XHRkYXRhTGFiZWwuX2F0dHIgPSB7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRhbGlnbjogbGFiZWxQb3NbNl1cblx0XHRcdFx0fTtcblx0XHRcdFx0ZGF0YUxhYmVsLl9wb3MgPSB7XG5cdFx0XHRcdFx0eDogeCArIG9wdGlvbnMueCArXG5cdFx0XHRcdFx0XHQoeyBsZWZ0OiBjb25uZWN0b3JQYWRkaW5nLCByaWdodDogLWNvbm5lY3RvclBhZGRpbmcgfVtsYWJlbFBvc1s2XV0gfHwgMCksXG5cdFx0XHRcdFx0eTogeSArIG9wdGlvbnMueSAtIDEwIC8vIDEwIGlzIGZvciB0aGUgYmFzZWxpbmUgKGxhYmVsIHZzIHRleHQpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGFMYWJlbC5jb25uWCA9IHg7XG5cdFx0XHRcdGRhdGFMYWJlbC5jb25uWSA9IHk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdC8vIERldGVjdCBvdmVyZmxvd2luZyBkYXRhIGxhYmVsc1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnNpemUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRkYXRhTGFiZWxXaWR0aCA9IGRhdGFMYWJlbC53aWR0aDtcblx0XHRcdFx0XHQvLyBPdmVyZmxvdyBsZWZ0XG5cdFx0XHRcdFx0aWYgKHggLSBkYXRhTGFiZWxXaWR0aCA8IGNvbm5lY3RvclBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93WzNdID0gbWF0aE1heChtYXRoUm91bmQoZGF0YUxhYmVsV2lkdGggLSB4ICsgY29ubmVjdG9yUGFkZGluZyksIG92ZXJmbG93WzNdKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIE92ZXJmbG93IHJpZ2h0XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh4ICsgZGF0YUxhYmVsV2lkdGggPiBwbG90V2lkdGggLSBjb25uZWN0b3JQYWRkaW5nKSB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvd1sxXSA9IG1hdGhNYXgobWF0aFJvdW5kKHggKyBkYXRhTGFiZWxXaWR0aCAtIHBsb3RXaWR0aCArIGNvbm5lY3RvclBhZGRpbmcpLCBvdmVyZmxvd1sxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIE92ZXJmbG93IHRvcFxuXHRcdFx0XHRcdGlmICh5IC0gbGFiZWxIZWlnaHQgLyAyIDwgMCkge1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3dbMF0gPSBtYXRoTWF4KG1hdGhSb3VuZCgteSArIGxhYmVsSGVpZ2h0IC8gMiksIG92ZXJmbG93WzBdKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIE92ZXJmbG93IGxlZnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgKyBsYWJlbEhlaWdodCAvIDIgPiBwbG90SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvd1syXSA9IG1hdGhNYXgobWF0aFJvdW5kKHkgKyBsYWJlbEhlaWdodCAvIDIgLSBwbG90SGVpZ2h0KSwgb3ZlcmZsb3dbMl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBmb3IgZWFjaCBwb2ludFxuXHRcdH0gLy8gZm9yIGVhY2ggaGFsZlxuXHRcdFxuXHRcdC8vIERvIG5vdCBhcHBseSB0aGUgZmluYWwgcGxhY2VtZW50IGFuZCBkcmF3IHRoZSBjb25uZWN0b3JzIHVudGlsIHdlIGhhdmUgdmVyaWZpZWRcblx0XHQvLyB0aGF0IGxhYmVscyBhcmUgbm90IHNwaWxsaW5nIG92ZXIuIFxuXHRcdGlmIChhcnJheU1heChvdmVyZmxvdykgPT09IDAgfHwgdGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyhvdmVyZmxvdykpIHtcblx0XHRcdFxuXHRcdFx0Ly8gUGxhY2UgdGhlIGxhYmVscyBpbiB0aGUgZmluYWwgcG9zaXRpb25cblx0XHRcdHRoaXMucGxhY2VEYXRhTGFiZWxzKCk7XG5cdFx0XHRcblx0XHRcdC8vIERyYXcgdGhlIGNvbm5lY3RvcnNcblx0XHRcdGlmIChvdXRzaWRlICYmIGNvbm5lY3RvcldpZHRoKSB7XG5cdFx0XHRcdGVhY2godGhpcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdGNvbm5lY3RvciA9IHBvaW50LmNvbm5lY3Rvcjtcblx0XHRcdFx0XHRsYWJlbFBvcyA9IHBvaW50LmxhYmVsUG9zO1xuXHRcdFx0XHRcdGRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsICYmIGRhdGFMYWJlbC5fcG9zKSB7XG5cdFx0XHRcdFx0XHR2aXNpYmlsaXR5ID0gZGF0YUxhYmVsLl9hdHRyLnZpc2liaWxpdHk7XG5cdFx0XHRcdFx0XHR4ID0gZGF0YUxhYmVsLmNvbm5YO1xuXHRcdFx0XHRcdFx0eSA9IGRhdGFMYWJlbC5jb25uWTtcblx0XHRcdFx0XHRcdGNvbm5lY3RvclBhdGggPSBzb2Z0Q29ubmVjdG9yID8gW1xuXHRcdFx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdFx0XHR4ICsgKGxhYmVsUG9zWzZdID09PSAnbGVmdCcgPyA1IDogLTUpLCB5LCAvLyBlbmQgb2YgdGhlIHN0cmluZyBhdCB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0J0MnLFxuXHRcdFx0XHRcdFx0XHR4LCB5LCAvLyBmaXJzdCBicmVhaywgbmV4dCB0byB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0MiAqIGxhYmVsUG9zWzJdIC0gbGFiZWxQb3NbNF0sIDIgKiBsYWJlbFBvc1szXSAtIGxhYmVsUG9zWzVdLFxuXHRcdFx0XHRcdFx0XHRsYWJlbFBvc1syXSwgbGFiZWxQb3NbM10sIC8vIHNlY29uZCBicmVha1xuXHRcdFx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdFx0XHRsYWJlbFBvc1s0XSwgbGFiZWxQb3NbNV0gLy8gYmFzZVxuXHRcdFx0XHRcdFx0XSA6IFtcblx0XHRcdFx0XHRcdFx0TSxcblx0XHRcdFx0XHRcdFx0eCArIChsYWJlbFBvc1s2XSA9PT0gJ2xlZnQnID8gNSA6IC01KSwgeSwgLy8gZW5kIG9mIHRoZSBzdHJpbmcgYXQgdGhlIGxhYmVsXG5cdFx0XHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzJdLCBsYWJlbFBvc1szXSwgLy8gc2Vjb25kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzRdLCBsYWJlbFBvc1s1XSAvLyBiYXNlXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFxuXHRcdFx0XHRcdFx0aWYgKGNvbm5lY3Rvcikge1xuXHRcdFx0XHRcdFx0XHRjb25uZWN0b3IuYW5pbWF0ZSh7IGQ6IGNvbm5lY3RvclBhdGggfSk7XG5cdFx0XHRcdFx0XHRcdGNvbm5lY3Rvci5hdHRyKCd2aXNpYmlsaXR5JywgdmlzaWJpbGl0eSk7XG5cdFx0XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChjb25uZWN0b3JQYXRoKS5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogY29ubmVjdG9yV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbm5lY3RvckNvbG9yIHx8IHBvaW50LmNvbG9yIHx8ICcjNjA2MDYwJyxcblx0XHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbm5lY3Rvcikge1xuXHRcdFx0XHRcdFx0cG9pbnQuY29ubmVjdG9yID0gY29ubmVjdG9yLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVx0XHRcdFxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBWZXJpZnkgd2hldGhlciB0aGUgZGF0YSBsYWJlbHMgYXJlIGFsbG93ZWQgdG8gZHJhdywgb3Igd2Ugc2hvdWxkIHJ1biBtb3JlIHRyYW5zbGF0aW9uIGFuZCBkYXRhXG5cdCAqIGxhYmVsIHBvc2l0aW9uaW5nIHRvIGtlZXAgdGhlbSBpbnNpZGUgdGhlIHBsb3QgYXJlYS4gUmV0dXJucyB0cnVlIHdoZW4gZGF0YSBsYWJlbHMgYXJlIHJlYWR5IFxuXHQgKiB0byBkcmF3LlxuXHQgKi9cblx0dmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3c6IGZ1bmN0aW9uIChvdmVyZmxvdykge1xuXHRcdFxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcixcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjZW50ZXJPcHRpb24gPSBvcHRpb25zLmNlbnRlcixcblx0XHRcdG1pblNpemUgPSBvcHRpb25zLm1pblNpemUgfHwgODAsXG5cdFx0XHRuZXdTaXplID0gbWluU2l6ZSxcblx0XHRcdHJldDtcblx0XHRcdFxuXHRcdC8vIEhhbmRsZSBob3Jpem9udGFsIHNpemUgYW5kIGNlbnRlclxuXHRcdGlmIChjZW50ZXJPcHRpb25bMF0gIT09IG51bGwpIHsgLy8gRml4ZWQgY2VudGVyXG5cdFx0XHRuZXdTaXplID0gbWF0aE1heChjZW50ZXJbMl0gLSBtYXRoTWF4KG92ZXJmbG93WzFdLCBvdmVyZmxvd1szXSksIG1pblNpemUpO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHsgLy8gQXV0byBjZW50ZXJcblx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KFxuXHRcdFx0XHRjZW50ZXJbMl0gLSBvdmVyZmxvd1sxXSAtIG92ZXJmbG93WzNdLCAvLyBob3Jpem9udGFsIG92ZXJmbG93XHRcdFx0XHRcdFxuXHRcdFx0XHRtaW5TaXplXG5cdFx0XHQpO1xuXHRcdFx0Y2VudGVyWzBdICs9IChvdmVyZmxvd1szXSAtIG92ZXJmbG93WzFdKSAvIDI7IC8vIGhvcml6b250YWwgY2VudGVyXG5cdFx0fVxuXHRcdFxuXHRcdC8vIEhhbmRsZSB2ZXJ0aWNhbCBzaXplIGFuZCBjZW50ZXJcblx0XHRpZiAoY2VudGVyT3B0aW9uWzFdICE9PSBudWxsKSB7IC8vIEZpeGVkIGNlbnRlclxuXHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgobWF0aE1pbihuZXdTaXplLCBjZW50ZXJbMl0gLSBtYXRoTWF4KG92ZXJmbG93WzBdLCBvdmVyZmxvd1syXSkpLCBtaW5TaXplKTtcblx0XHRcdFxuXHRcdH0gZWxzZSB7IC8vIEF1dG8gY2VudGVyXG5cdFx0XHRuZXdTaXplID0gbWF0aE1heChcblx0XHRcdFx0bWF0aE1pbihcblx0XHRcdFx0XHRuZXdTaXplLFx0XHRcblx0XHRcdFx0XHRjZW50ZXJbMl0gLSBvdmVyZmxvd1swXSAtIG92ZXJmbG93WzJdIC8vIHZlcnRpY2FsIG92ZXJmbG93XG5cdFx0XHRcdCksXG5cdFx0XHRcdG1pblNpemVcblx0XHRcdCk7XG5cdFx0XHRjZW50ZXJbMV0gKz0gKG92ZXJmbG93WzBdIC0gb3ZlcmZsb3dbMl0pIC8gMjsgLy8gdmVydGljYWwgY2VudGVyXG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIHRoZSBzaXplIG11c3QgYmUgZGVjcmVhc2VkLCB3ZSBuZWVkIHRvIHJ1biB0cmFuc2xhdGUgYW5kIGRyYXdEYXRhTGFiZWxzIGFnYWluXG5cdFx0aWYgKG5ld1NpemUgPCBjZW50ZXJbMl0pIHtcblx0XHRcdGNlbnRlclsyXSA9IG5ld1NpemU7XG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdGlmIChwb2ludC5kYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwuX3BvcyA9IG51bGw7IC8vIHJlc2V0XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kcmF3RGF0YUxhYmVscygpO1xuXHRcdFx0XG5cdFx0Ly8gRWxzZSwgcmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcGllIGFuZCBpdHMgbGFiZWxzIGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogUGVyZm9ybSB0aGUgZmluYWwgcGxhY2VtZW50IG9mIHRoZSBkYXRhIGxhYmVscyBhZnRlciB3ZSBoYXZlIHZlcmlmaWVkIHRoYXQgdGhleVxuXHQgKiBmYWxsIHdpdGhpbiB0aGUgcGxvdCBhcmVhLlxuXHQgKi9cblx0cGxhY2VEYXRhTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRfcG9zO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdF9wb3MgPSBkYXRhTGFiZWwuX3Bvcztcblx0XHRcdFx0aWYgKF9wb3MpIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cihkYXRhTGFiZWwuX2F0dHIpO1x0XHRcdFxuXHRcdFx0XHRcdGRhdGFMYWJlbFtkYXRhTGFiZWwubW92ZWQgPyAnYW5pbWF0ZScgOiAnYXR0ciddKF9wb3MpO1xuXHRcdFx0XHRcdGRhdGFMYWJlbC5tb3ZlZCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLmF0dHIoeyB5OiAtOTk5IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdFxuXHRhbGlnbkRhdGFMYWJlbDogbm9vcCxcblxuXHQvKipcblx0ICogRHJhdyBwb2ludCBzcGVjaWZpYyB0cmFja2VyIG9iamVjdHMuIEluaGVyaXQgZGlyZWN0bHkgZnJvbSBjb2x1bW4gc2VyaWVzLlxuXHQgKi9cblx0ZHJhd1RyYWNrZXI6IENvbHVtblNlcmllcy5wcm90b3R5cGUuZHJhd1RyYWNrZXIsXG5cblx0LyoqXG5cdCAqIFVzZSBhIHNpbXBsZSBzeW1ib2wgZnJvbSBjb2x1bW4gcHJvdG90eXBlXG5cdCAqL1xuXHRkcmF3TGVnZW5kU3ltYm9sOiBBcmVhU2VyaWVzLnByb3RvdHlwZS5kcmF3TGVnZW5kU3ltYm9sLFxuXG5cdC8qKlxuXHQgKiBQaWVzIGRvbid0IGhhdmUgcG9pbnQgbWFya2VyIHN5bWJvbHNcblx0ICovXG5cdGdldFN5bWJvbDogbm9vcFxuXG59O1xuUGllU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCBQaWVTZXJpZXMpO1xuc2VyaWVzVHlwZXMucGllID0gUGllU2VyaWVzO1xuXG5cbi8vIGdsb2JhbCB2YXJpYWJsZXNcbmV4dGVuZChIaWdoY2hhcnRzLCB7XG5cdFxuXHQvLyBDb25zdHJ1Y3RvcnNcblx0QXhpczogQXhpcyxcblx0Q2hhcnQ6IENoYXJ0LFxuXHRDb2xvcjogQ29sb3IsXG5cdExlZ2VuZDogTGVnZW5kLFxuXHRQb2ludGVyOiBQb2ludGVyLFxuXHRQb2ludDogUG9pbnQsXG5cdFRpY2s6IFRpY2ssXG5cdFRvb2x0aXA6IFRvb2x0aXAsXG5cdFJlbmRlcmVyOiBSZW5kZXJlcixcblx0U2VyaWVzOiBTZXJpZXMsXG5cdFNWR0VsZW1lbnQ6IFNWR0VsZW1lbnQsXG5cdFNWR1JlbmRlcmVyOiBTVkdSZW5kZXJlcixcblx0XG5cdC8vIFZhcmlvdXNcblx0YXJyYXlNaW46IGFycmF5TWluLFxuXHRhcnJheU1heDogYXJyYXlNYXgsXG5cdGNoYXJ0czogY2hhcnRzLFxuXHRkYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuXHRmb3JtYXQ6IGZvcm1hdCxcblx0cGF0aEFuaW06IHBhdGhBbmltLFxuXHRnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuXHRoYXNCaWRpQnVnOiBoYXNCaWRpQnVnLFxuXHRpc1RvdWNoRGV2aWNlOiBpc1RvdWNoRGV2aWNlLFxuXHRudW1iZXJGb3JtYXQ6IG51bWJlckZvcm1hdCxcblx0c2VyaWVzVHlwZXM6IHNlcmllc1R5cGVzLFxuXHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRhZGRFdmVudDogYWRkRXZlbnQsXG5cdHJlbW92ZUV2ZW50OiByZW1vdmVFdmVudCxcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0ZGlzY2FyZEVsZW1lbnQ6IGRpc2NhcmRFbGVtZW50LFxuXHRjc3M6IGNzcyxcblx0ZWFjaDogZWFjaCxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdG1hcDogbWFwLFxuXHRtZXJnZTogbWVyZ2UsXG5cdHBpY2s6IHBpY2ssXG5cdHNwbGF0OiBzcGxhdCxcblx0ZXh0ZW5kQ2xhc3M6IGV4dGVuZENsYXNzLFxuXHRwSW50OiBwSW50LFxuXHR3cmFwOiB3cmFwLFxuXHRzdmc6IGhhc1NWRyxcblx0Y2FudmFzOiB1c2VDYW5WRyxcblx0dm1sOiAhaGFzU1ZHICYmICF1c2VDYW5WRyxcblx0cHJvZHVjdDogUFJPRFVDVCxcblx0dmVyc2lvbjogVkVSU0lPTlxufSk7XG59KCkpO1xuIl0sImZpbGUiOiJwbHVnaW5zL3VlZGl0b3IvdGhpcmQtcGFydHkvaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLnNyYy5qcyJ9
